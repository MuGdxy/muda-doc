{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>MUDA is \u03bc-CUDA, yet another painless CUDA programming paradigm.</p> <p>COVER THE LAST MILE OF CUDA</p>"},{"location":"#what-is-muda","title":"What is muda?","text":"<ul> <li>Header-only library right out of the box</li> <li>Depends only on CUDA and standard libraries</li> <li>Improve readability, maintainability, security, and debugging efficiency of CUDA code.</li> <li>Reduce the difficulty of building CUDA Graphs and increase automation.</li> </ul>"},{"location":"#why-muda","title":"Why muda?","text":"<p>Think that you wanna try a new idea or implement a demo with CUDA. If the demo works well, you want to embed it into your project quickly. But you find that using CUDA directly will be a catastrophic disaster.</p> <p>Coding with C-API CUDA, you will be buried in irrelevant details, and the information density of the code is very low, which means that you need to write a lot of redundant code to achieve a simple function. Less is more, right?</p> <p>Debugging the GPU code is a nightmare. How much time do you spend on those weird Error Codes from CUDA, and finally find it's an illegal memory access? </p> <p></p> <p>Using a GPU Debugger when something goes wrong may be an approach. But the best way is to prevent bugs from happening, right? Most of the time, automatic range checking is all we want. It's a pretty fantasy that someone tells you, \"Hey Bro, at <code>Block 103, Thread 45</code>, in kernel named <code>set_up_array</code>, the buffer named <code>array</code> goes out of range because your index is <code>100</code> while the array size is <code>96</code>.\" After that, it exits the kernel and stops the program for you to prevent later chained dummy bugs from producing confusing debug information.</p> <p>It is muda! </p> <p>If you access memory resource using a MUDA Viewer. Dear muda will tell you all about that.</p> <p>MUDA also provides an elegant way to create and update CUDA Graph, called MUDA <code>ComputeGraph</code>.</p> <ul> <li>Users almost take only a bit of effort to switch from the Stream-Base Launch Mode to Graph Launch Mode.</li> <li>Updating the node parameters and shared resources in CUDA Graphs becomes intuitive, safe, and efficient.</li> </ul> <p>Simple to extend.</p> <ul> <li>User can obey the primary interface of muda to define their own object to reuse the MUDA facility</li> <li>Almost all \"Resource View Type\" can be used directly in the MUDA <code>ComputeGraph</code>.</li> </ul>"},{"location":"#a-substitution-of-thrust","title":"A substitution of thrust?","text":"<p>Nop! MUDA is a supplement of thrust!</p> <p>Thrust is a C++ template library for CUDA based on the Standard Template Library (STL). Thrust allows you to implement high-performance parallel applications with minimal programming effort through a high-level interface that is fully interoperable with CUDA C.</p> <p>Using iterators to prevent range error is a high-level approach. However, we still need to access the memory manually in our own kernel, no matter whether using raw cuda kernel launch <code>&lt;&lt;&lt;&gt;&gt;&gt;</code> or using thrust agent kernel (most of the time, using a <code>thrust::counting_iterator</code> in a <code>thrust::for_each</code> algorithm).</p> <p>So, I think MUDA is a mid-level approach. We have the same purpose but different levels and aim at different problems. Feel comfortable to use them together!</p> <p>Here is an example for using Thrust and MUDA together.</p> <pre><code>using namespace muda;\nusing namespace thrust;\n\nconstexpr auto N = 10;\nDeviceVector&lt;float&gt; x(N); // DeviceVector is derived from thrust::device_vector  \n\nKernelLabel label{\"thrust\"}; // give a kernel label for better debug info\n\n// equivalent to parallel for \nfor_each(thrust::cuda::par_nosync, // no sync after execution\n         make_counting_iterator(0), make_counting_iterator(N), // make a sequence from 0 -&gt; N\n         [x = x.viewer().name(\"x\")] __device__(int i) mutable\n         {\n             x(i) = i; // safe access through muda viewer\n         });\n</code></pre>"},{"location":"#overview","title":"Overview","text":"<p>This is a quick overview of some muda APIs. </p> <p>You can check it to find out something useful for you. A comprehensive description of MUDA is placed at Tutorial.</p>"},{"location":"#launch","title":"Launch","text":"<p>Simple, self-explanatory, intellisense-friendly Launcher.</p> <pre><code>#include &lt;muda/muda.h&gt;\nusing namespace muda;\n__global__ void raw_kernel()\n{\n    printf(\"hello muda!\\n\");\n}\n\nint main()\n{\n    // just launch\n    Launch(1, 1)\n        .apply(\n        [] __device__() \n        {\n            print(\"hello muda!\\n\"); \n        }).wait();\n\n    constexpr int N = 8;\n    // dynamic grid\n    ParallelFor(256 /*block size*/)\n        .apply(N,\n        [] __device__(int i) \n        {\n            print(\"hello muda %d!\\n\", i); \n        }).wait();\n\n    // grid stride loop\n    ParallelFor(8  /*grid size*/, \n                32 /*block size*/)\n        .apply(N,\n        [] __device__(int i) \n        {\n            print(\"hello muda %d!\\n\", i); \n        }).wait();\n\n    // automatic block size choosing\n    ParallelFor().apply(N,\n        [] __device__(int i) \n        {\n            print(\"hello muda %d!\\n\", i); \n        }).wait();\n\n    // intellisense-friendly wrapper \n    Kernel{32/*grid size*/, 64/*block size*/,0/*shared memory*/, stream, other_kernel}(...)\n}\n</code></pre>"},{"location":"#logger","title":"Logger","text":"<p>A <code>std::cout</code> like output stream with overload formatting.</p> <pre><code>Logger logger;\nLaunch(2, 2)\n    .apply(\n        [logger = logger.viewer()] __device__() mutable\n        {\n            // type override\n            logger &lt;&lt; \"int2: \" &lt;&lt; make_int2(1, 2) &lt;&lt; \"\\n\";\n            logger &lt;&lt; \"float3: \" &lt;&lt; make_float3(1.0f, 2.0f, 3.0f) &lt;&lt; \"\\n\";\n        })\n    .wait();\n// download the result to any ostream you like. \nlogger.retrieve(std::cout);\n</code></pre> <p>You can define a global<code>__device__ LoggerViewer cout</code> and call the overloaded constructor <code>Logger(LoggerViewer* global_viewer)</code> to use it without any capturing, which is useful when you need to use logger in some function but don't want to put the <code>LoggerViewer</code> in the function parameter.</p> <pre><code>namespace foo\n{\n__device__ LoggerViewer cout;\n__device__ void say_hello() { cout &lt;&lt; \"hello global logger!\\n\"; }\n}\n\nint main()\n{\n    // setup global logger\n    LoggerViewer* viewer_ptr = nullptr;\n    checkCudaErrors(cudaGetSymbolAddress((void**)&amp;viewer_ptr, foo::cout));\n    Logger logger(viewer_ptr);\n\n    Launch().apply([]__device__() mutable\n        {\n            foo::say_hello();\n        })\n    .wait();\n\n    logger.retrieve(std::cout);\n}\n</code></pre> <p>Further, you can use <code>muda::Debug::set_sync_callback()</code> to retrieve the output once <code>wait()</code> is called, as:</p> <pre><code>__device__ LoggerViewer cout;\n\nint main()\n{\n    // setup global logger\n    LoggerViewer* viewer_ptr = nullptr;\n    checkCudaErrors(cudaGetSymbolAddress((void**)&amp;viewer_ptr, foo::cout));\n    Logger logger(viewer_ptr);\n\n    muda::Debug::set_sync_callback([&amp;] { logger.retrieve(std::cout); });\n\n    Launch().apply([]__device__() mutable\n        {\n            cout &lt;&lt; \"hello\\n\";\n        })\n    .wait();\n\n    // no need to retrieve manully\n}\n</code></pre>"},{"location":"#buffer","title":"Buffer","text":"<p>A lightweight <code>std::vector</code>-like cuda device memory container. </p> <p>In addition, 2D/3D aligned buffers are also provided.</p> <pre><code>DeviceBuffer&lt;int&gt; buffer;\n\n// copy from std::vector\nstd::vector&lt;int&gt; host(8);\nbuffer.copy_from(host);\n\n// copy to raw memory\nint host_array[8];\nbuffer.copy_to(host_array);\n\n// use BufferView to copy sub-buffer\nbuffer.view(0,4).copy_from(host.data());\n\nDeviceBuffer&lt;int&gt; dst_buffer{4};\n// use BufferView to copy sub-buffer\nbuffer.view(0,4).copy_to(dst_buffer.view());\n\n// safe and easy resize\nDeviceBuffer2D&lt;int&gt; buffer2d;\nbuffer2d.resize(Extent2D{5, 5}, 1);\nbuffer2d.resize(Extent2D{7, 2}, 2);\nbuffer2d.resize(Extent2D{2, 7}, 3);\nbuffer2d.resize(Extent2D{9, 9}, 4);\n// subview \nbuffer2d.view(Offset2D{1,1}, Extent2D{3,3});\nbuffer2d.copy_to(host);\n\nDeviceBuffer3D&lt;int&gt; buffer3d;\nbuffer3d.resize(Extent3D{3, 4, 5}, 1);\nbuffer3d.copy_to(host);\n</code></pre> <p>The old data will be safely kept if you resize a 2D or 3D buffer. If you don't want to keep the old data, use <code>.clear()</code> before your <code>.resize()</code>. The result of the above chain of 2D buffer resizing is shown below.</p> <p></p>"},{"location":"#viewer-in-kernel","title":"Viewer In Kernel","text":"<p>MUDA Viewers provide safe inner-kernel memory access, which checks all input to ensure access does not go out of range and does not dereference a null pointer. If something goes wrong, they report the debug information as much as possible and trap the kernel to prevent further errors.</p> <p>You can fill out the <code>name</code> of a viewer and <code>kernel_name</code> or <code>`file_line</code> of a Launcher to get more readable debug information. These information only be removed in the release version.</p> <pre><code>DeviceVar&lt;int&gt; single;\nDeviceBuffer&lt;int&gt; array;\nDeviceBuffer2D&lt;int&gt; array2d;\nDeviceBuffer3D&lt;int&gt; array3d;\nLogger logger;\nLaunch()\n    .kernel_name(__FUNCTION__)\n    .file_line(__FILE__, __LINE__)\n    .apply(\n    [\n        single  = single.viewer().name(\"single\"), // give a name for more readable debug info\n        array   = buffer.viewer().name(\"array\"),\n        array2d = buffer_2d.viewer().name(\"array2d\"),\n        array3d = buffer_3d.viewer().name(\"array3d\"),\n        logger  = logger.viewer(),\n        ...\n    ] __device__ () mutable\n    {\n        single = 1;\n        array(i) = 1;\n        array2d(offset_in_height, offset_in_width) = 1;\n        array3d(offset_in_depth, offset_in_height, offset_in_width) = 1;\n        logger &lt;&lt; 1;\n    });\n</code></pre>"},{"location":"#event-and-stream","title":"Event And Stream","text":"<p>If you don't want to launch something on the default stream, use <code>Stream</code> to create async streams. And you can use <code>Event</code> to synchronize between streams.</p> <pre><code>Stream         s1, s2;\nEvent          set_value_done;\n\nDeviceVar&lt;int&gt; v = 1;\non(s1)\n    .next&lt;Launch&gt;(1, 1)\n    .apply(\n        [v = v.viewer()] __device__() mutable\n        {\n            int next = 2;\n            v = next;\n        })\n    .record(set_value_done)\n    .apply(\n        [] __device__()\n        {\n            some_work();\n        });\n\non(s2)\n    .when(set_value_done)\n    .next&lt;Launch&gt;(1, 1)\n    .apply([v = v.viewer()] __device__()\n           { int res = v; });\n</code></pre>"},{"location":"#asynchronous-operation","title":"Asynchronous Operation","text":"<p>MUDA Launchers' functions are Asynchronous, meaning we need to call <code>.wait()</code> to synchronize it on the host, unlike some APIs such as <code>BufferView::copy_fom</code>. NOTE: Operations of a Launcher will be asynchronous as possible, so you should synchronize the stream by yourself, while other APIs will synchronize themselves.</p> <pre><code>// kernel launch\nKernel{..., f}(...);\nLaunch(stream).apply(...).wait();\nParallelFor(stream).apply(N, ...).wait();\n\n// graph launch\nGraphLaunch().launch(graph).wait();\n\n// Memory\nMemory(stream).copy(...).wait();\nMemory(stream).set(...).wait();\n\n// Buffer: for BufferView/Buffer2DView/Buffer3DView\nBufferLaunch(stream).copy(BufferView, ...).wait();\nBufferLaunch(stream).fill(BufferView,...).wait();\n</code></pre> <p>Feel free to ignore <code>Memory</code> <code>BufferLaunch</code> Launcher when building your fast demo. Directly use the convenient synchronous APIs of <code>DeviceBuffer/BufferView</code> until you find it's the performance hotpot that will save you a lot of time.</p> <p>It's a good practice to keep Launchers asynchronous while keeping other APIs synchronous, which obeys the 80/20 rule.</p>"},{"location":"#extension-linear-system-support","title":"[Extension] Linear System Support","text":"<p>MUDA supports basic linear system operations. e.g.:</p> <ol> <li>Sparse Matrix Format Conversion</li> <li>Sparse Matrix Assembly</li> <li>Linear System Solving</li> </ol> <p></p> <p>The only thing you need to do is to declare a <code>muda::LinearSystemContext</code>. Note: <code>LinearSystemContext</code> is a relative heavy resource, so you should keep and reuse it as much as possible.</p> <pre><code>LinearSystemContext ctx;\n// non-unique triplets of (row_index, col_index, block3x3)\nDeviceTripletMatrix&lt;float, 3&gt; A_triplet;\n// setup the triplet matrix dimension\nA_triplet.reshape(block_rows,block_cols);\n// resize the triplets, we should know the total count of the triplets.\nA_triplet.resize_triplets(hessian_count); \n\n// unique triplets of (row_index, col_index, block3x3) faster SPMV than TripletMatrix\nDeviceBCOOMatrix&lt;float,3&gt; A_bcoo; \n\n// block compressed sparse row format, faster SPMV than BCOOMatrix\nDeviceBSRMatrix&lt;float,3&gt; A_bsr; \n\n// compressed sparse row format, slower SPMV than BSRMatrix\nDeviceCSRMatrix&lt;float,3&gt; A_csr\n\n// trivial dense matrix \nDeviceDenseMatrix&lt;float&gt; A_dense; \n\n// convert:\nctx.convert(A_triplet, A_bcoo);\nctx.convert(A_bcoo, A_bsr);\nctx.convert(A_bsr, A_dense);\nctx.convert(A_bsr, A_csr);\nctx.convert(A_bcoo, A_dense);\n\n// so for the Sparse Vector ...\n</code></pre> <p>We only allow users to assemble a Sparse Matrix from Triplet Matrix. And allow users to read from BCOOMatrix.</p> <p>To assemble a Triplet Matrix, user need to use the <code>viewer</code> of a Triplet Matrix.</p> <pre><code>DeviceTripletMatrix&lt;float, 3&gt; A_triplet;\nA_triplet.resize(block_rows,block_cols,hessian_count);\nDeviceDenseVector&lt;float&gt; x, b;\nx.resize(block_rows * 3);\nb.resize(block_rows * 3)\n\nParallelFor(256/*block size*/)\n    .apply(hessian_count,\n    [\n        H = A_triplet.viewer().name(\"Hessian\"),\n        g = x.viewer().name(\"gradient\")\n        // some infos to build up hessian and gradient\n    ] __device__(int i) \n    {\n        int row, col;\n        Eigen::Matrix3f hessian; // fill the local hessian, using your infos\n        Eigen::Vector3f gradient;\n\n        // write the (row, col, hessian) to the i-th triplet\n        H(i).write(row,col, hessin);\n\n        // atomic add the gradient vector\n        g.segment&lt;3&gt;(row * 3).atomic_add(gradient);\n    }).wait();\n\n// convert to bcoo for better performance on SPMV.\nctx.convert(A_triplet, A_bcoo);\nctx.convert(A_bcoo, A_bsr);\n\n// maybe in some iterative solver:\nctx.spmv(A_bsr.cview(), x.cview(), b.view());\n</code></pre>"},{"location":"#extension-field-layout","title":"[Extension] Field Layout","text":"<p>MUDA now supports the <code>SoA/AoS/AoSoA</code> layouts. Users can switch between them seamlessly(with different builder parameters). The copy operation in all directions and layouts is well-supported.</p> <p>Most of the time, <code>AoSoA</code> is the best layout for Vector and Matrix, with better memory coalescing and more compact memory storage. With the help of <code>Eigen::Map&lt;&gt;</code>, the read/write of a Vector/Matrix is as trivial as accessing a struct-version Vector/Matrix.</p> <p>Here is a simple example of <code>muda::Field</code>.</p> <pre><code>#include &lt;muda/ext/field.h&gt; // all you need for muda::Field\n\nvoid field_example(FieldEntryLayout layout)\n{\n    using namespace muda;\n    using namespace Eigen;\n\n    Field field;\n    // create a subfield called \"particle\"\n    // any entry in this field has the same size\n    auto&amp; particle = field[\"particle\"];\n    float dt       = 0.01f;\n\n    // build the field:\n    // auto builder = particle.AoSoA(); // compile time layout\n    auto builder = particle.builder(FieldEntryLayout::AoSoA);  // runtime layout\n    auto&amp; m      = builder.entry(\"mass\").scalar&lt;float&gt;();\n    auto&amp; pos    = builder.entry(\"position\").vector3&lt;float&gt;();\n    auto&amp; pos_old = builder.entry(\"position_old\").vector3&lt;float&gt;();\n    auto&amp; vel     = builder.entry(\"velocity\").vector3&lt;float&gt;();\n    auto&amp; force   = builder.entry(\"force\").vector3&lt;float&gt;();\n    // matrix is also supported, but in this example we don't use it\n    auto&amp; I = builder.entry(\"inertia\").matrix3x3&lt;float&gt;();\n    builder.build();  // finish building the field\n\n    // set size of the particle attributes\n    constexpr int N = 10;\n    particle.resize(N);\n\n    Logger logger;\n\n    ParallelFor(256)\n        .kernel_name(\"setup_vars\")\n        .apply(N,\n               [logger = logger.viewer(),\n                m      = m.viewer(),\n                pos    = pos.viewer(),\n                vel    = vel.viewer(),\n                f      = force.viewer()] __device__ (int i) mutable\n               {\n                   m(i)   = 1.0f;\n                   // a row of particles with position=(i,1,0)\n                   pos(i) = Vector3f::UnitY() + Vector3f::UnitX() * i;\n                   vel(i) = Vector3f::Zero();\n                   f(i)   = Vector3f{0.0f, -9.8f, 0.0f};\n\n                   logger &lt;&lt; \"--------------------------------\\n\"\n                          &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; \"\\n\"\n                          &lt;&lt; \"m=\" &lt;&lt; m(i) &lt;&lt; \"\\n\"\n                          &lt;&lt; \"pos=\" &lt;&lt; pos(i) &lt;&lt; \"\\n\"\n                          &lt;&lt; \"vel=\" &lt;&lt; vel(i) &lt;&lt; \"\\n\"\n                          &lt;&lt; \"f=\" &lt;&lt; f(i) &lt;&lt; \"\\n\";\n               })\n        .wait();\n\n    logger.retrieve();\n\n    ParallelFor(256)\n        .kernel_name(\"integration\")\n        .apply(N,\n               [logger = logger.viewer(),\n                m      = m.cviewer(),\n                pos    = pos.viewer(),\n                vel    = vel.viewer(),\n                f      = force.cviewer(),\n                dt] __device__ (int i) mutable\n               {\n                   auto     x = pos(i);\n                   auto     v = vel(i);\n                   Vector3f a = f(i) / m(i);\n\n                   v = v + a * dt;\n                   x = x + v * dt;\n\n                   logger &lt;&lt; \"--------------------------------\\n\"\n                          &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; \"\\n\"\n                          &lt;&lt; \"m=\" &lt;&lt; m(i) &lt;&lt; \"\\n\"\n                          &lt;&lt; \"pos=\" &lt;&lt; pos(i) &lt;&lt; \"\\n\"\n                          &lt;&lt; \"vel=\" &lt;&lt; vel(i) &lt;&lt; \"\\n\"\n                          &lt;&lt; \"f=\" &lt;&lt; f(i) &lt;&lt; \"\\n\";\n               })\n        .wait();\n\n    logger.retrieve();\n\n    // copy between entry and host\n    std::vector&lt;Vector3f&gt; positions;\n    pos.copy_to(positions);\n    pos.copy_from(positions);\n\n    // copy between entries\n    pos_old.copy_from(pos);\n\n    // copy between buffer and entry\n    DeviceBuffer&lt;Vector3f&gt; pos_buf;\n    pos.copy_to(pos_buf);\n    pos.copy_from(pos_buf);\n\n    // using cub to do reduction on any format\n    DeviceVar&lt;float&gt; total_mass;\n    DeviceReduce().Sum(m.view(), total_mass.view(), m.count());\n}\n</code></pre> <p>Additionally, resizing a subfield will resize all the entries, and the resizing is safe; all entries will be copied to a new buffer if the new size exceeds the capacity.</p> <pre><code>// safe resize, all entries will be copied to the new buffer.\nparticle.resize(N * 2);\n</code></pre> <p>It'd be useful if the topology will change in your simulation. For example, the fracture simulation always changes its tetrahedron mesh, and all attributes of particles, edges, triangles, and tetrahedra will change correspondently. It will be terrible if you resize all the attributes yourself.</p> <p>Note that every <code>FieldEntry</code> has a <code>View</code> called <code>FieldEntryView</code>. A <code>FieldEntryView</code> can be regarded as a <code>ComputeGraphVar</code>(see below), which means <code>FieldEntry</code> can also be used in <code>ComputeGraph</code>. </p>"},{"location":"#compute-graph","title":"Compute Graph","text":"<p>Define <code>MUDA_WITH_COMPUTE_GRAPH</code>  to turn on <code>Compute Graph</code> support.</p> <p>MUDA can generate <code>cudaGraph</code> nodes and dependencies from your <code>eval()</code> call. And the <code>cudaGraphExec</code> will be automatically updated (minimally) if you update a <code>muda::ComputeGraphVar</code>. More details in zhihu_ZH.</p> <p>Define a muda compute graph:</p> <pre><code>void compute_graph_simple()\n{\n    ComputeGraphVarManager manager;\n    ComputeGraph graph{manager};\n\n    // 1) define GraphVars\n    auto&amp; N   = manager.create_var&lt;size_t&gt;(\"N\");\n    // BufferView represents a fixed range of memory\n    // dynamic memory allocation is not allowed in GraphVars\n    auto&amp; x_0 = manager.create_var&lt;BufferView&lt;Vector3&gt;&gt;(\"x_0\");\n    auto&amp; x   = manager.create_var&lt;BufferView&lt;Vector3&gt;&gt;(\"x\");\n    auto&amp; y   = manager.create_var&lt;BufferView&lt;Vector3&gt;&gt;(\"y\");\n\n    // 2) create GraphNode\n    graph.create_node(\"cal_x_0\") &lt;&lt; [&amp;]\n    {\n        // initialize values\n        ParallelFor(256).apply(N.eval(),\n                               [x_0 = x_0.eval().viewer()] __device__(int i) mutable\n                               { x_0(i) = Vector3::Ones(); });\n    };\n\n    graph.create_node(\"copy_to_x\") // copy\n        &lt;&lt; [&amp;] { BufferLaunch().copy(x.eval(), x_0.ceval()); };\n\n    graph.create_node(\"copy_to_y\") // copy\n        &lt;&lt; [&amp;] { BufferLaunch().copy(y.eval(), x_0.ceval()); };\n\n    graph.create_node(\"print_x_y\") &lt;&lt; [&amp;]\n    {\n        // print\n        ParallelFor(256).apply(N.eval(),\n                               [x = x.ceval().cviewer(),\n                                y = y.ceval().cviewer(),\n                                N = N.eval()] __device__(int i) mutable\n                               {\n                                   if(N &lt;= 10)\n                                       print(\"[%d] x = (%f,%f,%f) y = (%f,%f,%f) \\n\",\n                                             i,\n                                             x(i).x(),\n                                             x(i).y(),\n                                             x(i).z(),\n                                             y(i).x(),\n                                             y(i).y(),\n                                             y(i).z());\n                               });\n    };\n    // 3) visualize it using graphviz (for debug)\n    graph.graphviz(std::cout);\n}\n</code></pre> <p></p> <p>Launch a muda compute graph:</p> <pre><code>void compute_graph_simple()\n{\n    // resources\n    auto N_value    = 4;\n    auto x_0_buffer = DeviceVector&lt;Vector3&gt;(N_value);\n    auto x_buffer   = DeviceVector&lt;Vector3&gt;(N_value);\n    auto y_buffer   = DeviceVector&lt;Vector3&gt;(N_value);\n\n    N.update(N_value);\n    x_0.update(x_0_buffer);\n    x.update(x_buffer);\n    y.update(y_buffer);\n\n    // create stream\n    Stream stream;\n    // sync graph on stream\n    graph.launch(stream);\n    // launch all nodes on a single stream (fallback to origin cuda kernel launch)\n    graph.launch(true, stream);\n}\n</code></pre>"},{"location":"#dynamic-parallelism","title":"Dynamic Parallelism","text":"<p>MUDA support dynamic parallelism based on MUDA ComputeGraph.</p> <pre><code>void dynamic_parallelism_graph()\n{\n    std::vector&lt;int&gt; host(16);\n    std::iota(host.begin(), host.end(), 0);\n\n    ComputeGraphVarManager manager;\n    // create graph\n    ComputeGraph      graph{manager, \"graph\", ComputeGraphFlag::DeviceLaunch};\n    // create resource\n    DeviceBuffer&lt;int&gt; src = host;\n    DeviceBuffer&lt;int&gt; dst(host.size());\n\n    // create graph var\n    auto&amp; src_var = manager.create_var(\"src\", src.view());\n    auto&amp; dst_var = manager.create_var(\"dst\", dst.view());\n\n    // create graph node\n    graph.$node(\"copy\")\n    {\n        BufferLaunch().copy(dst_var, src_var);\n    };\n    // build graph\n    graph.build();\n\n    // create a scheduler graph\n    ComputeGraph launch_graph{manager, \"launch_graph\", ComputeGraphFlag::DeviceLaunch};\n    auto&amp; graph_var = manager.create_var(\"graph\", graph.viewer());\n\n    // create a node to launch our graph\n    launch_graph.$node(\"launch\")\n    {\n        Launch().apply(\n            [graph = graph_var.ceval()] $()\n            {\n                graph.tail_launch();\n            });\n    };\n    // graphviz all graph we created\n    manager.graphviz(std::cout);\n    // launch and wait\n    launch_graph.launch().wait();\n}\n</code></pre> <p></p>"},{"location":"#muda-vs-cuda","title":"MUDA vs. CUDA","text":"<pre><code>/* \n* muda style\n*/\nvoid muda()\n{\n    DeviceBuffer&lt;int&gt;  dv(64);\n    dv.fill(1);\n\n    ParallelFor(256) // parallel-semantic\n        .kernel_name(\"my_kernel\") // or just .kernel_name(__FUNCTION__)\n        .apply(64, // automatically cover the range\n               [\n                   // mapping from the DeviceBuffer to a proper viewer\n                   // which can be trivially copy through device and host\n                   dv = dv.viewer().name(\"dv\")\n               ] \n               __device__(int i) mutable\n               { \n                   dv(i) *= 2; // safe, the viewer check the boundary automatically\n               })\n        .wait();// happy waiting, muda remember the stream.\n        //.apply(...) //if you want to go forward with the same config, just call .apply() again.\n}\n\n\n/* \n* cuda style\n*/\n\n// manually create kernel\n__global__ void times2(int* i, int N) // modifying parameters is horrible\n{\n    auto tid = threadIdx.x;\n    if(tid &lt; N) // check corner case manaully\n    {\n        i[tid] *= 2;// unsafe: no boundary check at all\n    }\n}\n\nvoid cuda()\n{\n    // to be brief, we just use thrust to allocate memory\n    thrust::device_vector&lt;int&gt; dv(64, 1);\n    // cast to raw pointer\n    auto dvptr = thrust::raw_pointer_cast(dv.data());\n    // create stream and check error\n    cudaStream_t s;\n    checkCudaErrors(cudaStreamCreate(&amp;s));\n    // call the kernel (which always ruins the Intellisense, if you use VS.)\n    times2&lt;&lt;&lt;1, 64, 0, s&gt;&gt;&gt;(dvptr, dv.size());\n    // boring waiting and error checking\n    checkCudaErrors(cudaStreamSynchronize(s));\n}\n</code></pre>"},{"location":"#build","title":"Build","text":""},{"location":"#cmake","title":"Cmake","text":"<pre><code>$ mkdir CMakeBuild\n$ cd CMakeBuild\n$ cmake -S ..\n$ cmake --build .\n</code></pre>"},{"location":"#xmake","title":"Xmake","text":"<p>Run example:</p> <p><pre><code>$ xmake f --example=true\n$ xmake \n$ xmake run muda_example hello_muda\n</code></pre> To show all examples:</p> <p><pre><code>$ xmake run muda_example -l\n</code></pre> Play all examples:</p> <pre><code>$ xmake run muda_example\n</code></pre>"},{"location":"#copy-headers","title":"Copy Headers","text":"<p>Because muda is header-only, copy the <code>src/muda/</code> folder to your project, set the include directory, and everything is done.</p>"},{"location":"#macro","title":"Macro","text":"Macro Value Details <code>MUDA_CHECK_ON</code> <code>1</code>(default) or <code>0</code> <code>MUDA_CHECK_ON=1</code> for turn on all muda runtime check(for safety) <code>MUDA_WITH_COMPUTE_GRAPH</code> <code>1</code>or<code>0</code>(default) <code>MUDA_WITH_COMPUTE_GRAPH=1</code> for turn on muda compute graph feature <p>If you manually copy the header files, don't forget to define the macros yourself. If you use cmake or xmake, just set the project dependency to muda.</p>"},{"location":"#examples","title":"Examples","text":"<p>All examples in <code>muda/example</code> are self-explanatory,  enjoy it.</p> <p></p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome. We are looking for or are working on:</p> <ol> <li> <p>muda development</p> </li> <li> <p>fancy simulation demos using muda</p> </li> <li> <p>better documentation of muda</p> </li> </ol>"},{"location":"#related-work","title":"Related Work","text":"<ul> <li>Topological braiding simulation using muda (old version)</li> </ul> <pre><code>@article{article,\nauthor = {Lu, Xinyu and Bo, Pengbo and Wang, Linqin},\nyear = {2023},\nmonth = {07},\npages = {},\ntitle = {Real-Time 3D Topological Braiding Simulation with Penetration-Free Guarantee},\nvolume = {164},\njournal = {Computer-Aided Design},\ndoi = {10.1016/j.cad.2023.103594}\n}\n</code></pre> <ul> <li>solid-sim-muda: a tiny solid simulator using muda.</li> </ul>"},{"location":"nav/","title":"Nav","text":"<ul> <li>Home</li> <li>Tutorial<ul> <li>MUDA Tutorial</li> <li>MUDA Tutorial - Event</li> <li>MUDA Tutorial - Logger</li> <li>Use Thrust with MUDA</li> <li>Compute Graph</li> </ul> </li> <li>API Documentation<ul> <li>Links</li> </ul> </li> <li>Classes<ul> <li>Index</li> <li>Hierarchy</li> <li>Members</li> <li>Member Functions</li> <li>Member Variables</li> <li>Member Typedefs</li> <li>Member Enumerations</li> </ul> </li> <li>Namespaces<ul> <li>Index</li> <li>Member</li> <li>Member Functions</li> <li>Member Variables</li> <li>Member Typedefs</li> <li>Member Enumerations</li> </ul> </li> <li>Functions</li> <li>Variables</li> <li>Macros</li> <li>Files</li> </ul>"},{"location":"tutorial/","title":"Tutorials","text":"<p>The tutorials cover the basic concepts and features of MUDA.</p> <ul> <li>MUDA Tutorial</li> <li>MUDA Tutorial - Event</li> <li>MUDA Tutorial - Logger</li> <li>Use Thrust with MUDA</li> <li>Automatic Generation of MUDA Compute Graph</li> </ul>"},{"location":"tutorial/event/","title":"Event","text":"<p>We will introduce how to use <code>Event</code> in MUDA in this article.</p> <p><code>muda::Event</code> is a RAII wrapper for <code>cudaEvent_t</code>. It creates <code>cudaEvent_t</code> when constructed and releases <code>cudaEvent_t</code> when destructed. </p> <p>Event is mainly used to synchronize tasks on two Streams. When a task on StreamA is completed, we can record an Event, and wait for the Event on StreamB. Then all tasks after the Event in StreamB will wait for the Event to be triggered before starting. </p> <p>Let's look at a simple example.</p> <pre><code>        stream1       stream2\n          A              \n          |              \n        record         when \n        event0 ------ event0\n          |             |\n          B             C\n</code></pre> <p>On <code>stream1</code>, we first launch a task A, record <code>event0</code> after A is completed, and then launch task B. On <code>stream2</code>, we first wait for <code>event0</code>, and then launch task C. </p> <p>Obviously, this setting can ensure that A is completed before B and C. </p> <ul> <li>B can start after A is completed because A and B are on the same Stream, and they implicitly synchronize on <code>stream1</code>. </li> <li>C can start after B is completed because A records an Event, and C waits for the same Event. They explicitly synchronize on <code>event0</code>.</li> </ul>"},{"location":"tutorial/event/#basic","title":"Basic","text":"<p>In MUDA, such relationships can be described very clearly and naturally:</p> <pre><code>Stream          s1, s2;\nEvent           set_value_done;\nDeviceVar&lt;int&gt; v = 1;\n\non(s1) // On Stream1\n    .next&lt;Launch&gt;(1, 1)\n    .apply(// Task A\n        [v = v.viewer()] __device__() mutable\n        {\n            int next = 2;\n            MUDA_KERNEL_PRINT(\"kernel A on stream 1, set v = %d -&gt; %d\", v, next);\n            v = next;\n        })\n    .record(set_value_done) // Record Event\uff1aset_value_done\n    .apply(// Task B\n        [] __device__()\n        {\n            some_work(); \n            MUDA_KERNEL_PRINT(\"kernel B on stream 1 costs a lot of time\");\n        });\n\non(s2) // On Stream2\n    .when(set_value_done) // Wait Event\uff1aset_value_done\n    .next&lt;Launch&gt;(1, 1) \n    .apply([v = make_viewer(v)] __device__() // Task C\n            { MUDA_KERNEL_PRINT(\"kernel C on stream 2, get v = %d\", v); });\n\n// Sync\nwait_device();\n</code></pre> <p>The output is as follows:</p> <p></p>"},{"location":"tutorial/event/#compute-graph-support","title":"Compute Graph Support","text":"<p>ComputeGraph is an important feature of MUDA, and event recording and waiting are also allowed between ComputeGraphs.</p> <pre><code>ComputeGraphVarManager manager;\nComputeGraph graph1{manager, \"graph1\"};\nComputeGraph graph2{manager, \"graph2\"};\n\nauto&amp; N     = manager.create_var&lt;size_t&gt;(\"N\");\nauto&amp; x     = manager.create_var&lt;BufferView&lt;int&gt;&gt;(\"x\");\n// Note: GraphVar type needs to be cudaEvent_t\nauto&amp; event = manager.create_var&lt;cudaEvent_t&gt;(\"event\");\n\ngraph1.create_node(\"set_x\") &lt;&lt; [&amp;] // Task A\n{\n    ParallelFor(256).apply(N.eval(),\n                            [x = x.eval().viewer()] __device__(int i) mutable\n                            {\n                                x(i) = 1;\n                                MUDA_KERNEL_PRINT(\"graph1 set x(%d) = %d\", i, x(i));\n                            });\n};\n\ngraph1.create_node(\"event:record_event\") &lt;&lt; [&amp;] { on().record(event, x); }; // Record event\n\ngraph1.create_node(\"do_some_work\") &lt;&lt; [&amp;] // Task B\n{\n    Launch().apply(\n        // dummy read x, to make sure the kernel is launched after set_x\n        [x = x.ceval().cviewer()] __device__() mutable\n        {\n            some_work();\n            MUDA_KERNEL_PRINT(\"graph1 do some other work\");\n        });\n};\n\ngraph2.create_node(\"event:wait_x\") &lt;&lt; [&amp;] { on().wait(event, x); }; // Wait event\n\ngraph2.create_node(\"read_x\") &lt;&lt; [&amp;] // Task C\n{\n    ParallelFor(256).apply(N.eval(),\n                            [x = x.ceval().cviewer()] __device__(int i) mutable {\n                                MUDA_KERNEL_PRINT(\"graph2 read x(%d) = %d\", i, x(i));\n                            });\n};\n\nStream stream1;\nStream stream2;\n\n\nauto N_value     = 4;\nauto x_value     = DeviceBuffer&lt;int&gt;(N_value);\nauto event_value = Event{};\n\n// Update ComputeGraphVar\nN     = N_value;\nx     = x_value;\nevent = event_value;\n\nMUDA_KERNEL_PRINT(\"launch graph1 on stream1:\");\ngraph1.launch(stream1);\nMUDA_KERNEL_PRINT(\"launch graph2 on stream2:\");\ngraph2.launch(stream2);\nwait_device();\n</code></pre> <p>The difference from the basic example is that we use <code>on().record(event, x)</code> and <code>on().wait(event, x)</code> instead of <code>on().record(event)</code> and <code>on().wait(event)</code>. Because MUDA ComputeGraph calculates node dependencies based on resource read-write situations, the event also needs to specify the corresponding resource. </p> <p>We can visualize these two ComputeGraphs with <code>manager.graphviz(std::cout)</code>:</p> <p></p> <p>We can see that the two nodes connected by the event both access <code>x</code> (both are red arrows). This is because for safety, MUDA Compute Graph Dependency Building must assume that Record and Wait nodes both read and write <code>x</code>, so that the generated dependencies are the most conservative.</p> <p>The result is as follows:</p> <p></p>"},{"location":"tutorial/event/#note","title":"Note","text":"<p>When using events between ComputeGraphs, you need to be extra careful. Incorrect event operations may cause data corruption, and this kind of data corruption is something that MUDA ComputeGraph cannot foresee or check (because the event is a dynamic synchronization operation, and this dependency is established when the graph is launched, which cannot be predicted). Events are mainly suitable for streaming models; while ComputeGraph is a graph model, the dependencies between nodes can be considered as events.</p>"},{"location":"tutorial/event/#best-practice","title":"Best Practice","text":"<p>Do not use Event in ComputeGraph unless you are fully aware of the consequences of your behavior. Use <code>manager.graphviz()</code> to visualize the ComputeGraph you constructed as much as possible.</p>"},{"location":"tutorial/graph/","title":"Compute Graph","text":"<p>Before introducing the automatic compute graph of muda, we need some basic knowledge of cuda graph.</p> <p>Getting Started with CUDA Graphs</p> <p> compute graph</p> <p>In conclusion, a cuda graph is a directed acyclic graph with a fixed topology (of course, the topology is not immutable, it is just that the cost of changing the topology is very high).</p> <p>The nodes represent various operations: </p> <ul> <li>Kernel Launch</li> <li>Memcpy/Memset</li> <li>Event Record/Event Wait</li> </ul> <p>The directed edges represent the dependency relationship between the nodes, and the branches without dependencies can be parallelized on the GPU (the parallelism here is not the same as the parallelism of threads within the Kernel, the former is a concurrency issue). </p> <p>If we correctly set the nodes and dependencies, then a cuda graph is constructed. Using cuda graph has lower startup overhead and higher GPU utilization than directly stuffing all operations into a cuda stream or manually allocating multiple cuda streams for concurrency. </p> <p> After the cuda graph is launched, multiple streams are automatically allocated for kernel concurrency.</p> <p>So far, the dependencies of the cuda graph need to be set manually by the user. When the input variables of the kernel or other operations change, the user needs to update the node parameters manually. When we face a large number of nodes and input parameters, it is not practical to manually construct the cuda graph and update the nodes, so the automatic compute graph of muda comes into being.</p>"},{"location":"tutorial/graph/#muda-compute-graph","title":"Muda Compute Graph","text":"<p>Here's a simple example of a muda compute graph definition.</p> <pre><code>void compute_graph_simple()\n{\n    ComputeGraphVarManager manager;\n    ComputeGraph graph{manager};\n\n    // 1) Define GraphVar\n    auto&amp; N   = manager.create_var&lt;size_t&gt;(\"N\");\n    // BufferView is a fixed memory\n    // GraphVar does not support dynamic memory (DeviceVector/DeviceBuffer, etc. are not accepted)\n    auto&amp; x_0 = manager.create_var&lt;BufferView&lt;Vector3&gt;&gt;(\"x_0\");\n    auto&amp; x   = manager.create_var&lt;BufferView&lt;Vector3&gt;&gt;(\"x\");\n    auto&amp; y   = manager.create_var&lt;BufferView&lt;Vector3&gt;&gt;(\"y\");\n\n    // 2) Create GraphNode\n    graph.create_node(\"cal_x_0\") &lt;&lt; [&amp;]\n    {\n        // simple initialization\n        ParallelFor(256).apply(N.eval(),\n                               [x_0 = x_0.viewer()] __device__(int i) mutable\n                               { x_0(i) = Vector3::Ones(); });\n    };\n\n    graph.create_node(\"copy_to_x\") // copy\n        &lt;&lt; [&amp;] { BufferLaunch().copy(x.eval(), x_0.ceval()); };\n\n    graph.create_node(\"copy_to_y\") // copy\n        &lt;&lt; [&amp;] { BufferLaunch().copy(y.eval(), x_0.ceval()); };\n\n    graph.create_node(\"print_x_y\") &lt;&lt; [&amp;]\n    {\n        // print\n        ParallelFor(256).apply(N.eval(),\n                               [x = x.cviewer(),\n                                y = y.cviewer(),\n                                N = N.eval()] __device__(int i) mutable\n                               {\n                                   if(N &lt;= 10)\n                                       print(\"[%d] x = (%f,%f,%f) y = (%f,%f,%f) \\n\",\n                                             i,\n                                             x(i).x(),\n                                             x(i).y(),\n                                             x(i).z(),\n                                             y(i).x(),\n                                             y(i).y(),\n                                             y(i).z());\n                               });\n    };\n    // 3) Generate graphviz code to visualize the dependency graph (optional, for debugging)\n    graph.graphviz(std::cout);\n}\n</code></pre> <p>We can paste the generated graphviz code into Graphviz Online to view:</p> <p></p> <p>We can see that <code>copy_to_x</code> and <code>copy_to_y</code> both depend on <code>cal_x_0</code>, which is expected because according to our logical order, <code>x_0</code> will be initialized first, and then copied to <code>x</code> and <code>y</code>. There is no dependency between <code>copy_to_x</code> and <code>copy_to_y</code> because they both only read <code>x_0</code>, so their execution can be completely parallel. Then we print <code>x</code> and <code>y</code>. Since <code>x</code> and <code>y</code> need to be fully written before printing, <code>print_x_y</code> depends on <code>copy_to_x</code> and <code>copy_to_y</code>.</p> <p>Besides nodes, we also visualize the read(red)/write(blue) status of each graph node to graph vars.</p> <p>More specifically:</p> <p>In 1), we define <code>graph var</code>. These graph vars in the muda compute graph only represent a virtual resource (muda compute graph defaults to no overlap between all virtual resources, i.e., memory does not overlap). Generally, we require the input variables of the graph to be a viewer (it does not own resources itself, it is just a resource accessor, and is trivially copyable), or a value type. If you know what you are doing, you can also use some tricks.</p> <p>Here we can give some examples of STL to illustrate what kind of object is a viewer, and what kind of object is not a viewer:</p> <ul> <li><code>std::vector</code> is not a viewer because it is a container with memory ownership.</li> <li><code>std::span</code> is a viewer because it is not a container, it is just a slice of a container.</li> <li><code>std::string</code> is not a viewer because it is a container with memory ownership.</li> <li><code>std::string_view</code> is a viewer because it is not a container, it is just a slice of a container.</li> </ul> <p>Of course, the so-called viewer cannot be accessed on the GPU, and muda requires that the viewer can be accessed on the host or device.</p> <p>In 2), we define the graph nodes. Note that the definition order of graph nodes will affect the dependency relationship of graph nodes. The definition order of graph nodes should be the logical order of all tasks, which is very intuitive! All our serial code is written like this.</p> <p>Let's look at the first graph node:</p> <pre><code>graph.create_node(\"cal_x_0\") &lt;&lt; [&amp;] // lambdaB\n{\n    ParallelFor(256).apply(N.eval(),\n                           [x_0 = x_0.viewer()] __device__(int i) mutable // lambdaA\n                           {\n                               x_0(i) = Vector3::Ones();\n                           });\n};\n</code></pre> <p>The innermost lambdaA is a muda-style kernel call, nothing special.</p> <p>The outermost lambdaB is called a graph node closure, which is a closure of a node construction process. This closure may be called multiple times throughout the life cycle of the graph, such as:</p> <ul> <li>Graph topology build: the phase of computing the graph dependency topology, during this phase, muda compute graph only constructs the dependency relationship and does not actually generate the cuda graph.</li> <li>Graph build: the phase of building the cuda graph, during this phase, the cuda graph is directly generated.</li> <li>Graph update: the phase of updating node parameters, when a graph var referenced by the user is updated, all nodes referencing this graph var need to update the parameters.</li> <li>Graph direct launch: muda compute graph direct call mode. At this time, all nodes are called serially on a cuda stream, generally used for debugging and profiling a graph.</li> </ul> <p>Calling these closures in different life cycle stages may use different underlying CUDA APIs.</p> <p>In the topology build phase, no CUDA API is called, only the <code>graph var</code>'s eval and ceval are responded to. By setting the properties of <code>eval=ReadWrite</code> and <code>ceval=ReadOnly</code>, we can mark the resource usage for the current node, which will be used to generate node dependency relationships.</p> <p>In the build phase, muda calls all graph node closures, which will call the <code>cudaGraphNodeCreate</code> series of APIs to generate cuda graph nodes, and then muda will supplement the dependencies in the cuda graph according to the dependencies generated in the topology build phase.</p> <p>In the graph update phase, the graph node closure corresponding to the node that needs to be updated will be called again (minimum update), and the cuda graph node parameters will be updated by calling the <code>cudaGraphExecSetParameter</code> series of APIs.</p> <p>In the graph direct launch phase, the most primitive cuda launch and runtime APIs are used, such as the classic triple angle brackets <code>&lt;&lt;&lt;&gt;&gt;&gt;</code> call, <code>cudaMemcpy</code>, etc.</p> <p>After that, we need to prepare to call this compute graph.</p> <pre><code>void compute_graph_simple()\n{\n    ...\n    graph.graphviz(std::cout);\n\n    // Allocate resources\n    auto N_value    = 10;\n    auto x_0_buffer = DeviceBuffer&lt;Vector3&gt;(N_value);\n    auto x_buffer   = DeviceBuffer&lt;Vector3&gt;(N_value);\n    auto y_buffer   = DeviceBuffer&lt;Vector3&gt;(N_value);\n\n    // Update graph var\n    // we need to use update() to pass in the corresponding resources, \n    // because we only defined the resources before and did not really input the resources into the graph\n    N.update(N_value);\n    x_0.update(x_0_buffer);\n    x.update(x_buffer);\n    y.update(y_buffer);\n\n    graph.launch();\n}\n</code></pre> <p>Ouptut:</p> <pre><code>[0] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[1] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[2] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[3] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[4] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[5] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[6] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[7] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[8] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[9] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n</code></pre> <p><code>graph.launch()</code> means that the graph will be synchronized on the default stream, and the graph will wait for all tasks in the default stream to complete before starting to run, and all tasks after the graph on the default stream will wait for the current graph to complete.</p> <p><code>graph.launch(stream)</code> means that the graph will be synchronized on this stream.</p> <p>In addition, we also provide another launch method: <code>graph.launch(single_stream=true, stream)</code>. When <code>single_stream=true</code>, the graph will not be called through the cuda graph, but will directly call all nodes in the order of <code>graph.create_node</code> on the stream. This will be beneficial for debugging and profiling. In theory, if there is no floating-point calculation problem, the final results of all the above calling methods should be consistent.</p>"},{"location":"tutorial/graph/#limitation","title":"Limitation","text":"<p>Now the graph node closure allows capturing references, which may cause side effects when the user makes a mistake, resulting in different results when calling the closure multiple times.</p>"},{"location":"tutorial/logger/","title":"Logger","text":"<p>We will introduce the usage of muda's <code>Logger</code> object in this article. Have you ever had the experience of printing a matrix in the kernel? It will be like this:</p> <pre><code>printf(\n\"%f %f %f %f \\n\"\n\"%f %f %f %f \\n\"\n\"%f %f %f %f \\n\"\n\"%f %f %f %f \\n\",\nm[0][0], m[0][1], m[0][2], m[0][3],\nm[1][0], m[1][1], m[1][2], m[1][3],\nm[2][0], m[2][1], m[2][2], m[2][3],\nm[3][0], m[3][1], m[3][2], m[3][3]);\n</code></pre> <p>It is so painful. This is just a <code>Matrix4x4</code>. To solve this pain point, <code>muda::Logger</code> provides a way to print similar to <code>std::cout</code>.</p>"},{"location":"tutorial/logger/#muda-logger","title":"Muda Logger","text":"<p><pre><code>using namespace muda;\nvoid logger_simple()\n{\n    Logger logger;\n    Launch(2, 1)\n        .apply(\n            [logger = logger.viewer()] __device__() mutable\n            {\n                //print hello world\n                logger &lt;&lt; \"hello world! from block (\" &lt;&lt; blockIdx &lt;&lt; \")\\n\";\n            })\n        .wait();\n    logger.retrieve(std::cout);\n}\n</code></pre> First we create a <code>logger</code> like defining <code>DeviceBuffer</code>, then get the viewer of the logger. So we can use the logger in the kernel like using <code>std::cout &lt;&lt; \"foo\"</code>. When we need to take out the content printed in the kernel, we need to call <code>logger.retrieve(...)</code> to manually write the content recorded in the logger to any <code>ostream</code>. Here we directly use <code>std::cout</code> as the output stream. </p> <p>The running result is:</p> <p></p> <p>The advantage of <code>muda::Logger</code> is that we can overload the <code>&lt;&lt;</code> operator to output any data the user wants. </p> <p>For example, if you want to unify the output of all <code>Eigen::Matrix</code> types, you can operate like this:</p> <pre><code>namespace muda\n{\ntemplate &lt;typename T, int M, int N&gt;\n__device__ LogProxy&amp; operator&lt;&lt;(LogProxy&amp; o, const Eigen::Matrix&lt;T, M, N&gt;&amp; val)\n{\n    for(int i = 0; i &lt; M; ++i, o &lt;&lt; \"\\n\")\n        for(int j = 0; j &lt; N; ++j)\n            o &lt;&lt; val(i, j) &lt;&lt; \" \";\n    return o;\n}\n}  // namespace muda\n\nvoid logger_overload()\n{\n    Logger logger;\n    Launch(2, 1)\n        .apply(\n            [logger = logger.viewer()] __device__() mutable\n            {\n                Eigen::Matrix3f ones =\n                    Eigen::Matrix3f::Ones() * static_cast&lt;float&gt;(blockIdx.x);\n                logger &lt;&lt; \"blockIdx: (\" &lt;&lt; blockIdx &lt;&lt; \"):\\n\" &lt;&lt; ones &lt;&lt; \"\\n\";\n            })\n        .wait();\n    logger.retrieve(std::cout);\n}\n</code></pre> <p>We overloaded the <code>__device__ LogProxy&amp; operator &lt;&lt; (LogProxy&amp; o, ...)</code> function in the <code>muda</code> namespace, so that the logger can recognize the type we want to output, and then define the output format as we did with <code>operator std::ostream&amp; operator &lt;&lt; (std::ostream&amp;, ...)</code>. After that, we can directly print any <code>Eigen::Matrix</code> in the kernel.</p> <p>You may wonder why the overloaded object is <code>LogProxy</code> instead of <code>LoggerViewer</code>. This question will be explained to you later in this article.</p> <p>The running result is:</p> <p></p>"},{"location":"tutorial/logger/#print-dynamic-array","title":"Print Dynamic Array","text":"<p>What can <code>muda::Logger</code> do that <code>printf</code> cannot do? Try this!</p> <pre><code>void logger()\n{\n    std::vector&lt;int&gt; host_array(10);\n    std::iota(host_array.begin(), host_array.end(), 0);\n    DeviceBuffer&lt;int&gt; dynamic_array;\n    dynamic_array = host_array;\n\n    std::cout &lt;&lt; \"print a dynamic array using cuda `printf()` (out of order):\\n\";\n    Launch(2, 1)\n        .apply(\n            [dynamic_array = dynamic_array.viewer()] __device__() mutable\n            {\n                printf(\"[thread=%d, block=%d]: \", threadIdx.x, blockIdx.x);\n                for(int i = 0; i &lt; dynamic_array.dim(); ++i)\n                    printf(\"%d \", dynamic_array(i));\n                printf(\"(N=%d)\\n\", dynamic_array.dim());\n            })\n        .wait();\n}\n</code></pre> <p>It looks plain, just print <code>dynamic_array</code> one by one. But what is the result?</p> <p></p> <p>It is quite bad, because different threads are printing at the same time, we cannot prevent other threads from interrupting the current output, so what we finally see is the alternating output of different threads. </p> <p>Using <code>muda::Logger</code>?</p> <pre><code>void logger()\n{\n    std::vector&lt;int&gt; host_array(10);\n    std::iota(host_array.begin(), host_array.end(), 0);\n    DeviceBuffer&lt;int&gt; dynamic_array;\n    dynamic_array = host_array;\n\n    std::cout &lt;&lt; \"print a dynamic array and keep the output order using `muda::Logger`:\\n\";\n    Logger logger;\n    Launch(2, 1)\n        .apply(\n            [logger = logger.viewer(), dynamic_array = dynamic_array.viewer()] __device__() mutable\n            {\n                LogProxy proxy{logger};\n                proxy &lt;&lt; \"[thread=\" &lt;&lt; threadIdx.x &lt;&lt; \", block=\" &lt;&lt; blockIdx.x &lt;&lt; \"]: \";\n                for(int i = 0; i &lt; dynamic_array.dim(); ++i)\n                    proxy &lt;&lt; dynamic_array(i) &lt;&lt; \" \";\n                proxy &lt;&lt; \"(N=\" &lt;&lt; dynamic_array.dim() &lt;&lt; \")\\n\";\n            })\n        .wait();\n    logger.retrieve(std::cout);\n}\n</code></pre> <p></p> <p>Good! It meets our expectations.</p> <p>In the <code>muda::Logger</code> system, <code>LogProxy</code> can be constructed from a <code>LoggerViewer</code>, which is a very simple object. The object sequence written to <code>LogProxy</code> will not be interrupted by other threads. </p> <p>In the example above, we printed a dynamic array in a very cumbersome way. In fact, this cumbersome process can be encapsulated into an overload of <code>__device__ LogProxy&amp; operator &lt;&lt; (LogProxy&amp; o, ...)</code>, just like we printed <code>Eigen Matrix</code> before.</p>"},{"location":"tutorial/logger/#implementation-details","title":"Implementation Details","text":"<p>From this section, we will briefly introduce the implementation details of <code>muda::Logger</code>. If you are not interested in this part, you can skip it boldly.</p> <p>The <code>muda::Logger</code> system separates the <code>push data</code> and <code>format</code> processes: </p> <ul> <li><code>push data</code> refers to separating the output object into basic types and pushing them to a specific log buffer. In this process, we do not convert the object into a string. </li> <li><code>format</code> refers to converting basic types into formatted strings. </li> </ul> <p>The push data process is completed in the GPU Kernel, and the format process is completed on the CPU (more specifically, we complete it when we call <code>logger.retrieve()</code>).</p> <p>Though the push data process is atomic, we cannot guarantee that the push data process of different threads will not be interrupted. For example, the dynamic array printing example above. To solve this problem, we can record an ID when pushing data. This ID is called <code>LogProxyID</code>, which increases with the construction of the <code>LogProxy</code> object. We call the combination of \"basic type bytecode + LogProxyID\" <code>LoggerMetaData</code>. In this way, we know which <code>LogProxy</code> the basic type belongs to when we get each basic type.</p> <p>Later, we only need to perform a stable sort on <code>LoggerMetaData</code> when calling <code>logger.retrieve()</code> to restore the print order. For performance reasons, this <code>Stable Sort</code> uses <code>cub::DeviceRadixSort</code> (on the GPU) instead of <code>std::stable_sort</code>.</p>"},{"location":"tutorial/logger/#summary","title":"Summary","text":"<ol> <li><code>muda::Logger</code> allows us to format output objects in the Kernel using <code>&lt;&lt;</code> and allows us to overload the format output.`</li> <li><code>LogProxy</code> allows us to continuously output a dynamic array and keep the output process uninterrupted.</li> <li><code>muda::Logger</code> allows us to send the output result to any <code>std::ostream</code>.</li> </ol>"},{"location":"tutorial/logger/#limitations","title":"Limitations","text":"<p>But <code>muda::Logger</code> has a fatal flaw: </p> <p>When a cuda error occurs, if the cuda device cannot be recovered, the content printed in the Kernel cannot be retrieved. But <code>printf</code> can print output before the cuda device fails.</p>"},{"location":"tutorial/thrust/","title":"Thrust","text":"<p>Thrust is a C++ parallel programming library developed by Nvidia. It provides a unified and convenient parallel algorithm call similar to the C++ STL API. Currently, thrust, along with <code>cub</code> and <code>libcudacxx</code>, has been included in cccl (CUDA C++ Core Libraries), becoming the most core official library of cuda c++ in essence.</p> <p>The most important contribution of Thrust is to provide a set of iterator interfaces to replace pointers. Thrust's iterators not only carry the information of the original pointer, but also carry the information of the execution backend. A concrete example is that we can use <code>type_traits</code> to distinguish whether the memory pointed to by the iterator belongs to the device or host.</p> <p>Based on the iterator interface, Thrust provides functions similar to the standard library <code>&lt;algorithm&gt;</code>, such as <code>thrust::sort</code>, <code>thrust::reduce</code>, etc. These algorithms are generally called <code>parallel primitives</code> and are the cornerstone of parallel programming.</p> <p>Thrust belongs to the high-level API, and we generally use iterators to use its algorithms. But there is always a moment when we need to manually design some kernels to achieve the desired functionality. At this time, we may have to use raw pointers to read memory.</p> <p>Your code may look like this: <pre><code>#include &lt;thrust/device_vector.h&gt;\nvoid pure_thrust()\n{\n    using namespace thrust;\n    // Execute on the default stream and synchronize after the function call\n    auto nosync_policy = thrust::cuda::par_nosync.on(nullptr);\n\n    constexpr auto N = 1000;\n\n    // Apply for device side vector\n    device_vector&lt;int&gt; buffer(N);\n\n    // parallel for\n    // Use count_iterator begin=0, end=N, to construct a sequence from 0 to N\n    // This sequence will be passed into i when calling the lambda expression\n    // So we get a similar effect to parallel_for\n    // We don't need sync, because the device_vector will synchronize when destructed.\n    for_each(nosync_policy,\n             make_counting_iterator(0),\n             make_counting_iterator(N), \n             [buffer = buffer.data()] __device__(int i) mutable\n             {\n                 buffer[i] = i;\n             });\n}\n</code></pre></p> <p>Here comes the problem, the access to <code>buffer[i]</code> is unsafe. As the problem becomes more complex, especially when encountering access like <code>buffer[map[i]]</code>, it is difficult to avoid out-of-bounds or null pointer problems.</p> <p>Luckily, MUDA provides a solution to this problem. </p> <p>We can modify the code like this: <pre><code>#include &lt;muda/muda.h&gt;\nvoid muda_thrust()\n{\n    using namespace muda;\n    using namespace thrust;\n\n    auto nosync_policy = thrust::cuda::par_nosync.on(nullptr);\n\n    constexpr auto N = 1000;\n\n    device_vector&lt;int&gt; buffer(N);\n\n    {\n        // Label the Kernel Name to get clearer debug output.\n        KernelLabel label{__FUNCTION__};\n\n        for_each(nosync_policy,\n                 make_counting_iterator(0),\n                 make_counting_iterator(N),\n                 [\n                  // Create a muda::Dense1D viewer from device_vector to safely access memory.\n                  buffer = Dense1D&lt;int&gt;(raw_pointer_cast(buffer.data()), N).name(\"buffer\")\n                 ] __device__(int i) mutable\n                 {\n                     buffer(i + 1) = i;\n                 });\n    }\n}\n</code></pre></p> <p>Note that the code here has been slightly modified, and we intentionally made the buffer write out of bounds.</p> <p>We will get the following output: <pre><code>(1|2)-(231|256):&lt;error&gt; Dense1D[buffer:muda_thrust]: out of range, index=(1000) m_dim=(1000)\n</code></pre></p> <p>We will see that muda correctly reports the out-of-bounds object as buffer in <code>muda_thrust</code> kernel, because the accessed index is greater than or equal to the container size.</p> <p>It is a bit cumbersome to construct <code>Dense1D</code> every time, so muda provides a container <code>DeviceVector</code> that inherits from <code>device_vector</code>. The code can be rewritten as:</p> <pre><code>void muda_thrust()\n{\n    using namespace muda;\n    using namespace thrust;\n\n    auto nosync_policy = thrust::cuda::par_nosync.on(nullptr);\n\n    constexpr auto N = 1000;\n\n    DeviceVector&lt;int&gt; buffer(N);\n\n    {\n        KernelLabel label{__FUNCTION__};\n        for_each(nosync_policy,\n                 make_counting_iterator(0),\n                 make_counting_iterator(N),\n                 [\n                  // Create a viewer from DeviceVector to safely access memory.\n                  buffer = buffer.viewer().name(\"buffer\")\n                 ] __device__(int i) mutable\n                 {\n                     buffer(i + 1) = i;\n                 });\n    }\n}\n</code></pre>"},{"location":"tutorial/tutorial/","title":"MUDA Tutorial","text":"<p>When some demo implemented in CUDA works pretty well, you wish to turn it into a real engineering project quickly. But you will find that it is a disaster to use CUDA directly:</p> <ul> <li>Extremely low readability, the c-like APIs bury you in the insignificant details.</li> <li>Extremely high mental burden, without boundary checks, every operation that across the boundary comes with extremely high cost. CUDA Error Codes are useless.</li> </ul> <p>Now you have some other options:</p> <p>Kokkos?</p> <p>The enormousness is the only drawback.</p> <p>Or taichi?</p> <p>It is suitable for demos, but you may have to rewrite everything in CPP at some point when you want to turn it into a real engineering project.</p> <p>Or LuisaCompute?</p> <p>The developers of LuisaCompute mainly work on rendering. So it would be a great option if your goal aligns with theirs. But if you are pursuing simulation and lives in CUDA ecosystem, LuisaCompute may not be the best choice, because its RHI layer isolates the backends(DirectX, CUDA, Vulkan, Metal) and the runtime. If you want to use CUDA functionalities quickly, you may very likely need to implement the corresponding extension yourself. I personally find it time-consuming and labour-intensive after participating the development of LuisaCompute CUDA CUB Extension and Tensor Extension.</p> <p>How do other huge projects use CUDA? Actually, Zeno and Blender make a layer of abstraction over CUDA more or less. All reach some consensus:</p> <ul> <li>Use lambda expressions provided by nvcc to encapsulate kernel launches.</li> <li>Provide the visitors of device memory, naming proxy or view, and initialize these visitors in the capture lists of lambda expressions.</li> </ul> <p>With these two encapsulations, many security checks can be included naturally.</p> <p>Back to the previous question, if you want to use CUDA elegantly without importing a huge codebase, MUDA may be a great option.</p>"},{"location":"tutorial/tutorial/#what-is-muda","title":"What is MUDA?","text":"<p>MUDA is \u03bc-cuda\uff0caiming to solve the last problem of the CUDA programming:</p> <ul> <li>Header only library, works out of the box.</li> <li>Depends on CUDA and standard library.</li> <li>Improve the readability, maintainability, security and debugging efficiency of the CUDA code.</li> <li>Improve the degree of automation by simplifying the construction of CUDA graphs.</li> <li>...</li> </ul> <p>Examples\uff1a</p> <ul> <li>Once there's a operation across the boundary of the memory, MUDA tells the user the exact container/kernel/block/thread where the operation happens and terminate the program.</li> <li>When using MUDA compute graph, the dependencies of CUDA graph nodes are formed automatically and the parameters of the node are updated automatically. Users can switch between graph launch and kernel launch seamlessly.</li> <li>Kernel launch in MUDA provides enough information for user to perform operations such as reducing and scanning inside the kernel securely.</li> </ul> <p>In the next section, we will introduce the basic usage of MUDA.</p>"},{"location":"tutorial/tutorial/#getting-started","title":"Getting Started","text":"<pre><code>#include &lt;muda/muda.h&gt;\nusing namespace muda;\nint main()\n{\n    Launch(1, 1)\n        .apply(\n            [] __device__() \n            {\n                print(\"hello muda!\\n\"); \n            })\n        .wait();\n    return 0;\n}\n</code></pre> <p>This example introduce Launcher, one of the important concept in MUDA. <code>Launch</code> is the simplest launcher, with similar configuration with CUDA, except that the parameters previously inside <code>&lt;&lt;&lt;&gt;&gt;&gt;</code> are moved into the constructor of <code>Launch</code>. <code>&lt;&lt;&lt;&gt;&gt;&gt;</code> makes it hard for developing cause <code>intellisense</code> cannot recognize it, resulting in massive false information that hides the true errors.</p> <p>The invocation of <code>kernel</code> starts from <code>apply</code>. Kernels in MUDA require the types of the objects passed in to be <code>__device__ callable object</code>.</p> <p>Inside MUDA, user defined callable objects will be invoked by some <code>__global__</code> functions. All user defined kernels are executed by MUDA kernels. After calling <code>apply</code>, we call <code>wait</code> to wait for the current CUDA stream.</p> <p>In this example, we showcase a pattern of method chaining, similar to Reactive Programming, such as :</p> <ul> <li>reactive: The Reactive Extensions for .NET</li> <li>UniRx: Reactive Extensions for Unity</li> </ul> <p>Reactive Programming is proven to be suitable for async programming. The lack of knowledge on Reactive Programming doesn't hinder you from using MUDA.</p> <p>Callable Object Launch: Invoking <code>__device__ callable object</code> through <code>__global__</code> kernels.</p> <p>Remember VectorAdd in CUDA Samples?</p> <p>It computes the sum of two vectors on the device. Let's implement the same thing with MUDA.</p> <pre><code>#include &lt;muda/muda.h&gt;\n#include &lt;muda/container.h&gt;\nusing namespace muda;\nint main()\n{\n    constexpr int       N = 1024;\n    HostVector&lt;float&gt;   hA(N), hB(N),hC(N);\n    DeviceVector&lt;float&gt; dA(N), dB(N), dC(N);\n\n    // initialize A and B using random numbers\n    auto rand = [] { return std::rand() / (float)RAND_MAX; };\n    std::generate(hA.begin(), hA.end(), rand);\n    std::generate(hB.begin(), hB.end(), rand);\n\n    // copy A and B to device\n    dA = hA;\n    dB = hB;\n\n    int threadsPerBlock = 256;\n    int blocksPerGrid   = (N + threadsPerBlock - 1) / threadsPerBlock;\n\n    Launch(blocksPerGrid, threadsPerBlock)\n        .apply([dC = dC.viewer(),   // | this is a capture list              |\n                dA = dA.cviewer(),  // | map from device_vector to a viewer  |\n                dB = dB.cviewer()]  // | which is the most muda-style part!  |\n               __device__() mutable  // place \"mutable\" to make dC modifiable\n               {\n                   int i = blockDim.x * blockIdx.x + threadIdx.x;\n                   if(i &lt; N)\n                       dC(i) = dA(i) + dB(i);\n               })\n        .wait();  // wait the kernel to finish\n\n    // copy C back to host\n    hC = dC;\n}\n</code></pre> <p>Compared to <code>Hello MUDA</code>, we capture <code>viewer</code>(Read Write Viewer) and <code>cviewer</code>(Read Only Viewer). Viewer is the second important concept in MUDA.</p> <p>Definition: MUDA-viewer is a family of observer of memory, providing a method to access the memory without owning it.</p> <p>MUDA Viewer has the following traits:</p> <ul> <li>trivial copyable: there is no side-effect of copying viewers on the host, on the device or between host and device.</li> <li>mapping: viewer converts logical index to memory offset.</li> <li>checking: viewer checks the boundary when processing logical index, avoiding out-of-bounds behaviors and null pointer accesses.</li> </ul> <p>The code above is not elegant enough, in which the logic of parallel codes interweave with the parameters of the kernels, making the code obscure and less readable. In fact, this kind of operations are pretty common so there is a new Launcher <code>ParallelFor</code> in MUDA for this.</p> <p>Let's change <code>Launch</code> related code to <code>ParallelFor</code>.</p> <pre><code>#include &lt;muda/muda.h&gt;\n#include &lt;muda/container.h&gt;\nusing namespace muda;\nint main()\n{\n    constexpr int       N = 1024;\n    HostVector&lt;float&gt;   hA(N), hB(N),hC(N);\n    DeviceVector&lt;float&gt; dA(N), dB(N), dC(N);\n\n    // initialize A and B using random numbers\n    auto rand = [] { return std::rand() / (float)RAND_MAX; };\n    std::generate(hA.begin(), hA.end(), rand);\n    std::generate(hB.begin(), hB.end(), rand);\n\n    // copy A and B to device\n    dA = hA;\n    dB = hB;\n\n    // block size = 256\n    ParallelFor(256)\n        .apply(N,\n               [dC = dC.viewer(),   // | this is a capture list              |\n                dA = dA.cviewer(),  // | map from device_vector to a viewer  |\n                dB = dB.cviewer()]  // | which is the most muda-style part!  |\n               __device__(int i) mutable  // place \"mutable\" to make dC modifiable\n               {\n                   // safe parallel for will cover the rang [0, N)\n                   // i just goes from 0 to N-1\n                   dC(i) = dA(i) + dB(i);\n               })\n        .wait();  // wait the kernel to finish\n\n    // copy C back to host\n    hC = dC;\n}\n</code></pre> <p>It is easy to find that we didn't compute <code>gridDim</code> ourselves, because <code>ParallelFor</code> does this for us. The only thing we need to care about is the total number <code>N</code>. And in the kernel, we don't check the upper bound of iteration, which is also done by <code>PallelFor</code>.</p> <p>What if we want to use fixed <code>gridDim</code> and <code>blockDim</code>? Just specify them and <code>ParallelFor</code> will run in <code>grid stride loop</code>. The code code is unchanged.</p> <p><pre><code>ParallelFor(32 /*gridDim*/, 64 /*blockDim*/)\n    .apply(N,\n           [dC = dC.viewer(),   // | this is a capture list              |\n            dA = dA.cviewer(),  // | map from device_vector to a viewer  |\n            dB = dB.cviewer()]  // | which is the most muda-style part!  |\n           __device__(int i) mutable  // place \"mutable\" to make dC modifiable\n           {\n               // safe parallel for will cover the rang [0, N)\n               // i just goes from 0 to N-1\n               dC(i) = dA(i) + dB(i);\n           })\n    .wait();  // wait the kernel to finish\n</code></pre> If you are an advanced user, you may need more information to do <code>warp</code> and <code>reduce</code> safely in the kernel. You can get all of them like this.</p> <pre><code>ParallelFor(256)\n    .apply(N,\n           [] __device__(const ParallelForDetails&amp; details) mutable\n           {\n               // DynamicBlocks or GridStrideLoop\n               auto parallel_for_type   = details.parallel_for_type();\n\n               auto i                   = details.i();\n\n               auto is_final_block      = details.is_final_block();\n               auto active_num_in_block = details.active_num_in_block();\n               auto total_num           = details.total_num();\n\n               // for grid stride loop\n               auto batch_i             = details.batch_i();\n               auto total_batch         = details.total_batch();\n           })\n    .wait();\n</code></pre> <p>Replacing <code>int i</code> with <code>const ParallelForDetail&amp; details</code> to get all details about <code>ParallelFor</code>, <code>active_num_in_block</code> for example, which helps the user to avoid undefined behavior by identifying the current active thread, when doing <code>block reduce</code> or <code>warp reduce</code>.</p> <p>Next, let's across the boundary:</p> <pre><code>ParallelFor(256)\n    .apply(N,\n           [dC = dC.viewer(),   // | this is a capture list              |\n            dA = dA.cviewer(),  // | map from device_vector to a viewer  |\n            dB = dB.cviewer()]  // | which is the most muda-style part!  |\n           __device__(int i) mutable  // place \"mutable\" to make dC modifiable\n           {\n               dC(i+1) = dA(i) + dB(i);\n           })\n    .wait();  // wait the kernel to finish\n</code></pre> <p>Output:</p> <p><pre><code>(3|4)-(255|256):&lt;error&gt; dense1D[~:~]: out of range, index=(1024) m_dim=(1024)\n</code></pre> We will find that we across the boundary at <code>blockIdx=3, threadIdx=255</code>, since the index <code>1024</code> exceeds the size of the viewer. But we still don't know which viewer across the boundary.</p> <p>Let's modify the code a bit:</p> <pre><code>ParallelFor(256)\n    .kernel_name(\"vector_add\")\n    .apply(N,\n           [dC = dC.viewer().name(\"dC\"),  //  | this is a capture list              |\n            dA = dA.cviewer().name(\"dA\"),  // | map from device_vector to a viewer  |\n            dB = dB.cviewer().name(\"dB\")]  // | which is the most muda-style part!  |\n           __device__(int i) mutable  // place \"mutable\" to make dC modifiable\n           {\n               dC(i + 1) = dA(i) + dB(i);\n           })\n    .wait();  // wait the kernel to finish\n</code></pre> <p>Now we can pinpoint the error after adding the kernel name and viewer name.</p> <p>Output\uff1a</p> <pre><code>(3|4)-(255|256):&lt;error&gt; dense1D[dC:vector_add]: out of range, index=(1024) m_dim=(1024)\n</code></pre> <p>MUDA provides syntax sugar to name the viewer in <code>muda/syntax_sugar.h</code>. To avoid macro collision, do not include <code>muda/syntax_sugar.h</code> in headers.</p> <pre><code>#include &lt;muda/syntax_sugar.h&gt;\n$def(dC, dC.viewer())\n</code></pre> <p>is equivalent to </p> <pre><code>dC = dC.viewer().name(\"dC\")\n</code></pre>"},{"location":"tutorial/tutorial/#buffer-and-bufferview","title":"Buffer and BufferView","text":"<p>In addition to <code>DeviceVector</code> derived from <code>thrust::device_vector</code>, MUDA provides a light weight container, <code>DeviceBuffer&lt;T&gt;</code> for memory and <code>DeviceVar&lt;T&gt;</code> for variable on device.</p> <p>For <code>DeviceBuffer</code>, we have the following operations:</p> <pre><code>// device-device copy\nDeviceBuffer&amp; operator=(const DeviceBuffer&lt;T&gt;&amp; other);\n// device-device copy\nDeviceBuffer&amp; operator=(BufferView&lt;T&gt; other);\n// copy from host\nDeviceBuffer&amp; operator=(const std::vector&lt;T&gt;&amp; other);\n// copy to host\nvoid copy_to(T* host) const;\n// copy to host\nvoid copy_to(std::vector&lt;T&gt;&amp; host) const;\n\nvoid resize(size_t new_size);\nvoid resize(size_t new_size, const T&amp; value);\nvoid clear();\nvoid shrink_to_fit();\nvoid fill(const T&amp; v);\n</code></pre> <p>For <code>DeviceVar</code>, we have the following operations:</p> <pre><code>// device-device copy\nDeviceVar&amp; operator=(const DeviceVar&lt;T&gt;&amp; other);\n// device-device copy\nDeviceVar&amp; operator=(VarView&lt;T&gt; other);\n\n// copy from host\nDeviceVar&amp; operator=(const T&amp; val);\n// copy to host\noperator T() const;\n</code></pre> <p>All functions mentioned above run on default streams and block the main thread, meaning that the function synchronize with the main thread before returning.</p> <p>Async version of these functions should be used with <code>BufferLaunch</code>, another Launcher. </p> <p>For example, we can use the following to copy data.</p> <pre><code>Stream s;\nstd::vector&lt;int&gt; h_buffer{5};\nDeviceBuffer&lt;int&gt; d_buffer{10};\nBufferLaunch(s)\n    .copy(d_buffer.view(0/*offset*/,5/*size*/), h_buffer.data())\n    .wait();\n</code></pre> <p>In the above example, <code>BufferLaunch</code> copies data in <code>h_buffer</code> to <code>d_buffer[0, )</code>.</p> <p>Note that <code>BufferLaunch</code> will not block the main thread and synchronize with the main thread when user invoke <code>wait()</code>. Of course, some operation may still block the main thread because <code>cudaMallocAsync</code> doesn't exist in early version of CUDA and MUDA replace it with <code>cudaMalloc</code>.</p> <p>Furthermore, large proportion of interfaces in <code>BufferLaunch</code> operate on <code>BufferView</code> instead of <code>DeviceBuffer</code>. Cause these interfaces only copy or initialize the data, they don't allocate or free memory. <code>BufferView</code> records only the memory address of the original <code>DeviceBuffer</code>, i.e., the size of the offset of the original buffer, which is used by <code>BufferLaunch</code> to determine the range of the operation. MUDA also provides the transformation from <code>DeviceVector</code> to <code>BufferView</code>. The interaction between <code>DeviceBuffer</code> and <code>DeviceVector</code> builds upon the <code>BufferView</code>. <code>VarView</code> works in a similar way.</p> <p>If user have their own containers, they can use <code>BufferLaunch</code> through <code>BufferView</code> and <code>VarView</code>.</p> <pre><code>// device &lt;- device\ntemplate &lt;typename T&gt;\nBufferLaunch&amp; copy(BufferView&lt;T&gt; dst, const BufferView&lt;T&gt;&amp; src);\n// host &lt;- device\ntemplate &lt;typename T&gt;\nBufferLaunch&amp; copy(T* dst, const BufferView&lt;T&gt;&amp; src);\n// device &lt;- host\ntemplate &lt;typename T&gt;\nBufferLaunch&amp; copy(BufferView&lt;T&gt; dst, const T* src);\n\n// device &lt;- device\ntemplate &lt;typename T&gt;\nBufferLaunch&amp; copy(VarView&lt;T&gt; dst, const VarView&lt;T&gt;&amp; src);\n// host &lt;- device\ntemplate &lt;typename T&gt;\nBufferLaunch&amp; copy(T* dst, const VarView&lt;T&gt;&amp; src);\n// device &lt;- host\ntemplate &lt;typename T&gt;\nBufferLaunch&amp; copy(VarView&lt;T&gt; dst, const T* src);\n\n// device &lt;- host\ntemplate &lt;typename T&gt;\nBufferLaunch&amp; fill(BufferView&lt;T&gt; buffer, const T&amp; val);\n// device &lt;- host\ntemplate &lt;typename T&gt;\nBufferLaunch&amp; fill(VarView&lt;T&gt; buffer, const T&amp; val);\n</code></pre> <p>All the operations above will not block the main thread, so the user should invoke <code>.wait()</code> to synchronize with the main thread.</p>"},{"location":"tutorial/tutorial/#muda-compute-graph","title":"MUDA Compute Graph","text":"<p>Next, we will introduce the MUDA Compute Graph. We will focus on the usage and its meaning for engineering here. Please refer to this tutorial for its implementation details.</p> <p>For completeness of this tutorial, we will repeat part of the content of the above tutorial.</p> <pre><code>void compute_graph_simple()\n{\n    ComputeGraphVarManager manager;\n    ComputeGraph graph{manager};\n\n    // 1) Define GraphVar\n    auto&amp; N   = manager.create_var&lt;size_t&gt;(\"N\");\n    // BufferView represents a fixed memory\n    // GraphVar doesn't support dynamic memory including DeviceVector, DeviceBuffer and so on.\n    auto&amp; x_0 = manager.create_var&lt;BufferView&lt;Vector3&gt;&gt;(\"x_0\");\n    auto&amp; x   = manager.create_var&lt;BufferView&lt;Vector3&gt;&gt;(\"x\");\n    auto&amp; y   = manager.create_var&lt;BufferView&lt;Vector3&gt;&gt;(\"y\");\n\n    // 2) Create GraphNode\n    graph.create_node(\"cal_x_0\") &lt;&lt; [&amp;]\n    {\n        //Initialization\n        ParallelFor(256).apply(N.eval(),\n                               [x_0 = x_0.eval().viewer()] __device__(int i) mutable\n                               { x_0(i) = Vector3::Ones(); });\n    };\n\n    graph.create_node(\"copy_to_x\") // copy\n        &lt;&lt; [&amp;] { BufferLaunch().copy(x.eval(), x_0.ceval()); };\n\n    graph.create_node(\"copy_to_y\") // copy\n        &lt;&lt; [&amp;] { BufferLaunch().copy(y.eval(), x_0.ceval()); };\n\n    graph.create_node(\"print_x_y\") &lt;&lt; [&amp;]\n    {\n        // print\n        ParallelFor(256).apply(N.eval(),\n                               [x = x.ceval().cviewer(),\n                                y = y.ceval().cviewer(),\n                                N = N.eval()] __device__(int i) mutable\n                               {\n                                   if(N &lt;= 10)\n                                       print(\"[%d] x = (%f,%f,%f) y = (%f,%f,%f) \\n\",\n                                             i,\n                                             x(i).x(),\n                                             x(i).y(),\n                                             x(i).z(),\n                                             y(i).x(),\n                                             y(i).y(),\n                                             y(i).z());\n                               });\n    };\n    // 3) Visualize dependency graph using graphviz (Optional)\n    graph.graphviz(std::cout);\n}\n</code></pre> <p>The generated graphviz code can be viewed on Graphviz Online:</p> <p></p> <p>In the image we find that <code>copy_to_x</code> and <code>copy_to_y</code> both depends on <code>cal_x_0</code>, which is expected. It is because <code>x_0</code> is initialized first and then copied to <code>x</code> and <code>y</code>. The execution of <code>copy_to_x</code> and <code>copy_to_y</code> are fully paralleled since they read <code>x_0</code> only and they do not depend on each other. Then <code>print_x_y</code> depends on <code>copy_to_x</code> and <code>copy_to_y</code> because the writing of <code>x</code> and <code>y</code> should be finished before printing.</p> <p>Besides the nodes, we visualize the reads(red) and writes(blue) of graph vars by every graph node.</p> <p>Then we are invoking the compute graph.</p> <pre><code>void compute_graph_simple()\n{\n    ...\n    graph.graphviz(std::cout);\n\n    // Alloc resources\n    auto N_value    = 4;\n    auto x_0_buffer = DeviceBuffer&lt;Vector3&gt;(N_value);\n    auto x_buffer   = DeviceBuffer&lt;Vector3&gt;(N_value);\n    auto y_buffer   = DeviceBuffer&lt;Vector3&gt;(N_value);\n\n    // Update graph var\n    // Use update() to pass resources since we just defined the resources before.\n    N.update(N_value);\n\n    // Pass DeviceBuffer to update GraphVar directly since DeviceBuffer converts to BufferView implicitly.\n    x_0.update(x_0_buffer);\n    x.update(x_buffer);\n    y.update(y_buffer);\n\n    // Launch Graph\n    graph.launch();\n    // Or invoke all Kernels synchronously without cudaGraph\n    // graph.launch(true);\n}\n</code></pre> <p>The output is:</p> <pre><code>[0] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[1] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[2] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n[3] x = (1.000000,1.000000,1.000000) y = (1.000000,1.000000,1.000000)\n</code></pre> <p>When using <code>graph.launch()</code>, the graph will synchronize on the default stream, meaning that the graph will wait for every tasks on the default stream and the subsequent tasks after this graph will wait for current graph to complete.</p> <p><code>graph.launch(stream)</code> means that the graph will synchronize on this stream.</p> <p>In addition, we can use <code>graph.launch(single_stream=true, stream)</code>. When setting <code>single_stream</code> to true, all nodes will be invoked synchronously on the stream following the order of <code>graph.create_node</code>, other than using the cuda graph. This is helpful for debugging and profiling. In theory, the results of all the above launch methods will be the same without float number problems.</p>"},{"location":"tutorial/tutorial/#engineering-practices","title":"Engineering Practices","text":"<p>MUDA compute graph decouples the memory and computation, and it supports the automatic generation of the dependencies and the automatic update of the nodes. The design of the <code>ComputeGraphVarManager</code> allows us to store a <code>Manager</code> and several <code>ComputeGraph</code> globally. All compute graphs will receive notifications every time we update a <code>GraphVar</code> somewhere in the system, so that the related nodes will be updated before the execution of the <code>ComputeGraph</code>.</p> <p>For a huge system, we can utilize the <code>ComputeGraphVarManager</code> to construct <code>ComputeGraph</code> and update resources in anywhere of the system freely:</p> <ul> <li>Users are agnostic on the <code>ComputeGraph</code> when updating the resources.</li> <li>Users are agnostic on the resources when constructing and using the <code>ComputeGraph</code>.</li> </ul> <p>Note: Previously created <code>GraphVar</code> can be fetched by <code>find_var</code>.</p> <pre><code>auto var = manager.find_var&lt;T&gt;(\"var_name\");\n</code></pre>"},{"location":"muda/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace TCB_SPAN_NAMESPACE_NAME <ul> <li>namespace detail <ul> <li>struct has_size_and_data </li> <li>struct has_size_and_data </li> <li>struct is_complete </li> <li>struct is_complete </li> <li>struct is_container </li> <li>struct is_container_element_type_compatible </li> <li>struct is_container_element_type_compatible </li> <li>struct is_span </li> <li>struct is_span </li> <li>struct is_std_array </li> <li>struct is_std_array </li> <li>struct span_storage </li> <li>struct span_storage </li> </ul> </li> <li>class span </li> </ul> </li> <li>namespace muda <ul> <li>class BSRMatrixViewT </li> <li>class Buffer2DViewT </li> <li>class Buffer3DViewT </li> <li>class BufferLaunch </li> <li>class BufferViewT </li> <li>class CFieldEntryView </li> <li>class CFieldEntryViewer </li> <li>class CMatrixMapInfo </li> <li>class COOMatrixViewT </li> <li>class COOVectorViewBase </li> <li>class ClosureId </li> <li>class ComputeGraph <ul> <li>class AddNodeProxy </li> <li>class GraphPhaseGuard </li> </ul> </li> <li>class ComputeGraphBuilder </li> <li>class ComputeGraphCaptureNode </li> <li>class ComputeGraphClosure </li> <li>class ComputeGraphDependency </li> <li>class ComputeGraphGraphvizOptions </li> <li>class ComputeGraphNode </li> <li>class ComputeGraphNodeBase </li> <li>class ComputeGraphVar </li> <li>class ComputeGraphVar </li> <li>class ComputeGraphVar </li> <li>class ComputeGraphVar </li> <li>class ComputeGraphVar </li> <li>class ComputeGraphVar </li> <li>class ComputeGraphVarBase </li> <li>class ComputeGraphVarManager </li> <li>class CubWrapper </li> <li>class Debug </li> <li>struct Default </li> <li>class Dense1DT </li> <li>class Dense2DBase </li> <li>class Dense3DBase </li> <li>class DenseMatrixViewT </li> <li>class DenseMatrixViewerT </li> <li>class DenseVectorViewT </li> <li>class DenseVectorViewerT </li> <li>class DenseViewerT </li> <li>class DeviceBCOOMatrix </li> <li>class DeviceBCOOMatrix </li> <li>class DeviceBCOOVector </li> <li>class DeviceBCOOVector </li> <li>class DeviceBSRMatrix </li> <li>class DeviceBuffer A <code>std::vector</code> like wrapper of cuda device memory, allows user to: </li> <li>class DeviceBuffer2D </li> <li>class DeviceBuffer3D </li> <li>class DeviceDenseMatrix </li> <li>class DeviceDenseVector </li> <li>class DeviceDoubletVector </li> <li>class DeviceHistogram </li> <li>class DeviceMergeSort </li> <li>class DevicePartition </li> <li>class DeviceRadixSort </li> <li>class DeviceReduce </li> <li>class DeviceRunLengthEncode </li> <li>class DeviceScan </li> <li>class DeviceSegmentedRadixSort </li> <li>class DeviceSegmentedReduce </li> <li>class DeviceSegmentedSort </li> <li>class DeviceSelect </li> <li>class DeviceSpmv </li> <li>class DeviceTripletMatrix </li> <li>class DeviceVar </li> <li>class DeviceVector </li> <li>class DoubletVectorViewT </li> <li>class DoubletVectorViewT </li> <li>class DoubletVectorViewerT <ul> <li>struct CDoublet </li> <li>class Proxy </li> </ul> </li> <li>class Empty </li> <li>class Event RAII wrapper for cudaEvent. </li> <li>class EventRecordNode </li> <li>class EventWaitNode </li> <li>class Extent2D </li> <li>class Extent3D </li> <li>class Field </li> <li>class FieldBuildOptions </li> <li>class FieldBuilder <ul> <li>class EntryProxy </li> </ul> </li> <li>class FieldEntry </li> <li>class FieldEntryBase </li> <li>class FieldEntryBaseData </li> <li>class FieldEntryCore </li> <li>class FieldEntryLaunch </li> <li>class FieldEntryLayoutInfo </li> <li>class FieldEntryView </li> <li>class FieldEntryViewBase </li> <li>class FieldEntryViewCore <ul> <li>struct AsIterator </li> </ul> </li> <li>class FieldEntryViewer </li> <li>class FieldEntryViewerBase </li> <li>class FieldEntryViewerCore </li> <li>class Flags </li> <li>class Graph </li> <li>class GraphExec </li> <li>class GraphLaunch </li> <li>class GraphNode </li> <li>class GraphViewer </li> <li>class HostCall </li> <li>class HostDeviceConfig </li> <li>class HostDeviceConfigView </li> <li>class HostNode </li> <li>class HostNodeParms </li> <li>class HostVector </li> <li>class IdWithType </li> <li>class Kernel </li> <li>class KernelLabel </li> <li>class KernelNode </li> <li>class KernelNodeParms </li> <li>class Launch A wrapper of raw cuda kernel launch in muda style , removing the<code>&lt;&lt;&lt;&gt;&gt;&gt;</code> usage, for better intellisense support. </li> <li>class LaunchBase </li> <li>class LaunchCore </li> <li>class LinearSystemAlgorithm </li> <li>class LinearSystemContext </li> <li>class LinearSystemContextCreateInfo </li> <li>class LinearSystemHandles </li> <li>class LinearSystemSolveReorder </li> <li>class LinearSystemSolveTolerance </li> <li>class LogProxy </li> <li>class Logger </li> <li>class LoggerDataContainer </li> <li>class LoggerMetaData </li> <li>class LoggerViewer </li> <li>class MatrixFormatConverter </li> <li>class MatrixMapInfo For MapMatrix e.g. Eigen::Map&lt; ... &gt; </li> <li>class MemcpyNode </li> <li>class Memory </li> <li>class MemsetNode </li> <li>class NDReshaper </li> <li>class NodeId </li> <li>class NodeParms </li> <li>class Offset2D </li> <li>class Offset3D </li> <li>class ParallelFor a frequently used parallel for loop, DynamicBlockDim andGridStrideLoop strategy are provided, and can be switched seamlessly to each other. </li> <li>class ParallelForDetails </li> <li>class Profile </li> <li>class RangeName </li> <li>class Stream RAII wrapper for cudaStream. <ul> <li>class FireAndForget </li> <li>class GraphFireAndForget </li> <li>class GraphTailLaunch </li> <li>class TailLaunch </li> </ul> </li> <li>class SubField </li> <li>class SubFieldImpl </li> <li>class SubFieldImpl </li> <li>class SubFieldImpl </li> <li>class SubFieldImpl </li> <li>class SubFieldInterface </li> <li>struct Tag </li> <li>class TripletMatrixViewT </li> <li>class TripletMatrixViewT </li> <li>class TripletMatrixViewerT <ul> <li>struct CTriplet </li> <li>class Proxy </li> </ul> </li> <li>class VarId </li> <li>class VarViewT </li> <li>class ViewBase </li> <li>class ViewerBase </li> <li>struct always_false </li> <li>struct always_true </li> <li>namespace config </li> <li>class cuda_error </li> <li>namespace details <ul> <li>class ComputeGraphAccessor </li> <li>class HostDeviceStringCache </li> <li>struct LaunchCallable </li> <li>class LaunchInfoCache </li> <li>class LocalVarId </li> <li>class LocalVarInfo </li> <li>class LoggerMetaData </li> <li>class LoggerOffset </li> <li>class MatrixFormatConverter </li> <li>class MatrixFormatConverterBase </li> <li>class MatrixFormatConverterType </li> <li>class ParallelForCallable </li> <li>struct SoACopyMap </li> <li>class StringPointer </li> <li>class TempBuffer </li> <li>namespace buffer <ul> <li>class BufferInfoAccessor </li> </ul> </li> <li>namespace eigen <ul> <li>union un </li> </ul> </li> <li>namespace field </li> <li>namespace stream </li> </ul> </li> <li>namespace distance </li> <li>namespace eigen <ul> <li>struct AnalyticalInverse </li> <li>struct GaussEliminationInverse </li> </ul> </li> <li>class exception </li> <li>struct force_trivial </li> <li>struct force_trivially_constructible </li> <li>struct force_trivially_copy_assignable </li> <li>struct force_trivially_copy_constructible </li> <li>struct force_trivially_destructible </li> <li>class invalid_argument </li> <li>struct is_cuda_arch </li> <li>namespace lbvh <ul> <li>struct AABB </li> <li>class BVH </li> <li>struct DefaultMortonCodeCalculator </li> <li>namespace details <ul> <li>class BVHViewerBase <ul> <li>struct DefaultQueryCallback </li> </ul> </li> <li>struct Node </li> </ul> </li> <li>struct query_nearest </li> <li>struct query_overlap </li> <li>struct vector_of </li> <li>struct vector_of </li> <li>struct vector_of </li> </ul> </li> <li>class logic_error </li> <li>class not_implemented </li> <li>class out_of_range </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_only_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>struct read_write_view </li> <li>class runtime_error </li> <li>namespace spatial_hash <ul> <li>class AABB </li> <li>class BoundingSphere </li> <li>class CollisionPair </li> <li>class DefaultPredication </li> <li>class Morton </li> <li>class Morton </li> <li>class Morton </li> <li>class SparseSpatialHash </li> <li>class SpatialHashTableInfo </li> <li>class SpatialPartitionCell To represent a cell-object pair in the spatial hash 3D grid e.g. (cell_id,object_id) = (1024, 32) for the meaning: the 32th object overlap with the 1024th cell. </li> <li>namespace details <ul> <li>class SparseSpatialHashImpl </li> </ul> </li> </ul> </li> </ul> </li> <li>class RelatedClosureInfo </li> <li>class StringLocation </li> <li>namespace std <ul> <li>struct hash&lt; muda::ClosureId &gt; </li> <li>struct hash&lt; muda::IdWithType&lt; T &gt; &gt; </li> <li>struct hash&lt; muda::details::MatrixFormatConverterType &gt; </li> <li>class tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; </li> <li>class tuple_size&lt; TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; </li> </ul> </li> <li>namespace thrust </li> </ul>"},{"location":"muda/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>dir muda <ul> <li>file assert.h </li> <li>file atomic.h </li> <li>file buffer.h </li> <li>file compute_graph.h </li> <li>file container.h </li> <li>file debug.h </li> <li>file exception.h </li> <li>file graph.h </li> <li>file launch.h </li> <li>file logger.h </li> <li>file muda.h </li> <li>file muda_config.h </li> <li>file muda_def.h </li> <li>file print.h </li> <li>file profiler.h </li> <li>dir buffer <ul> <li>file agent.h </li> <li>file buffer_2d_view.h </li> <li>file buffer_3d_view.h </li> <li>file buffer_fwd.h </li> <li>file buffer_info_accessor.h </li> <li>file buffer_launch.h </li> <li>file buffer_view.h A view interface for any array-like liner memory, which can be constructed from DeviceBuffer/DeviceVector or any thing that is a array-like liner memory, e.g. raw cuda pointer. </li> <li>file device_buffer.h A light-weight wrapper of cuda device memory. Like <code>std::vector</code> , allow user to resize, reserve, shrink_to_fit, fill, also provide muda viewer for in-kernel access. </li> <li>file device_buffer_2d.h </li> <li>file device_buffer_3d.h A light-weight wrapper of cuda device memory3D, allows user to resize, reserve, shrink_to_fit, fill, also provide muda viewer for in-kernel access. </li> <li>file device_var.h </li> <li>file graph_buffer_2d_view.h </li> <li>file graph_buffer_3d_view.h </li> <li>file graph_buffer_view.h </li> <li>file graph_var_view.h </li> <li>dir agent <ul> <li>file kernel_assign.h </li> <li>file kernel_construct.h </li> <li>file kernel_copy_construct.h </li> <li>file kernel_destruct.h </li> <li>file kernel_fill.h </li> </ul> </li> <li>dir reshape_nd <ul> <li>file masked_compare.h </li> <li>file masked_swap.h </li> <li>file nd_reshaper.h </li> <li>file reserve.h </li> </ul> </li> <li>file var_view.h </li> </ul> </li> <li>dir check <ul> <li>file check.h </li> <li>file check_cublas.h </li> <li>file check_cuda_errors.h </li> <li>file check_cusolver.h </li> <li>file check_cusparse.h </li> </ul> </li> <li>dir compute_graph <ul> <li>file compute_graph.h </li> <li>file compute_graph_accessor.h </li> <li>file compute_graph_builder.h </li> <li>file compute_graph_closure.h </li> <li>file compute_graph_closure_id.h </li> <li>file compute_graph_dependency.h </li> <li>file compute_graph_flag.h </li> <li>file compute_graph_fwd.h </li> <li>file compute_graph_node.h </li> <li>file compute_graph_node_id.h </li> <li>file compute_graph_node_type.h </li> <li>file compute_graph_phase.h </li> <li>file compute_graph_var.h </li> <li>file compute_graph_var_id.h </li> <li>file compute_graph_var_manager.h </li> <li>file compute_graph_var_usage.h </li> <li>file graphviz_options.h </li> <li>dir nodes <ul> <li>file compute_graph_catpure_node.h </li> <li>file compute_graph_event_node.h </li> <li>file compute_graph_kernel_node.h </li> <li>file compute_graph_memory_node.h </li> </ul> </li> </ul> </li> <li>dir container <ul> <li>file var.h </li> <li>file vector.h </li> </ul> </li> <li>dir cub <ul> <li>file cub.h </li> <li>file cub_device.h </li> <li>dir device <ul> <li>file cub_wrapper.h </li> <li>file device_adjacent_difference.h </li> <li>file device_histogram.h </li> <li>file device_merge_sort.h </li> <li>file device_partition.h </li> <li>file device_radix_sort.h </li> <li>file device_reduce.h </li> <li>file device_run_length_encode.h </li> <li>file device_scan.h </li> <li>file device_segmented_radix_sort.h </li> <li>file device_segmented_reduce.h </li> <li>file device_segmented_sort.h </li> <li>file device_select.h </li> <li>file device_spmv.h </li> </ul> </li> <li>file util_type.h </li> </ul> </li> <li>dir cuda <ul> <li>file cooperative_groups.h </li> <li>file cuda_runtime.h </li> <li>file cuda_runtime_api.h </li> <li>file device_atomic_functions.h </li> <li>file device_functions.h </li> <li>dir cooperative_groups <ul> <li>file memcpy_async.h </li> <li>file reduce.h </li> <li>file scan.h </li> </ul> </li> </ul> </li> <li>dir ext <ul> <li>file eigen.h </li> <li>file field.h </li> <li>file linear_system.h </li> <li>dir eigen <ul> <li>file as_eigen.h </li> <li>file atomic.h </li> <li>file eigen_core_cxx20.h </li> <li>file eigen_cxx20.h </li> <li>file eigen_dense_cxx20.h </li> <li>file evd.h </li> <li>file inverse.h </li> <li>file log_proxy.h </li> <li>dir inverse <ul> <li>file analytic_inverse.h </li> <li>file gauss_elimination.h </li> </ul> </li> <li>dir svd <ul> <li>file svd_impl.h </li> </ul> </li> <li>file svd.h </li> </ul> </li> <li>dir field <ul> <li>file field.h </li> <li>file field_build_options.h </li> <li>file field_builder.h </li> <li>file field_entry.h </li> <li>file field_entry_base_data.h </li> <li>file field_entry_core.h </li> <li>file field_entry_launch.h </li> <li>file field_entry_layout.h </li> <li>file field_entry_type.h </li> <li>file field_entry_view.h </li> <li>file field_entry_viewer.h </li> <li>file field_viewer.h </li> <li>file matrix_map_info.h </li> <li>dir sub_field <ul> <li>file aos_sub_field.h </li> <li>file aosoa_sub_field.h </li> <li>file soa_sub_field.h </li> </ul> </li> <li>file sub_field.h </li> <li>file sub_field_interface.h </li> </ul> </li> <li>dir geo <ul> <li>file distance.h distance calculation for point/edge/triangle </li> <li>file lbvh.h </li> <li>file spatial_hash.h </li> <li>dir distance <ul> <li>file ccd.h </li> <li>file distance_type.h </li> <li>file distance_unclassified.h </li> <li>file edge_edge.h </li> <li>file edge_edge_mollified.h </li> <li>file point_edge.h </li> <li>file point_point.h </li> <li>file point_triangle.h </li> </ul> </li> <li>dir lbvh <ul> <li>file aabb.h </li> <li>file bvh.h </li> <li>file bvh_viewer.h </li> <li>file lbvh.h </li> <li>file morton_code.h </li> <li>file predicator.h </li> <li>file query.h </li> <li>file utility.h </li> </ul> </li> <li>dir spatial_hash <ul> <li>file bounding_volume.h </li> <li>file collision_pair.h </li> <li>file morton_hash.h </li> <li>file sparse_spatial_hash.h </li> <li>file sparse_spatial_hash_impl.h </li> </ul> </li> </ul> </li> <li>dir linear_system <ul> <li>file bcoo_matrix_view.h </li> <li>file bcoo_matrix_viewer.h </li> <li>file bcoo_vector_view.h </li> <li>file bcoo_vector_viewer.h </li> <li>file bsr_matrix_view.h </li> <li>file common.h </li> <li>file csr_matrix_view.h </li> <li>file dense_matrix_view.h </li> <li>file dense_matrix_viewer.h </li> <li>file dense_vector_view.h </li> <li>file dense_vector_viewer.h </li> <li>file device_bcoo_matrix.h </li> <li>file device_bcoo_vector.h </li> <li>file device_bsr_matrix.h </li> <li>file device_csr_matrix.h </li> <li>file device_dense_matrix.h </li> <li>file device_dense_vector.h </li> <li>file device_doublet_vector.h </li> <li>file device_triplet_matrix.h </li> <li>file doublet_vector_view.h </li> <li>file doublet_vector_viewer.h </li> <li>file linear_system_context.h </li> <li>file linear_system_handles.h </li> <li>file linear_system_solve_reorder.h </li> <li>file linear_system_solve_tolerance.h </li> <li>file matrix_format_converter.h </li> <li>file matrix_format_converter_impl.h </li> <li>dir type_mapper <ul> <li>file algo_mapper.h </li> <li>file data_type_mapper.h </li> </ul> </li> <li>file triplet_matrix_view.h </li> <li>file triplet_matrix_viewer.h </li> </ul> </li> </ul> </li> <li>dir graph <ul> <li>file event_node.h </li> <li>file graph.h </li> <li>file graph_base.h </li> <li>file graph_exec.h </li> <li>file graph_graph_viewer.h </li> <li>file graph_instantiate_flag.h </li> <li>file graph_launch.h </li> <li>file graph_viewer.h </li> <li>file host_node.h </li> <li>file kernel_node.h </li> <li>file memory_node.h </li> </ul> </li> <li>dir launch <ul> <li>file event.h </li> <li>file host_call.h </li> <li>file kernel.h </li> <li>file kernel_label.h </li> <li>file kernel_tag.h </li> <li>file launch.h cuda kernel launch in muda style. </li> <li>file launch_base.h </li> <li>file memory.h </li> <li>file parallel_for.h A frequently used parallel for loop, DynamicBlockDim andGridStrideLoop strategy are provided, and can be switched seamlessly to each other. </li> <li>file stream.h </li> <li>file stream_define.h </li> </ul> </li> <li>dir literal <ul> <li>file unit.h </li> </ul> </li> <li>dir logger <ul> <li>file logger.h </li> <li>file logger_basic_data.h </li> <li>file logger_function.h </li> <li>file logger_viewer.h </li> </ul> </li> <li>dir mstl <ul> <li>file span.h </li> <li>dir tcb <ul> <li>file span.hpp </li> </ul> </li> </ul> </li> <li>dir tools <ul> <li>file cuda_vec_utils.h </li> <li>file debug_break.h </li> <li>file debug_log.h </li> <li>file extent.h </li> <li>file filesystem.h </li> <li>file flag.h </li> <li>file fuzzy.h </li> <li>file host_device_config.h </li> <li>file host_device_string_cache.h </li> <li>file id_with_type.h </li> <li>file launch_info_cache.h </li> <li>file platform.h </li> <li>file string_pointer.h </li> <li>file temp_buffer.h </li> <li>file version.h </li> </ul> </li> <li>dir type_traits <ul> <li>file always.h </li> <li>file cuda_arch.h </li> <li>file type_label.h </li> <li>file type_modifier.h </li> </ul> </li> <li>dir view <ul> <li>file view_base.h </li> </ul> </li> <li>dir viewer <ul> <li>file dense.h </li> <li>dir dense <ul> <li>file dense_0d.h </li> <li>file dense_1d.h A C/C++ array like viewer for kernel access, with safe checking on any input. You can index the element in <code>Dense1D&lt;T&gt;</code> by<code>operator ()</code> . </li> <li>file dense_2d.h </li> <li>file dense_3d.h </li> </ul> </li> <li>file viewer_base.h </li> </ul> </li> <li>file syntax_sugar.h </li> <li>file type_define.h </li> <li>file viewer.h </li> </ul> </li> </ul> </li> </ul>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/","title":"Namespace TCB_SPAN_NAMESPACE_NAME","text":"<p>Namespace List &gt; TCB_SPAN_NAMESPACE_NAME</p>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#namespaces","title":"Namespaces","text":"Type Name namespace detail"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#classes","title":"Classes","text":"Type Name class span &lt;typename ElementType, Extent&gt;"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#public-types","title":"Public Types","text":"Type Name typedef unsigned char byte"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#public-attributes","title":"Public Attributes","text":"Type Name TCB_SPAN_INLINE_VAR constexpr std::size_t dynamic_extent   = = SIZE_MAX"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#public-functions","title":"Public Functions","text":"Type Name span&lt; const byte,((Extent==dynamic_extent) ? dynamic_extent :sizeof(ElementType) *Extent)&gt; as_bytes (span&lt; ElementType, Extent &gt; s) noexcept span&lt; byte,((Extent==dynamic_extent) ? dynamic_extent :sizeof(ElementType) *Extent)&gt; as_writable_bytes (span&lt; ElementType, Extent &gt; s) noexcept decltype(s[N]) get (span&lt; E, S &gt; s)  span&lt; ElementType, Extent &gt; make_span (span&lt; ElementType, Extent &gt; s) noexcept span&lt; T, N &gt; make_span (T(&amp;) arr) noexcept TCB_SPAN_ARRAY_CONSTEXPR span&lt; T, N &gt; make_span (std::array&lt; T, N &gt; &amp; arr) noexcept TCB_SPAN_ARRAY_CONSTEXPR span&lt; const T, N &gt; make_span (const std::array&lt; T, N &gt; &amp; arr) noexcept span&lt; typename std::remove_reference&lt; decltype(*detail::data(std::declval&lt; Container &amp; &gt;()))&gt;::type &gt; make_span (Container &amp; cont)  span&lt; const typename Container::value_type &gt; make_span (const Container &amp; cont)"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#typedef-byte","title":"typedef byte","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::byte =  unsigned char;\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#variable-dynamic_extent","title":"variable dynamic_extent","text":"<pre><code>TCB_SPAN_INLINE_VAR constexpr std::size_t TCB_SPAN_NAMESPACE_NAME::dynamic_extent;\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#function-as_bytes","title":"function as_bytes","text":"<pre><code>template&lt;typename ElementType, std::size_t Extent&gt;\nspan &lt; const byte,((Extent==dynamic_extent) ? dynamic_extent :sizeof(ElementType) *Extent)&gt; TCB_SPAN_NAMESPACE_NAME::as_bytes (\n    span &lt; ElementType, Extent &gt; s\n) noexcept\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#function-as_writable_bytes","title":"function as_writable_bytes","text":"<pre><code>template&lt;class ElementType, size_t Extent, typename std::enable_if&lt;!std::is_const&lt; ElementType &gt;::value, int &gt;::type&gt;\nspan &lt; byte,((Extent==dynamic_extent) ? dynamic_extent :sizeof(ElementType) *Extent)&gt; TCB_SPAN_NAMESPACE_NAME::as_writable_bytes (\n    span &lt; ElementType, Extent &gt; s\n) noexcept\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#function-get","title":"function get","text":"<pre><code>template&lt;std::size_t N, typename E, std::size_t S&gt;\ndecltype(s[N]) TCB_SPAN_NAMESPACE_NAME::get (\n    span &lt; E, S &gt; s\n) \n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#function-make_span","title":"function make_span","text":"<pre><code>template&lt;typename ElementType, std::size_t Extent&gt;\nspan &lt; ElementType, Extent &gt; TCB_SPAN_NAMESPACE_NAME::make_span (\n    span &lt; ElementType, Extent &gt; s\n) noexcept\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#function-make_span_1","title":"function make_span","text":"<pre><code>template&lt;typename T, std::size_t N&gt;\nspan &lt; T, N &gt; TCB_SPAN_NAMESPACE_NAME::make_span (\n    T(&amp;) arr\n) noexcept\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#function-make_span_2","title":"function make_span","text":"<pre><code>template&lt;typename T, std::size_t N&gt;\nTCB_SPAN_ARRAY_CONSTEXPR span &lt; T, N &gt; TCB_SPAN_NAMESPACE_NAME::make_span (\n    std::array&lt; T, N &gt; &amp; arr\n) noexcept\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#function-make_span_3","title":"function make_span","text":"<pre><code>template&lt;typename T, std::size_t N&gt;\nTCB_SPAN_ARRAY_CONSTEXPR span &lt; const T, N &gt; TCB_SPAN_NAMESPACE_NAME::make_span (\n    const std::array&lt; T, N &gt; &amp; arr\n) noexcept\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#function-make_span_4","title":"function make_span","text":"<pre><code>template&lt;typename Container&gt;\nspan &lt; typename std::remove_reference&lt; decltype(*detail::data(std::declval&lt; Container &amp; &gt;()))&gt;::type &gt; TCB_SPAN_NAMESPACE_NAME::make_span (\n    Container &amp; cont\n) \n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e/#function-make_span_5","title":"function make_span","text":"<pre><code>template&lt;typename Container&gt;\nspan &lt; const typename Container::value_type &gt; TCB_SPAN_NAMESPACE_NAME::make_span (\n    const Container &amp; cont\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/","title":"Namespace TCB_SPAN_NAMESPACE_NAME::detail","text":"<p>Namespace List &gt; TCB_SPAN_NAMESPACE_NAME &gt; detail</p>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#classes","title":"Classes","text":"Type Name struct has_size_and_data &lt;typename, typename&gt; struct has_size_and_data &lt;typename, typename&gt; struct is_complete &lt;typename, typename&gt; struct is_complete &lt;typename, typename&gt; struct is_container &lt;typename C, typename U&gt; struct is_container_element_type_compatible &lt;typename, typename, typename&gt; struct is_container_element_type_compatible &lt;typename, typename, typename&gt; struct is_span &lt;typename&gt; struct is_span &lt;typename&gt; struct is_std_array &lt;typename&gt; struct is_std_array &lt;typename&gt; struct span_storage &lt;typename E, S&gt; struct span_storage &lt;typename E, S&gt;"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#public-types","title":"Public Types","text":"Type Name typedef typename std::remove_pointer&lt; T &gt;::type remove_pointer_t typedef typename std::remove_cv&lt; typename std::remove_reference&lt; T &gt;::type &gt;::type uncvref_t typedef void void_t"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#public-functions","title":"Public Functions","text":"Type Name decltype(c.data()) data (C &amp; c)  decltype(c.data()) data (const C &amp; c)  T * data (T(&amp;) array) noexcept const E * data (std::initializer_list&lt; E &gt; il) noexcept decltype(c.size()) size (const C &amp; c)  std::size_t size (const  T) noexcept"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#typedef-remove_pointer_t","title":"typedef remove_pointer_t","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::detail::remove_pointer_t =  typename std::remove_pointer&lt;T&gt;::type;\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#typedef-uncvref_t","title":"typedef uncvref_t","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::detail::uncvref_t = \n    typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type;\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#typedef-void_t","title":"typedef void_t","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::detail::void_t =  void;\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#function-data","title":"function data","text":"<pre><code>template&lt;class C&gt;\ndecltype(c.data()) TCB_SPAN_NAMESPACE_NAME::detail::data (\n    C &amp; c\n) \n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#function-data_1","title":"function data","text":"<pre><code>template&lt;class C&gt;\ndecltype(c.data()) TCB_SPAN_NAMESPACE_NAME::detail::data (\n    const C &amp; c\n) \n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#function-data_2","title":"function data","text":"<pre><code>template&lt;class T, std::size_t N&gt;\nT * TCB_SPAN_NAMESPACE_NAME::detail::data (\n    T(&amp;) array\n) noexcept\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#function-data_3","title":"function data","text":"<pre><code>template&lt;class E&gt;\nconst E * TCB_SPAN_NAMESPACE_NAME::detail::data (\n    std::initializer_list&lt; E &gt; il\n) noexcept\n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#function-size","title":"function size","text":"<pre><code>template&lt;class C&gt;\ndecltype(c.size()) TCB_SPAN_NAMESPACE_NAME::detail::size (\n    const C &amp; c\n) \n</code></pre>"},{"location":"muda/namespace_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail/#function-size_1","title":"function size","text":"<pre><code>template&lt;class T, std::size_t N&gt;\nstd::size_t TCB_SPAN_NAMESPACE_NAME::detail::size (\n    const T\n) noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1has__size__and__data/","title":"Struct TCB_SPAN_NAMESPACE_NAME::detail::has_size_and_data","text":"<p>template &lt;typename, typename&gt;</p> <p>ClassList &gt; TCB_SPAN_NAMESPACE_NAME &gt; detail &gt; has_size_and_data</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1is__complete/","title":"Struct TCB_SPAN_NAMESPACE_NAME::detail::is_complete","text":"<p>template &lt;typename, typename&gt;</p> <p>ClassList &gt; TCB_SPAN_NAMESPACE_NAME &gt; detail &gt; is_complete</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1is__container/","title":"Struct TCB_SPAN_NAMESPACE_NAME::detail::is_container","text":"<p>template &lt;typename C, typename U&gt;</p> <p>ClassList &gt; TCB_SPAN_NAMESPACE_NAME &gt; detail &gt; is_container</p>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1is__container/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool value   = = &lt;U&gt;::value &amp;&amp; &lt;U&gt;::value &amp;&amp; !std::is_array&lt;U&gt;::value &amp;&amp; has_size_and_data&lt;C&gt;::value"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1is__container/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1is__container/#variable-value","title":"variable value","text":"<pre><code>bool TCB_SPAN_NAMESPACE_NAME::detail::is_container&lt; C, U &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1is__container__element__type__compatible/","title":"Struct TCB_SPAN_NAMESPACE_NAME::detail::is_container_element_type_compatible","text":"<p>template &lt;typename, typename, typename&gt;</p> <p>ClassList &gt; TCB_SPAN_NAMESPACE_NAME &gt; detail &gt; is_container_element_type_compatible</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1is__span/","title":"Struct TCB_SPAN_NAMESPACE_NAME::detail::is_span","text":"<p>template &lt;typename&gt;</p> <p>ClassList &gt; TCB_SPAN_NAMESPACE_NAME &gt; detail &gt; is_span</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1is__std__array/","title":"Struct TCB_SPAN_NAMESPACE_NAME::detail::is_std_array","text":"<p>template &lt;typename&gt;</p> <p>ClassList &gt; TCB_SPAN_NAMESPACE_NAME &gt; detail &gt; is_std_array</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/","title":"Struct TCB_SPAN_NAMESPACE_NAME::detail::span_storage","text":"<p>template &lt;typename E, std::size_t S&gt;</p> <p>ClassList &gt; TCB_SPAN_NAMESPACE_NAME &gt; detail &gt; span_storage</p>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#public-attributes","title":"Public Attributes","text":"Type Name E * ptr   = = nullptr"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::size_t size   = = S"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#public-functions","title":"Public Functions","text":"Type Name constexpr span_storage () noexcept constexpr span_storage (E * p_ptr, std::size_t) noexcept"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#variable-ptr","title":"variable ptr","text":"<pre><code>E* TCB_SPAN_NAMESPACE_NAME::detail::span_storage&lt; E, S &gt;::ptr;\n</code></pre>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#variable-size","title":"variable size","text":"<pre><code>std::size_t TCB_SPAN_NAMESPACE_NAME::detail::span_storage&lt; E, S &gt;::size;\n</code></pre>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#function-span_storage-12","title":"function span_storage [1/2]","text":"<pre><code>constexpr TCB_SPAN_NAMESPACE_NAME::detail::span_storage::span_storage () noexcept\n</code></pre>"},{"location":"muda/struct_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1detail_1_1span__storage/#function-span_storage-22","title":"function span_storage [2/2]","text":"<pre><code>inline constexpr TCB_SPAN_NAMESPACE_NAME::detail::span_storage::span_storage (\n    E * p_ptr,\n    std::size_t\n) noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/","title":"Class TCB_SPAN_NAMESPACE_NAME::span","text":"<p>template &lt;typename ElementType, std::size_t Extent&gt;</p> <p>ClassList &gt; TCB_SPAN_NAMESPACE_NAME &gt; span</p>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#public-types","title":"Public Types","text":"Type Name typedef const element_type * const_pointer typedef const element_type &amp; const_reference typedef std::ptrdiff_t difference_type typedef ElementType element_type typedef pointer iterator typedef element_type * pointer typedef element_type &amp; reference typedef std::reverse_iterator&lt; iterator &gt; reverse_iterator typedef std::size_t size_type typedef span&lt; ElementType, Count !=dynamic_extent ? Count :(Extent !=dynamic_extent ? Extent - Offset :dynamic_extent)&gt; subspan_return_t typedef typename std::remove_cv&lt; ElementType &gt;::type value_type"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#public-static-attributes","title":"Public Static Attributes","text":"Type Name size_type extent   = = Extent"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#public-functions","title":"Public Functions","text":"Type Name TCB_SPAN_CONSTEXPR11 reference back () const iterator begin () noexcept const pointer data () noexcept const TCB_SPAN_NODISCARD constexpr bool empty () noexcept const iterator end () noexcept const TCB_SPAN_CONSTEXPR11 span&lt; element_type, Count &gt; first () const TCB_SPAN_CONSTEXPR11 span&lt; element_type, dynamic_extent &gt; first (size_type count) const TCB_SPAN_CONSTEXPR11 reference front () const TCB_SPAN_CONSTEXPR11 span&lt; element_type, Count &gt; last () const TCB_SPAN_CONSTEXPR11 span&lt; element_type, dynamic_extent &gt; last (size_type count) const TCB_SPAN_CONSTEXPR_ASSIGN span &amp; operator= (const span &amp; other) noexcept TCB_SPAN_CONSTEXPR11 reference operator[] (size_type idx) const TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rbegin () noexcept const TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rend () noexcept const size_type size () noexcept const size_type size_bytes () noexcept const constexpr span () noexcept TCB_SPAN_CONSTEXPR11 span (pointer ptr, size_type count)  TCB_SPAN_CONSTEXPR11 span (pointer first_elem, pointer last_elem)  constexpr span (element_type(&amp;) arr) noexcept TCB_SPAN_ARRAY_CONSTEXPR span (std::array&lt; T, N &gt; &amp; arr) noexcept TCB_SPAN_ARRAY_CONSTEXPR span (const std::array&lt; T, N &gt; &amp; arr) noexcept constexpr span (Container &amp; cont)  constexpr span (const Container &amp; cont)  constexpr span (const span &amp; other) noexcept constexpr span (const span&lt; OtherElementType, OtherExtent &gt; &amp; other) noexcept TCB_SPAN_CONSTEXPR11 subspan_return_t&lt; Offset, Count &gt; subspan () const TCB_SPAN_CONSTEXPR11 span&lt; element_type, dynamic_extent &gt; subspan (size_type offset, size_type count=dynamic_extent) const ~span () noexcept"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-const_pointer","title":"typedef const_pointer","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::const_pointer =  const element_type*;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-const_reference","title":"typedef const_reference","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::const_reference =  const element_type&amp;;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::difference_type =  std::ptrdiff_t;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-element_type","title":"typedef element_type","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::element_type =  ElementType;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-iterator","title":"typedef iterator","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::iterator =  pointer;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-pointer","title":"typedef pointer","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::pointer =  element_type*;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-reference","title":"typedef reference","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::reference =  element_type&amp;;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-reverse_iterator","title":"typedef reverse_iterator","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::reverse_iterator =  std::reverse_iterator&lt;iterator&gt;;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-size_type","title":"typedef size_type","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::size_type =  std::size_t;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-subspan_return_t","title":"typedef subspan_return_t","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::subspan_return_t = \n        span&lt;ElementType, Count != dynamic_extent\n                              ? Count\n                              : (Extent != dynamic_extent ? Extent - Offset\n                                                          : dynamic_extent)&gt;;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::value_type =  typename std::remove_cv&lt;ElementType&gt;::type;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#variable-extent","title":"variable extent","text":"<pre><code>size_type TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt;::extent;\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-back","title":"function back","text":"<pre><code>inline TCB_SPAN_CONSTEXPR11 reference TCB_SPAN_NAMESPACE_NAME::span::back () const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-begin","title":"function begin","text":"<pre><code>inline iterator TCB_SPAN_NAMESPACE_NAME::span::begin () noexcept const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-data","title":"function data","text":"<pre><code>inline pointer TCB_SPAN_NAMESPACE_NAME::span::data () noexcept const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-empty","title":"function empty","text":"<pre><code>inline TCB_SPAN_NODISCARD constexpr bool TCB_SPAN_NAMESPACE_NAME::span::empty () noexcept const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-end","title":"function end","text":"<pre><code>inline iterator TCB_SPAN_NAMESPACE_NAME::span::end () noexcept const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-first-12","title":"function first [1/2]","text":"<pre><code>template&lt;std::size_t Count&gt;\ninline TCB_SPAN_CONSTEXPR11 span &lt; element_type, Count &gt; TCB_SPAN_NAMESPACE_NAME::span::first () const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-first-22","title":"function first [2/2]","text":"<pre><code>inline TCB_SPAN_CONSTEXPR11 span &lt; element_type, dynamic_extent &gt; TCB_SPAN_NAMESPACE_NAME::span::first (\n    size_type count\n) const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-front","title":"function front","text":"<pre><code>inline TCB_SPAN_CONSTEXPR11 reference TCB_SPAN_NAMESPACE_NAME::span::front () const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-last-12","title":"function last [1/2]","text":"<pre><code>template&lt;std::size_t Count&gt;\ninline TCB_SPAN_CONSTEXPR11 span &lt; element_type, Count &gt; TCB_SPAN_NAMESPACE_NAME::span::last () const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-last-22","title":"function last [2/2]","text":"<pre><code>inline TCB_SPAN_CONSTEXPR11 span &lt; element_type, dynamic_extent &gt; TCB_SPAN_NAMESPACE_NAME::span::last (\n    size_type count\n) const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-operator","title":"function operator=","text":"<pre><code>TCB_SPAN_CONSTEXPR_ASSIGN span &amp; TCB_SPAN_NAMESPACE_NAME::span::operator= (\n    const span &amp; other\n) noexcept\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-operator_1","title":"function operator[]","text":"<pre><code>inline TCB_SPAN_CONSTEXPR11 reference TCB_SPAN_NAMESPACE_NAME::span::operator[] (\n    size_type idx\n) const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-rbegin","title":"function rbegin","text":"<pre><code>inline TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator TCB_SPAN_NAMESPACE_NAME::span::rbegin () noexcept const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-rend","title":"function rend","text":"<pre><code>inline TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator TCB_SPAN_NAMESPACE_NAME::span::rend () noexcept const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-size","title":"function size","text":"<pre><code>inline size_type TCB_SPAN_NAMESPACE_NAME::span::size () noexcept const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-size_bytes","title":"function size_bytes","text":"<pre><code>inline size_type TCB_SPAN_NAMESPACE_NAME::span::size_bytes () noexcept const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-110","title":"function span [1/10]","text":"<pre><code>template&lt;std::size_t E, typename std::enable_if&lt;(E==dynamic_extent||E&lt;=0), int &gt;::type&gt;\ninline constexpr TCB_SPAN_NAMESPACE_NAME::span::span () noexcept\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-210","title":"function span [2/10]","text":"<pre><code>inline TCB_SPAN_CONSTEXPR11 TCB_SPAN_NAMESPACE_NAME::span::span (\n    pointer ptr,\n    size_type count\n) \n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-310","title":"function span [3/10]","text":"<pre><code>inline TCB_SPAN_CONSTEXPR11 TCB_SPAN_NAMESPACE_NAME::span::span (\n    pointer first_elem,\n    pointer last_elem\n) \n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-410","title":"function span [4/10]","text":"<pre><code>template&lt;std::size_t N, std::size_t E, typename std::enable_if&lt;(E==dynamic_extent||N==E) &amp;&amp; detail::is_container_element_type_compatible &lt; element_type(&amp;)[N], ElementType &gt;::value, int &gt;::type&gt;\ninline constexpr TCB_SPAN_NAMESPACE_NAME::span::span (\n    element_type(&amp;) arr\n) noexcept\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-510","title":"function span [5/10]","text":"<pre><code>template&lt;typename T, std::size_t N, std::size_t E, typename std::enable_if&lt;(E==dynamic_extent||N==E) &amp;&amp; detail::is_container_element_type_compatible &lt; std::array&lt; T, N &gt; &amp;, ElementType &gt;::value, int &gt;::type&gt;\ninline TCB_SPAN_ARRAY_CONSTEXPR TCB_SPAN_NAMESPACE_NAME::span::span (\n    std::array&lt; T, N &gt; &amp; arr\n) noexcept\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-610","title":"function span [6/10]","text":"<pre><code>template&lt;typename T, std::size_t N, std::size_t E, typename std::enable_if&lt;(E==dynamic_extent||N==E) &amp;&amp; detail::is_container_element_type_compatible &lt; const std::array&lt; T, N &gt; &amp;, ElementType &gt;::value, int &gt;::type&gt;\ninline TCB_SPAN_ARRAY_CONSTEXPR TCB_SPAN_NAMESPACE_NAME::span::span (\n    const std::array&lt; T, N &gt; &amp; arr\n) noexcept\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-710","title":"function span [7/10]","text":"<pre><code>template&lt;typename Container, std::size_t E, typename std::enable_if&lt; E==dynamic_extent &amp;&amp; detail::is_container &lt; Container &gt;::value &amp;&amp; detail::is_container_element_type_compatible &lt; Container &amp;, ElementType &gt;::value, int &gt;::type&gt;\ninline constexpr TCB_SPAN_NAMESPACE_NAME::span::span (\n    Container &amp; cont\n) \n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-810","title":"function span [8/10]","text":"<pre><code>template&lt;typename Container, std::size_t E, typename std::enable_if&lt; E==dynamic_extent &amp;&amp; detail::is_container &lt; Container &gt;::value &amp;&amp; detail::is_container_element_type_compatible &lt; const Container &amp;, ElementType &gt;::value, int &gt;::type&gt;\ninline constexpr TCB_SPAN_NAMESPACE_NAME::span::span (\n    const Container &amp; cont\n) \n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-910","title":"function span [9/10]","text":"<pre><code>constexpr TCB_SPAN_NAMESPACE_NAME::span::span (\n    const span &amp; other\n) noexcept\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span-1010","title":"function span [10/10]","text":"<pre><code>template&lt;typename OtherElementType, std::size_t OtherExtent, typename std::enable_if&lt;(Extent==dynamic_extent||OtherExtent==dynamic_extent||Extent==OtherExtent) &amp;&amp;std::is_convertible&lt; OtherElementType(*)[], ElementType(*)[]&gt;::value, int &gt;::type&gt;\ninline constexpr TCB_SPAN_NAMESPACE_NAME::span::span (\n    const span &lt; OtherElementType, OtherExtent &gt; &amp; other\n) noexcept\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-subspan-12","title":"function subspan [1/2]","text":"<pre><code>template&lt;std::size_t Offset, std::size_t Count&gt;\ninline TCB_SPAN_CONSTEXPR11 subspan_return_t &lt; Offset, Count &gt; TCB_SPAN_NAMESPACE_NAME::span::subspan () const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-subspan-22","title":"function subspan [2/2]","text":"<pre><code>inline TCB_SPAN_CONSTEXPR11 span &lt; element_type, dynamic_extent &gt; TCB_SPAN_NAMESPACE_NAME::span::subspan (\n    size_type offset,\n    size_type count=dynamic_extent\n) const\n</code></pre>"},{"location":"muda/class_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span/#function-span","title":"function ~span","text":"<pre><code>TCB_SPAN_NAMESPACE_NAME::span::~span () noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/namespacemuda/","title":"Namespace muda","text":"<p>Namespace List &gt; muda</p>"},{"location":"muda/namespacemuda/#namespaces","title":"Namespaces","text":"Type Name namespace config namespace details namespace distance namespace eigen namespace lbvh namespace spatial_hash"},{"location":"muda/namespacemuda/#classes","title":"Classes","text":"Type Name class BSRMatrixViewT &lt;IsConst, typename Ty, N&gt; class Buffer2DViewT &lt;IsConst, typename T&gt; class Buffer3DViewT &lt;IsConst, typename T&gt; class BufferLaunch class BufferViewT &lt;IsConst, typename T&gt; class CFieldEntryView &lt;typename T, Layout, M, N&gt; class CFieldEntryViewer &lt;typename T, Layout, M, N&gt; class CMatrixMapInfo &lt;typename T, M, N&gt; class COOMatrixViewT &lt;IsConst, typename Ty&gt; class COOVectorViewBase &lt;IsConst, typename T&gt; class ClosureId class ComputeGraph class ComputeGraphBuilder class ComputeGraphCaptureNode class ComputeGraphClosure class ComputeGraphDependency class ComputeGraphGraphvizOptions class ComputeGraphNode &lt;typename NodeT, Type&gt; class ComputeGraphNodeBase class ComputeGraphVar &lt;typename T&gt; class ComputeGraphVar &lt;typename T&gt; class ComputeGraphVar &lt;typename T&gt; class ComputeGraphVar &lt;typename T&gt; class ComputeGraphVar &lt;typename T&gt; class ComputeGraphVar &lt;typename T&gt; class ComputeGraphVarBase class ComputeGraphVarManager class CubWrapper &lt;typename Derive&gt; class Debug struct Default class Dense1DT &lt;IsConst, typename T&gt; class Dense2DBase &lt;IsConst, typename T&gt; class Dense3DBase &lt;IsConst, typename T&gt; class DenseMatrixViewT &lt;IsConst, typename Ty&gt; class DenseMatrixViewerT &lt;IsConst, typename T&gt; class DenseVectorViewT &lt;IsConst, typename T&gt; class DenseVectorViewerT &lt;IsConst, typename T&gt; class DenseViewerT &lt;IsConst, typename T&gt; class DeviceBCOOMatrix &lt;typename T, N&gt; class DeviceBCOOMatrix &lt;typename T, N&gt; class DeviceBCOOVector &lt;typename T, N&gt; class DeviceBCOOVector &lt;typename T, N&gt; class DeviceBSRMatrix &lt;typename Ty, N&gt; class DeviceBuffer &lt;typename T&gt;A <code>std::vector</code> like wrapper of cuda device memory, allows user to: class DeviceBuffer2D &lt;typename T&gt; class DeviceBuffer3D &lt;typename T&gt; class DeviceDenseMatrix &lt;typename Ty&gt; class DeviceDenseVector &lt;typename T&gt; class DeviceDoubletVector &lt;typename T, N&gt; class DeviceHistogram class DeviceMergeSort class DevicePartition class DeviceRadixSort class DeviceReduce class DeviceRunLengthEncode class DeviceScan class DeviceSegmentedRadixSort class DeviceSegmentedReduce class DeviceSegmentedSort class DeviceSelect class DeviceSpmv class DeviceTripletMatrix &lt;typename T, N&gt; class DeviceVar &lt;typename T&gt; class DeviceVector &lt;typename T&gt; class DoubletVectorViewT &lt;IsConst, typename T, N&gt; class DoubletVectorViewT &lt;IsConst, typename T, N&gt; class DoubletVectorViewerT &lt;IsConst, typename T, N&gt; class Empty class Event RAII wrapper for cudaEvent. class EventRecordNode class EventWaitNode class Extent2D class Extent3D class Field class FieldBuildOptions class FieldBuilder &lt;Layout&gt; class FieldEntry &lt;typename T, Layout, M, N&gt; class FieldEntryBase class FieldEntryBaseData class FieldEntryCore class FieldEntryLaunch class FieldEntryLayoutInfo class FieldEntryView &lt;typename T, Layout, M, N&gt; class FieldEntryViewBase &lt;IsConst, typename T, Layout, M, N&gt; class FieldEntryViewCore &lt;IsConst, typename T, Layout, M, N&gt; class FieldEntryViewer &lt;typename T, Layout, M, N&gt; class FieldEntryViewerBase &lt;IsConst, typename T, Layout, M, N&gt; class FieldEntryViewerCore &lt;IsConst, typename T, Layout, M, N&gt; class Flags &lt;typename BitType&gt; class Graph class GraphExec class GraphLaunch class GraphNode class GraphViewer class HostCall class HostDeviceConfig &lt;typename T&gt; class HostDeviceConfigView &lt;typename T&gt; class HostNode class HostNodeParms &lt;typename T&gt; class HostVector &lt;typename T&gt; class IdWithType &lt;typename T&gt; class Kernel &lt;typename F&gt; class KernelLabel class KernelNode class KernelNodeParms &lt;typename U&gt; class Launch A wrapper of raw cuda kernel launch in muda style , removing the<code>&lt;&lt;&lt;&gt;&gt;&gt;</code> usage, for better intellisense support. class LaunchBase &lt;typename T&gt; class LaunchCore class LinearSystemAlgorithm class LinearSystemContext class LinearSystemContextCreateInfo class LinearSystemHandles class LinearSystemSolveReorder class LinearSystemSolveTolerance class LogProxy class Logger class LoggerDataContainer class LoggerMetaData class LoggerViewer class MatrixFormatConverter class MatrixMapInfo &lt;typename T, M, N&gt;For MapMatrix e.g. Eigen::Map&lt; ... &gt; class MemcpyNode class Memory class MemsetNode class NDReshaper class NodeId class NodeParms class Offset2D class Offset3D class ParallelFor a frequently used parallel for loop, DynamicBlockDim andGridStrideLoop strategy are provided, and can be switched seamlessly to each other. class ParallelForDetails class Profile class RangeName class Stream RAII wrapper for cudaStream. class SubField class SubFieldImpl &lt;Layout&gt; class SubFieldImpl &lt;Layout&gt; class SubFieldImpl &lt;Layout&gt; class SubFieldImpl &lt;Layout&gt; class SubFieldInterface struct Tag &lt;typename T&gt; class TripletMatrixViewT &lt;IsConst, typename Ty, N&gt; class TripletMatrixViewT &lt;IsConst, typename Ty, N&gt; class TripletMatrixViewerT &lt;IsConst, typename T, N&gt; class VarId class VarViewT &lt;IsConst, typename T&gt; class ViewBase &lt;IsConst_&gt; class ViewerBase &lt;IsConst_&gt; struct always_false &lt;typename T&gt; struct always_true &lt;typename T&gt; class cuda_error &lt;typename T&gt; class exception struct force_trivial &lt;typename T&gt; struct force_trivially_constructible &lt;typename T&gt; struct force_trivially_copy_assignable &lt;typename T&gt; struct force_trivially_copy_constructible &lt;typename T&gt; struct force_trivially_destructible &lt;typename T&gt; class invalid_argument struct is_cuda_arch class logic_error class not_implemented class out_of_range struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; class runtime_error"},{"location":"muda/namespacemuda/#public-types","title":"Public Types","text":"Type Name typedef TripletMatrixView&lt; T, N &gt; BCOOMatrixView typedef CTripletMatrixViewer&lt; T, N &gt; BCOOMatrixViewer typedef DoubletVectorView&lt; T, N &gt; BCOOVectorView typedef CDoubletVectorViewer&lt; T, N &gt; BCOOVectorViewer typedef BSRMatrixViewT&lt; false, Ty, N &gt; BSRMatrixView typedef Buffer2DViewT&lt; false, T &gt; Buffer2DView typedef Buffer3DViewT&lt; false, T &gt; Buffer3DView typedef BufferViewT&lt; false, T &gt; BufferView typedef CTripletMatrixView&lt; T, N &gt; CBCOOMatrixView typedef CTripletMatrixViewer&lt; T, N &gt; CBCOOMatrixViewer typedef CDoubletVectorView&lt; T, N &gt; CBCOOVectorView typedef CDoubletVectorViewer&lt; T, N &gt; CBCOOVectorViewer typedef BSRMatrixViewT&lt; true, Ty, N &gt; CBSRMatrixView typedef Buffer2DViewT&lt; true, T &gt; CBuffer2DView typedef Buffer3DViewT&lt; true, T &gt; CBuffer3DView typedef BufferViewT&lt; true, T &gt; CBufferView typedef COOMatrixViewT&lt; true, Ty &gt; CCOOMatrixView typedef CBCOOMatrixViewer&lt; T, 1 &gt; CCOOMatrixViewer typedef COOVectorViewBase&lt; true, T &gt; CCOOVectorView typedef CBCOOVectorViewer&lt; T, 1 &gt; CCOOVectorViewer typedef CSRMatrixViewT&lt; true, Ty &gt; CCSRMatrixView typedef DenseViewerT&lt; true, T &gt; CDense typedef Dense1DT&lt; true, T &gt; CDense1D typedef Dense2DBase&lt; true, T &gt; CDense2D typedef Dense3DBase&lt; true, T &gt; CDense3D typedef DenseMatrixViewT&lt; true, Ty &gt; CDenseMatrixView typedef DenseMatrixViewerT&lt; true, T &gt; CDenseMatrixViewer typedef DenseVectorViewT&lt; true, Ty &gt; CDenseVectorView typedef DenseVectorViewerT&lt; true, T &gt; CDenseVectorViewer typedef DoubletVectorViewT&lt; true, T, N &gt; CDoubletVectorView typedef DoubletVectorViewerT&lt; true, T, N &gt; CDoubletVectorViewer typedef COOMatrixViewT&lt; false, Ty &gt; COOMatrixView typedef BCOOMatrixViewer&lt; T, 1 &gt; COOMatrixViewer typedef COOVectorViewBase&lt; false, T &gt; COOVectorView typedef BCOOVectorViewer&lt; T, 1 &gt; COOVectorViewer typedef CSRMatrixViewT&lt; false, Ty &gt; CSRMatrixView typedef BSRMatrixViewT&lt; IsConst, Ty, 1 &gt; CSRMatrixViewT typedef TripletMatrixViewT&lt; true, Ty, N &gt; CTripletMatrixView typedef TripletMatrixViewerT&lt; true, T, N &gt; CTripletMatrixViewer typedef VarViewT&lt; true, T &gt; CVarView typedef ComputeGraphNode&lt; EventRecordNode, ComputeGraphNodeType::EventRecordNode &gt; ComputeGraphEventRecordNode typedef ComputeGraphNode&lt; EventWaitNode, ComputeGraphNodeType::EventWaitNode &gt; ComputeGraphEventWaitNode enum ComputeGraphFlag typedef ComputeGraphNode&lt; KernelNode, ComputeGraphNodeType::KernelNode &gt; ComputeGraphKernelNode typedef ComputeGraphNode&lt; MemcpyNode, ComputeGraphNodeType::MemcpyNode &gt; ComputeGraphMemcpyNode typedef ComputeGraphNode&lt; MemsetNode, ComputeGraphNodeType::MemsetNode &gt; ComputeGraphMemsetNode enum uint8_t ComputeGraphNodeType enum ComputeGraphPhase enum char ComputeGraphVarUsage typedef Tag&lt; Default &gt; DefaultTag typedef DenseViewerT&lt; false, T &gt; Dense typedef Dense1DT&lt; false, T &gt; Dense1D typedef Dense2DBase&lt; false, T &gt; Dense2D typedef Dense3DBase&lt; false, T &gt; Dense3D typedef DenseMatrixViewT&lt; false, Ty &gt; DenseMatrixView typedef DenseMatrixViewerT&lt; false, T &gt; DenseMatrixViewer typedef DenseVectorViewT&lt; false, Ty &gt; DenseVectorView typedef DenseVectorViewerT&lt; false, T &gt; DenseVectorViewer typedef DeviceBCOOMatrix&lt; T, 1 &gt; DeviceCOOMatrix typedef DeviceBCOOVector&lt; T, 1 &gt; DeviceCOOVector typedef DeviceBSRMatrix&lt; T, 1 &gt; DeviceCSRMatrix typedef DoubletVectorViewT&lt; false, T, N &gt; DoubletVectorView typedef DoubletVectorViewerT&lt; false, T, N &gt; DoubletVectorViewer enum FieldEntryLayout enum FieldEntryType enum GraphInstantiateFlagBit typedef IdWithType&lt; int32_t &gt; I32IdWithType typedef IdWithType&lt; int64_t &gt; I64IdWithType typedef cub::KeyValuePair&lt; Key, Value &gt; KeyValuePair enum LinearSystemReorderMethod enum uint16_t LoggerBasicType typedef void(*)(void *formatter, const void *obj) LoggerFmtArg enum uint32_t ParallelForType typedef TripletMatrixViewT&lt; false, Ty, N &gt; TripletMatrixView typedef TripletMatrixViewerT&lt; false, T, N &gt; TripletMatrixViewer typedef IdWithType&lt; uint32_t &gt; U32IdWithType typedef IdWithType&lt; uint64_t &gt; U64IdWithType typedef VarViewT&lt; false, T &gt; VarView typedef std::remove_all_extents_t&lt; std::remove_reference_t&lt; T &gt; &gt; raw_type_t typedef typename read_only_view&lt; T &gt;::type read_only_view_t typedef typename read_write_view&lt; T &gt;::type read_write_view_t typedef tcb::span&lt; T &gt; span"},{"location":"muda/namespacemuda/#public-attributes","title":"Public Attributes","text":"Type Name bool COMPUTE_GRAPH_ON   = = MUDA_COMPUTE_GRAPH_ON bool DEBUG_VIEWER   = = config::on(true) bool DEFAULT_ASYNC_ALLOC_FREE   = = false int HEAVY_WORKLOAD_BLOCK_SIZE   = = 64 int LIGHT_WORKLOAD_BLOCK_SIZE   = = 256 int MIDDLE_WORKLOAD_BLOCK_SIZE   = = 128 bool RUNTIME_CHECK_ON   = = MUDA_CHECK_ON bool TRAP_ON_ERROR   = = config::on(true) bool always_false_v   = = always_false&lt;T&gt;::value bool force_trivial_v   = = force_trivial&lt;T&gt;::value bool force_trivially_constructible_v   = = force_trivially_constructible&lt;T&gt;::value bool force_trivially_copy_assignable_v   = = force_trivially_copy_assignable&lt;T&gt;::value bool force_trivially_copy_constructible_v   = = force_trivially_copy_constructible&lt;T&gt;::value bool force_trivially_destructible_v   = = force_trivially_destructible&lt;T&gt;::value bool is_cuda_arch_v   = = is_cuda_arch::value bool is_read_only_view_v   = = std::is_same_v&lt;T, read_only_view_t&lt;T&gt;&gt; bool is_read_write_view_v   = = std::is_same_v&lt;T, read_write_view_t&lt;T&gt;&gt; bool is_trivial_v   = = std::is_trivial_v&lt;T&gt; || force_trivial_v&lt;T&gt; bool is_trivially_constructible_v   = = std::is_trivially_constructible_v&lt;T&gt; || force_trivially_constructible_v&lt;T&gt; bool is_trivially_copy_assignable_v   = = std::is_trivially_copy_assignable_v&lt;T&gt; || force_trivially_copy_assignable_v&lt;T&gt; bool is_trivially_copy_constructible_v   = = std::is_trivially_copy_constructible_v&lt;T&gt; || force_trivially_copy_constructible_v&lt;T&gt; bool is_trivially_destructible_v   = = std::is_trivially_destructible_v&lt;T&gt; || force_trivially_destructible_v&lt;T&gt; bool is_uniform_view_v   = = is_read_only_view_v&lt;T&gt; &amp;&amp; is_read_write_view_v&lt;T&gt;"},{"location":"muda/namespacemuda/#public-functions","title":"Public Functions","text":"Type Name MUDA_DEFINE_ARITHMATIC_OPERATOR (+)  MUDA_DEFINE_ARITHMATIC_OPERATOR (-)  MUDA_DEFINE_COMPARISON_OPERATOR (&lt;=)  MUDA_DEFINE_COMPARISON_OPERATOR ()  MUDA_INLINE MUDA_GENERIC Extent2D as_extent (const Offset2D &amp; offset)  MUDA_INLINE MUDA_GENERIC Extent3D as_extent (const Offset3D &amp; offset)  MUDA_INLINE MUDA_GENERIC Offset2D as_offset (const Extent2D &amp; extent)  MUDA_INLINE MUDA_GENERIC Offset3D as_offset (const Extent3D &amp; extent)  __forceinline__ __device__ T atomic_add (T * address, T val)  __forceinline__ __device__ T atomic_and (T * address, T val)  __forceinline__ __device__ T atomic_cas (T * address, T compare, T val)  __forceinline__ __device__ T atomic_exch (T * address, T val)  __forceinline__ __device__ T atomic_max (T * address, T val)  __forceinline__ __device__ T atomic_min (T * address, T val)  __forceinline__ __device__ T atomic_or (T * address, T val)  __forceinline__ __device__ T atomic_sub (T * address, T val)  __forceinline__ __device__ T atomic_xor (T * address, T val)  MUDA_INLINE MUDA_GENERIC dim3 block_dim ()  MUDA_INLINE MUDA_GENERIC dim3 block_idx ()  MUDA_INLINE MUDA_GENERIC void brkpt ()  __host__ __device__ void check (T result, char const *const func, const char *const file, int const line)  dim3 cube (int x)  cublasOperation_t cublas_trans_operation (bool b)  cudaDataType_t cuda_data_type ()  cusparseIndexType_t cusparse_index_type ()  std::string_view enum_name (ComputeGraphNodeType t)  MUDA_INLINE MUDA_GENERIC dim3 grid_dim ()  MUDA_GLOBAL void grid_stride_loop_kernel (ParallelForCallable&lt; F &gt; f)  MUDA_INLINE MUDA_GENERIC decltype(auto) invoke (FHost &amp;&amp; host, FDevice &amp;&amp; device)  MUDA_INLINE MUDA_GENERIC auto make_cdense (const T * data)  MUDA_INLINE MUDA_GENERIC auto make_cdense_1d (const T * data, int dimx)  MUDA_INLINE MUDA_GENERIC auto make_cdense_1d (const T(&amp;) data)  MUDA_INLINE MUDA_GENERIC auto make_cdense_2d (const T * data, const int2 &amp; dim)  MUDA_INLINE MUDA_GENERIC auto make_cdense_2d (const T * data, int dimx, int dimy)  MUDA_INLINE MUDA_GENERIC auto make_cdense_3d (const T * data, const int3 &amp; dim)  MUDA_INLINE MUDA_GENERIC auto make_cdense_3d (const T * data, int dimx, int dimy, int dimz)  MUDA_INLINE MUDA_GENERIC auto make_dense (T * data)  MUDA_INLINE MUDA_GENERIC auto make_dense_1d (T * data, int dimx)  MUDA_INLINE MUDA_GENERIC auto make_dense_1d (T(&amp;) data)  MUDA_INLINE MUDA_GENERIC auto make_dense_2d (T * data, const int2 &amp; dim)  MUDA_INLINE MUDA_GENERIC auto make_dense_2d (T * data, int dimx, int dimy)  MUDA_INLINE MUDA_GENERIC auto make_dense_3d (T * data, const int3 &amp; dim)  MUDA_INLINE MUDA_GENERIC auto make_dense_3d (T * data, int dimx, int dimy, int dimz)  MUDA_INLINE MUDA_GENERIC Extent2D max (const Extent2D &amp; lhs, const Extent2D &amp; rhs)  MUDA_INLINE MUDA_GENERIC Extent3D max (const Extent3D &amp; lhs, const Extent3D &amp; rhs)  MUDA_INLINE MUDA_GENERIC Offset2D min (const Offset2D &amp; lhs, const Offset2D &amp; rhs)  MUDA_INLINE MUDA_GENERIC Offset3D min (const Offset3D &amp; lhs, const Offset3D &amp; rhs)  MUDA_INLINE MUDA_GENERIC const char * mudaCudaGetErrorEnum (cusolverStatus_t error)  Empty on (::cudaStream_t stream)  Empty on ()  MUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; operator&amp; (BitType bit, Flags&lt; BitType &gt; const &amp; flags)  MUDA_INLINE MUDA_GENERIC int2 operator+ (const int2 &amp; a, const int2 &amp; b)  bool operator&lt; (ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)  MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy o, const Eigen::Matrix&lt; T, M, N &gt; &amp; val)  MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy o, const Eigen::Map&lt; Eigen::Matrix&lt; T, M, N &gt;, MapOptions, StrideType &gt; &amp; val)  MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy o, const Eigen::Map&lt; const Eigen::Matrix&lt; T, M, N &gt;, MapOptions, StrideType &gt; &amp; val)  MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy o, const Eigen::MatrixX&lt; T &gt; &amp; val)  MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy o, const Eigen::VectorX&lt; T &gt; &amp; val)  MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy o, const Eigen::RowVectorX&lt; T &gt; &amp; val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, char1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, char2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, char3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, char4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, short1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, short2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, short3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, short4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, int1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, int2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, int3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, int4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, long1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, long2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, long3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, long4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, longlong1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, longlong2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, longlong3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, longlong4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, uchar1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, uchar2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, uchar3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, uchar4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, uint1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, uint2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, uint3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, uint4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, ulong1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, ulong2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, ulong3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, ulong4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, ulonglong1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, ulonglong2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, ulonglong3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, ulonglong4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, float1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, float2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, float3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, float4 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, double1 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, double2 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, double3 val)  MUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt; (LogProxy proxy, double4 val)  bool operator&lt;= (ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)  bool operator== (ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)  bool operator&gt; (ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)  bool operator&gt;= (ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)  MUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; operator^ (BitType bit, Flags&lt; BitType &gt; const &amp; flags)  MUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; operator| (BitType bit, Flags&lt; BitType &gt; const &amp; flags)  MUDA_GLOBAL void parallel_for_kernel (ParallelForCallable&lt; F &gt; f)  MUDA_INLINE MUDA_GENERIC void print (const char *const fmt, Args &amp;&amp;... arg)  MUDA_INLINE MUDA_GENERIC const T &amp; print_check (const T &amp; t)  MUDA_INLINE MUDA_GENERIC auto print_check (const char * t)  MUDA_INLINE MUDA_GENERIC OutType print_convert (const InType &amp; v)  MUDA_INLINE MUDA_GENERIC auto print_convert (const char * v)  MUDA_INLINE MUDA_GENERIC const T &amp; print_convert (const Dense&lt; T &gt; &amp; v)  MUDA_INLINE MUDA_GENERIC const T &amp; print_convert (const CDense&lt; T &gt; &amp; v)  MUDA_HOST double profile_host (F &amp;&amp; f)  MUDA_GENERIC MUDA_INLINE constexpr T * remove_const (const T * ptr) noexcept MUDA_GENERIC MUDA_INLINE constexpr T &amp; remove_const (const T &amp; ref) noexcept dim3 square (int x)  MUDA_INLINE MUDA_GENERIC dim3 thread_idx ()  MUDA_INLINE MUDA_GENERIC void trap ()  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/namespacemuda/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/namespacemuda/#typedef-bcoomatrixview","title":"typedef BCOOMatrixView","text":"<pre><code>using muda::BCOOMatrixView =  TripletMatrixView&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-bcoomatrixviewer","title":"typedef BCOOMatrixViewer","text":"<pre><code>using muda::BCOOMatrixViewer =  CTripletMatrixViewer&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-bcoovectorview","title":"typedef BCOOVectorView","text":"<pre><code>using muda::BCOOVectorView =  DoubletVectorView&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-bcoovectorviewer","title":"typedef BCOOVectorViewer","text":"<pre><code>using muda::BCOOVectorViewer =  CDoubletVectorViewer&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-bsrmatrixview","title":"typedef BSRMatrixView","text":"<pre><code>using muda::BSRMatrixView =  BSRMatrixViewT&lt;false, Ty, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-buffer2dview","title":"typedef Buffer2DView","text":"<pre><code>using muda::Buffer2DView =  Buffer2DViewT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-buffer3dview","title":"typedef Buffer3DView","text":"<pre><code>using muda::Buffer3DView =  Buffer3DViewT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-bufferview","title":"typedef BufferView","text":"<pre><code>using muda::BufferView =  BufferViewT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cbcoomatrixview","title":"typedef CBCOOMatrixView","text":"<pre><code>using muda::CBCOOMatrixView =  CTripletMatrixView&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cbcoomatrixviewer","title":"typedef CBCOOMatrixViewer","text":"<pre><code>using muda::CBCOOMatrixViewer =  CTripletMatrixViewer&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cbcoovectorview","title":"typedef CBCOOVectorView","text":"<pre><code>using muda::CBCOOVectorView =  CDoubletVectorView&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cbcoovectorviewer","title":"typedef CBCOOVectorViewer","text":"<pre><code>using muda::CBCOOVectorViewer =  CDoubletVectorViewer&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cbsrmatrixview","title":"typedef CBSRMatrixView","text":"<pre><code>using muda::CBSRMatrixView =  BSRMatrixViewT&lt;true, Ty, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cbuffer2dview","title":"typedef CBuffer2DView","text":"<pre><code>using muda::CBuffer2DView =  Buffer2DViewT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cbuffer3dview","title":"typedef CBuffer3DView","text":"<pre><code>using muda::CBuffer3DView =  Buffer3DViewT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cbufferview","title":"typedef CBufferView","text":"<pre><code>using muda::CBufferView =  BufferViewT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-ccoomatrixview","title":"typedef CCOOMatrixView","text":"<pre><code>using muda::CCOOMatrixView =  COOMatrixViewT&lt;true, Ty&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-ccoomatrixviewer","title":"typedef CCOOMatrixViewer","text":"<pre><code>using muda::CCOOMatrixViewer =  CBCOOMatrixViewer&lt;T, 1&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-ccoovectorview","title":"typedef CCOOVectorView","text":"<pre><code>using muda::CCOOVectorView =  COOVectorViewBase&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-ccoovectorviewer","title":"typedef CCOOVectorViewer","text":"<pre><code>using muda::CCOOVectorViewer =  CBCOOVectorViewer&lt;T, 1&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-ccsrmatrixview","title":"typedef CCSRMatrixView","text":"<pre><code>using muda::CCSRMatrixView =  CSRMatrixViewT&lt;true, Ty&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdense","title":"typedef CDense","text":"<pre><code>using muda::CDense =  DenseViewerT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdense1d","title":"typedef CDense1D","text":"<pre><code>using muda::CDense1D =  Dense1DT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdense2d","title":"typedef CDense2D","text":"<pre><code>using muda::CDense2D =  Dense2DBase&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdense3d","title":"typedef CDense3D","text":"<pre><code>using muda::CDense3D =  Dense3DBase&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdensematrixview","title":"typedef CDenseMatrixView","text":"<pre><code>using muda::CDenseMatrixView =  DenseMatrixViewT&lt;true, Ty&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdensematrixviewer","title":"typedef CDenseMatrixViewer","text":"<pre><code>using muda::CDenseMatrixViewer =  DenseMatrixViewerT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdensevectorview","title":"typedef CDenseVectorView","text":"<pre><code>using muda::CDenseVectorView =  DenseVectorViewT&lt;true, Ty&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdensevectorviewer","title":"typedef CDenseVectorViewer","text":"<pre><code>using muda::CDenseVectorViewer =  DenseVectorViewerT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdoubletvectorview","title":"typedef CDoubletVectorView","text":"<pre><code>using muda::CDoubletVectorView =  DoubletVectorViewT&lt;true, T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cdoubletvectorviewer","title":"typedef CDoubletVectorViewer","text":"<pre><code>using muda::CDoubletVectorViewer =  DoubletVectorViewerT&lt;true, T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-coomatrixview","title":"typedef COOMatrixView","text":"<pre><code>using muda::COOMatrixView =  COOMatrixViewT&lt;false, Ty&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-coomatrixviewer","title":"typedef COOMatrixViewer","text":"<pre><code>using muda::COOMatrixViewer =  BCOOMatrixViewer&lt;T, 1&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-coovectorview","title":"typedef COOVectorView","text":"<pre><code>using muda::COOVectorView =  COOVectorViewBase&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-coovectorviewer","title":"typedef COOVectorViewer","text":"<pre><code>using muda::COOVectorViewer =  BCOOVectorViewer&lt;T, 1&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-csrmatrixview","title":"typedef CSRMatrixView","text":"<pre><code>using muda::CSRMatrixView =  CSRMatrixViewT&lt;false, Ty&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-csrmatrixviewt","title":"typedef CSRMatrixViewT","text":"<pre><code>using muda::CSRMatrixViewT =  BSRMatrixViewT&lt;IsConst, Ty, 1&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-ctripletmatrixview","title":"typedef CTripletMatrixView","text":"<pre><code>using muda::CTripletMatrixView =  TripletMatrixViewT&lt;true, Ty, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-ctripletmatrixviewer","title":"typedef CTripletMatrixViewer","text":"<pre><code>using muda::CTripletMatrixViewer =  TripletMatrixViewerT&lt;true, T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-cvarview","title":"typedef CVarView","text":"<pre><code>using muda::CVarView =  VarViewT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-computegrapheventrecordnode","title":"typedef ComputeGraphEventRecordNode","text":"<pre><code>using muda::ComputeGraphEventRecordNode = \n    ComputeGraphNode&lt;EventRecordNode, ComputeGraphNodeType::EventRecordNode&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-computegrapheventwaitnode","title":"typedef ComputeGraphEventWaitNode","text":"<pre><code>using muda::ComputeGraphEventWaitNode = \n    ComputeGraphNode&lt;EventWaitNode, ComputeGraphNodeType::EventWaitNode&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#enum-computegraphflag","title":"enum ComputeGraphFlag","text":"<pre><code>enum muda::ComputeGraphFlag {\n    HostLaunch = 1,\n    DeviceLaunch = 2 | HostLaunch\n};\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-computegraphkernelnode","title":"typedef ComputeGraphKernelNode","text":"<pre><code>using muda::ComputeGraphKernelNode = \n    ComputeGraphNode&lt;KernelNode, ComputeGraphNodeType::KernelNode&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-computegraphmemcpynode","title":"typedef ComputeGraphMemcpyNode","text":"<pre><code>using muda::ComputeGraphMemcpyNode = \n    ComputeGraphNode&lt;MemcpyNode, ComputeGraphNodeType::MemcpyNode&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-computegraphmemsetnode","title":"typedef ComputeGraphMemsetNode","text":"<pre><code>using muda::ComputeGraphMemsetNode = \n    ComputeGraphNode&lt;MemsetNode, ComputeGraphNodeType::MemsetNode&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#enum-computegraphnodetype","title":"enum ComputeGraphNodeType","text":"<pre><code>enum muda::ComputeGraphNodeType {\n    None,\n    KernelNode,\n    MemcpyNode,\n    MemsetNode,\n    CaptureNode,\n    EventRecordNode,\n    EventWaitNode,\n    Max\n};\n</code></pre>"},{"location":"muda/namespacemuda/#enum-computegraphphase","title":"enum ComputeGraphPhase","text":"<pre><code>enum muda::ComputeGraphPhase {\n    None,\n    TopoBuilding,\n    Building,\n    Updating,\n    SerialLaunching,\n    Max\n};\n</code></pre>"},{"location":"muda/namespacemuda/#enum-computegraphvarusage","title":"enum ComputeGraphVarUsage","text":"<pre><code>enum muda::ComputeGraphVarUsage {\n    None,\n    Read,\n    ReadWrite,\n    Max\n};\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-defaulttag","title":"typedef DefaultTag","text":"<pre><code>using muda::DefaultTag =  Tag&lt;Default&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-dense","title":"typedef Dense","text":"<pre><code>using muda::Dense =  DenseViewerT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-dense1d","title":"typedef Dense1D","text":"<pre><code>using muda::Dense1D =  Dense1DT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-dense2d","title":"typedef Dense2D","text":"<pre><code>using muda::Dense2D =  Dense2DBase&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-dense3d","title":"typedef Dense3D","text":"<pre><code>using muda::Dense3D =  Dense3DBase&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-densematrixview","title":"typedef DenseMatrixView","text":"<pre><code>using muda::DenseMatrixView =  DenseMatrixViewT&lt;false, Ty&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-densematrixviewer","title":"typedef DenseMatrixViewer","text":"<pre><code>using muda::DenseMatrixViewer =  DenseMatrixViewerT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-densevectorview","title":"typedef DenseVectorView","text":"<pre><code>using muda::DenseVectorView =  DenseVectorViewT&lt;false, Ty&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-densevectorviewer","title":"typedef DenseVectorViewer","text":"<pre><code>using muda::DenseVectorViewer =  DenseVectorViewerT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-devicecoomatrix","title":"typedef DeviceCOOMatrix","text":"<pre><code>using muda::DeviceCOOMatrix =  DeviceBCOOMatrix&lt;T, 1&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-devicecoovector","title":"typedef DeviceCOOVector","text":"<pre><code>using muda::DeviceCOOVector =  DeviceBCOOVector&lt;T, 1&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-devicecsrmatrix","title":"typedef DeviceCSRMatrix","text":"<pre><code>using muda::DeviceCSRMatrix =  DeviceBSRMatrix&lt;T, 1&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-doubletvectorview","title":"typedef DoubletVectorView","text":"<pre><code>using muda::DoubletVectorView =  DoubletVectorViewT&lt;false, T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-doubletvectorviewer","title":"typedef DoubletVectorViewer","text":"<pre><code>using muda::DoubletVectorViewer =  DoubletVectorViewerT&lt;false, T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#enum-fieldentrylayout","title":"enum FieldEntryLayout","text":"<pre><code>enum muda::FieldEntryLayout {\n    None,\n    AoS,\n    SoA,\n    AoSoA,\n    RuntimeLayout\n};\n</code></pre>"},{"location":"muda/namespacemuda/#enum-fieldentrytype","title":"enum FieldEntryType","text":"<pre><code>enum muda::FieldEntryType {\n    None,\n    Scalar,\n    Vector,\n    Matrix,\n    Object\n};\n</code></pre>"},{"location":"muda/namespacemuda/#enum-graphinstantiateflagbit","title":"enum GraphInstantiateFlagBit","text":"<pre><code>enum muda::GraphInstantiateFlagBit {\n    FreeOnLaunch = CUgraphInstantiate_flags::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH,\n    Upload = 2,\n    DeviceLaunch = 4,\n    UseNodePriority = 8\n};\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-i32idwithtype","title":"typedef I32IdWithType","text":"<pre><code>using muda::I32IdWithType =  IdWithType&lt;int32_t&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-i64idwithtype","title":"typedef I64IdWithType","text":"<pre><code>using muda::I64IdWithType =  IdWithType&lt;int64_t&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-keyvaluepair","title":"typedef KeyValuePair","text":"<pre><code>using muda::KeyValuePair =  cub::KeyValuePair&lt;Key, Value&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#enum-linearsystemreordermethod","title":"enum LinearSystemReorderMethod","text":"<pre><code>enum muda::LinearSystemReorderMethod {\n    None = 0,\n    Symrcm = 1,\n    Symamd = 2,\n    Csrmetisnd = 3\n};\n</code></pre>"},{"location":"muda/namespacemuda/#enum-loggerbasictype","title":"enum LoggerBasicType","text":"<pre><code>enum muda::LoggerBasicType {\n    None,\n    Int8,\n    Int16,\n    Int,\n    Int32 = Int,\n    Int64,\n    Long,\n    LongLong,\n    UInt8,\n    UInt16,\n    UInt,\n    UInt32 = UInt,\n    UInt64,\n    ULong,\n    ULongLong,\n    Float,\n    Double,\n    String,\n    FmtString,\n    Object\n};\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-loggerfmtarg","title":"typedef LoggerFmtArg","text":"<pre><code>using muda::LoggerFmtArg =  void (*)(void* formatter, const void* obj);\n</code></pre>"},{"location":"muda/namespacemuda/#enum-parallelfortype","title":"enum ParallelForType","text":"<pre><code>enum muda::ParallelForType {\n    DynamicBlocks,\n    GridStrideLoop\n};\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-tripletmatrixview","title":"typedef TripletMatrixView","text":"<pre><code>using muda::TripletMatrixView =  TripletMatrixViewT&lt;false, Ty, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-tripletmatrixviewer","title":"typedef TripletMatrixViewer","text":"<pre><code>using muda::TripletMatrixViewer =  TripletMatrixViewerT&lt;false, T, N&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-u32idwithtype","title":"typedef U32IdWithType","text":"<pre><code>using muda::U32IdWithType =  IdWithType&lt;uint32_t&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-u64idwithtype","title":"typedef U64IdWithType","text":"<pre><code>using muda::U64IdWithType =  IdWithType&lt;uint64_t&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-varview","title":"typedef VarView","text":"<pre><code>using muda::VarView =  VarViewT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-raw_type_t","title":"typedef raw_type_t","text":"<pre><code>using muda::raw_type_t =  std::remove_all_extents_t&lt;std::remove_reference_t&lt;T&gt;&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-read_only_view_t","title":"typedef read_only_view_t","text":"<pre><code>using muda::read_only_view_t =  typename read_only_view&lt;T&gt;::type;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-read_write_view_t","title":"typedef read_write_view_t","text":"<pre><code>using muda::read_write_view_t =  typename read_write_view&lt;T&gt;::type;\n</code></pre>"},{"location":"muda/namespacemuda/#typedef-span","title":"typedef span","text":"<pre><code>using muda::span =  tcb::span&lt;T&gt;;\n</code></pre>"},{"location":"muda/namespacemuda/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/namespacemuda/#variable-compute_graph_on","title":"variable COMPUTE_GRAPH_ON","text":"<pre><code>bool muda::COMPUTE_GRAPH_ON;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-debug_viewer","title":"variable DEBUG_VIEWER","text":"<pre><code>bool muda::DEBUG_VIEWER;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-default_async_alloc_free","title":"variable DEFAULT_ASYNC_ALLOC_FREE","text":"<pre><code>bool muda::DEFAULT_ASYNC_ALLOC_FREE;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-heavy_workload_block_size","title":"variable HEAVY_WORKLOAD_BLOCK_SIZE","text":"<pre><code>int muda::HEAVY_WORKLOAD_BLOCK_SIZE;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-light_workload_block_size","title":"variable LIGHT_WORKLOAD_BLOCK_SIZE","text":"<pre><code>int muda::LIGHT_WORKLOAD_BLOCK_SIZE;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-middle_workload_block_size","title":"variable MIDDLE_WORKLOAD_BLOCK_SIZE","text":"<pre><code>int muda::MIDDLE_WORKLOAD_BLOCK_SIZE;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-runtime_check_on","title":"variable RUNTIME_CHECK_ON","text":"<pre><code>bool muda::RUNTIME_CHECK_ON;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-trap_on_error","title":"variable TRAP_ON_ERROR","text":"<pre><code>bool muda::TRAP_ON_ERROR;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-always_false_v","title":"variable always_false_v","text":"<pre><code>bool muda::always_false_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-force_trivial_v","title":"variable force_trivial_v","text":"<pre><code>bool muda::force_trivial_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-force_trivially_constructible_v","title":"variable force_trivially_constructible_v","text":"<pre><code>bool muda::force_trivially_constructible_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-force_trivially_copy_assignable_v","title":"variable force_trivially_copy_assignable_v","text":"<pre><code>bool muda::force_trivially_copy_assignable_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-force_trivially_copy_constructible_v","title":"variable force_trivially_copy_constructible_v","text":"<pre><code>bool muda::force_trivially_copy_constructible_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-force_trivially_destructible_v","title":"variable force_trivially_destructible_v","text":"<pre><code>bool muda::force_trivially_destructible_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-is_cuda_arch_v","title":"variable is_cuda_arch_v","text":"<pre><code>bool muda::is_cuda_arch_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-is_read_only_view_v","title":"variable is_read_only_view_v","text":"<pre><code>bool muda::is_read_only_view_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-is_read_write_view_v","title":"variable is_read_write_view_v","text":"<pre><code>bool muda::is_read_write_view_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-is_trivial_v","title":"variable is_trivial_v","text":"<pre><code>bool muda::is_trivial_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-is_trivially_constructible_v","title":"variable is_trivially_constructible_v","text":"<pre><code>bool muda::is_trivially_constructible_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-is_trivially_copy_assignable_v","title":"variable is_trivially_copy_assignable_v","text":"<pre><code>bool muda::is_trivially_copy_assignable_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-is_trivially_copy_constructible_v","title":"variable is_trivially_copy_constructible_v","text":"<pre><code>bool muda::is_trivially_copy_constructible_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-is_trivially_destructible_v","title":"variable is_trivially_destructible_v","text":"<pre><code>bool muda::is_trivially_destructible_v;\n</code></pre>"},{"location":"muda/namespacemuda/#variable-is_uniform_view_v","title":"variable is_uniform_view_v","text":"<pre><code>bool muda::is_uniform_view_v;\n</code></pre>"},{"location":"muda/namespacemuda/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda/#function-muda_define_arithmatic_operator","title":"function MUDA_DEFINE_ARITHMATIC_OPERATOR","text":"<pre><code>muda::MUDA_DEFINE_ARITHMATIC_OPERATOR (\n    +\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-muda_define_arithmatic_operator_1","title":"function MUDA_DEFINE_ARITHMATIC_OPERATOR","text":"<pre><code>muda::MUDA_DEFINE_ARITHMATIC_OPERATOR (\n    -\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-muda_define_comparison_operator","title":"function MUDA_DEFINE_COMPARISON_OPERATOR","text":"<pre><code>muda::MUDA_DEFINE_COMPARISON_OPERATOR (\n    &lt;=\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-muda_define_comparison_operator_1","title":"function MUDA_DEFINE_COMPARISON_OPERATOR","text":"<pre><code>muda::MUDA_DEFINE_COMPARISON_OPERATOR () \n</code></pre>"},{"location":"muda/namespacemuda/#function-as_extent","title":"function as_extent","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Extent2D muda::as_extent (\n    const Offset2D &amp; offset\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-as_extent_1","title":"function as_extent","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Extent3D muda::as_extent (\n    const Offset3D &amp; offset\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-as_offset","title":"function as_offset","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Offset2D muda::as_offset (\n    const Extent2D &amp; extent\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-as_offset_1","title":"function as_offset","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Offset3D muda::as_offset (\n    const Extent3D &amp; extent\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-atomic_add","title":"function atomic_add","text":"<pre><code>template&lt;typename T&gt;\n__forceinline__ __device__ T muda::atomic_add (\n    T * address,\n    T val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-atomic_and","title":"function atomic_and","text":"<pre><code>template&lt;typename T&gt;\n__forceinline__ __device__ T muda::atomic_and (\n    T * address,\n    T val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-atomic_cas","title":"function atomic_cas","text":"<pre><code>template&lt;typename T&gt;\n__forceinline__ __device__ T muda::atomic_cas (\n    T * address,\n    T compare,\n    T val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-atomic_exch","title":"function atomic_exch","text":"<pre><code>template&lt;typename T&gt;\n__forceinline__ __device__ T muda::atomic_exch (\n    T * address,\n    T val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-atomic_max","title":"function atomic_max","text":"<pre><code>template&lt;typename T&gt;\n__forceinline__ __device__ T muda::atomic_max (\n    T * address,\n    T val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-atomic_min","title":"function atomic_min","text":"<pre><code>template&lt;typename T&gt;\n__forceinline__ __device__ T muda::atomic_min (\n    T * address,\n    T val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-atomic_or","title":"function atomic_or","text":"<pre><code>template&lt;typename T&gt;\n__forceinline__ __device__ T muda::atomic_or (\n    T * address,\n    T val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-atomic_sub","title":"function atomic_sub","text":"<pre><code>template&lt;typename T&gt;\n__forceinline__ __device__ T muda::atomic_sub (\n    T * address,\n    T val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-atomic_xor","title":"function atomic_xor","text":"<pre><code>template&lt;typename T&gt;\n__forceinline__ __device__ T muda::atomic_xor (\n    T * address,\n    T val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-block_dim","title":"function block_dim","text":"<pre><code>MUDA_INLINE MUDA_GENERIC dim3 muda::block_dim () \n</code></pre>"},{"location":"muda/namespacemuda/#function-block_idx","title":"function block_idx","text":"<pre><code>MUDA_INLINE MUDA_GENERIC dim3 muda::block_idx () \n</code></pre>"},{"location":"muda/namespacemuda/#function-brkpt","title":"function brkpt","text":"<pre><code>MUDA_INLINE MUDA_GENERIC void muda::brkpt () \n</code></pre>"},{"location":"muda/namespacemuda/#function-check","title":"function check","text":"<pre><code>template&lt;typename T&gt;\ninline __host__ __device__ void muda::check (\n    T result,\n    char const *const func,\n    const char *const file,\n    int const line\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-cube","title":"function cube","text":"<pre><code>dim3 muda::cube (\n    int x\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-cublas_trans_operation","title":"function cublas_trans_operation","text":"<pre><code>cublasOperation_t muda::cublas_trans_operation (\n    bool b\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-cuda_data_type","title":"function cuda_data_type","text":"<pre><code>template&lt;typename T&gt;\ninline cudaDataType_t muda::cuda_data_type () \n</code></pre>"},{"location":"muda/namespacemuda/#function-cusparse_index_type","title":"function cusparse_index_type","text":"<pre><code>template&lt;typename T&gt;\ncusparseIndexType_t muda::cusparse_index_type () \n</code></pre>"},{"location":"muda/namespacemuda/#function-enum_name","title":"function enum_name","text":"<pre><code>inline std::string_view muda::enum_name (\n    ComputeGraphNodeType t\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-grid_dim","title":"function grid_dim","text":"<pre><code>MUDA_INLINE MUDA_GENERIC dim3 muda::grid_dim () \n</code></pre>"},{"location":"muda/namespacemuda/#function-grid_stride_loop_kernel","title":"function grid_stride_loop_kernel","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_GLOBAL void muda::grid_stride_loop_kernel (\n    ParallelForCallable&lt; F &gt; f\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-invoke","title":"function invoke","text":"<pre><code>template&lt;typename FHost, typename FDevice&gt;\nMUDA_INLINE MUDA_GENERIC decltype(auto) muda::invoke (\n    FHost &amp;&amp; host,\n    FDevice &amp;&amp; device\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_cdense","title":"function make_cdense","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_cdense (\n    const T * data\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_cdense_1d","title":"function make_cdense_1d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_cdense_1d (\n    const T * data,\n    int dimx\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_cdense_1d_1","title":"function make_cdense_1d","text":"<pre><code>template&lt;typename T, int N&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_cdense_1d (\n    const T(&amp;) data\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_cdense_2d","title":"function make_cdense_2d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_cdense_2d (\n    const T * data,\n    const int2 &amp; dim\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_cdense_2d_1","title":"function make_cdense_2d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_cdense_2d (\n    const T * data,\n    int dimx,\n    int dimy\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_cdense_3d","title":"function make_cdense_3d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_cdense_3d (\n    const T * data,\n    const int3 &amp; dim\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_cdense_3d_1","title":"function make_cdense_3d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_cdense_3d (\n    const T * data,\n    int dimx,\n    int dimy,\n    int dimz\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_dense","title":"function make_dense","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_dense (\n    T * data\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_dense_1d","title":"function make_dense_1d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_dense_1d (\n    T * data,\n    int dimx\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_dense_1d_1","title":"function make_dense_1d","text":"<pre><code>template&lt;typename T, int N&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_dense_1d (\n    T(&amp;) data\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_dense_2d","title":"function make_dense_2d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_dense_2d (\n    T * data,\n    const int2 &amp; dim\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_dense_2d_1","title":"function make_dense_2d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_dense_2d (\n    T * data,\n    int dimx,\n    int dimy\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_dense_3d","title":"function make_dense_3d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_dense_3d (\n    T * data,\n    const int3 &amp; dim\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-make_dense_3d_1","title":"function make_dense_3d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto muda::make_dense_3d (\n    T * data,\n    int dimx,\n    int dimy,\n    int dimz\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-max","title":"function max","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Extent2D muda::max (\n    const Extent2D &amp; lhs,\n    const Extent2D &amp; rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-max_1","title":"function max","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Extent3D muda::max (\n    const Extent3D &amp; lhs,\n    const Extent3D &amp; rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-min","title":"function min","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Offset2D muda::min (\n    const Offset2D &amp; lhs,\n    const Offset2D &amp; rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-min_1","title":"function min","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Offset3D muda::min (\n    const Offset3D &amp; lhs,\n    const Offset3D &amp; rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-mudacudageterrorenum","title":"function mudaCudaGetErrorEnum","text":"<pre><code>MUDA_INLINE MUDA_GENERIC const char * muda::mudaCudaGetErrorEnum (\n    cusolverStatus_t error\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-on","title":"function on","text":"<pre><code>Empty muda::on (\n    ::cudaStream_t stream\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-on_1","title":"function on","text":"<pre><code>Empty muda::on () \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator","title":"function operator&amp;","text":"<pre><code>template&lt;typename BitType&gt;\nMUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; muda::operator&amp; (\n    BitType bit,\n    Flags &lt; BitType &gt; const &amp; flags\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_1","title":"function operator+","text":"<pre><code>MUDA_INLINE MUDA_GENERIC int2 muda::operator+ (\n    const int2 &amp; a,\n    const int2 &amp; b\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_2","title":"function operator&lt;","text":"<pre><code>inline bool muda::operator&lt; (\n    ComputeGraphVarUsage lhs,\n    ComputeGraphVarUsage rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_3","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T, int M, int N&gt;\nMUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy o,\n    const Eigen::Matrix&lt; T, M, N &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_4","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T, int M, int N, int MapOptions, typename StrideType&gt;\nMUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy o,\n    const Eigen::Map&lt; Eigen::Matrix&lt; T, M, N &gt;, MapOptions, StrideType &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_5","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T, int M, int N, int MapOptions, typename StrideType&gt;\nMUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy o,\n    const Eigen::Map&lt; const Eigen::Matrix&lt; T, M, N &gt;, MapOptions, StrideType &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_6","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\nMUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy o,\n    const Eigen::MatrixX&lt; T &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_7","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\nMUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy o,\n    const Eigen::VectorX&lt; T &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_8","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\nMUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy o,\n    const Eigen::RowVectorX&lt; T &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_9","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    char1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_10","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    char2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_11","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    char3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_12","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    char4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_13","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    short1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_14","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    short2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_15","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    short3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_16","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    short4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_17","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    int1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_18","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    int2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_19","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    int3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_20","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    int4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_21","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    long1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_22","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    long2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_23","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    long3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_24","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    long4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_25","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    longlong1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_26","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    longlong2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_27","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    longlong3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_28","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    longlong4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_29","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    uchar1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_30","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    uchar2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_31","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    uchar3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_32","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    uchar4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_33","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    uint1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_34","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    uint2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_35","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    uint3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_36","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    uint4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_37","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    ulong1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_38","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    ulong2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_39","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    ulong3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_40","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    ulong4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_41","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    ulonglong1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_42","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    ulonglong2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_43","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    ulonglong3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_44","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    ulonglong4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_45","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    float1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_46","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    float2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_47","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    float3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_48","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    float4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_49","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    double1 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_50","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    double2 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_51","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    double3 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_52","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_INLINE MUDA_DEVICE LogProxy muda::operator&lt;&lt; (\n    LogProxy proxy,\n    double4 val\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_53","title":"function operator&lt;=","text":"<pre><code>inline bool muda::operator&lt;= (\n    ComputeGraphVarUsage lhs,\n    ComputeGraphVarUsage rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_54","title":"function operator==","text":"<pre><code>inline bool muda::operator== (\n    ComputeGraphVarUsage lhs,\n    ComputeGraphVarUsage rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_55","title":"function operator&gt;","text":"<pre><code>inline bool muda::operator&gt; (\n    ComputeGraphVarUsage lhs,\n    ComputeGraphVarUsage rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_56","title":"function operator&gt;=","text":"<pre><code>inline bool muda::operator&gt;= (\n    ComputeGraphVarUsage lhs,\n    ComputeGraphVarUsage rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_57","title":"function operator^","text":"<pre><code>template&lt;typename BitType&gt;\nMUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; muda::operator^ (\n    BitType bit,\n    Flags &lt; BitType &gt; const &amp; flags\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-operator_58","title":"function operator|","text":"<pre><code>template&lt;typename BitType&gt;\nMUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; muda::operator| (\n    BitType bit,\n    Flags &lt; BitType &gt; const &amp; flags\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-parallel_for_kernel","title":"function parallel_for_kernel","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_GLOBAL void muda::parallel_for_kernel (\n    ParallelForCallable&lt; F &gt; f\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-print","title":"function print","text":"<pre><code>template&lt;typename... Args&gt;\nMUDA_INLINE MUDA_GENERIC void muda::print (\n    const char *const fmt,\n    Args &amp;&amp;... arg\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-print_check","title":"function print_check","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC const T &amp; muda::print_check (\n    const T &amp; t\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-print_check_1","title":"function print_check","text":"<pre><code>MUDA_INLINE MUDA_GENERIC auto muda::print_check (\n    const char * t\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-print_convert","title":"function print_convert","text":"<pre><code>template&lt;typename InType, typename OutType&gt;\nMUDA_INLINE MUDA_GENERIC OutType muda::print_convert (\n    const InType &amp; v\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-print_convert_1","title":"function print_convert","text":"<pre><code>MUDA_INLINE MUDA_GENERIC auto muda::print_convert (\n    const char * v\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-print_convert_2","title":"function print_convert","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC const T &amp; muda::print_convert (\n    const Dense &lt; T &gt; &amp; v\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-print_convert_3","title":"function print_convert","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC const T &amp; muda::print_convert (\n    const CDense &lt; T &gt; &amp; v\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-profile_host","title":"function profile_host","text":"<pre><code>template&lt;typename F&gt;\nMUDA_HOST double muda::profile_host (\n    F &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-remove_const","title":"function remove_const","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC MUDA_INLINE constexpr T * muda::remove_const (\n    const T * ptr\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda/#function-remove_const_1","title":"function remove_const","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC MUDA_INLINE constexpr T &amp; muda::remove_const (\n    const T &amp; ref\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda/#function-square","title":"function square","text":"<pre><code>dim3 muda::square (\n    int x\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-thread_idx","title":"function thread_idx","text":"<pre><code>MUDA_INLINE MUDA_GENERIC dim3 muda::thread_idx () \n</code></pre>"},{"location":"muda/namespacemuda/#function-trap","title":"function trap","text":"<pre><code>MUDA_INLINE MUDA_GENERIC void muda::trap () \n</code></pre>"},{"location":"muda/namespacemuda/#function-wait_device","title":"function wait_device","text":"<pre><code>void muda::wait_device () \n</code></pre>"},{"location":"muda/namespacemuda/#function-wait_event","title":"function wait_event","text":"<pre><code>void muda::wait_event (\n    cudaEvent_t event\n) \n</code></pre>"},{"location":"muda/namespacemuda/#function-wait_stream","title":"function wait_stream","text":"<pre><code>void muda::wait_stream (\n    ::cudaStream_t stream\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/assert.h</code></p>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/","title":"Class muda::BSRMatrixViewT","text":"<p>template &lt;bool IsConst, typename Ty, int N&gt;</p> <p>ClassList &gt; muda &gt; BSRMatrixViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#public-types","title":"Public Types","text":"Type Name typedef BSRMatrixViewT&lt; true, Ty, N &gt; ConstView typedef BSRMatrixViewT&lt; false, Ty, N &gt; NonConstView typedef BSRMatrixViewT&lt; IsConst, Ty, N &gt; ThisView typedef std::conditional_t&lt; N==1, Ty, Eigen::Matrix&lt; Ty, N, N &gt; &gt; ValueT"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC BSRMatrixViewT () noexcept MUDA_GENERIC BSRMatrixViewT (int row, int col, auto_const_t&lt; int &gt; * block_row_offsets, auto_const_t&lt; int &gt; * block_col_indices, auto_const_t&lt; ValueT &gt; * block_values, int non_zeros, cusparseSpMatDescr_t descr, cusparseMatDescr_t legacy_descr, bool trans) noexcept MUDA_GENERIC BSRMatrixViewT (const BSRMatrixViewT&lt; OtherIsConst, Ty, N &gt; &amp; other) noexcept MUDA_GENERIC auto T () const MUDA_GENERIC ConstView as_const () const MUDA_GENERIC auto col_indices () const MUDA_GENERIC auto cols () const MUDA_GENERIC auto descr () const MUDA_GENERIC auto is_trans () const MUDA_GENERIC auto legacy_descr () const MUDA_GENERIC auto non_zeros () const MUDA_GENERIC auto row_offsets () const MUDA_GENERIC auto rows () const MUDA_GENERIC auto values () const"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name int m_col   = = 0 auto_const_t&lt; int &gt; * m_col_indices   = = nullptr cusparseSpMatDescr_t m_descr   = = nullptr cusparseMatDescr_t m_legacy_descr   = = nullptr int m_non_zeros   = = 0 int m_row   = = 0 auto_const_t&lt; int &gt; * m_row_offsets   = = nullptr bool m_trans   = = false auto_const_t&lt; ValueT &gt; * m_values   = = nullptr"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::ConstView =  BSRMatrixViewT&lt;true, Ty, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#typedef-nonconstview","title":"typedef NonConstView","text":"<pre><code>using muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::NonConstView =  BSRMatrixViewT&lt;false, Ty, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::ThisView =  BSRMatrixViewT&lt;IsConst, Ty, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#typedef-valuet","title":"typedef ValueT","text":"<pre><code>using muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::ValueT =  std::conditional_t&lt;N == 1, Ty, Eigen::Matrix&lt;Ty, N, N&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-bsrmatrixviewt-24","title":"function BSRMatrixViewT [2/4]","text":"<pre><code>MUDA_GENERIC muda::BSRMatrixViewT::BSRMatrixViewT () noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-bsrmatrixviewt-34","title":"function BSRMatrixViewT [3/4]","text":"<pre><code>inline MUDA_GENERIC muda::BSRMatrixViewT::BSRMatrixViewT (\n    int row,\n    int col,\n    auto_const_t&lt; int &gt; * block_row_offsets,\n    auto_const_t&lt; int &gt; * block_col_indices,\n    auto_const_t&lt; ValueT &gt; * block_values,\n    int non_zeros,\n    cusparseSpMatDescr_t descr,\n    cusparseMatDescr_t legacy_descr,\n    bool trans\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-bsrmatrixviewt-44","title":"function BSRMatrixViewT [4/4]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::BSRMatrixViewT::BSRMatrixViewT (\n    const BSRMatrixViewT &lt; OtherIsConst, Ty, N &gt; &amp; other\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-t","title":"function T","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::T () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC ConstView muda::BSRMatrixViewT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-col_indices","title":"function col_indices","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::col_indices () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-cols","title":"function cols","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::cols () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-descr","title":"function descr","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::descr () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-is_trans","title":"function is_trans","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::is_trans () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-legacy_descr","title":"function legacy_descr","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::legacy_descr () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-non_zeros","title":"function non_zeros","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::non_zeros () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-row_offsets","title":"function row_offsets","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::row_offsets () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-rows","title":"function rows","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::rows () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#function-values","title":"function values","text":"<pre><code>inline MUDA_GENERIC auto muda::BSRMatrixViewT::values () const\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#variable-m_col","title":"variable m_col","text":"<pre><code>int muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::m_col;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#variable-m_col_indices","title":"variable m_col_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::m_col_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#variable-m_descr","title":"variable m_descr","text":"<pre><code>cusparseSpMatDescr_t muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::m_descr;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#variable-m_legacy_descr","title":"variable m_legacy_descr","text":"<pre><code>cusparseMatDescr_t muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::m_legacy_descr;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#variable-m_non_zeros","title":"variable m_non_zeros","text":"<pre><code>int muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::m_non_zeros;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#variable-m_row","title":"variable m_row","text":"<pre><code>int muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::m_row;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#variable-m_row_offsets","title":"variable m_row_offsets","text":"<pre><code>auto_const_t&lt;int&gt;* muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::m_row_offsets;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#variable-m_trans","title":"variable m_trans","text":"<pre><code>bool muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::m_trans;\n</code></pre>"},{"location":"muda/classmuda_1_1_b_s_r_matrix_view_t/#variable-m_values","title":"variable m_values","text":"<pre><code>auto_const_t&lt;ValueT&gt;* muda::BSRMatrixViewT&lt; IsConst, Ty, N &gt;::m_values;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/bsr_matrix_view.h</code></p>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/","title":"Class muda::Buffer2DViewT","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; Buffer2DViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#public-types","title":"Public Types","text":"Type Name typedef CDense2D&lt; T &gt; CViewer typedef Buffer2DViewT&lt; true, T &gt; ConstView typedef Buffer2DViewT&lt; IsConst, T &gt; ThisView typedef std::conditional_t&lt; IsConst, CViewer, Viewer &gt; ThisViewer typedef Dense2D&lt; T &gt; Viewer"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Buffer2DViewT ()  MUDA_GENERIC Buffer2DViewT (const Buffer2DViewT &amp;)  MUDA_GENERIC Buffer2DViewT (const Buffer2DViewT&lt; OtherIsConst, T &gt; &amp; other)  MUDA_GENERIC Buffer2DViewT (auto_const_t&lt; T &gt; * data, size_t pitch_bytes, size_t origin_width, size_t origin_height, const Offset2D &amp; offset, const Extent2D &amp; extent)  MUDA_GENERIC Buffer2DViewT (auto_const_t&lt; T &gt; * data, size_t pitch_bytes, const Offset2D &amp; offset, const Extent2D &amp; extent)  MUDA_GENERIC ConstView as_const () const MUDA_HOST void copy_from (const Buffer2DViewT&lt; true, T &gt; &amp; other)  MUDA_HOST void copy_from (const T * host)  MUDA_HOST void copy_to (T * host) const MUDA_GENERIC CViewer cviewer () const MUDA_GENERIC auto_const_t&lt; T &gt; * data (size_t x, size_t y) const MUDA_GENERIC auto_const_t&lt; T &gt; * data (size_t flatten_i) const MUDA_GENERIC Extent2D extent () const MUDA_HOST void fill (const T &amp; v)  MUDA_GENERIC Offset2D offset () const MUDA_GENERIC auto_const_t&lt; T &gt; * origin_data () const MUDA_GENERIC size_t pitch_bytes () const MUDA_GENERIC ThisView subview (Offset2D offset, Extent2D extent={}) const MUDA_GENERIC size_t total_size () const MUDA_GENERIC ThisViewer viewer () const"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data   = = nullptr Extent2D m_extent Offset2D m_offset size_t m_origin_height   = = 0 size_t m_origin_width   = = 0 size_t m_pitch_bytes   = = ~0"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#typedef-cviewer","title":"typedef CViewer","text":"<pre><code>using muda::Buffer2DViewT&lt; IsConst, T &gt;::CViewer =  CDense2D&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::Buffer2DViewT&lt; IsConst, T &gt;::ConstView =  Buffer2DViewT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::Buffer2DViewT&lt; IsConst, T &gt;::ThisView =  Buffer2DViewT&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::Buffer2DViewT&lt; IsConst, T &gt;::ThisViewer =  std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#typedef-viewer","title":"typedef Viewer","text":"<pre><code>using muda::Buffer2DViewT&lt; IsConst, T &gt;::Viewer =  Dense2D&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-buffer2dviewt-26","title":"function Buffer2DViewT [2/6]","text":"<pre><code>MUDA_GENERIC muda::Buffer2DViewT::Buffer2DViewT () \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-buffer2dviewt-36","title":"function Buffer2DViewT [3/6]","text":"<pre><code>MUDA_GENERIC muda::Buffer2DViewT::Buffer2DViewT (\n    const Buffer2DViewT &amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-buffer2dviewt-46","title":"function Buffer2DViewT [4/6]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\nMUDA_GENERIC muda::Buffer2DViewT::Buffer2DViewT (\n    const Buffer2DViewT &lt; OtherIsConst, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-buffer2dviewt-56","title":"function Buffer2DViewT [5/6]","text":"<pre><code>MUDA_GENERIC muda::Buffer2DViewT::Buffer2DViewT (\n    auto_const_t&lt; T &gt; * data,\n    size_t pitch_bytes,\n    size_t origin_width,\n    size_t origin_height,\n    const Offset2D &amp; offset,\n    const Extent2D &amp; extent\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-buffer2dviewt-66","title":"function Buffer2DViewT [6/6]","text":"<pre><code>MUDA_GENERIC muda::Buffer2DViewT::Buffer2DViewT (\n    auto_const_t&lt; T &gt; * data,\n    size_t pitch_bytes,\n    const Offset2D &amp; offset,\n    const Extent2D &amp; extent\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-as_const","title":"function as_const","text":"<pre><code>MUDA_GENERIC ConstView muda::Buffer2DViewT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-copy_from-12","title":"function copy_from [1/2]","text":"<pre><code>MUDA_HOST void muda::Buffer2DViewT::copy_from (\n    const Buffer2DViewT &lt; true, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-copy_from-22","title":"function copy_from [2/2]","text":"<pre><code>MUDA_HOST void muda::Buffer2DViewT::copy_from (\n    const T * host\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-copy_to","title":"function copy_to","text":"<pre><code>MUDA_HOST void muda::Buffer2DViewT::copy_to (\n    T * host\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-cviewer","title":"function cviewer","text":"<pre><code>MUDA_GENERIC CViewer muda::Buffer2DViewT::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-data-12","title":"function data [1/2]","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::Buffer2DViewT::data (\n    size_t x,\n    size_t y\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-data-22","title":"function data [2/2]","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::Buffer2DViewT::data (\n    size_t flatten_i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-extent","title":"function extent","text":"<pre><code>MUDA_GENERIC Extent2D muda::Buffer2DViewT::extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-fill","title":"function fill","text":"<pre><code>MUDA_HOST void muda::Buffer2DViewT::fill (\n    const T &amp; v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-offset","title":"function offset","text":"<pre><code>MUDA_GENERIC Offset2D muda::Buffer2DViewT::offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-origin_data","title":"function origin_data","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::Buffer2DViewT::origin_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-pitch_bytes","title":"function pitch_bytes","text":"<pre><code>MUDA_GENERIC size_t muda::Buffer2DViewT::pitch_bytes () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-subview","title":"function subview","text":"<pre><code>MUDA_GENERIC ThisView muda::Buffer2DViewT::subview (\n    Offset2D offset,\n    Extent2D extent={}\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-total_size","title":"function total_size","text":"<pre><code>MUDA_GENERIC size_t muda::Buffer2DViewT::total_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#function-viewer","title":"function viewer","text":"<pre><code>MUDA_GENERIC ThisViewer muda::Buffer2DViewT::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::Buffer2DViewT&lt; IsConst, T &gt;::m_data;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#variable-m_extent","title":"variable m_extent","text":"<pre><code>Extent2D muda::Buffer2DViewT&lt; IsConst, T &gt;::m_extent;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#variable-m_offset","title":"variable m_offset","text":"<pre><code>Offset2D muda::Buffer2DViewT&lt; IsConst, T &gt;::m_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#variable-m_origin_height","title":"variable m_origin_height","text":"<pre><code>size_t muda::Buffer2DViewT&lt; IsConst, T &gt;::m_origin_height;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#variable-m_origin_width","title":"variable m_origin_width","text":"<pre><code>size_t muda::Buffer2DViewT&lt; IsConst, T &gt;::m_origin_width;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#variable-m_pitch_bytes","title":"variable m_pitch_bytes","text":"<pre><code>size_t muda::Buffer2DViewT&lt; IsConst, T &gt;::m_pitch_bytes;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_buffer2_d_view_t/#friend-bufferinfoaccessor","title":"friend BufferInfoAccessor","text":"<pre><code>class muda::Buffer2DViewT::BufferInfoAccessor (\n    details::buffer::BufferInfoAccessor\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_2d_view.h</code></p>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/","title":"Class muda::Buffer3DViewT","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; Buffer3DViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#public-types","title":"Public Types","text":"Type Name typedef CDense3D&lt; T &gt; CViewer typedef Buffer3DViewT&lt; true, T &gt; ConstView typedef Buffer3DViewT&lt; false, T &gt; NonConstView typedef Buffer3DViewT&lt;!IsConst, T &gt; OtherView typedef Buffer3DViewT&lt; IsConst, T &gt; ThisView typedef std::conditional_t&lt; IsConst, CViewer, Viewer &gt; ThisViewer typedef Dense3D&lt; T &gt; Viewer"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Buffer3DViewT ()  MUDA_GENERIC Buffer3DViewT (const Buffer3DViewT &amp;)  MUDA_GENERIC Buffer3DViewT (const Buffer3DViewT&lt; OtherIsConst, T &gt; &amp; other)  MUDA_GENERIC Buffer3DViewT (auto_const_t&lt; T &gt; * data, size_t pitch_bytes, size_t pitch_bytes_area, size_t origin_width, size_t origin_height, const Offset3D &amp; offset, const Extent3D &amp; extent)  MUDA_GENERIC Buffer3DViewT (T * data, size_t pitch_bytes, size_t pitch_bytes_area, const Offset3D &amp; offset, const Extent3D &amp; extent)  MUDA_GENERIC ConstView as_const () const MUDA_HOST void copy_from (const Buffer3DViewT&lt; true, T &gt; &amp; other) const MUDA_HOST void copy_from (const T * host) const MUDA_HOST void copy_to (T * host) const MUDA_GENERIC CViewer cviewer () const MUDA_GENERIC auto_const_t&lt; T &gt; * data (size_t x, size_t y, size_t z) const MUDA_GENERIC auto_const_t&lt; T &gt; * data (size_t flatten_i) const MUDA_GENERIC Extent3D extent () const MUDA_HOST void fill (const T &amp; v) const MUDA_GENERIC Offset3D offset () const MUDA_GENERIC auto_const_t&lt; T &gt; * origin_data () const MUDA_GENERIC size_t pitch_bytes () const MUDA_GENERIC size_t pitch_bytes_area () const MUDA_GENERIC ThisView subview (Offset3D offset, Extent3D extent={}) const MUDA_GENERIC size_t total_size () const MUDA_GENERIC ThisViewer viewer () const"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data   = = nullptr Extent3D m_extent Offset3D m_offset size_t m_origin_height   = = ~0 size_t m_origin_width   = = ~0 size_t m_pitch_bytes   = = ~0 size_t m_pitch_bytes_area   = = ~0"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#typedef-cviewer","title":"typedef CViewer","text":"<pre><code>using muda::Buffer3DViewT&lt; IsConst, T &gt;::CViewer =  CDense3D&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::Buffer3DViewT&lt; IsConst, T &gt;::ConstView =  Buffer3DViewT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#typedef-nonconstview","title":"typedef NonConstView","text":"<pre><code>using muda::Buffer3DViewT&lt; IsConst, T &gt;::NonConstView =  Buffer3DViewT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#typedef-otherview","title":"typedef OtherView","text":"<pre><code>using muda::Buffer3DViewT&lt; IsConst, T &gt;::OtherView =  Buffer3DViewT&lt;!IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::Buffer3DViewT&lt; IsConst, T &gt;::ThisView =  Buffer3DViewT&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::Buffer3DViewT&lt; IsConst, T &gt;::ThisViewer =  std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#typedef-viewer","title":"typedef Viewer","text":"<pre><code>using muda::Buffer3DViewT&lt; IsConst, T &gt;::Viewer =  Dense3D&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-buffer3dviewt-26","title":"function Buffer3DViewT [2/6]","text":"<pre><code>MUDA_GENERIC muda::Buffer3DViewT::Buffer3DViewT () \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-buffer3dviewt-36","title":"function Buffer3DViewT [3/6]","text":"<pre><code>MUDA_GENERIC muda::Buffer3DViewT::Buffer3DViewT (\n    const Buffer3DViewT &amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-buffer3dviewt-46","title":"function Buffer3DViewT [4/6]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\nMUDA_GENERIC muda::Buffer3DViewT::Buffer3DViewT (\n    const Buffer3DViewT &lt; OtherIsConst, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-buffer3dviewt-56","title":"function Buffer3DViewT [5/6]","text":"<pre><code>MUDA_GENERIC muda::Buffer3DViewT::Buffer3DViewT (\n    auto_const_t&lt; T &gt; * data,\n    size_t pitch_bytes,\n    size_t pitch_bytes_area,\n    size_t origin_width,\n    size_t origin_height,\n    const Offset3D &amp; offset,\n    const Extent3D &amp; extent\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-buffer3dviewt-66","title":"function Buffer3DViewT [6/6]","text":"<pre><code>MUDA_GENERIC muda::Buffer3DViewT::Buffer3DViewT (\n    T * data,\n    size_t pitch_bytes,\n    size_t pitch_bytes_area,\n    const Offset3D &amp; offset,\n    const Extent3D &amp; extent\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-as_const","title":"function as_const","text":"<pre><code>MUDA_GENERIC ConstView muda::Buffer3DViewT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-copy_from-12","title":"function copy_from [1/2]","text":"<pre><code>MUDA_HOST void muda::Buffer3DViewT::copy_from (\n    const Buffer3DViewT &lt; true, T &gt; &amp; other\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-copy_from-22","title":"function copy_from [2/2]","text":"<pre><code>MUDA_HOST void muda::Buffer3DViewT::copy_from (\n    const T * host\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-copy_to","title":"function copy_to","text":"<pre><code>MUDA_HOST void muda::Buffer3DViewT::copy_to (\n    T * host\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-cviewer","title":"function cviewer","text":"<pre><code>MUDA_GENERIC CViewer muda::Buffer3DViewT::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-data-12","title":"function data [1/2]","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::Buffer3DViewT::data (\n    size_t x,\n    size_t y,\n    size_t z\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-data-22","title":"function data [2/2]","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::Buffer3DViewT::data (\n    size_t flatten_i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-extent","title":"function extent","text":"<pre><code>MUDA_GENERIC Extent3D muda::Buffer3DViewT::extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-fill","title":"function fill","text":"<pre><code>MUDA_HOST void muda::Buffer3DViewT::fill (\n    const T &amp; v\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-offset","title":"function offset","text":"<pre><code>MUDA_GENERIC Offset3D muda::Buffer3DViewT::offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-origin_data","title":"function origin_data","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::Buffer3DViewT::origin_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-pitch_bytes","title":"function pitch_bytes","text":"<pre><code>MUDA_GENERIC size_t muda::Buffer3DViewT::pitch_bytes () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-pitch_bytes_area","title":"function pitch_bytes_area","text":"<pre><code>MUDA_GENERIC size_t muda::Buffer3DViewT::pitch_bytes_area () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-subview","title":"function subview","text":"<pre><code>MUDA_GENERIC ThisView muda::Buffer3DViewT::subview (\n    Offset3D offset,\n    Extent3D extent={}\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-total_size","title":"function total_size","text":"<pre><code>MUDA_GENERIC size_t muda::Buffer3DViewT::total_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#function-viewer","title":"function viewer","text":"<pre><code>MUDA_GENERIC ThisViewer muda::Buffer3DViewT::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::Buffer3DViewT&lt; IsConst, T &gt;::m_data;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#variable-m_extent","title":"variable m_extent","text":"<pre><code>Extent3D muda::Buffer3DViewT&lt; IsConst, T &gt;::m_extent;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#variable-m_offset","title":"variable m_offset","text":"<pre><code>Offset3D muda::Buffer3DViewT&lt; IsConst, T &gt;::m_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#variable-m_origin_height","title":"variable m_origin_height","text":"<pre><code>size_t muda::Buffer3DViewT&lt; IsConst, T &gt;::m_origin_height;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#variable-m_origin_width","title":"variable m_origin_width","text":"<pre><code>size_t muda::Buffer3DViewT&lt; IsConst, T &gt;::m_origin_width;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#variable-m_pitch_bytes","title":"variable m_pitch_bytes","text":"<pre><code>size_t muda::Buffer3DViewT&lt; IsConst, T &gt;::m_pitch_bytes;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#variable-m_pitch_bytes_area","title":"variable m_pitch_bytes_area","text":"<pre><code>size_t muda::Buffer3DViewT&lt; IsConst, T &gt;::m_pitch_bytes_area;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_buffer3_d_view_t/#friend-bufferinfoaccessor","title":"friend BufferInfoAccessor","text":"<pre><code>class muda::Buffer3DViewT::BufferInfoAccessor (\n    details::buffer::BufferInfoAccessor\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_3d_view.h</code></p>"},{"location":"muda/classmuda_1_1_buffer_launch/","title":"Class muda::BufferLaunch","text":"<p>ClassList &gt; muda &gt; BufferLaunch</p> <p>Inherits the following classes: muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_buffer_launch/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_buffer_launch/#public-functions","title":"Public Functions","text":"Type Name MUDA_HOST BufferLaunch (cudaStream_t s=nullptr)  MUDA_HOST BufferLaunch (int block_dim, cudaStream_t s=nullptr)  MUDA_HOST BufferLaunch (int grid_dim, int block_dim, cudaStream_t s=nullptr)  MUDA_HOST BufferLaunch &amp; alloc (DeviceBuffer&lt; T &gt; &amp; buffer, size_t n)  MUDA_HOST BufferLaunch &amp; alloc (DeviceBuffer2D&lt; T &gt; &amp; buffer, Extent2D extent)  MUDA_HOST BufferLaunch &amp; alloc (DeviceBuffer3D&lt; T &gt; &amp; buffer, Extent3D extent)  MUDA_HOST BufferLaunch &amp; clear (DeviceBuffer&lt; T &gt; &amp; buffer)  MUDA_HOST BufferLaunch &amp; clear (DeviceBuffer2D&lt; T &gt; &amp; buffer)  MUDA_HOST BufferLaunch &amp; clear (DeviceBuffer3D&lt; T &gt; &amp; buffer)  MUDA_HOST BufferLaunch &amp; copy (VarView&lt; T &gt; dst, CVarView&lt; T &gt; src)  MUDA_HOST BufferLaunch &amp; copy (BufferView&lt; T &gt; dst, CBufferView&lt; T &gt; src)  MUDA_HOST BufferLaunch &amp; copy (Buffer2DView&lt; T &gt; dst, CBuffer2DView&lt; T &gt; src)  MUDA_HOST BufferLaunch &amp; copy (Buffer3DView&lt; T &gt; dst, CBuffer3DView&lt; T &gt; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; VarView&lt; T &gt; &gt; &amp; dst, const ComputeGraphVar&lt; VarView&lt; T &gt; &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; BufferView&lt; T &gt; &gt; &amp; dst, const ComputeGraphVar&lt; BufferView&lt; T &gt; &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; Buffer2DView&lt; T &gt; &gt; &amp; dst, const ComputeGraphVar&lt; Buffer2DView&lt; T &gt; &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; Buffer3DView&lt; T &gt; &gt; &amp; dst, const ComputeGraphVar&lt; Buffer3DView&lt; T &gt; &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (T * dst, CVarView&lt; T &gt; src)  MUDA_HOST BufferLaunch &amp; copy (T * dst, CBufferView&lt; T &gt; src)  MUDA_HOST BufferLaunch &amp; copy (T * dst, CBuffer2DView&lt; T &gt; src)  MUDA_HOST BufferLaunch &amp; copy (T * dst, CBuffer3DView&lt; T &gt; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; T * &gt; &amp; dst, const ComputeGraphVar&lt; BufferView&lt; T &gt; &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; T * &gt; &amp; dst, const ComputeGraphVar&lt; Buffer2DView&lt; T &gt; &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; T * &gt; &amp; dst, const ComputeGraphVar&lt; VarView&lt; T &gt; &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; T * &gt; &amp; dst, const ComputeGraphVar&lt; Buffer3DView&lt; T &gt; &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (VarView&lt; T &gt; dst, const T * src)  MUDA_HOST BufferLaunch &amp; copy (BufferView&lt; T &gt; dst, const T * src)  MUDA_HOST BufferLaunch &amp; copy (Buffer2DView&lt; T &gt; dst, const T * src)  MUDA_HOST BufferLaunch &amp; copy (Buffer3DView&lt; T &gt; dst, const T * src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; BufferView&lt; T &gt; &gt; &amp; dst, const ComputeGraphVar&lt; T * &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; Buffer2DView&lt; T &gt; &gt; &amp; dst, const ComputeGraphVar&lt; T * &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; VarView&lt; T &gt; &gt; &amp; dst, const ComputeGraphVar&lt; T * &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; copy (ComputeGraphVar&lt; Buffer3DView&lt; T &gt; &gt; &amp; dst, const ComputeGraphVar&lt; T * &gt; &amp; src)  MUDA_HOST BufferLaunch &amp; fill (VarView&lt; T &gt; buffer, const T &amp; val)  MUDA_HOST BufferLaunch &amp; fill (BufferView&lt; T &gt; buffer, const T &amp; val)  MUDA_HOST BufferLaunch &amp; fill (Buffer2DView&lt; T &gt; buffer, const T &amp; val)  MUDA_HOST BufferLaunch &amp; fill (Buffer3DView&lt; T &gt; buffer, const T &amp; val)  MUDA_HOST BufferLaunch &amp; fill (ComputeGraphVar&lt; VarView&lt; T &gt; &gt; &amp; buffer, const ComputeGraphVar&lt; T &gt; &amp; val)  MUDA_HOST BufferLaunch &amp; fill (ComputeGraphVar&lt; BufferView&lt; T &gt; &gt; &amp; buffer, const ComputeGraphVar&lt; T &gt; &amp; val)  MUDA_HOST BufferLaunch &amp; fill (ComputeGraphVar&lt; Buffer2DView&lt; T &gt; &gt; &amp; buffer, const ComputeGraphVar&lt; T &gt; &amp; val)  MUDA_HOST BufferLaunch &amp; fill (ComputeGraphVar&lt; Buffer3DView&lt; T &gt; &gt; &amp; buffer, const ComputeGraphVar&lt; T &gt; &amp; val)  MUDA_HOST BufferLaunch &amp; free (DeviceBuffer&lt; T &gt; &amp; buffer)  MUDA_HOST BufferLaunch &amp; free (DeviceBuffer2D&lt; T &gt; &amp; buffer)  MUDA_HOST BufferLaunch &amp; free (DeviceBuffer3D&lt; T &gt; &amp; buffer)  MUDA_HOST BufferLaunch &amp; reserve (DeviceBuffer&lt; T &gt; &amp; buffer, size_t capacity)  MUDA_HOST BufferLaunch &amp; reserve (DeviceBuffer2D&lt; T &gt; &amp; buffer, Extent2D capacity)  MUDA_HOST BufferLaunch &amp; reserve (DeviceBuffer3D&lt; T &gt; &amp; buffer, Extent3D capacity)  MUDA_HOST BufferLaunch &amp; resize (DeviceBuffer&lt; T &gt; &amp; buffer, size_t size)  MUDA_HOST BufferLaunch &amp; resize (DeviceBuffer2D&lt; T &gt; &amp; buffer, Extent2D extent)  MUDA_HOST BufferLaunch &amp; resize (DeviceBuffer3D&lt; T &gt; &amp; buffer, Extent3D extent)  MUDA_HOST BufferLaunch &amp; resize (DeviceBuffer&lt; T &gt; &amp; buffer, size_t size, const T &amp; val)  MUDA_HOST BufferLaunch &amp; resize (DeviceBuffer2D&lt; T &gt; &amp; buffer, Extent2D extent, const T &amp; val)  MUDA_HOST BufferLaunch &amp; resize (DeviceBuffer3D&lt; T &gt; &amp; buffer, Extent3D extent, const T &amp; val)  MUDA_HOST BufferLaunch &amp; shrink_to_fit (DeviceBuffer&lt; T &gt; &amp; buffer)  MUDA_HOST BufferLaunch &amp; shrink_to_fit (DeviceBuffer2D&lt; T &gt; &amp; buffer)  MUDA_HOST BufferLaunch &amp; shrink_to_fit (DeviceBuffer3D&lt; T &gt; &amp; buffer)"},{"location":"muda/classmuda_1_1_buffer_launch/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_buffer_launch/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_buffer_launch/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_buffer_launch/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_buffer_launch/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_buffer_launch/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_buffer_launch/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_buffer_launch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_buffer_launch/#function-bufferlaunch-13","title":"function BufferLaunch [1/3]","text":"<pre><code>inline MUDA_HOST muda::BufferLaunch::BufferLaunch (\n    cudaStream_t s=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-bufferlaunch-23","title":"function BufferLaunch [2/3]","text":"<pre><code>inline MUDA_HOST muda::BufferLaunch::BufferLaunch (\n    int block_dim,\n    cudaStream_t s=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-bufferlaunch-33","title":"function BufferLaunch [3/3]","text":"<pre><code>inline MUDA_HOST muda::BufferLaunch::BufferLaunch (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t s=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-alloc-13","title":"function alloc [1/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::alloc (\n    DeviceBuffer &lt; T &gt; &amp; buffer,\n    size_t n\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-alloc-23","title":"function alloc [2/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::alloc (\n    DeviceBuffer2D &lt; T &gt; &amp; buffer,\n    Extent2D extent\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-alloc-33","title":"function alloc [3/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::alloc (\n    DeviceBuffer3D &lt; T &gt; &amp; buffer,\n    Extent3D extent\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-clear-13","title":"function clear [1/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::clear (\n    DeviceBuffer &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-clear-23","title":"function clear [2/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::clear (\n    DeviceBuffer2D &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-clear-33","title":"function clear [3/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::clear (\n    DeviceBuffer3D &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-124","title":"function copy [1/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    VarView &lt; T &gt; dst,\n    CVarView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-224","title":"function copy [2/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    BufferView &lt; T &gt; dst,\n    CBufferView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-324","title":"function copy [3/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    Buffer2DView &lt; T &gt; dst,\n    CBuffer2DView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-424","title":"function copy [4/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    Buffer3DView &lt; T &gt; dst,\n    CBuffer3DView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-524","title":"function copy [5/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; VarView &lt; T &gt; &gt; &amp; dst,\n    const ComputeGraphVar &lt; VarView &lt; T &gt; &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-624","title":"function copy [6/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; BufferView &lt; T &gt; &gt; &amp; dst,\n    const ComputeGraphVar &lt; BufferView &lt; T &gt; &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-724","title":"function copy [7/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; Buffer2DView &lt; T &gt; &gt; &amp; dst,\n    const ComputeGraphVar &lt; Buffer2DView &lt; T &gt; &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-824","title":"function copy [8/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; Buffer3DView &lt; T &gt; &gt; &amp; dst,\n    const ComputeGraphVar &lt; Buffer3DView &lt; T &gt; &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-924","title":"function copy [9/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    T * dst,\n    CVarView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1024","title":"function copy [10/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    T * dst,\n    CBufferView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1124","title":"function copy [11/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    T * dst,\n    CBuffer2DView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1224","title":"function copy [12/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    T * dst,\n    CBuffer3DView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1324","title":"function copy [13/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; T * &gt; &amp; dst,\n    const ComputeGraphVar &lt; BufferView &lt; T &gt; &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1424","title":"function copy [14/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; T * &gt; &amp; dst,\n    const ComputeGraphVar &lt; Buffer2DView &lt; T &gt; &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1524","title":"function copy [15/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; T * &gt; &amp; dst,\n    const ComputeGraphVar &lt; VarView &lt; T &gt; &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1624","title":"function copy [16/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; T * &gt; &amp; dst,\n    const ComputeGraphVar &lt; Buffer3DView &lt; T &gt; &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1724","title":"function copy [17/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    VarView &lt; T &gt; dst,\n    const T * src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1824","title":"function copy [18/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    BufferView &lt; T &gt; dst,\n    const T * src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-1924","title":"function copy [19/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    Buffer2DView &lt; T &gt; dst,\n    const T * src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-2024","title":"function copy [20/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    Buffer3DView &lt; T &gt; dst,\n    const T * src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-2124","title":"function copy [21/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; BufferView &lt; T &gt; &gt; &amp; dst,\n    const ComputeGraphVar &lt; T * &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-2224","title":"function copy [22/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; Buffer2DView &lt; T &gt; &gt; &amp; dst,\n    const ComputeGraphVar &lt; T * &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-2324","title":"function copy [23/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; VarView &lt; T &gt; &gt; &amp; dst,\n    const ComputeGraphVar &lt; T * &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-copy-2424","title":"function copy [24/24]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::copy (\n    ComputeGraphVar &lt; Buffer3DView &lt; T &gt; &gt; &amp; dst,\n    const ComputeGraphVar &lt; T * &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-fill-18","title":"function fill [1/8]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::fill (\n    VarView &lt; T &gt; buffer,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-fill-28","title":"function fill [2/8]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::fill (\n    BufferView &lt; T &gt; buffer,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-fill-38","title":"function fill [3/8]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::fill (\n    Buffer2DView &lt; T &gt; buffer,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-fill-48","title":"function fill [4/8]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::fill (\n    Buffer3DView &lt; T &gt; buffer,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-fill-58","title":"function fill [5/8]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::fill (\n    ComputeGraphVar &lt; VarView &lt; T &gt; &gt; &amp; buffer,\n    const ComputeGraphVar &lt; T &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-fill-68","title":"function fill [6/8]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::fill (\n    ComputeGraphVar &lt; BufferView &lt; T &gt; &gt; &amp; buffer,\n    const ComputeGraphVar &lt; T &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-fill-78","title":"function fill [7/8]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::fill (\n    ComputeGraphVar &lt; Buffer2DView &lt; T &gt; &gt; &amp; buffer,\n    const ComputeGraphVar &lt; T &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-fill-88","title":"function fill [8/8]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::fill (\n    ComputeGraphVar &lt; Buffer3DView &lt; T &gt; &gt; &amp; buffer,\n    const ComputeGraphVar &lt; T &gt; &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-free-13","title":"function free [1/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::free (\n    DeviceBuffer &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-free-23","title":"function free [2/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::free (\n    DeviceBuffer2D &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-free-33","title":"function free [3/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::free (\n    DeviceBuffer3D &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-reserve-13","title":"function reserve [1/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::reserve (\n    DeviceBuffer &lt; T &gt; &amp; buffer,\n    size_t capacity\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-reserve-23","title":"function reserve [2/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::reserve (\n    DeviceBuffer2D &lt; T &gt; &amp; buffer,\n    Extent2D capacity\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-reserve-33","title":"function reserve [3/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::reserve (\n    DeviceBuffer3D &lt; T &gt; &amp; buffer,\n    Extent3D capacity\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-resize-19","title":"function resize [1/9]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::resize (\n    DeviceBuffer &lt; T &gt; &amp; buffer,\n    size_t size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-resize-29","title":"function resize [2/9]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::resize (\n    DeviceBuffer2D &lt; T &gt; &amp; buffer,\n    Extent2D extent\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-resize-39","title":"function resize [3/9]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::resize (\n    DeviceBuffer3D &lt; T &gt; &amp; buffer,\n    Extent3D extent\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-resize-49","title":"function resize [4/9]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::resize (\n    DeviceBuffer &lt; T &gt; &amp; buffer,\n    size_t size,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-resize-59","title":"function resize [5/9]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::resize (\n    DeviceBuffer2D &lt; T &gt; &amp; buffer,\n    Extent2D extent,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-resize-69","title":"function resize [6/9]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::resize (\n    DeviceBuffer3D &lt; T &gt; &amp; buffer,\n    Extent3D extent,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-shrink_to_fit-13","title":"function shrink_to_fit [1/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::shrink_to_fit (\n    DeviceBuffer &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-shrink_to_fit-23","title":"function shrink_to_fit [2/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::shrink_to_fit (\n    DeviceBuffer2D &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_launch/#function-shrink_to_fit-33","title":"function shrink_to_fit [3/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST BufferLaunch &amp; muda::BufferLaunch::shrink_to_fit (\n    DeviceBuffer3D &lt; T &gt; &amp; buffer\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_launch.h</code></p>"},{"location":"muda/classmuda_1_1_buffer_view_t/","title":"Class muda::BufferViewT","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; BufferViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_buffer_view_t/#public-types","title":"Public Types","text":"Type Name typedef CDense1D&lt; T &gt; CViewer typedef BufferViewT&lt; true, T &gt; ConstView typedef BufferViewT&lt; IsConst, T &gt; ThisView typedef std::conditional_t&lt; IsConst, CViewer, Viewer &gt; ThisViewer typedef Dense1D&lt; T &gt; Viewer typedef typename Base::template auto_const_t&lt; U &gt; auto_const_t typedef size_t difference_type typedef std::random_access_iterator_tag iterator_category typedef T * pointer typedef T &amp; reference typedef T value_type"},{"location":"muda/classmuda_1_1_buffer_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_buffer_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_buffer_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC BufferViewT ()  MUDA_GENERIC BufferViewT (const BufferViewT &amp; other)  MUDA_GENERIC BufferViewT (auto_const_t&lt; T &gt; * data, size_t offset, size_t size)  MUDA_GENERIC BufferViewT (auto_const_t&lt; T &gt; * data, size_t size)  MUDA_GENERIC BufferViewT (const BufferViewT&lt; OtherIsConst, T &gt; &amp; other)  MUDA_GENERIC ConstView as_const () const MUDA_HOST void copy_from (const BufferViewT&lt; true, T &gt; &amp; other) const MUDA_HOST void copy_from (const T * host) const MUDA_HOST void copy_to (T * host) const MUDA_GENERIC CViewer cviewer () const MUDA_GENERIC auto_const_t&lt; T &gt; * data () const MUDA_GENERIC auto_const_t&lt; T &gt; * data (size_t i) const MUDA_HOST void fill (const T &amp; value) const MUDA_GENERIC size_t offset () const MUDA_GENERIC reference operator* () const MUDA_GENERIC ThisView operator+ (int i) const MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator[] (size_t i) const MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator[] (int i) const MUDA_GENERIC auto_const_t&lt; T &gt; * origin_data () const MUDA_GENERIC size_t size () const MUDA_GENERIC ThisView subview (size_t offset, size_t size=~0) const MUDA_GENERIC ThisViewer viewer () const"},{"location":"muda/classmuda_1_1_buffer_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data   = = nullptr size_t m_offset   = = ~0 size_t m_size   = = ~0"},{"location":"muda/classmuda_1_1_buffer_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-cviewer","title":"typedef CViewer","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::CViewer =  CDense1D&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::ConstView =  BufferViewT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::ThisView =  BufferViewT&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::ThisViewer =  std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-viewer","title":"typedef Viewer","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::Viewer =  Dense1D&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-auto_const_t","title":"typedef auto_const_t","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::auto_const_t =  typename Base::template auto_const_t&lt;U&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::difference_type =  size_t;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::iterator_category =  std::random_access_iterator_tag;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-pointer","title":"typedef pointer","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::pointer =  T*;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-reference","title":"typedef reference","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::reference =  T&amp;;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::BufferViewT&lt; IsConst, T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_buffer_view_t/#function-bufferviewt-26","title":"function BufferViewT [2/6]","text":"<pre><code>MUDA_GENERIC muda::BufferViewT::BufferViewT () \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-bufferviewt-36","title":"function BufferViewT [3/6]","text":"<pre><code>MUDA_GENERIC muda::BufferViewT::BufferViewT (\n    const BufferViewT &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-bufferviewt-46","title":"function BufferViewT [4/6]","text":"<pre><code>MUDA_GENERIC muda::BufferViewT::BufferViewT (\n    auto_const_t&lt; T &gt; * data,\n    size_t offset,\n    size_t size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-bufferviewt-56","title":"function BufferViewT [5/6]","text":"<pre><code>MUDA_GENERIC muda::BufferViewT::BufferViewT (\n    auto_const_t&lt; T &gt; * data,\n    size_t size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-bufferviewt-66","title":"function BufferViewT [6/6]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\nMUDA_GENERIC muda::BufferViewT::BufferViewT (\n    const BufferViewT &lt; OtherIsConst, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-as_const","title":"function as_const","text":"<pre><code>MUDA_GENERIC ConstView muda::BufferViewT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-copy_from-12","title":"function copy_from [1/2]","text":"<pre><code>MUDA_HOST void muda::BufferViewT::copy_from (\n    const BufferViewT &lt; true, T &gt; &amp; other\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-copy_from-22","title":"function copy_from [2/2]","text":"<pre><code>MUDA_HOST void muda::BufferViewT::copy_from (\n    const T * host\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-copy_to","title":"function copy_to","text":"<pre><code>MUDA_HOST void muda::BufferViewT::copy_to (\n    T * host\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-cviewer","title":"function cviewer","text":"<pre><code>MUDA_GENERIC CViewer muda::BufferViewT::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-data-12","title":"function data [1/2]","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::BufferViewT::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-data-22","title":"function data [2/2]","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::BufferViewT::data (\n    size_t i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-fill","title":"function fill","text":"<pre><code>MUDA_HOST void muda::BufferViewT::fill (\n    const T &amp; value\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-offset","title":"function offset","text":"<pre><code>inline MUDA_GENERIC size_t muda::BufferViewT::offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-operator","title":"function operator*","text":"<pre><code>MUDA_GENERIC reference muda::BufferViewT::operator* () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-operator_1","title":"function operator+","text":"<pre><code>MUDA_GENERIC ThisView muda::BufferViewT::operator+ (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-operator_2","title":"function operator[]","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::BufferViewT::operator[] (\n    size_t i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-operator_3","title":"function operator[]","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::BufferViewT::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-origin_data","title":"function origin_data","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::BufferViewT::origin_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-size","title":"function size","text":"<pre><code>inline MUDA_GENERIC size_t muda::BufferViewT::size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-subview","title":"function subview","text":"<pre><code>MUDA_GENERIC ThisView muda::BufferViewT::subview (\n    size_t offset,\n    size_t size=~0\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#function-viewer","title":"function viewer","text":"<pre><code>MUDA_GENERIC ThisViewer muda::BufferViewT::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_buffer_view_t/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::BufferViewT&lt; IsConst, T &gt;::m_data;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#variable-m_offset","title":"variable m_offset","text":"<pre><code>size_t muda::BufferViewT&lt; IsConst, T &gt;::m_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_buffer_view_t/#variable-m_size","title":"variable m_size","text":"<pre><code>size_t muda::BufferViewT&lt; IsConst, T &gt;::m_size;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_fwd.h</code></p>"},{"location":"muda/classmuda_1_1_c_field_entry_view/","title":"Class muda::CFieldEntryView","text":"<p>template &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; CFieldEntryView</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_view.h</code></p>"},{"location":"muda/classmuda_1_1_c_field_entry_viewer/","title":"Class muda::CFieldEntryViewer","text":"<p>template &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; CFieldEntryViewer</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_c_matrix_map_info/","title":"Class muda::CMatrixMapInfo","text":"<p>template &lt;typename T, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; CMatrixMapInfo</p>"},{"location":"muda/classmuda_1_1_c_matrix_map_info/#public-attributes","title":"Public Attributes","text":"Type Name const T * begin int inner_stride int outer_stride"},{"location":"muda/classmuda_1_1_c_matrix_map_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_c_matrix_map_info/#variable-begin","title":"variable begin","text":"<pre><code>const T* muda::CMatrixMapInfo&lt; T, M, N &gt;::begin;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_matrix_map_info/#variable-inner_stride","title":"variable inner_stride","text":"<pre><code>int muda::CMatrixMapInfo&lt; T, M, N &gt;::inner_stride;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_matrix_map_info/#variable-outer_stride","title":"variable outer_stride","text":"<pre><code>int muda::CMatrixMapInfo&lt; T, M, N &gt;::outer_stride;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/matrix_map_info.h</code></p>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/","title":"Class muda::COOMatrixViewT","text":"<p>template &lt;bool IsConst, typename Ty&gt;</p> <p>ClassList &gt; muda &gt; COOMatrixViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#public-types","title":"Public Types","text":"Type Name typedef COOMatrixViewT&lt; true, Ty &gt; ConstView typedef COOMatrixViewT&lt; false, Ty &gt; NonConstView typedef COOMatrixViewT&lt; IsConst, Ty &gt; ThisView"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC COOMatrixViewT () = default MUDA_GENERIC COOMatrixViewT (int rows, int cols, int triplet_index_offset, int triplet_count, int total_triplet_count, int2 submatrix_offset, int2 submatrix_extent, auto_const_t&lt; int &gt; * row_indices, auto_const_t&lt; int &gt; * col_indices, auto_const_t&lt; Ty &gt; * values, cusparseSpMatDescr_t descr, cusparseMatDescr_t legacy_descr, bool trans)  MUDA_GENERIC COOMatrixViewT (int rows, int cols, int total_triplet_count, auto_const_t&lt; int &gt; * row_indices, auto_const_t&lt; int &gt; * col_indices, auto_const_t&lt; Ty &gt; * values, cusparseSpMatDescr_t descr, cusparseMatDescr_t legacy_descr, bool trans)  MUDA_GENERIC COOMatrixViewT (const COOMatrixViewT&lt; OtherIsConst, Ty &gt; &amp; other)  MUDA_GENERIC auto as_const () const auto col_indices () const auto cols () const MUDA_GENERIC auto cviewer () const auto descr () const auto is_trans () const auto legacy_descr () const auto row_indices () const auto rows () const auto total_triplet_count () const auto tripet_index_offset () const auto triplet_count () const auto values () const MUDA_GENERIC auto viewer ()"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; int &gt; * m_col_indices int m_cols   = = 0 cusparseSpMatDescr_t m_descr   = = nullptr cusparseMatDescr_t m_legacy_descr   = = nullptr auto_const_t&lt; int &gt; * m_row_indices int m_rows   = = 0 int2 m_submatrix_extent   = = {0, 0} int2 m_submatrix_offset   = = {0, 0} int m_total_triplet_count   = = 0 bool m_trans   = = false int m_triplet_count   = = 0 int m_triplet_index_offset   = = 0 auto_const_t&lt; Ty &gt; * m_values"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::COOMatrixViewT&lt; IsConst, Ty &gt;::ConstView =  COOMatrixViewT&lt;true, Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#typedef-nonconstview","title":"typedef NonConstView","text":"<pre><code>using muda::COOMatrixViewT&lt; IsConst, Ty &gt;::NonConstView =  COOMatrixViewT&lt;false, Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::COOMatrixViewT&lt; IsConst, Ty &gt;::ThisView =  COOMatrixViewT&lt;IsConst, Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-coomatrixviewt-25","title":"function COOMatrixViewT [2/5]","text":"<pre><code>MUDA_GENERIC muda::COOMatrixViewT::COOMatrixViewT () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-coomatrixviewt-35","title":"function COOMatrixViewT [3/5]","text":"<pre><code>inline MUDA_GENERIC muda::COOMatrixViewT::COOMatrixViewT (\n    int rows,\n    int cols,\n    int triplet_index_offset,\n    int triplet_count,\n    int total_triplet_count,\n    int2 submatrix_offset,\n    int2 submatrix_extent,\n    auto_const_t&lt; int &gt; * row_indices,\n    auto_const_t&lt; int &gt; * col_indices,\n    auto_const_t&lt; Ty &gt; * values,\n    cusparseSpMatDescr_t descr,\n    cusparseMatDescr_t legacy_descr,\n    bool trans\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-coomatrixviewt-45","title":"function COOMatrixViewT [4/5]","text":"<pre><code>inline MUDA_GENERIC muda::COOMatrixViewT::COOMatrixViewT (\n    int rows,\n    int cols,\n    int total_triplet_count,\n    auto_const_t&lt; int &gt; * row_indices,\n    auto_const_t&lt; int &gt; * col_indices,\n    auto_const_t&lt; Ty &gt; * values,\n    cusparseSpMatDescr_t descr,\n    cusparseMatDescr_t legacy_descr,\n    bool trans\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-coomatrixviewt-55","title":"function COOMatrixViewT [5/5]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::COOMatrixViewT::COOMatrixViewT (\n    const COOMatrixViewT &lt; OtherIsConst, Ty &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::COOMatrixViewT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-col_indices","title":"function col_indices","text":"<pre><code>inline auto muda::COOMatrixViewT::col_indices () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-cols","title":"function cols","text":"<pre><code>inline auto muda::COOMatrixViewT::cols () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-cviewer","title":"function cviewer","text":"<pre><code>inline MUDA_GENERIC auto muda::COOMatrixViewT::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-descr","title":"function descr","text":"<pre><code>inline auto muda::COOMatrixViewT::descr () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-is_trans","title":"function is_trans","text":"<pre><code>inline auto muda::COOMatrixViewT::is_trans () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-legacy_descr","title":"function legacy_descr","text":"<pre><code>inline auto muda::COOMatrixViewT::legacy_descr () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-row_indices","title":"function row_indices","text":"<pre><code>inline auto muda::COOMatrixViewT::row_indices () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-rows","title":"function rows","text":"<pre><code>inline auto muda::COOMatrixViewT::rows () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-total_triplet_count","title":"function total_triplet_count","text":"<pre><code>inline auto muda::COOMatrixViewT::total_triplet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-tripet_index_offset","title":"function tripet_index_offset","text":"<pre><code>inline auto muda::COOMatrixViewT::tripet_index_offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-triplet_count","title":"function triplet_count","text":"<pre><code>inline auto muda::COOMatrixViewT::triplet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-values","title":"function values","text":"<pre><code>inline auto muda::COOMatrixViewT::values () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#function-viewer","title":"function viewer","text":"<pre><code>inline MUDA_GENERIC auto muda::COOMatrixViewT::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_col_indices","title":"variable m_col_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_col_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_cols","title":"variable m_cols","text":"<pre><code>int muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_cols;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_descr","title":"variable m_descr","text":"<pre><code>cusparseSpMatDescr_t muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_descr;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_legacy_descr","title":"variable m_legacy_descr","text":"<pre><code>cusparseMatDescr_t muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_legacy_descr;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_row_indices","title":"variable m_row_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_row_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_rows","title":"variable m_rows","text":"<pre><code>int muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_rows;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_submatrix_extent","title":"variable m_submatrix_extent","text":"<pre><code>int2 muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_submatrix_extent;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_submatrix_offset","title":"variable m_submatrix_offset","text":"<pre><code>int2 muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_submatrix_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_total_triplet_count","title":"variable m_total_triplet_count","text":"<pre><code>int muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_total_triplet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_trans","title":"variable m_trans","text":"<pre><code>bool muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_trans;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_triplet_count","title":"variable m_triplet_count","text":"<pre><code>int muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_triplet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_triplet_index_offset","title":"variable m_triplet_index_offset","text":"<pre><code>int muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_triplet_index_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_matrix_view_t/#variable-m_values","title":"variable m_values","text":"<pre><code>auto_const_t&lt;Ty&gt;* muda::COOMatrixViewT&lt; IsConst, Ty &gt;::m_values;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/bcoo_matrix_view.h</code></p>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/","title":"Class muda::COOVectorViewBase","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; COOVectorViewBase</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#public-types","title":"Public Types","text":"Type Name typedef CCOOVectorViewer&lt; T &gt; CViewer typedef COOVectorViewBase&lt; true, T &gt; ConstView typedef COOVectorViewBase&lt; false, T &gt; NonConstView typedef COOVectorViewBase&lt; IsConst, T &gt; ThisView typedef std::conditional_t&lt; IsConst, CViewer, Viewer &gt; ThisViewer typedef COOVectorViewer&lt; T &gt; Viewer"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC COOVectorViewBase () = default MUDA_GENERIC COOVectorViewBase (int size, int doublet_index_offset, int doublet_count, int total_doublet_count, auto_const_t&lt; int &gt; * indices, auto_const_t&lt; T &gt; * values, cusparseSpVecDescr_t descr)  MUDA_GENERIC auto as_const () const MUDA_GENERIC auto cviewer () const MUDA_GENERIC auto descr () const MUDA_GENERIC auto doublet_count () const MUDA_GENERIC auto doublet_index_offset () const MUDA_GENERIC operator ConstView () const MUDA_GENERIC auto subview (int offset, int count)  MUDA_GENERIC auto subview (int offset)  MUDA_GENERIC ConstView subview (int offset, int count) const MUDA_GENERIC ConstView subview (int offset) const MUDA_GENERIC auto total_doublet_count () const MUDA_GENERIC auto vector_size () const MUDA_GENERIC auto viewer ()"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#protected-attributes","title":"Protected Attributes","text":"Type Name cusparseSpVecDescr_t m_descr   = = nullptr int m_doublet_count   = = 0 int m_doublet_index_offset   = = 0 auto_const_t&lt; int &gt; * m_indices   = = nullptr int m_size   = = 0 int m_total_doublet_count   = = 0 auto_const_t&lt; T &gt; * m_values   = = nullptr"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#typedef-cviewer","title":"typedef CViewer","text":"<pre><code>using muda::COOVectorViewBase&lt; IsConst, T &gt;::CViewer =  CCOOVectorViewer&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::COOVectorViewBase&lt; IsConst, T &gt;::ConstView =  COOVectorViewBase&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#typedef-nonconstview","title":"typedef NonConstView","text":"<pre><code>using muda::COOVectorViewBase&lt; IsConst, T &gt;::NonConstView =  COOVectorViewBase&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::COOVectorViewBase&lt; IsConst, T &gt;::ThisView =  COOVectorViewBase&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::COOVectorViewBase&lt; IsConst, T &gt;::ThisViewer =  std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#typedef-viewer","title":"typedef Viewer","text":"<pre><code>using muda::COOVectorViewBase&lt; IsConst, T &gt;::Viewer =  COOVectorViewer&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-coovectorviewbase-12","title":"function COOVectorViewBase [1/2]","text":"<pre><code>MUDA_GENERIC muda::COOVectorViewBase::COOVectorViewBase () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-coovectorviewbase-22","title":"function COOVectorViewBase [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::COOVectorViewBase::COOVectorViewBase (\n    int size,\n    int doublet_index_offset,\n    int doublet_count,\n    int total_doublet_count,\n    auto_const_t&lt; int &gt; * indices,\n    auto_const_t&lt; T &gt; * values,\n    cusparseSpVecDescr_t descr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-cviewer","title":"function cviewer","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-descr","title":"function descr","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::descr () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-doublet_count","title":"function doublet_count","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::doublet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-doublet_index_offset","title":"function doublet_index_offset","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::doublet_index_offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-operator-constview","title":"function operator ConstView","text":"<pre><code>inline MUDA_GENERIC muda::COOVectorViewBase::operator ConstView () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-subview-14","title":"function subview [1/4]","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::subview (\n    int offset,\n    int count\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-subview-24","title":"function subview [2/4]","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::subview (\n    int offset\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-subview-34","title":"function subview [3/4]","text":"<pre><code>inline MUDA_GENERIC ConstView muda::COOVectorViewBase::subview (\n    int offset,\n    int count\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-subview-44","title":"function subview [4/4]","text":"<pre><code>inline MUDA_GENERIC ConstView muda::COOVectorViewBase::subview (\n    int offset\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-total_doublet_count","title":"function total_doublet_count","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::total_doublet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-vector_size","title":"function vector_size","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::vector_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#function-viewer","title":"function viewer","text":"<pre><code>inline MUDA_GENERIC auto muda::COOVectorViewBase::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#variable-m_descr","title":"variable m_descr","text":"<pre><code>cusparseSpVecDescr_t muda::COOVectorViewBase&lt; IsConst, T &gt;::m_descr;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#variable-m_doublet_count","title":"variable m_doublet_count","text":"<pre><code>int muda::COOVectorViewBase&lt; IsConst, T &gt;::m_doublet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#variable-m_doublet_index_offset","title":"variable m_doublet_index_offset","text":"<pre><code>int muda::COOVectorViewBase&lt; IsConst, T &gt;::m_doublet_index_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#variable-m_indices","title":"variable m_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::COOVectorViewBase&lt; IsConst, T &gt;::m_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#variable-m_size","title":"variable m_size","text":"<pre><code>int muda::COOVectorViewBase&lt; IsConst, T &gt;::m_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#variable-m_total_doublet_count","title":"variable m_total_doublet_count","text":"<pre><code>int muda::COOVectorViewBase&lt; IsConst, T &gt;::m_total_doublet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_c_o_o_vector_view_base/#variable-m_values","title":"variable m_values","text":"<pre><code>auto_const_t&lt;T&gt;* muda::COOVectorViewBase&lt; IsConst, T &gt;::m_values;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/bcoo_vector_view.h</code></p>"},{"location":"muda/classmuda_1_1_closure_id/","title":"Class muda::ClosureId","text":"<p>ClassList &gt; muda &gt; ClosureId</p> <p>Inherits the following classes: muda::IdWithType</p>"},{"location":"muda/classmuda_1_1_closure_id/#public-types-inherited-from-mudaidwithtype","title":"Public Types inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_closure_id/#public-static-attributes-inherited-from-mudaidwithtype","title":"Public Static Attributes inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name auto invalid_id   = = std::numeric_limits&lt;value_type&gt;::max()"},{"location":"muda/classmuda_1_1_closure_id/#public-functions-inherited-from-mudaidwithtype","title":"Public Functions inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name MUDA_GENERIC IdWithType (value_type value) noexcept MUDA_GENERIC IdWithType () noexcept MUDA_GENERIC bool is_valid () noexcept const MUDA_GENERIC value_type value () noexcept const"},{"location":"muda/classmuda_1_1_closure_id/#protected-attributes-inherited-from-mudaidwithtype","title":"Protected Attributes inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name value_type m_value   = {invalid_id} <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_closure_id.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph/","title":"Class muda::ComputeGraph","text":"<p>ClassList &gt; muda &gt; ComputeGraph</p>"},{"location":"muda/classmuda_1_1_compute_graph/#classes","title":"Classes","text":"Type Name class AddNodeProxy class GraphPhaseGuard"},{"location":"muda/classmuda_1_1_compute_graph/#public-types","title":"Public Types","text":"Type Name typedef ComputeGraphDependency Dependency"},{"location":"muda/classmuda_1_1_compute_graph/#public-functions","title":"Public Functions","text":"Type Name ComputeGraph (const ComputeGraph &amp;) = delete ComputeGraph (ComputeGraph &amp;&amp;) = delete ComputeGraph (ComputeGraphVarManager &amp; manager, std::string_view name=\"graph\", ComputeGraphFlag flag=ComputeGraphFlag::HostLaunch)  void build ()  void capture (std::function&lt; void(cudaStream_t)&gt; &amp;&amp; f)  void capture (std::string_view name, std::function&lt; void(cudaStream_t)&gt; &amp;&amp; f)  AddNodeProxy create_node (std::string_view node_name)  void graphviz (std::ostream &amp; o, const ComputeGraphGraphvizOptions &amp; options={})  void launch (bool single_stream, cudaStream_t s=nullptr)  void launch (cudaStream_t s=nullptr)  std::string_view name () const operator GraphViewer ()  ComputeGraph &amp; operator= (const ComputeGraph &amp;) = delete ComputeGraph &amp; operator= (ComputeGraph &amp;&amp;) = delete Event::QueryResult query () const void update ()  GraphViewer viewer ()  ~ComputeGraph ()"},{"location":"muda/classmuda_1_1_compute_graph/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph/#typedef-dependency","title":"typedef Dependency","text":"<pre><code>using muda::ComputeGraph::Dependency =  ComputeGraphDependency;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph/#function-computegraph-13","title":"function ComputeGraph [1/3]","text":"<pre><code>muda::ComputeGraph::ComputeGraph (\n    const ComputeGraph &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-computegraph-23","title":"function ComputeGraph [2/3]","text":"<pre><code>muda::ComputeGraph::ComputeGraph (\n    ComputeGraph &amp;&amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-computegraph-33","title":"function ComputeGraph [3/3]","text":"<pre><code>muda::ComputeGraph::ComputeGraph (\n    ComputeGraphVarManager &amp; manager,\n    std::string_view name=\"graph\",\n    ComputeGraphFlag flag=ComputeGraphFlag::HostLaunch\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-build","title":"function build","text":"<pre><code>void muda::ComputeGraph::build () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-capture-12","title":"function capture [1/2]","text":"<pre><code>void muda::ComputeGraph::capture (\n    std::function&lt; void(cudaStream_t)&gt; &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-capture-22","title":"function capture [2/2]","text":"<pre><code>void muda::ComputeGraph::capture (\n    std::string_view name,\n    std::function&lt; void(cudaStream_t)&gt; &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-create_node","title":"function create_node","text":"<pre><code>AddNodeProxy muda::ComputeGraph::create_node (\n    std::string_view node_name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-graphviz","title":"function graphviz","text":"<pre><code>void muda::ComputeGraph::graphviz (\n    std::ostream &amp; o,\n    const ComputeGraphGraphvizOptions &amp; options={}\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-launch-12","title":"function launch [1/2]","text":"<pre><code>void muda::ComputeGraph::launch (\n    bool single_stream,\n    cudaStream_t s=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-launch-22","title":"function launch [2/2]","text":"<pre><code>inline void muda::ComputeGraph::launch (\n    cudaStream_t s=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-name","title":"function name","text":"<pre><code>inline std::string_view muda::ComputeGraph::name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-operator-graphviewer","title":"function operator GraphViewer","text":"<pre><code>inline muda::ComputeGraph::operator GraphViewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-operator","title":"function operator=","text":"<pre><code>ComputeGraph &amp; muda::ComputeGraph::operator= (\n    const ComputeGraph &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-operator_1","title":"function operator=","text":"<pre><code>ComputeGraph &amp; muda::ComputeGraph::operator= (\n    ComputeGraph &amp;&amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-query","title":"function query","text":"<pre><code>Event::QueryResult muda::ComputeGraph::query () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-update","title":"function update","text":"<pre><code>void muda::ComputeGraph::update () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-viewer","title":"function viewer","text":"<pre><code>GraphViewer muda::ComputeGraph::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#function-computegraph","title":"function ~ComputeGraph","text":"<pre><code>muda::ComputeGraph::~ComputeGraph () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph/#friend-computegraphaccessor","title":"friend ComputeGraphAccessor","text":"<pre><code>class muda::ComputeGraph::ComputeGraphAccessor (\n    muda::details::ComputeGraphAccessor\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_1_1_add_node_proxy/","title":"Class muda::ComputeGraph::AddNodeProxy","text":"<p>ClassList &gt; muda &gt; ComputeGraph &gt; AddNodeProxy</p>"},{"location":"muda/classmuda_1_1_compute_graph_1_1_add_node_proxy/#public-functions","title":"Public Functions","text":"Type Name AddNodeProxy (ComputeGraph &amp; cg, std::string_view node_name)  ComputeGraph &amp; operator&lt;&lt; (std::function&lt; void()&gt; &amp;&amp; f)"},{"location":"muda/classmuda_1_1_compute_graph_1_1_add_node_proxy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_1_1_add_node_proxy/#function-addnodeproxy","title":"function AddNodeProxy","text":"<pre><code>muda::ComputeGraph::AddNodeProxy::AddNodeProxy (\n    ComputeGraph &amp; cg,\n    std::string_view node_name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_1_1_add_node_proxy/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>ComputeGraph &amp; muda::ComputeGraph::AddNodeProxy::operator&lt;&lt; (\n    std::function&lt; void()&gt; &amp;&amp; f\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_1_1_graph_phase_guard/","title":"Class muda::ComputeGraph::GraphPhaseGuard","text":"<p>ClassList &gt; muda &gt; ComputeGraph &gt; GraphPhaseGuard</p>"},{"location":"muda/classmuda_1_1_compute_graph_1_1_graph_phase_guard/#public-functions","title":"Public Functions","text":"Type Name GraphPhaseGuard (ComputeGraph &amp; cg, ComputeGraphPhase phase)  ~GraphPhaseGuard ()"},{"location":"muda/classmuda_1_1_compute_graph_1_1_graph_phase_guard/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_1_1_graph_phase_guard/#function-graphphaseguard","title":"function GraphPhaseGuard","text":"<pre><code>muda::ComputeGraph::GraphPhaseGuard::GraphPhaseGuard (\n    ComputeGraph &amp; cg,\n    ComputeGraphPhase phase\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_1_1_graph_phase_guard/#function-graphphaseguard_1","title":"function ~GraphPhaseGuard","text":"<pre><code>muda::ComputeGraph::GraphPhaseGuard::~GraphPhaseGuard () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_builder/","title":"Class muda::ComputeGraphBuilder","text":"<p>ClassList &gt; muda &gt; ComputeGraphBuilder</p>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#public-static-functions","title":"Public Static Functions","text":"Type Name void capture (CaptureAction &amp;&amp; cap)  void capture (std::string_view name, CaptureAction &amp;&amp; cap)  Phase current_phase ()  void invoke_phase_actions (PhaseAction &amp;&amp; do_when_direct_launch, PhaseAction &amp;&amp; do_when_set_node, PhaseAction &amp;&amp; do_when_topo_building_set_node)  void invoke_phase_actions (PhaseAction &amp;&amp; do_when_direct_launch, PhaseAction &amp;&amp; do_when_set_node)  void invoke_phase_actions (PhaseAction &amp;&amp; do_in_every_phase)  bool is_building ()  bool is_caturing ()  bool is_direct_launching ()  bool is_phase_none ()  bool is_phase_serial_launching ()  bool is_topo_building ()"},{"location":"muda/classmuda_1_1_compute_graph_builder/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-capture-12","title":"function capture [1/2]","text":"<pre><code>static void muda::ComputeGraphBuilder::capture (\n    CaptureAction &amp;&amp; cap\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-capture-22","title":"function capture [2/2]","text":"<pre><code>static void muda::ComputeGraphBuilder::capture (\n    std::string_view name,\n    CaptureAction &amp;&amp; cap\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-current_phase","title":"function current_phase","text":"<pre><code>static Phase muda::ComputeGraphBuilder::current_phase () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-invoke_phase_actions-13","title":"function invoke_phase_actions [1/3]","text":"<pre><code>static void muda::ComputeGraphBuilder::invoke_phase_actions (\n    PhaseAction &amp;&amp; do_when_direct_launch,\n    PhaseAction &amp;&amp; do_when_set_node,\n    PhaseAction &amp;&amp; do_when_topo_building_set_node\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-invoke_phase_actions-23","title":"function invoke_phase_actions [2/3]","text":"<pre><code>static void muda::ComputeGraphBuilder::invoke_phase_actions (\n    PhaseAction &amp;&amp; do_when_direct_launch,\n    PhaseAction &amp;&amp; do_when_set_node\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-invoke_phase_actions-33","title":"function invoke_phase_actions [3/3]","text":"<pre><code>static void muda::ComputeGraphBuilder::invoke_phase_actions (\n    PhaseAction &amp;&amp; do_in_every_phase\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-is_building","title":"function is_building","text":"<pre><code>static bool muda::ComputeGraphBuilder::is_building () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-is_caturing","title":"function is_caturing","text":"<pre><code>static bool muda::ComputeGraphBuilder::is_caturing () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-is_direct_launching","title":"function is_direct_launching","text":"<pre><code>static bool muda::ComputeGraphBuilder::is_direct_launching () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-is_phase_none","title":"function is_phase_none","text":"<pre><code>static bool muda::ComputeGraphBuilder::is_phase_none () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-is_phase_serial_launching","title":"function is_phase_serial_launching","text":"<pre><code>static bool muda::ComputeGraphBuilder::is_phase_serial_launching () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#function-is_topo_building","title":"function is_topo_building","text":"<pre><code>static bool muda::ComputeGraphBuilder::is_topo_building () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_builder/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_builder/#friend-computegraphaccessor","title":"friend ComputeGraphAccessor","text":"<pre><code>class muda::ComputeGraphBuilder::ComputeGraphAccessor (\n    details::ComputeGraphAccessor\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_builder.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/","title":"Class muda::ComputeGraphCaptureNode","text":"<p>ClassList &gt; muda &gt; ComputeGraphCaptureNode</p> <p>Inherits the following classes: muda::ComputeGraphNodeBase</p>"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#public-functions-inherited-from-mudacomputegraphnodebase","title":"Public Functions inherited from muda::ComputeGraphNodeBase","text":"<p>See muda::ComputeGraphNodeBase</p> Type Name auto access_index () const auto name () const auto node_id () const auto type () const virtual ~ComputeGraphNodeBase () = default"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#protected-types-inherited-from-mudacomputegraphnodebase","title":"Protected Types inherited from muda::ComputeGraphNodeBase","text":"<p>See muda::ComputeGraphNodeBase</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#protected-attributes","title":"Protected Attributes","text":"Type Name cudaGraph_t m_sub_graph   = = nullptr"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#protected-attributes-inherited-from-mudacomputegraphnodebase","title":"Protected Attributes inherited from muda::ComputeGraphNodeBase","text":"<p>See muda::ComputeGraphNodeBase</p> Type Name uint64_t m_access_index cudaGraphNode_t m_cuda_node   = = nullptr std::string m_name NodeId m_node_id ComputeGraphNodeType m_type"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#protected-functions","title":"Protected Functions","text":"Type Name ComputeGraphCaptureNode (NodeId node_id, uint64_t access_index)  void set_node (cudaGraphNode_t node)  void update_sub_graph (cudaGraph_t sub_graph)  virtual ~ComputeGraphCaptureNode () override"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#protected-functions-inherited-from-mudacomputegraphnodebase","title":"Protected Functions inherited from muda::ComputeGraphNodeBase","text":"<p>See muda::ComputeGraphNodeBase</p> Type Name ComputeGraphNodeBase (std::string_view name, NodeId node_id, uint64_t access_index, ComputeGraphNodeType type)  auto handle () const auto is_valid () const void set_handle (cudaGraphNode_t handle)"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#variable-m_sub_graph","title":"variable m_sub_graph","text":"<pre><code>cudaGraph_t muda::ComputeGraphCaptureNode::m_sub_graph;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#function-computegraphcapturenode","title":"function ComputeGraphCaptureNode","text":"<pre><code>inline muda::ComputeGraphCaptureNode::ComputeGraphCaptureNode (\n    NodeId node_id,\n    uint64_t access_index\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#function-set_node","title":"function set_node","text":"<pre><code>inline void muda::ComputeGraphCaptureNode::set_node (\n    cudaGraphNode_t node\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#function-update_sub_graph","title":"function update_sub_graph","text":"<pre><code>inline void muda::ComputeGraphCaptureNode::update_sub_graph (\n    cudaGraph_t sub_graph\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#function-computegraphcapturenode_1","title":"function ~ComputeGraphCaptureNode","text":"<pre><code>inline virtual muda::ComputeGraphCaptureNode::~ComputeGraphCaptureNode () override\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_capture_node/#friend-computegraphaccessor","title":"friend ComputeGraphAccessor","text":"<pre><code>class muda::ComputeGraphCaptureNode::ComputeGraphAccessor (\n    details::ComputeGraphAccessor\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/nodes/compute_graph_catpure_node.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_closure/","title":"Class muda::ComputeGraphClosure","text":"<p>ClassList &gt; muda &gt; ComputeGraphClosure</p>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#public-functions","title":"Public Functions","text":"Type Name auto clousure_id () const span&lt; const ComputeGraphDependency &gt; deps () const virtual void graphviz_def (std::ostream &amp; o, const ComputeGraphGraphvizOptions &amp; options) const virtual void graphviz_id (std::ostream &amp; o, const ComputeGraphGraphvizOptions &amp; options) const virtual void graphviz_var_usages (std::ostream &amp; o, const ComputeGraphGraphvizOptions &amp; options) const auto name () const auto type () const const auto &amp; var_usages () const virtual ~ComputeGraphClosure () = default"},{"location":"muda/classmuda_1_1_compute_graph_closure/#protected-types","title":"Protected Types","text":"Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_compute_graph_closure/#protected-attributes","title":"Protected Attributes","text":"Type Name uint64_t m_access_graph_index std::function&lt; void()&gt; m_closure ClosureId m_clousure_id size_t m_deps_begin   = = 0 size_t m_deps_count   = = 0 ComputeGraph * m_graph std::vector&lt; ComputeGraphNodeBase * &gt; m_graph_nodes std::string m_name ComputeGraphNodeType m_type std::map&lt; VarId, ComputeGraphVarUsage &gt; m_var_usages"},{"location":"muda/classmuda_1_1_compute_graph_closure/#protected-functions","title":"Protected Functions","text":"Type Name ComputeGraphClosure (ComputeGraph * graph, ClosureId clousure_id, std::string_view name, const std::function&lt; void()&gt; f)  void operator() ()  void set_deps_range (size_t begin, size_t count)"},{"location":"muda/classmuda_1_1_compute_graph_closure/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-clousure_id","title":"function clousure_id","text":"<pre><code>inline auto muda::ComputeGraphClosure::clousure_id () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-deps","title":"function deps","text":"<pre><code>span&lt; const ComputeGraphDependency &gt; muda::ComputeGraphClosure::deps () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-graphviz_def","title":"function graphviz_def","text":"<pre><code>virtual void muda::ComputeGraphClosure::graphviz_def (\n    std::ostream &amp; o,\n    const ComputeGraphGraphvizOptions &amp; options\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-graphviz_id","title":"function graphviz_id","text":"<pre><code>virtual void muda::ComputeGraphClosure::graphviz_id (\n    std::ostream &amp; o,\n    const ComputeGraphGraphvizOptions &amp; options\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-graphviz_var_usages","title":"function graphviz_var_usages","text":"<pre><code>virtual void muda::ComputeGraphClosure::graphviz_var_usages (\n    std::ostream &amp; o,\n    const ComputeGraphGraphvizOptions &amp; options\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-name","title":"function name","text":"<pre><code>inline auto muda::ComputeGraphClosure::name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-type","title":"function type","text":"<pre><code>inline auto muda::ComputeGraphClosure::type () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-var_usages","title":"function var_usages","text":"<pre><code>inline const auto &amp; muda::ComputeGraphClosure::var_usages () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-computegraphclosure","title":"function ~ComputeGraphClosure","text":"<pre><code>virtual muda::ComputeGraphClosure::~ComputeGraphClosure () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_closure/#typedef-s","title":"typedef S","text":"<pre><code>using muda::ComputeGraphClosure::S =  std::shared_ptr&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_access_graph_index","title":"variable m_access_graph_index","text":"<pre><code>uint64_t muda::ComputeGraphClosure::m_access_graph_index;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_closure","title":"variable m_closure","text":"<pre><code>std::function&lt;void()&gt; muda::ComputeGraphClosure::m_closure;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_clousure_id","title":"variable m_clousure_id","text":"<pre><code>ClosureId muda::ComputeGraphClosure::m_clousure_id;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_deps_begin","title":"variable m_deps_begin","text":"<pre><code>size_t muda::ComputeGraphClosure::m_deps_begin;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_deps_count","title":"variable m_deps_count","text":"<pre><code>size_t muda::ComputeGraphClosure::m_deps_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_graph","title":"variable m_graph","text":"<pre><code>ComputeGraph* muda::ComputeGraphClosure::m_graph;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_graph_nodes","title":"variable m_graph_nodes","text":"<pre><code>std::vector&lt;ComputeGraphNodeBase*&gt; muda::ComputeGraphClosure::m_graph_nodes;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_name","title":"variable m_name","text":"<pre><code>std::string muda::ComputeGraphClosure::m_name;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_type","title":"variable m_type","text":"<pre><code>ComputeGraphNodeType muda::ComputeGraphClosure::m_type;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#variable-m_var_usages","title":"variable m_var_usages","text":"<pre><code>std::map&lt;VarId, ComputeGraphVarUsage&gt; muda::ComputeGraphClosure::m_var_usages;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-computegraphclosure_1","title":"function ComputeGraphClosure","text":"<pre><code>inline muda::ComputeGraphClosure::ComputeGraphClosure (\n    ComputeGraph * graph,\n    ClosureId clousure_id,\n    std::string_view name,\n    const std::function&lt; void()&gt; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-operator","title":"function operator()","text":"<pre><code>inline void muda::ComputeGraphClosure::operator() () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#function-set_deps_range","title":"function set_deps_range","text":"<pre><code>void muda::ComputeGraphClosure::set_deps_range (\n    size_t begin,\n    size_t count\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_closure/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_closure/#friend-computegraphaccessor","title":"friend ComputeGraphAccessor","text":"<pre><code>class muda::ComputeGraphClosure::ComputeGraphAccessor (\n    details::ComputeGraphAccessor\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_closure.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_dependency/","title":"Class muda::ComputeGraphDependency","text":"<p>ClassList &gt; muda &gt; ComputeGraphDependency</p>"},{"location":"muda/classmuda_1_1_compute_graph_dependency/#public-attributes","title":"Public Attributes","text":"Type Name ClosureId from ClosureId to"},{"location":"muda/classmuda_1_1_compute_graph_dependency/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_dependency/#variable-from","title":"variable from","text":"<pre><code>ClosureId muda::ComputeGraphDependency::from;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_dependency/#variable-to","title":"variable to","text":"<pre><code>ClosureId muda::ComputeGraphDependency::to;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_dependency.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/","title":"Class muda::ComputeGraphGraphvizOptions","text":"<p>ClassList &gt; muda &gt; ComputeGraphGraphvizOptions</p>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#public-attributes","title":"Public Attributes","text":"Type Name std::string all_nodes_closure_style   = = R\"(shape=\"Mrecord\", color=\"#82B366\", style=\"filled\", fillcolor=\"#D5E8D4\",)\" std::string arc_style   = = R\"(color=\"#82B366\", )\" bool as_subgraph   = = false std::string cluster_style   = = R\"(fontcolor=\"#82B366\" fontsize=18; color = \"#82B366\"; style = \"dashed\";)\" std::string cluster_var_style   = = R\"(color=\"#F08705\"; style=\"dashed\";)\" std::string event_style   = = R\"(shape=\"rectangle\", color=\"#8E44AD\", style=\"filled,rounded\", fillcolor=\"#BB8FCE\",)\" std::string graph_font   = = R\"(graph [fontname = \"helvetica\"]; node [fontname = \"helvetica\"]; edge [fontname = \"helvetica\"];)\" int graph_id   = = 0 std::string graph_viewer_style   = = R\"(shape=\"rectangle\", color=\"#82B366\", style=\"filled,rounded\", fillcolor=\"#D5E8D4\",)\" std::string node_style   = = R\"(shape=\"egg\", color=\"#82B366\", style=\"filled\", fillcolor=\"#D5E8D4\",)\" std::string read_style   = = R\"(color=\"#64BBE2\", arrowhead = dot, )\" std::string read_write_style   = = R\"(color=\"#F08E81\", arrowhead = diamond,)\" bool show_all_graph_nodes_in_a_closure   = = false bool show_nodes   = = true bool show_vars   = = true std::string var_style   = = R\"(shape=\"rectangle\", color=\"#F08705\", style=\"filled,rounded\", fillcolor=\"#F5AF58\",)\""},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-all_nodes_closure_style","title":"variable all_nodes_closure_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::all_nodes_closure_style;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-arc_style","title":"variable arc_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::arc_style;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-as_subgraph","title":"variable as_subgraph","text":"<pre><code>bool muda::ComputeGraphGraphvizOptions::as_subgraph;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-cluster_style","title":"variable cluster_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::cluster_style;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-cluster_var_style","title":"variable cluster_var_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::cluster_var_style;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-event_style","title":"variable event_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::event_style;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-graph_font","title":"variable graph_font","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::graph_font;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-graph_id","title":"variable graph_id","text":"<pre><code>int muda::ComputeGraphGraphvizOptions::graph_id;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-graph_viewer_style","title":"variable graph_viewer_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::graph_viewer_style;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-node_style","title":"variable node_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::node_style;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-read_style","title":"variable read_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::read_style;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-read_write_style","title":"variable read_write_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::read_write_style;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-show_all_graph_nodes_in_a_closure","title":"variable show_all_graph_nodes_in_a_closure","text":"<pre><code>bool muda::ComputeGraphGraphvizOptions::show_all_graph_nodes_in_a_closure;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-show_nodes","title":"variable show_nodes","text":"<pre><code>bool muda::ComputeGraphGraphvizOptions::show_nodes;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-show_vars","title":"variable show_vars","text":"<pre><code>bool muda::ComputeGraphGraphvizOptions::show_vars;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_graphviz_options/#variable-var_style","title":"variable var_style","text":"<pre><code>std::string muda::ComputeGraphGraphvizOptions::var_style;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/graphviz_options.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_node/","title":"Class muda::ComputeGraphNode","text":"<p>template &lt;typename NodeT, ComputeGraphNodeType Type&gt;</p> <p>ClassList &gt; muda &gt; ComputeGraphNode</p> <p>Inherits the following classes: muda::ComputeGraphNodeBase</p>"},{"location":"muda/classmuda_1_1_compute_graph_node/#public-functions-inherited-from-mudacomputegraphnodebase","title":"Public Functions inherited from muda::ComputeGraphNodeBase","text":"<p>See muda::ComputeGraphNodeBase</p> Type Name auto access_index () const auto name () const auto node_id () const auto type () const virtual ~ComputeGraphNodeBase () = default"},{"location":"muda/classmuda_1_1_compute_graph_node/#protected-types-inherited-from-mudacomputegraphnodebase","title":"Protected Types inherited from muda::ComputeGraphNodeBase","text":"<p>See muda::ComputeGraphNodeBase</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_compute_graph_node/#protected-attributes","title":"Protected Attributes","text":"Type Name S&lt; NodeT &gt; m_node"},{"location":"muda/classmuda_1_1_compute_graph_node/#protected-attributes-inherited-from-mudacomputegraphnodebase","title":"Protected Attributes inherited from muda::ComputeGraphNodeBase","text":"<p>See muda::ComputeGraphNodeBase</p> Type Name uint64_t m_access_index cudaGraphNode_t m_cuda_node   = = nullptr std::string m_name NodeId m_node_id ComputeGraphNodeType m_type"},{"location":"muda/classmuda_1_1_compute_graph_node/#protected-functions","title":"Protected Functions","text":"Type Name ComputeGraphNode (NodeId node_id, uint64_t access_graph_index)  void set_node (S&lt; NodeT &gt; node)  virtual ~ComputeGraphNode () = default"},{"location":"muda/classmuda_1_1_compute_graph_node/#protected-functions-inherited-from-mudacomputegraphnodebase","title":"Protected Functions inherited from muda::ComputeGraphNodeBase","text":"<p>See muda::ComputeGraphNodeBase</p> Type Name ComputeGraphNodeBase (std::string_view name, NodeId node_id, uint64_t access_index, ComputeGraphNodeType type)  auto handle () const auto is_valid () const void set_handle (cudaGraphNode_t handle)"},{"location":"muda/classmuda_1_1_compute_graph_node/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_node/#variable-m_node","title":"variable m_node","text":"<pre><code>S&lt;NodeT&gt; muda::ComputeGraphNode&lt; NodeT, Type &gt;::m_node;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_node/#function-computegraphnode","title":"function ComputeGraphNode","text":"<pre><code>muda::ComputeGraphNode::ComputeGraphNode (\n    NodeId node_id,\n    uint64_t access_graph_index\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node/#function-set_node","title":"function set_node","text":"<pre><code>void muda::ComputeGraphNode::set_node (\n    S&lt; NodeT &gt; node\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node/#function-computegraphnode_1","title":"function ~ComputeGraphNode","text":"<pre><code>virtual muda::ComputeGraphNode::~ComputeGraphNode () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_node/#friend-computegraphaccessor","title":"friend ComputeGraphAccessor","text":"<pre><code>class muda::ComputeGraphNode::ComputeGraphAccessor (\n    details::ComputeGraphAccessor\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_node.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/","title":"Class muda::ComputeGraphNodeBase","text":"<p>ClassList &gt; muda &gt; ComputeGraphNodeBase</p> <p>Inherited by the following classes: muda::ComputeGraphNode,  muda::ComputeGraphNode,  muda::ComputeGraphNode,  muda::ComputeGraphNode,  muda::ComputeGraphNode,  muda::ComputeGraphCaptureNode,  muda::ComputeGraphNode</p>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#public-functions","title":"Public Functions","text":"Type Name auto access_index () const auto name () const auto node_id () const auto type () const virtual ~ComputeGraphNodeBase () = default"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#protected-types","title":"Protected Types","text":"Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#protected-attributes","title":"Protected Attributes","text":"Type Name uint64_t m_access_index cudaGraphNode_t m_cuda_node   = = nullptr std::string m_name NodeId m_node_id ComputeGraphNodeType m_type"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#protected-functions","title":"Protected Functions","text":"Type Name ComputeGraphNodeBase (std::string_view name, NodeId node_id, uint64_t access_index, ComputeGraphNodeType type)  auto handle () const auto is_valid () const void set_handle (cudaGraphNode_t handle)"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_node_base/#function-access_index","title":"function access_index","text":"<pre><code>inline auto muda::ComputeGraphNodeBase::access_index () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#function-name","title":"function name","text":"<pre><code>inline auto muda::ComputeGraphNodeBase::name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#function-node_id","title":"function node_id","text":"<pre><code>inline auto muda::ComputeGraphNodeBase::node_id () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#function-type","title":"function type","text":"<pre><code>inline auto muda::ComputeGraphNodeBase::type () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#function-computegraphnodebase","title":"function ~ComputeGraphNodeBase","text":"<pre><code>virtual muda::ComputeGraphNodeBase::~ComputeGraphNodeBase () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_node_base/#typedef-s","title":"typedef S","text":"<pre><code>using muda::ComputeGraphNodeBase::S =  std::shared_ptr&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_node_base/#variable-m_access_index","title":"variable m_access_index","text":"<pre><code>uint64_t muda::ComputeGraphNodeBase::m_access_index;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#variable-m_cuda_node","title":"variable m_cuda_node","text":"<pre><code>cudaGraphNode_t muda::ComputeGraphNodeBase::m_cuda_node;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#variable-m_name","title":"variable m_name","text":"<pre><code>std::string muda::ComputeGraphNodeBase::m_name;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#variable-m_node_id","title":"variable m_node_id","text":"<pre><code>NodeId muda::ComputeGraphNodeBase::m_node_id;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#variable-m_type","title":"variable m_type","text":"<pre><code>ComputeGraphNodeType muda::ComputeGraphNodeBase::m_type;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_node_base/#function-computegraphnodebase_1","title":"function ComputeGraphNodeBase","text":"<pre><code>inline muda::ComputeGraphNodeBase::ComputeGraphNodeBase (\n    std::string_view name,\n    NodeId node_id,\n    uint64_t access_index,\n    ComputeGraphNodeType type\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#function-handle","title":"function handle","text":"<pre><code>inline auto muda::ComputeGraphNodeBase::handle () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#function-is_valid","title":"function is_valid","text":"<pre><code>inline auto muda::ComputeGraphNodeBase::is_valid () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_node_base/#function-set_handle","title":"function set_handle","text":"<pre><code>inline void muda::ComputeGraphNodeBase::set_handle (\n    cudaGraphNode_t handle\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_node.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_var/","title":"Class muda::ComputeGraphVar","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; ComputeGraphVar</p> <p>Inherits the following classes: muda::ComputeGraphVarBase</p>"},{"location":"muda/classmuda_1_1_compute_graph_var/#public-types","title":"Public Types","text":"Type Name typedef read_only_view_t&lt; T &gt; ROViewer typedef T RWViewer"},{"location":"muda/classmuda_1_1_compute_graph_var/#public-functions","title":"Public Functions","text":"Type Name ROViewer ceval () const RWViewer eval ()  virtual void graphviz_def (std::ostream &amp; os, const ComputeGraphGraphvizOptions &amp; options) override const operator ROViewer () const operator RWViewer ()  ComputeGraphVar&lt; T &gt; &amp; operator= (const RWViewer &amp; view)  void update (const RWViewer &amp; view)"},{"location":"muda/classmuda_1_1_compute_graph_var/#public-functions-inherited-from-mudacomputegraphvarbase","title":"Public Functions inherited from muda::ComputeGraphVarBase","text":"<p>See muda::ComputeGraphVarBase</p> Type Name virtual void graphviz_def (std::ostream &amp; os, const ComputeGraphGraphvizOptions &amp; options) const virtual void graphviz_id (std::ostream &amp; os, const ComputeGraphGraphvizOptions &amp; options) const bool is_using ()  bool is_valid () const std::string_view name () const Event::QueryResult query ()  void sync ()  void update ()  VarId var_id () const"},{"location":"muda/classmuda_1_1_compute_graph_var/#protected-attributes-inherited-from-mudacomputegraphvarbase","title":"Protected Attributes inherited from muda::ComputeGraphVarBase","text":"<p>See muda::ComputeGraphVarBase</p> Type Name std::set&lt; ClosureId &gt; m_closure_ids"},{"location":"muda/classmuda_1_1_compute_graph_var/#protected-functions","title":"Protected Functions","text":"Type Name ComputeGraphVar (ComputeGraphVarManager * var_manager, std::string_view name, VarId var_id)  ComputeGraphVar (ComputeGraphVarManager * var_manager, std::string_view name, VarId var_id, const T &amp; init_value)  ComputeGraphVarBase (ComputeGraphVarManager * var_manager, std::string_view name, VarId var_id)  ComputeGraphVarBase (ComputeGraphVarManager * var_manager, std::string_view name, VarId var_id, bool is_valid)  virtual ~ComputeGraphVar () = default"},{"location":"muda/classmuda_1_1_compute_graph_var/#protected-functions-inherited-from-mudacomputegraphvarbase","title":"Protected Functions inherited from muda::ComputeGraphVarBase","text":"<p>See muda::ComputeGraphVarBase</p> Type Name ComputeGraphVarBase (ComputeGraphVarManager * var_manager, std::string_view name, VarId var_id)  ComputeGraphVarBase (ComputeGraphVarManager * var_manager, std::string_view name, VarId var_id, bool is_valid)  ROView _ceval (ROView &amp; view) const RWView _eval (const RWView &amp; view)  void base_update ()  virtual ~ComputeGraphVarBase () = default"},{"location":"muda/classmuda_1_1_compute_graph_var/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_var/#typedef-roviewer","title":"typedef ROViewer","text":"<pre><code>using muda::ComputeGraphVar&lt; T &gt;::ROViewer =  read_only_view_t&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#typedef-rwviewer","title":"typedef RWViewer","text":"<pre><code>using muda::ComputeGraphVar&lt; T &gt;::RWViewer =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_var/#function-ceval","title":"function ceval","text":"<pre><code>inline ROViewer muda::ComputeGraphVar::ceval () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-eval","title":"function eval","text":"<pre><code>inline RWViewer muda::ComputeGraphVar::eval () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-graphviz_def","title":"function graphviz_def","text":"<pre><code>virtual void muda::ComputeGraphVar::graphviz_def (\n    std::ostream &amp; os,\n    const ComputeGraphGraphvizOptions &amp; options\n) override const\n</code></pre> <p>Implements muda::ComputeGraphVarBase::graphviz_def</p>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-operator-roviewer","title":"function operator ROViewer","text":"<pre><code>inline muda::ComputeGraphVar::operator ROViewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-operator-rwviewer","title":"function operator RWViewer","text":"<pre><code>inline muda::ComputeGraphVar::operator RWViewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-operator","title":"function operator=","text":"<pre><code>ComputeGraphVar &lt; T &gt; &amp; muda::ComputeGraphVar::operator= (\n    const RWViewer &amp; view\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-update","title":"function update","text":"<pre><code>void muda::ComputeGraphVar::update (\n    const RWViewer &amp; view\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_var/#function-computegraphvar-12","title":"function ComputeGraphVar [1/2]","text":"<pre><code>inline muda::ComputeGraphVar::ComputeGraphVar (\n    ComputeGraphVarManager * var_manager,\n    std::string_view name,\n    VarId var_id\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-computegraphvar-22","title":"function ComputeGraphVar [2/2]","text":"<pre><code>inline muda::ComputeGraphVar::ComputeGraphVar (\n    ComputeGraphVarManager * var_manager,\n    std::string_view name,\n    VarId var_id,\n    const T &amp; init_value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-computegraphvarbase-12","title":"function ComputeGraphVarBase [1/2]","text":"<pre><code>inline muda::ComputeGraphVar::ComputeGraphVarBase (\n    ComputeGraphVarManager * var_manager,\n    std::string_view name,\n    VarId var_id\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-computegraphvarbase-22","title":"function ComputeGraphVarBase [2/2]","text":"<pre><code>inline muda::ComputeGraphVar::ComputeGraphVarBase (\n    ComputeGraphVarManager * var_manager,\n    std::string_view name,\n    VarId var_id,\n    bool is_valid\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var/#function-computegraphvar","title":"function ~ComputeGraphVar","text":"<pre><code>virtual muda::ComputeGraphVar::~ComputeGraphVar () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_launch.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/","title":"Class muda::ComputeGraphVarBase","text":"<p>ClassList &gt; muda &gt; ComputeGraphVarBase</p> <p>Inherited by the following classes: muda::ComputeGraphVar,  muda::ComputeGraphVar,  muda::ComputeGraphVar,  muda::ComputeGraphVar,  muda::ComputeGraphVar,  muda::ComputeGraphVar,  muda::ComputeGraphVar,  muda::ComputeGraphVar,  muda::ComputeGraphVar,  muda::ComputeGraphVar,  muda::ComputeGraphVar</p>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#public-functions","title":"Public Functions","text":"Type Name virtual void graphviz_def (std::ostream &amp; os, const ComputeGraphGraphvizOptions &amp; options) const virtual void graphviz_id (std::ostream &amp; os, const ComputeGraphGraphvizOptions &amp; options) const bool is_using ()  bool is_valid () const std::string_view name () const Event::QueryResult query ()  void sync ()  void update ()  VarId var_id () const"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#protected-attributes","title":"Protected Attributes","text":"Type Name std::set&lt; ClosureId &gt; m_closure_ids"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#protected-functions","title":"Protected Functions","text":"Type Name ComputeGraphVarBase (ComputeGraphVarManager * var_manager, std::string_view name, VarId var_id)  ComputeGraphVarBase (ComputeGraphVarManager * var_manager, std::string_view name, VarId var_id, bool is_valid)  ROView _ceval (ROView &amp; view) const RWView _eval (const RWView &amp; view)  void base_update ()  virtual ~ComputeGraphVarBase () = default"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-graphviz_def","title":"function graphviz_def","text":"<pre><code>virtual void muda::ComputeGraphVarBase::graphviz_def (\n    std::ostream &amp; os,\n    const ComputeGraphGraphvizOptions &amp; options\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-graphviz_id","title":"function graphviz_id","text":"<pre><code>virtual void muda::ComputeGraphVarBase::graphviz_id (\n    std::ostream &amp; os,\n    const ComputeGraphGraphvizOptions &amp; options\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-is_using","title":"function is_using","text":"<pre><code>bool muda::ComputeGraphVarBase::is_using () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-is_valid","title":"function is_valid","text":"<pre><code>inline bool muda::ComputeGraphVarBase::is_valid () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-name","title":"function name","text":"<pre><code>inline std::string_view muda::ComputeGraphVarBase::name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-query","title":"function query","text":"<pre><code>Event::QueryResult muda::ComputeGraphVarBase::query () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-sync","title":"function sync","text":"<pre><code>void muda::ComputeGraphVarBase::sync () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-update","title":"function update","text":"<pre><code>void muda::ComputeGraphVarBase::update () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-var_id","title":"function var_id","text":"<pre><code>inline VarId muda::ComputeGraphVarBase::var_id () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_var_base/#variable-m_closure_ids","title":"variable m_closure_ids","text":"<pre><code>std::set&lt;ClosureId&gt; muda::ComputeGraphVarBase::m_closure_ids;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-computegraphvarbase-12","title":"function ComputeGraphVarBase [1/2]","text":"<pre><code>inline muda::ComputeGraphVarBase::ComputeGraphVarBase (\n    ComputeGraphVarManager * var_manager,\n    std::string_view name,\n    VarId var_id\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-computegraphvarbase-22","title":"function ComputeGraphVarBase [2/2]","text":"<pre><code>inline muda::ComputeGraphVarBase::ComputeGraphVarBase (\n    ComputeGraphVarManager * var_manager,\n    std::string_view name,\n    VarId var_id,\n    bool is_valid\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-_ceval","title":"function _ceval","text":"<pre><code>template&lt;typename ROView&gt;\nROView muda::ComputeGraphVarBase::_ceval (\n    ROView &amp; view\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-_eval","title":"function _eval","text":"<pre><code>template&lt;typename RWView&gt;\nRWView muda::ComputeGraphVarBase::_eval (\n    const RWView &amp; view\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-base_update","title":"function base_update","text":"<pre><code>void muda::ComputeGraphVarBase::base_update () \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base/#function-computegraphvarbase","title":"function ~ComputeGraphVarBase","text":"<pre><code>virtual muda::ComputeGraphVarBase::~ComputeGraphVarBase () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_var.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/","title":"Class muda::ComputeGraphVarManager","text":"<p>ClassList &gt; muda &gt; ComputeGraphVarManager</p>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#public-functions","title":"Public Functions","text":"Type Name ComputeGraphVarManager () = default S&lt; ComputeGraph &gt; create_graph (std::string_view name=\"graph\", ComputeGraphFlag flags={})  ComputeGraphVar&lt; T &gt; &amp; create_var (std::string_view name)  ComputeGraphVar&lt; T &gt; &amp; create_var (std::string_view name, const T &amp; init_value)  ComputeGraphVar&lt; T &gt; * find_var (std::string_view name)  const auto &amp; graphs () const void graphviz (std::ostream &amp; os, const ComputeGraphGraphvizOptions &amp; options={}) const bool is_using () const bool is_using (const ComputeGraphVar&lt; T &gt; &amp;... vars) const bool is_using (const span&lt; const ComputeGraphVarBase * &gt; vars) const void sync () const void sync (const ComputeGraphVar&lt; T &gt; &amp;... vars) const void sync (const span&lt; const ComputeGraphVarBase * &gt; vars) const void sync_on (cudaStream_t stream) const void sync_on (cudaStream_t stream, const ComputeGraphVar&lt; T &gt; &amp;... vars) const void sync_on (cudaStream_t stream, const span&lt; const ComputeGraphVarBase * &gt; vars) const ~ComputeGraphVarManager ()"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-computegraphvarmanager","title":"function ComputeGraphVarManager","text":"<pre><code>muda::ComputeGraphVarManager::ComputeGraphVarManager () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-create_graph","title":"function create_graph","text":"<pre><code>S&lt; ComputeGraph &gt; muda::ComputeGraphVarManager::create_graph (\n    std::string_view name=\"graph\",\n    ComputeGraphFlag flags={}\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-create_var-12","title":"function create_var [1/2]","text":"<pre><code>template&lt;typename T&gt;\nComputeGraphVar &lt; T &gt; &amp; muda::ComputeGraphVarManager::create_var (\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-create_var-22","title":"function create_var [2/2]","text":"<pre><code>template&lt;typename T&gt;\nComputeGraphVar &lt; T &gt; &amp; muda::ComputeGraphVarManager::create_var (\n    std::string_view name,\n    const T &amp; init_value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-find_var","title":"function find_var","text":"<pre><code>template&lt;typename T&gt;\nComputeGraphVar &lt; T &gt; * muda::ComputeGraphVarManager::find_var (\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-graphs","title":"function graphs","text":"<pre><code>inline const auto &amp; muda::ComputeGraphVarManager::graphs () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-graphviz","title":"function graphviz","text":"<pre><code>void muda::ComputeGraphVarManager::graphviz (\n    std::ostream &amp; os,\n    const ComputeGraphGraphvizOptions &amp; options={}\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-is_using-13","title":"function is_using [1/3]","text":"<pre><code>bool muda::ComputeGraphVarManager::is_using () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-is_using-23","title":"function is_using [2/3]","text":"<pre><code>template&lt;typename... T&gt;\nbool muda::ComputeGraphVarManager::is_using (\n    const ComputeGraphVar &lt; T &gt; &amp;... vars\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-is_using-33","title":"function is_using [3/3]","text":"<pre><code>bool muda::ComputeGraphVarManager::is_using (\n    const span&lt; const ComputeGraphVarBase * &gt; vars\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-sync-13","title":"function sync [1/3]","text":"<pre><code>void muda::ComputeGraphVarManager::sync () const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-sync-23","title":"function sync [2/3]","text":"<pre><code>template&lt;typename... T&gt;\nvoid muda::ComputeGraphVarManager::sync (\n    const ComputeGraphVar &lt; T &gt; &amp;... vars\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-sync-33","title":"function sync [3/3]","text":"<pre><code>void muda::ComputeGraphVarManager::sync (\n    const span&lt; const ComputeGraphVarBase * &gt; vars\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-sync_on-13","title":"function sync_on [1/3]","text":"<pre><code>void muda::ComputeGraphVarManager::sync_on (\n    cudaStream_t stream\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-sync_on-23","title":"function sync_on [2/3]","text":"<pre><code>template&lt;typename... T&gt;\nvoid muda::ComputeGraphVarManager::sync_on (\n    cudaStream_t stream,\n    const ComputeGraphVar &lt; T &gt; &amp;... vars\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-sync_on-33","title":"function sync_on [3/3]","text":"<pre><code>void muda::ComputeGraphVarManager::sync_on (\n    cudaStream_t stream,\n    const span&lt; const ComputeGraphVarBase * &gt; vars\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_manager/#function-computegraphvarmanager_1","title":"function ~ComputeGraphVarManager","text":"<pre><code>muda::ComputeGraphVarManager::~ComputeGraphVarManager () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_var_manager.h</code></p>"},{"location":"muda/classmuda_1_1_cub_wrapper/","title":"Class muda::CubWrapper","text":"<p>template &lt;typename Derive&gt;</p> <p>ClassList &gt; muda &gt; CubWrapper</p> <p>Inherits the following classes: muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_cub_wrapper/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_cub_wrapper/#public-attributes","title":"Public Attributes","text":"Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_cub_wrapper/#public-functions","title":"Public Functions","text":"Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_cub_wrapper/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_cub_wrapper/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_cub_wrapper/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_cub_wrapper/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_cub_wrapper/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_cub_wrapper/#protected-functions","title":"Protected Functions","text":"Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_cub_wrapper/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_cub_wrapper/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_cub_wrapper/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_cub_wrapper/#variable-m_muda_stream","title":"variable m_muda_stream","text":"<pre><code>Stream* muda::CubWrapper&lt; Derive &gt;::m_muda_stream;\n</code></pre>"},{"location":"muda/classmuda_1_1_cub_wrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_cub_wrapper/#function-cubwrapper","title":"function CubWrapper","text":"<pre><code>inline muda::CubWrapper::CubWrapper (\n    Stream &amp; stream=Stream::Default()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_cub_wrapper/#function-kernel_name","title":"function kernel_name","text":"<pre><code>void muda::CubWrapper::kernel_name (\n    std::string_view\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_cub_wrapper/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_cub_wrapper/#function-prepare_buffer","title":"function prepare_buffer","text":"<pre><code>inline std::byte * muda::CubWrapper::prepare_buffer (\n    size_t reqSize\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/cub_wrapper.h</code></p>"},{"location":"muda/classmuda_1_1_debug/","title":"Class muda::Debug","text":"<p>ClassList &gt; muda &gt; Debug</p>"},{"location":"muda/classmuda_1_1_debug/#public-static-functions","title":"Public Static Functions","text":"Type Name void call_sync_callback ()  bool debug_sync_all (bool value)  bool is_debug_sync_all ()  void set_sync_callback (std::function&lt; void()&gt; callback)"},{"location":"muda/classmuda_1_1_debug/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_debug/#function-call_sync_callback","title":"function call_sync_callback","text":"<pre><code>static inline void muda::Debug::call_sync_callback () \n</code></pre>"},{"location":"muda/classmuda_1_1_debug/#function-debug_sync_all","title":"function debug_sync_all","text":"<pre><code>static inline bool muda::Debug::debug_sync_all (\n    bool value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_debug/#function-is_debug_sync_all","title":"function is_debug_sync_all","text":"<pre><code>static inline bool muda::Debug::is_debug_sync_all () \n</code></pre>"},{"location":"muda/classmuda_1_1_debug/#function-set_sync_callback","title":"function set_sync_callback","text":"<pre><code>static inline void muda::Debug::set_sync_callback (\n    std::function&lt; void()&gt; callback\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/debug.h</code></p>"},{"location":"muda/structmuda_1_1_default/","title":"Struct muda::Default","text":"<p>ClassList &gt; muda &gt; Default</p> <p>The documentation for this class was generated from the following file <code>src/muda/launch/kernel_tag.h</code></p>"},{"location":"muda/classmuda_1_1_dense1_d_t/","title":"Class muda::Dense1DT","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; Dense1DT</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_dense1_d_t/#public-types","title":"Public Types","text":"Type Name typedef Dense1DT&lt; true, T &gt; ConstViewer typedef Dense1DT&lt; false, T &gt; NonConstViewer typedef Dense1DT&lt; IsConst, T &gt; ThisViewer typedef T value_type"},{"location":"muda/classmuda_1_1_dense1_d_t/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_dense1_d_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Dense1DT ()  MUDA_GENERIC Dense1DT (auto_const_t&lt; T &gt; * p, int dim)  MUDA_GENERIC Dense1DT (const Dense1DT &amp; other) = default MUDA_GENERIC Dense1DT (const Dense1DT&lt; OtherIsConst, T &gt; &amp; other)  MUDA_GENERIC auto as_const () const MUDA_GENERIC auto_const_t&lt; T &gt; * data () const MUDA_GENERIC int dim () const MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator() (int x) const MUDA_GENERIC ThisViewer subview (int offset) const MUDA_GENERIC ThisViewer subview (int offset, int size) const MUDA_GENERIC int total_size () const"},{"location":"muda/classmuda_1_1_dense1_d_t/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_dense1_d_t/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_dense1_d_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data   = = nullptr int m_dim   = = 0"},{"location":"muda/classmuda_1_1_dense1_d_t/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC void check () const MUDA_GENERIC int map (int x) const"},{"location":"muda/classmuda_1_1_dense1_d_t/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_dense1_d_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense1_d_t/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::Dense1DT&lt; IsConst, T &gt;::ConstViewer =  Dense1DT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::Dense1DT&lt; IsConst, T &gt;::NonConstViewer =  Dense1DT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::Dense1DT&lt; IsConst, T &gt;::ThisViewer =  Dense1DT&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::Dense1DT&lt; IsConst, T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense1_d_t/#function-dense1dt-14","title":"function Dense1DT [1/4]","text":"<pre><code>MUDA_GENERIC muda::Dense1DT::Dense1DT () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-dense1dt-24","title":"function Dense1DT [2/4]","text":"<pre><code>inline MUDA_GENERIC muda::Dense1DT::Dense1DT (\n    auto_const_t&lt; T &gt; * p,\n    int dim\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-dense1dt-34","title":"function Dense1DT [3/4]","text":"<pre><code>MUDA_GENERIC muda::Dense1DT::Dense1DT (\n    const Dense1DT &amp; other\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-dense1dt-44","title":"function Dense1DT [4/4]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::Dense1DT::Dense1DT (\n    const Dense1DT &lt; OtherIsConst, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::Dense1DT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-data","title":"function data","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; * muda::Dense1DT::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-dim","title":"function dim","text":"<pre><code>inline MUDA_GENERIC int muda::Dense1DT::dim () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-operator","title":"function operator()","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::Dense1DT::operator() (\n    int x\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-subview-12","title":"function subview [1/2]","text":"<pre><code>inline MUDA_GENERIC ThisViewer muda::Dense1DT::subview (\n    int offset\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-subview-22","title":"function subview [2/2]","text":"<pre><code>inline MUDA_GENERIC ThisViewer muda::Dense1DT::subview (\n    int offset,\n    int size\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-total_size","title":"function total_size","text":"<pre><code>inline MUDA_GENERIC int muda::Dense1DT::total_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_dense1_d_t/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::Dense1DT&lt; IsConst, T &gt;::m_data;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#variable-m_dim","title":"variable m_dim","text":"<pre><code>int muda::Dense1DT&lt; IsConst, T &gt;::m_dim;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense1_d_t/#function-check","title":"function check","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::Dense1DT::check () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense1_d_t/#function-map","title":"function map","text":"<pre><code>inline MUDA_GENERIC int muda::Dense1DT::map (\n    int x\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense/dense_1d.h</code></p>"},{"location":"muda/classmuda_1_1_dense2_d_base/","title":"Class muda::Dense2DBase","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; Dense2DBase</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_dense2_d_base/#public-types","title":"Public Types","text":"Type Name typedef Dense2DBase&lt; true, T &gt; ConstViewer typedef Dense2DBase&lt; false, T &gt; NonConstViewer typedef Dense2DBase&lt; IsConst, T &gt; ThisViewer typedef T value_type"},{"location":"muda/classmuda_1_1_dense2_d_base/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_dense2_d_base/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Dense2DBase ()  MUDA_GENERIC Dense2DBase (auto_const_t&lt; T &gt; * p, const int2 &amp; offset, const int2 &amp; dim, int pitch_bytes)  MUDA_GENERIC auto area () const MUDA_GENERIC auto as_const () const MUDA_GENERIC auto_const_t&lt; T &gt; * data ()  MUDA_GENERIC const T * data () const MUDA_GENERIC auto dim () const MUDA_GENERIC auto_const_t&lt; T &gt; &amp; flatten (int i)  MUDA_GENERIC const T &amp; flatten (int i) const MUDA_GENERIC operator ConstViewer () const MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator() (int x, int y)  MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator() (const int2 &amp; xy)  MUDA_GENERIC const T &amp; operator() (const int2 &amp; xy) const MUDA_GENERIC const T &amp; operator() (int x, int y) const MUDA_GENERIC auto pitch_bytes () const MUDA_GENERIC auto total_size () const"},{"location":"muda/classmuda_1_1_dense2_d_base/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_dense2_d_base/#protected-types","title":"Protected Types","text":"Type Name typedef typename Base::template auto_const_t&lt; U &gt; auto_const_t"},{"location":"muda/classmuda_1_1_dense2_d_base/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_dense2_d_base/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data int2 m_dim int2 m_offset int m_pitch_bytes"},{"location":"muda/classmuda_1_1_dense2_d_base/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC void check () const MUDA_INLINE MUDA_GENERIC void check_range (int x, int y) const"},{"location":"muda/classmuda_1_1_dense2_d_base/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_dense2_d_base/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense2_d_base/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::Dense2DBase&lt; IsConst, T &gt;::ConstViewer =  Dense2DBase&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::Dense2DBase&lt; IsConst, T &gt;::NonConstViewer =  Dense2DBase&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::Dense2DBase&lt; IsConst, T &gt;::ThisViewer =  Dense2DBase&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::Dense2DBase&lt; IsConst, T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense2_d_base/#function-dense2dbase-12","title":"function Dense2DBase [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::Dense2DBase::Dense2DBase () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-dense2dbase-22","title":"function Dense2DBase [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::Dense2DBase::Dense2DBase (\n    auto_const_t&lt; T &gt; * p,\n    const int2 &amp; offset,\n    const int2 &amp; dim,\n    int pitch_bytes\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-area","title":"function area","text":"<pre><code>inline MUDA_GENERIC auto muda::Dense2DBase::area () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::Dense2DBase::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-data-12","title":"function data [1/2]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; * muda::Dense2DBase::data () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-data-22","title":"function data [2/2]","text":"<pre><code>inline MUDA_GENERIC const T * muda::Dense2DBase::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-dim","title":"function dim","text":"<pre><code>inline MUDA_GENERIC auto muda::Dense2DBase::dim () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-flatten-12","title":"function flatten [1/2]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::Dense2DBase::flatten (\n    int i\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-flatten-22","title":"function flatten [2/2]","text":"<pre><code>inline MUDA_GENERIC const T &amp; muda::Dense2DBase::flatten (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-operator-constviewer","title":"function operator ConstViewer","text":"<pre><code>inline MUDA_GENERIC muda::Dense2DBase::operator ConstViewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-operator-14","title":"function operator() [1/4]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::Dense2DBase::operator() (\n    int x,\n    int y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-operator-24","title":"function operator() [2/4]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::Dense2DBase::operator() (\n    const int2 &amp; xy\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-operator-34","title":"function operator() [3/4]","text":"<pre><code>inline MUDA_GENERIC const T &amp; muda::Dense2DBase::operator() (\n    const int2 &amp; xy\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-operator-44","title":"function operator() [4/4]","text":"<pre><code>inline MUDA_GENERIC const T &amp; muda::Dense2DBase::operator() (\n    int x,\n    int y\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-pitch_bytes","title":"function pitch_bytes","text":"<pre><code>inline MUDA_GENERIC auto muda::Dense2DBase::pitch_bytes () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-total_size","title":"function total_size","text":"<pre><code>inline MUDA_GENERIC auto muda::Dense2DBase::total_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense2_d_base/#typedef-auto_const_t","title":"typedef auto_const_t","text":"<pre><code>using muda::Dense2DBase&lt; IsConst, T &gt;::auto_const_t =  typename Base::template auto_const_t&lt;U&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_dense2_d_base/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::Dense2DBase&lt; IsConst, T &gt;::m_data;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#variable-m_dim","title":"variable m_dim","text":"<pre><code>int2 muda::Dense2DBase&lt; IsConst, T &gt;::m_dim;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#variable-m_offset","title":"variable m_offset","text":"<pre><code>int2 muda::Dense2DBase&lt; IsConst, T &gt;::m_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#variable-m_pitch_bytes","title":"variable m_pitch_bytes","text":"<pre><code>int muda::Dense2DBase&lt; IsConst, T &gt;::m_pitch_bytes;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense2_d_base/#function-check","title":"function check","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::Dense2DBase::check () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense2_d_base/#function-check_range","title":"function check_range","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::Dense2DBase::check_range (\n    int x,\n    int y\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense/dense_2d.h</code></p>"},{"location":"muda/classmuda_1_1_dense3_d_base/","title":"Class muda::Dense3DBase","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; Dense3DBase</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_dense3_d_base/#public-types","title":"Public Types","text":"Type Name typedef Dense3DBase&lt; true, T &gt; ConstViewer typedef Dense3DBase&lt; false, T &gt; NonConstViewer typedef Dense3DBase&lt; IsConst, T &gt; ThisViewer typedef T value_type"},{"location":"muda/classmuda_1_1_dense3_d_base/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_dense3_d_base/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Dense3DBase ()  MUDA_GENERIC Dense3DBase (auto_const_t&lt; T &gt; * p, const int3 &amp; offset, const int3 &amp; dim, int pitch_bytes, int pitch_bytes_area)  MUDA_GENERIC int area () const MUDA_GENERIC auto as_const () const MUDA_GENERIC auto_const_t&lt; T &gt; * data ()  MUDA_GENERIC const T * data () const MUDA_GENERIC auto dim () const MUDA_GENERIC auto_const_t&lt; T &gt; &amp; flatten (int i)  MUDA_GENERIC const T &amp; flatten (int i) const MUDA_GENERIC operator ConstViewer () const MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator() (int x, int y, int z)  MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator() (const int3 &amp; xyz)  MUDA_GENERIC const T &amp; operator() (int x, int y, int z) const MUDA_GENERIC const T &amp; operator() (const int3 &amp; xyz) const MUDA_GENERIC int pitch_bytes () const MUDA_GENERIC int pitch_bytes_area () const MUDA_GENERIC int total_bytes () const MUDA_GENERIC int total_size () const MUDA_GENERIC int volume () const"},{"location":"muda/classmuda_1_1_dense3_d_base/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_dense3_d_base/#protected-types","title":"Protected Types","text":"Type Name typedef typename Base::template auto_const_t&lt; U &gt; auto_const_t"},{"location":"muda/classmuda_1_1_dense3_d_base/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_dense3_d_base/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data int3 m_dim int3 m_offset int m_pitch_bytes int m_pitch_bytes_area"},{"location":"muda/classmuda_1_1_dense3_d_base/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC void check () const MUDA_INLINE MUDA_GENERIC void check_range (int x, int y, int z) const"},{"location":"muda/classmuda_1_1_dense3_d_base/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_dense3_d_base/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense3_d_base/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::Dense3DBase&lt; IsConst, T &gt;::ConstViewer =  Dense3DBase&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::Dense3DBase&lt; IsConst, T &gt;::NonConstViewer =  Dense3DBase&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::Dense3DBase&lt; IsConst, T &gt;::ThisViewer =  Dense3DBase&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::Dense3DBase&lt; IsConst, T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense3_d_base/#function-dense3dbase-12","title":"function Dense3DBase [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::Dense3DBase::Dense3DBase () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-dense3dbase-22","title":"function Dense3DBase [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::Dense3DBase::Dense3DBase (\n    auto_const_t&lt; T &gt; * p,\n    const int3 &amp; offset,\n    const int3 &amp; dim,\n    int pitch_bytes,\n    int pitch_bytes_area\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-area","title":"function area","text":"<pre><code>inline MUDA_GENERIC int muda::Dense3DBase::area () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::Dense3DBase::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-data-12","title":"function data [1/2]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; * muda::Dense3DBase::data () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-data-22","title":"function data [2/2]","text":"<pre><code>inline MUDA_GENERIC const T * muda::Dense3DBase::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-dim","title":"function dim","text":"<pre><code>inline MUDA_GENERIC auto muda::Dense3DBase::dim () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-flatten-12","title":"function flatten [1/2]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::Dense3DBase::flatten (\n    int i\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-flatten-22","title":"function flatten [2/2]","text":"<pre><code>inline MUDA_GENERIC const T &amp; muda::Dense3DBase::flatten (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-operator-constviewer","title":"function operator ConstViewer","text":"<pre><code>inline MUDA_GENERIC muda::Dense3DBase::operator ConstViewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-operator-14","title":"function operator() [1/4]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::Dense3DBase::operator() (\n    int x,\n    int y,\n    int z\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-operator-24","title":"function operator() [2/4]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::Dense3DBase::operator() (\n    const int3 &amp; xyz\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-operator-34","title":"function operator() [3/4]","text":"<pre><code>inline MUDA_GENERIC const T &amp; muda::Dense3DBase::operator() (\n    int x,\n    int y,\n    int z\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-operator-44","title":"function operator() [4/4]","text":"<pre><code>inline MUDA_GENERIC const T &amp; muda::Dense3DBase::operator() (\n    const int3 &amp; xyz\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-pitch_bytes","title":"function pitch_bytes","text":"<pre><code>inline MUDA_GENERIC int muda::Dense3DBase::pitch_bytes () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-pitch_bytes_area","title":"function pitch_bytes_area","text":"<pre><code>inline MUDA_GENERIC int muda::Dense3DBase::pitch_bytes_area () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-total_bytes","title":"function total_bytes","text":"<pre><code>inline MUDA_GENERIC int muda::Dense3DBase::total_bytes () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-total_size","title":"function total_size","text":"<pre><code>inline MUDA_GENERIC int muda::Dense3DBase::total_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-volume","title":"function volume","text":"<pre><code>inline MUDA_GENERIC int muda::Dense3DBase::volume () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense3_d_base/#typedef-auto_const_t","title":"typedef auto_const_t","text":"<pre><code>using muda::Dense3DBase&lt; IsConst, T &gt;::auto_const_t =  typename Base::template auto_const_t&lt;U&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_dense3_d_base/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::Dense3DBase&lt; IsConst, T &gt;::m_data;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#variable-m_dim","title":"variable m_dim","text":"<pre><code>int3 muda::Dense3DBase&lt; IsConst, T &gt;::m_dim;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#variable-m_offset","title":"variable m_offset","text":"<pre><code>int3 muda::Dense3DBase&lt; IsConst, T &gt;::m_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#variable-m_pitch_bytes","title":"variable m_pitch_bytes","text":"<pre><code>int muda::Dense3DBase&lt; IsConst, T &gt;::m_pitch_bytes;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#variable-m_pitch_bytes_area","title":"variable m_pitch_bytes_area","text":"<pre><code>int muda::Dense3DBase&lt; IsConst, T &gt;::m_pitch_bytes_area;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense3_d_base/#function-check","title":"function check","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::Dense3DBase::check () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense3_d_base/#function-check_range","title":"function check_range","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::Dense3DBase::check_range (\n    int x,\n    int y,\n    int z\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense/dense_3d.h</code></p>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/","title":"Class muda::DenseMatrixViewT","text":"<p>template &lt;bool IsConst, typename Ty&gt;</p> <p>ClassList &gt; muda &gt; DenseMatrixViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#public-types","title":"Public Types","text":"Type Name typedef Buffer2DView&lt; Ty &gt; Buffer2DView typedef CBuffer2DView&lt; Ty &gt; CBuffer2DView typedef CDenseMatrixViewer&lt; Ty &gt; CViewer typedef DenseMatrixViewT&lt; true, Ty &gt; ConstView typedef DenseMatrixViewT&lt; false, Ty &gt; NonConstView typedef std::conditional_t&lt; IsConst, CBuffer2DView, Buffer2DView &gt; ThisBuffer2DView typedef DenseMatrixViewT&lt; IsConst, Ty &gt; ThisView typedef std::conditional_t&lt; IsConst, CViewer, Viewer &gt; ThisViewer typedef DenseMatrixViewer&lt; Ty &gt; Viewer"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC DenseMatrixViewT (ThisBuffer2DView view, size_t row, size_t col, bool trans=false, bool sym=false)  MUDA_GENERIC DenseMatrixViewT (const DenseMatrixViewT&lt; OtherIsConst, Ty &gt; &amp; other)  MUDA_GENERIC auto T ()  MUDA_GENERIC auto as_const () const MUDA_GENERIC auto buffer_view () const MUDA_GENERIC size_t col () const MUDA_GENERIC auto cviewer ()  MUDA_GENERIC auto data () const MUDA_GENERIC bool is_sym () const MUDA_GENERIC bool is_trans () const MUDA_GENERIC size_t lda () const MUDA_GENERIC size_t row () const MUDA_GENERIC auto viewer ()"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t m_col   = = 0 size_t m_row   = = 0 bool m_sym   = = false bool m_trans   = = false ThisBuffer2DView m_view"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#typedef-buffer2dview","title":"typedef Buffer2DView","text":"<pre><code>using muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::Buffer2DView =  Buffer2DView&lt;Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#typedef-cbuffer2dview","title":"typedef CBuffer2DView","text":"<pre><code>using muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::CBuffer2DView =  CBuffer2DView&lt;Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#typedef-cviewer","title":"typedef CViewer","text":"<pre><code>using muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::CViewer =  CDenseMatrixViewer&lt;Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::ConstView =  DenseMatrixViewT&lt;true, Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#typedef-nonconstview","title":"typedef NonConstView","text":"<pre><code>using muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::NonConstView =  DenseMatrixViewT&lt;false, Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#typedef-thisbuffer2dview","title":"typedef ThisBuffer2DView","text":"<pre><code>using muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::ThisBuffer2DView =  std::conditional_t&lt;IsConst, CBuffer2DView, Buffer2DView&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::ThisView =  DenseMatrixViewT&lt;IsConst, Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::ThisViewer =  std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#typedef-viewer","title":"typedef Viewer","text":"<pre><code>using muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::Viewer =  DenseMatrixViewer&lt;Ty&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-densematrixviewt-23","title":"function DenseMatrixViewT [2/3]","text":"<pre><code>inline MUDA_GENERIC muda::DenseMatrixViewT::DenseMatrixViewT (\n    ThisBuffer2DView view,\n    size_t row,\n    size_t col,\n    bool trans=false,\n    bool sym=false\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-densematrixviewt-33","title":"function DenseMatrixViewT [3/3]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::DenseMatrixViewT::DenseMatrixViewT (\n    const DenseMatrixViewT &lt; OtherIsConst, Ty &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-t","title":"function T","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewT::T () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-buffer_view","title":"function buffer_view","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewT::buffer_view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-col","title":"function col","text":"<pre><code>inline MUDA_GENERIC size_t muda::DenseMatrixViewT::col () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-cviewer","title":"function cviewer","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewT::cviewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-data","title":"function data","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewT::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-is_sym","title":"function is_sym","text":"<pre><code>inline MUDA_GENERIC bool muda::DenseMatrixViewT::is_sym () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-is_trans","title":"function is_trans","text":"<pre><code>inline MUDA_GENERIC bool muda::DenseMatrixViewT::is_trans () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-lda","title":"function lda","text":"<pre><code>inline MUDA_GENERIC size_t muda::DenseMatrixViewT::lda () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-row","title":"function row","text":"<pre><code>inline MUDA_GENERIC size_t muda::DenseMatrixViewT::row () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#function-viewer","title":"function viewer","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewT::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#variable-m_col","title":"variable m_col","text":"<pre><code>size_t muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::m_col;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#variable-m_row","title":"variable m_row","text":"<pre><code>size_t muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::m_row;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#variable-m_sym","title":"variable m_sym","text":"<pre><code>bool muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::m_sym;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#variable-m_trans","title":"variable m_trans","text":"<pre><code>bool muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::m_trans;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_view_t/#variable-m_view","title":"variable m_view","text":"<pre><code>ThisBuffer2DView muda::DenseMatrixViewT&lt; IsConst, Ty &gt;::m_view;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/dense_matrix_view.h</code></p>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/","title":"Class muda::DenseMatrixViewerT","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; DenseMatrixViewerT</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#public-types","title":"Public Types","text":"Type Name typedef Buffer2DView&lt; T &gt; Buffer2DView typedef CBuffer2DView&lt; T &gt; CBuffer2DView typedef MapMatrixT&lt; const MatrixType &gt; CMapMatrix typedef DenseMatrixViewerT&lt; true, T &gt; ConstViewer typedef MapMatrixT&lt; MatrixType &gt; MapMatrix typedef Eigen::Map&lt; U, Eigen::AlignmentType::Unaligned, Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt; &gt; MapMatrixT typedef Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor &gt; MatrixType typedef DenseMatrixViewerT&lt; false, T &gt; NonConstViewer typedef std::conditional_t&lt; IsConst, CBuffer2DView, Buffer2DView &gt; ThisBuffer2DView typedef std::conditional_t&lt; IsConst, CMapMatrix, MapMatrix &gt; ThisMapMatrix typedef std::conditional_t&lt; IsConst, ConstViewer, NonConstViewer &gt; ThisViewer"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC DenseMatrixViewerT (ThisBuffer2DView view, size_t row_offset, size_t col_offset, size_t row_size, size_t col_size)  MUDA_GENERIC DenseMatrixViewerT (const DenseMatrixViewerT&lt; OtherIsConst, T &gt; &amp; other)  MUDA_VIEWER_COMMON_NAME (DenseMatrixViewerT)  MUDA_GENERIC auto as_const () const MUDA_GENERIC Eigen::Block&lt; ThisMapMatrix &gt; as_eigen () const MUDA_DEVICE T atomic_add (size_t i, size_t j, T val) const MUDA_DEVICE Eigen::Matrix&lt; T, M, N &gt; atomic_add (const Eigen::Matrix&lt; T, M, N &gt; &amp; other) const MUDA_GENERIC ThisViewer block (size_t row_offset, size_t col_offset, size_t row_size, size_t col_size) const MUDA_GENERIC ThisViewer block (int row_offset, int col_offset)  MUDA_GENERIC auto buffer_view () const MUDA_GENERIC size_t col () const MUDA_GENERIC auto col_offset () const MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator() (size_t i, size_t j) const MUDA_GENERIC DenseMatrixViewerT &amp; operator= (const Eigen::Matrix&lt; T, M, N &gt; &amp; other) const MUDA_GENERIC size_t origin_col () const MUDA_GENERIC size_t origin_row () const MUDA_GENERIC size_t row () const MUDA_GENERIC auto row_offset () const"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t m_col_offset   = = 0 size_t m_col_size   = = 0 size_t m_row_offset   = = 0 size_t m_row_size   = = 0 ThisBuffer2DView m_view"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-buffer2dview","title":"typedef Buffer2DView","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::Buffer2DView =  Buffer2DView&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-cbuffer2dview","title":"typedef CBuffer2DView","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::CBuffer2DView =  CBuffer2DView&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-cmapmatrix","title":"typedef CMapMatrix","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::CMapMatrix =  MapMatrixT&lt;const MatrixType&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::ConstViewer =  DenseMatrixViewerT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-mapmatrix","title":"typedef MapMatrix","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::MapMatrix =  MapMatrixT&lt;MatrixType&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-mapmatrixt","title":"typedef MapMatrixT","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::MapMatrixT = \n        Eigen::Map&lt;U, Eigen::AlignmentType::Unaligned, Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-matrixtype","title":"typedef MatrixType","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::MatrixType =  Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::NonConstViewer =  DenseMatrixViewerT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-thisbuffer2dview","title":"typedef ThisBuffer2DView","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::ThisBuffer2DView =  std::conditional_t&lt;IsConst, CBuffer2DView, Buffer2DView&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-thismapmatrix","title":"typedef ThisMapMatrix","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::ThisMapMatrix =  std::conditional_t&lt;IsConst, CMapMatrix, MapMatrix&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::DenseMatrixViewerT&lt; IsConst, T &gt;::ThisViewer =  std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-densematrixviewert-23","title":"function DenseMatrixViewerT [2/3]","text":"<pre><code>inline MUDA_GENERIC muda::DenseMatrixViewerT::DenseMatrixViewerT (\n    ThisBuffer2DView view,\n    size_t row_offset,\n    size_t col_offset,\n    size_t row_size,\n    size_t col_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-densematrixviewert-33","title":"function DenseMatrixViewerT [3/3]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::DenseMatrixViewerT::DenseMatrixViewerT (\n    const DenseMatrixViewerT &lt; OtherIsConst, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-muda_viewer_common_name","title":"function MUDA_VIEWER_COMMON_NAME","text":"<pre><code>muda::DenseMatrixViewerT::MUDA_VIEWER_COMMON_NAME (\n    DenseMatrixViewerT\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewerT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-as_eigen","title":"function as_eigen","text":"<pre><code>inline MUDA_GENERIC Eigen::Block&lt; ThisMapMatrix &gt; muda::DenseMatrixViewerT::as_eigen () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-atomic_add-12","title":"function atomic_add [1/2]","text":"<pre><code>inline MUDA_DEVICE T muda::DenseMatrixViewerT::atomic_add (\n    size_t i,\n    size_t j,\n    T val\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-atomic_add-22","title":"function atomic_add [2/2]","text":"<pre><code>template&lt;int M, int N&gt;\ninline MUDA_DEVICE Eigen::Matrix&lt; T, M, N &gt; muda::DenseMatrixViewerT::atomic_add (\n    const Eigen::Matrix&lt; T, M, N &gt; &amp; other\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-block-12","title":"function block [1/2]","text":"<pre><code>inline MUDA_GENERIC ThisViewer muda::DenseMatrixViewerT::block (\n    size_t row_offset,\n    size_t col_offset,\n    size_t row_size,\n    size_t col_size\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-block-22","title":"function block [2/2]","text":"<pre><code>template&lt;int M, int N&gt;\ninline MUDA_GENERIC ThisViewer muda::DenseMatrixViewerT::block (\n    int row_offset,\n    int col_offset\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-buffer_view","title":"function buffer_view","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewerT::buffer_view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-col","title":"function col","text":"<pre><code>inline MUDA_GENERIC size_t muda::DenseMatrixViewerT::col () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-col_offset","title":"function col_offset","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewerT::col_offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-operator","title":"function operator()","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::DenseMatrixViewerT::operator() (\n    size_t i,\n    size_t j\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-operator_1","title":"function operator=","text":"<pre><code>template&lt;int M, int N&gt;\ninline MUDA_GENERIC DenseMatrixViewerT &amp; muda::DenseMatrixViewerT::operator= (\n    const Eigen::Matrix&lt; T, M, N &gt; &amp; other\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-origin_col","title":"function origin_col","text":"<pre><code>inline MUDA_GENERIC size_t muda::DenseMatrixViewerT::origin_col () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-origin_row","title":"function origin_row","text":"<pre><code>inline MUDA_GENERIC size_t muda::DenseMatrixViewerT::origin_row () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-row","title":"function row","text":"<pre><code>inline MUDA_GENERIC size_t muda::DenseMatrixViewerT::row () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#function-row_offset","title":"function row_offset","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseMatrixViewerT::row_offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#variable-m_col_offset","title":"variable m_col_offset","text":"<pre><code>size_t muda::DenseMatrixViewerT&lt; IsConst, T &gt;::m_col_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#variable-m_col_size","title":"variable m_col_size","text":"<pre><code>size_t muda::DenseMatrixViewerT&lt; IsConst, T &gt;::m_col_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#variable-m_row_offset","title":"variable m_row_offset","text":"<pre><code>size_t muda::DenseMatrixViewerT&lt; IsConst, T &gt;::m_row_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#variable-m_row_size","title":"variable m_row_size","text":"<pre><code>size_t muda::DenseMatrixViewerT&lt; IsConst, T &gt;::m_row_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_matrix_viewer_t/#variable-m_view","title":"variable m_view","text":"<pre><code>ThisBuffer2DView muda::DenseMatrixViewerT&lt; IsConst, T &gt;::m_view;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/dense_matrix_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/","title":"Class muda::DenseVectorViewT","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; DenseVectorViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#public-types","title":"Public Types","text":"Type Name typedef BufferView&lt; T &gt; BufferView typedef CBufferView&lt; T &gt; CBufferView typedef CDenseVectorViewer&lt; T &gt; CViewer typedef DenseVectorViewT&lt; true, T &gt; ConstView typedef DenseVectorViewT&lt; false, T &gt; NonConstView typedef std::conditional_t&lt; IsConst, CBufferView, BufferView &gt; ThisBufferView typedef DenseVectorViewT&lt; IsConst, T &gt; ThisView typedef std::conditional_t&lt; IsConst, CViewer, Viewer &gt; ThisViewer typedef DenseVectorViewer&lt; T &gt; Viewer"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC DenseVectorViewT () = default MUDA_GENERIC DenseVectorViewT (auto_const_t&lt; T &gt; * data, cusparseDnVecDescr_t descr, int offset, int inc, int size, int origin_size)  MUDA_GENERIC DenseVectorViewT (const DenseVectorViewT&lt; OtherIsConst, T &gt; &amp; other)  MUDA_GENERIC ConstView as_const () const MUDA_GENERIC auto buffer_view () const MUDA_GENERIC auto cviewer () const MUDA_GENERIC auto data () const MUDA_GENERIC auto descr () const MUDA_GENERIC auto inc () const MUDA_GENERIC auto offset () const MUDA_GENERIC auto origin_data () const MUDA_GENERIC auto size () const MUDA_GENERIC auto subview (int offset, int size) const MUDA_GENERIC auto viewer () const"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data   = = nullptr cusparseDnVecDescr_t m_descr   = = nullptr int m_inc   = = -1 int m_offset   = = -1 int m_origin_size   = = -1 int m_size   = = -1"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense_vector_view_t/#typedef-bufferview","title":"typedef BufferView","text":"<pre><code>using muda::DenseVectorViewT&lt; IsConst, T &gt;::BufferView =  BufferView&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#typedef-cbufferview","title":"typedef CBufferView","text":"<pre><code>using muda::DenseVectorViewT&lt; IsConst, T &gt;::CBufferView =  CBufferView&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#typedef-cviewer","title":"typedef CViewer","text":"<pre><code>using muda::DenseVectorViewT&lt; IsConst, T &gt;::CViewer =  CDenseVectorViewer&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::DenseVectorViewT&lt; IsConst, T &gt;::ConstView =  DenseVectorViewT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#typedef-nonconstview","title":"typedef NonConstView","text":"<pre><code>using muda::DenseVectorViewT&lt; IsConst, T &gt;::NonConstView =  DenseVectorViewT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#typedef-thisbufferview","title":"typedef ThisBufferView","text":"<pre><code>using muda::DenseVectorViewT&lt; IsConst, T &gt;::ThisBufferView =  std::conditional_t&lt;IsConst, CBufferView, BufferView&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::DenseVectorViewT&lt; IsConst, T &gt;::ThisView =  DenseVectorViewT&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::DenseVectorViewT&lt; IsConst, T &gt;::ThisViewer =  std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#typedef-viewer","title":"typedef Viewer","text":"<pre><code>using muda::DenseVectorViewT&lt; IsConst, T &gt;::Viewer =  DenseVectorViewer&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-densevectorviewt-24","title":"function DenseVectorViewT [2/4]","text":"<pre><code>MUDA_GENERIC muda::DenseVectorViewT::DenseVectorViewT () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-densevectorviewt-34","title":"function DenseVectorViewT [3/4]","text":"<pre><code>inline MUDA_GENERIC muda::DenseVectorViewT::DenseVectorViewT (\n    auto_const_t&lt; T &gt; * data,\n    cusparseDnVecDescr_t descr,\n    int offset,\n    int inc,\n    int size,\n    int origin_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-densevectorviewt-44","title":"function DenseVectorViewT [4/4]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::DenseVectorViewT::DenseVectorViewT (\n    const DenseVectorViewT &lt; OtherIsConst, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC ConstView muda::DenseVectorViewT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-buffer_view","title":"function buffer_view","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::buffer_view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-cviewer","title":"function cviewer","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-data","title":"function data","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-descr","title":"function descr","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::descr () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-inc","title":"function inc","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::inc () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-offset","title":"function offset","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-origin_data","title":"function origin_data","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::origin_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-size","title":"function size","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-subview","title":"function subview","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::subview (\n    int offset,\n    int size\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#function-viewer","title":"function viewer","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewT::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_dense_vector_view_t/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::DenseVectorViewT&lt; IsConst, T &gt;::m_data;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#variable-m_descr","title":"variable m_descr","text":"<pre><code>cusparseDnVecDescr_t muda::DenseVectorViewT&lt; IsConst, T &gt;::m_descr;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#variable-m_inc","title":"variable m_inc","text":"<pre><code>int muda::DenseVectorViewT&lt; IsConst, T &gt;::m_inc;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#variable-m_offset","title":"variable m_offset","text":"<pre><code>int muda::DenseVectorViewT&lt; IsConst, T &gt;::m_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#variable-m_origin_size","title":"variable m_origin_size","text":"<pre><code>int muda::DenseVectorViewT&lt; IsConst, T &gt;::m_origin_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_view_t/#variable-m_size","title":"variable m_size","text":"<pre><code>int muda::DenseVectorViewT&lt; IsConst, T &gt;::m_size;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/dense_vector_view.h</code></p>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/","title":"Class muda::DenseVectorViewerT","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; DenseVectorViewerT</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#public-types","title":"Public Types","text":"Type Name typedef BufferView&lt; T &gt; BufferView typedef CBufferView&lt; T &gt; CBufferView typedef MapVectorT&lt; const VectorType &gt; CMapVector typedef DenseVectorViewerT&lt; true, T &gt; ConstViewer typedef MapVectorT&lt; VectorType &gt; MapVector typedef Eigen::Map&lt; U, Eigen::AlignmentType::Unaligned, Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt; &gt; MapVectorT typedef DenseVectorViewerT&lt; false, T &gt; NonConstViewer typedef std::conditional_t&lt; IsConst, CBufferView, BufferView &gt; ThisBufferView typedef std::conditional_t&lt; IsConst, CMapVector, MapVector &gt; ThisMapVector typedef std::conditional_t&lt; IsConst, ConstViewer, NonConstViewer &gt; ThisViewer typedef Eigen::Vector&lt; T, Eigen::Dynamic &gt; VectorType"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC DenseVectorViewerT (auto_const_t&lt; T &gt; * data, int offset, int size, int origin_size)  MUDA_GENERIC DenseVectorViewerT (const DenseVectorViewerT&lt; OtherIsConst, T &gt; &amp; other)  MUDA_VIEWER_COMMON_NAME (DenseVectorViewerT)  MUDA_GENERIC auto as_const () const MUDA_GENERIC Eigen::VectorBlock&lt; ThisMapVector &gt; as_eigen () const MUDA_DEVICE T atomic_add (int i, T val) const MUDA_DEVICE Eigen::Vector&lt; T, N &gt; atomic_add (const Eigen::Vector&lt; T, N &gt; &amp; val) const MUDA_DEVICE T atomic_add (const T &amp; val)  MUDA_GENERIC auto offset () const MUDA_GENERIC VectorBlock&lt; ThisMapVector &gt; ()  MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator() (int i) const MUDA_GENERIC DenseVectorViewerT &amp; operator= (const Eigen::Vector&lt; T, N &gt; &amp; other)  MUDA_GENERIC auto origin_data () const MUDA_GENERIC auto origin_size () const MUDA_GENERIC auto segment (int offset, int size) const MUDA_GENERIC auto segment (int offset) const MUDA_GENERIC auto size () const"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data int m_offset   = = 0 int m_origin_size   = = 0 int m_size   = = 0"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC void check_data () const MUDA_INLINE MUDA_GENERIC void check_segment (int offset, int size) const MUDA_INLINE MUDA_GENERIC void check_size_matching (int N) const MUDA_INLINE MUDA_GENERIC int index (int i) const"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-bufferview","title":"typedef BufferView","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::BufferView =  BufferView&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-cbufferview","title":"typedef CBufferView","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::CBufferView =  CBufferView&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-cmapvector","title":"typedef CMapVector","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::CMapVector =  MapVectorT&lt;const VectorType&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::ConstViewer =  DenseVectorViewerT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-mapvector","title":"typedef MapVector","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::MapVector =  MapVectorT&lt;VectorType&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-mapvectort","title":"typedef MapVectorT","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::MapVectorT = \n        Eigen::Map&lt;U, Eigen::AlignmentType::Unaligned, Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::NonConstViewer =  DenseVectorViewerT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-thisbufferview","title":"typedef ThisBufferView","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::ThisBufferView =  std::conditional_t&lt;IsConst, CBufferView, BufferView&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-thismapvector","title":"typedef ThisMapVector","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::ThisMapVector =  std::conditional_t&lt;IsConst, CMapVector, MapVector&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::ThisViewer =  std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>using muda::DenseVectorViewerT&lt; IsConst, T &gt;::VectorType =  Eigen::Vector&lt;T, Eigen::Dynamic&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-densevectorviewert-23","title":"function DenseVectorViewerT [2/3]","text":"<pre><code>inline MUDA_GENERIC muda::DenseVectorViewerT::DenseVectorViewerT (\n    auto_const_t&lt; T &gt; * data,\n    int offset,\n    int size,\n    int origin_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-densevectorviewert-33","title":"function DenseVectorViewerT [3/3]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::DenseVectorViewerT::DenseVectorViewerT (\n    const DenseVectorViewerT &lt; OtherIsConst, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-muda_viewer_common_name","title":"function MUDA_VIEWER_COMMON_NAME","text":"<pre><code>muda::DenseVectorViewerT::MUDA_VIEWER_COMMON_NAME (\n    DenseVectorViewerT\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewerT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-as_eigen","title":"function as_eigen","text":"<pre><code>inline MUDA_GENERIC Eigen::VectorBlock&lt; ThisMapVector &gt; muda::DenseVectorViewerT::as_eigen () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-atomic_add-13","title":"function atomic_add [1/3]","text":"<pre><code>inline MUDA_DEVICE T muda::DenseVectorViewerT::atomic_add (\n    int i,\n    T val\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-atomic_add-23","title":"function atomic_add [2/3]","text":"<pre><code>template&lt;int N&gt;\ninline MUDA_DEVICE Eigen::Vector&lt; T, N &gt; muda::DenseVectorViewerT::atomic_add (\n    const Eigen::Vector&lt; T, N &gt; &amp; val\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-atomic_add-33","title":"function atomic_add [3/3]","text":"<pre><code>inline MUDA_DEVICE T muda::DenseVectorViewerT::atomic_add (\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-offset","title":"function offset","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewerT::offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-vectorblock-thismapvector","title":"function VectorBlock&lt; ThisMapVector &gt;","text":"<pre><code>inline MUDA_GENERIC muda::DenseVectorViewerT::VectorBlock&lt; ThisMapVector &gt; () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-operator","title":"function operator()","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::DenseVectorViewerT::operator() (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-operator_1","title":"function operator=","text":"<pre><code>template&lt;int N&gt;\ninline MUDA_GENERIC DenseVectorViewerT &amp; muda::DenseVectorViewerT::operator= (\n    const Eigen::Vector&lt; T, N &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-origin_data","title":"function origin_data","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewerT::origin_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-origin_size","title":"function origin_size","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewerT::origin_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-segment-12","title":"function segment [1/2]","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewerT::segment (\n    int offset,\n    int size\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-segment-22","title":"function segment [2/2]","text":"<pre><code>template&lt;int N&gt;\ninline MUDA_GENERIC auto muda::DenseVectorViewerT::segment (\n    int offset\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-size","title":"function size","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseVectorViewerT::size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::DenseVectorViewerT&lt; IsConst, T &gt;::m_data;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#variable-m_offset","title":"variable m_offset","text":"<pre><code>int muda::DenseVectorViewerT&lt; IsConst, T &gt;::m_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#variable-m_origin_size","title":"variable m_origin_size","text":"<pre><code>int muda::DenseVectorViewerT&lt; IsConst, T &gt;::m_origin_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#variable-m_size","title":"variable m_size","text":"<pre><code>int muda::DenseVectorViewerT&lt; IsConst, T &gt;::m_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-check_data","title":"function check_data","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::DenseVectorViewerT::check_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-check_segment","title":"function check_segment","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::DenseVectorViewerT::check_segment (\n    int offset,\n    int size\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-check_size_matching","title":"function check_size_matching","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::DenseVectorViewerT::check_size_matching (\n    int N\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_vector_viewer_t/#function-index","title":"function index","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC int muda::DenseVectorViewerT::index (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/dense_vector_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_dense_viewer_t/","title":"Class muda::DenseViewerT","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; DenseViewerT</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#public-types","title":"Public Types","text":"Type Name typedef DenseViewerT&lt; true, T &gt; ConstViewer typedef DenseViewerT&lt; false, T &gt; NonConstViewer typedef DenseViewerT&lt; IsConst, T &gt; ThisViewer typedef T value_type"},{"location":"muda/classmuda_1_1_dense_viewer_t/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_dense_viewer_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC DenseViewerT ()  MUDA_GENERIC DenseViewerT (auto_const_t&lt; T &gt; * p)  MUDA_GENERIC DenseViewerT (const DenseViewerT &amp;)  MUDA_GENERIC DenseViewerT (const DenseViewerT&lt; OtherIsConst, T &gt; &amp; other)  MUDA_GENERIC auto as_const () const MUDA_GENERIC auto_const_t&lt; T &gt; * data () const MUDA_GENERIC operator auto_const_t&lt; T &gt; &amp; () const MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator* () const MUDA_GENERIC auto_const_t&lt; T &gt; * operator-&gt; () const MUDA_GENERIC ThisViewer &amp; operator= (const T &amp; v)"},{"location":"muda/classmuda_1_1_dense_viewer_t/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_dense_viewer_t/#protected-types","title":"Protected Types","text":"Type Name typedef typename Base::template auto_const_t&lt; U &gt; auto_const_t"},{"location":"muda/classmuda_1_1_dense_viewer_t/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_dense_viewer_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data   = = nullptr"},{"location":"muda/classmuda_1_1_dense_viewer_t/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC void check () const"},{"location":"muda/classmuda_1_1_dense_viewer_t/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_dense_viewer_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense_viewer_t/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::DenseViewerT&lt; IsConst, T &gt;::ConstViewer =  DenseViewerT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::DenseViewerT&lt; IsConst, T &gt;::NonConstViewer =  DenseViewerT&lt;false, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::DenseViewerT&lt; IsConst, T &gt;::ThisViewer =  DenseViewerT&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::DenseViewerT&lt; IsConst, T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-denseviewert-25","title":"function DenseViewerT [2/5]","text":"<pre><code>MUDA_GENERIC muda::DenseViewerT::DenseViewerT () \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-denseviewert-35","title":"function DenseViewerT [3/5]","text":"<pre><code>inline explicit MUDA_GENERIC muda::DenseViewerT::DenseViewerT (\n    auto_const_t&lt; T &gt; * p\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-denseviewert-45","title":"function DenseViewerT [4/5]","text":"<pre><code>MUDA_GENERIC muda::DenseViewerT::DenseViewerT (\n    const DenseViewerT &amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-denseviewert-55","title":"function DenseViewerT [5/5]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::DenseViewerT::DenseViewerT (\n    const DenseViewerT &lt; OtherIsConst, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::DenseViewerT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-data","title":"function data","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; * muda::DenseViewerT::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-operator-auto_const_t-t","title":"function operator auto_const_t&lt; T &gt; &amp;","text":"<pre><code>inline MUDA_GENERIC muda::DenseViewerT::operator auto_const_t&lt; T &gt; &amp; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-operator","title":"function operator*","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::DenseViewerT::operator* () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; * muda::DenseViewerT::operator-&gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-operator_1","title":"function operator=","text":"<pre><code>inline MUDA_GENERIC ThisViewer &amp; muda::DenseViewerT::operator= (\n    const T &amp; v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"muda/classmuda_1_1_dense_viewer_t/#typedef-auto_const_t","title":"typedef auto_const_t","text":"<pre><code>using muda::DenseViewerT&lt; IsConst, T &gt;::auto_const_t =  typename Base::template auto_const_t&lt;U&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_dense_viewer_t/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::DenseViewerT&lt; IsConst, T &gt;::m_data;\n</code></pre>"},{"location":"muda/classmuda_1_1_dense_viewer_t/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_dense_viewer_t/#function-check","title":"function check","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::DenseViewerT::check () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense/dense_0d.h</code></p>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/","title":"Class muda::DeviceBCOOMatrix","text":"<p>template &lt;typename T, int N&gt;</p> <p>ClassList &gt; muda &gt; DeviceBCOOMatrix</p> <p>Inherits the following classes: muda::DeviceTripletMatrix</p>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#public-types-inherited-from-mudadevicetripletmatrix","title":"Public Types inherited from muda::DeviceTripletMatrix","text":"<p>See muda::DeviceTripletMatrix</p> Type Name typedef std::conditional_t&lt; N==1, T, Eigen::Matrix&lt; T, N, N &gt; &gt; ValueT"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#public-static-attributes-inherited-from-mudadevicetripletmatrix","title":"Public Static Attributes inherited from muda::DeviceTripletMatrix","text":"<p>See muda::DeviceTripletMatrix</p> Type Name bool IsBlockMatrix   = = (N &gt; 1)"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#public-functions","title":"Public Functions","text":"Type Name DeviceBCOOMatrix () = default DeviceBCOOMatrix (const DeviceBCOOMatrix &amp;) = default DeviceBCOOMatrix (DeviceBCOOMatrix &amp;&amp;) = default auto non_zeros () const DeviceBCOOMatrix &amp; operator= (const DeviceBCOOMatrix &amp;) = default DeviceBCOOMatrix &amp; operator= (DeviceBCOOMatrix &amp;&amp;) = default ~DeviceBCOOMatrix () = default"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#public-functions-inherited-from-mudadevicetripletmatrix","title":"Public Functions inherited from muda::DeviceTripletMatrix","text":"<p>See muda::DeviceTripletMatrix</p> Type Name DeviceTripletMatrix () = default DeviceTripletMatrix (const DeviceTripletMatrix &amp;) = default DeviceTripletMatrix (DeviceTripletMatrix &amp;&amp;) = default void clear ()  auto col_indices ()  auto col_indices () const auto cols () const auto cview () const auto cviewer () const operator CTripletMatrixView&lt; T, N &gt; () const operator TripletMatrixView&lt; T, N &gt; ()  DeviceTripletMatrix &amp; operator= (const DeviceTripletMatrix &amp;) = default DeviceTripletMatrix &amp; operator= (DeviceTripletMatrix &amp;&amp;) = default void reserve_triplets (size_t nonzero_count)  void reshape (int row, int col)  void resize (int row, int col, size_t nonzero_count)  void resize_triplets (size_t nonzero_count)  auto row_indices ()  auto row_indices () const auto rows () const auto triplet_capacity () const auto triplet_count () const auto values ()  auto values () const auto view ()  auto view () const auto viewer ()  ~DeviceTripletMatrix () = default"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#public-static-functions-inherited-from-mudadevicetripletmatrix","title":"Public Static Functions inherited from muda::DeviceTripletMatrix","text":"<p>See muda::DeviceTripletMatrix</p> Type Name int block_dim ()"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#protected-attributes-inherited-from-mudadevicetripletmatrix","title":"Protected Attributes inherited from muda::DeviceTripletMatrix","text":"<p>See muda::DeviceTripletMatrix</p> Type Name DeviceBuffer&lt; int &gt; m_col_indices int m_cols   = = 0 DeviceBuffer&lt; int &gt; m_row_indices int m_rows   = = 0 DeviceBuffer&lt; ValueT &gt; m_values"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#function-devicebcoomatrix-13","title":"function DeviceBCOOMatrix [1/3]","text":"<pre><code>muda::DeviceBCOOMatrix::DeviceBCOOMatrix () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#function-devicebcoomatrix-23","title":"function DeviceBCOOMatrix [2/3]","text":"<pre><code>muda::DeviceBCOOMatrix::DeviceBCOOMatrix (\n    const DeviceBCOOMatrix &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#function-devicebcoomatrix-33","title":"function DeviceBCOOMatrix [3/3]","text":"<pre><code>muda::DeviceBCOOMatrix::DeviceBCOOMatrix (\n    DeviceBCOOMatrix &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#function-non_zeros","title":"function non_zeros","text":"<pre><code>inline auto muda::DeviceBCOOMatrix::non_zeros () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#function-operator","title":"function operator=","text":"<pre><code>DeviceBCOOMatrix &amp; muda::DeviceBCOOMatrix::operator= (\n    const DeviceBCOOMatrix &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceBCOOMatrix &amp; muda::DeviceBCOOMatrix::operator= (\n    DeviceBCOOMatrix &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#function-devicebcoomatrix","title":"function ~DeviceBCOOMatrix","text":"<pre><code>muda::DeviceBCOOMatrix::~DeviceBCOOMatrix () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_c_o_o_matrix/#friend-matrixformatconverter-t-n","title":"friend MatrixFormatConverter&lt; T, N &gt;","text":"<pre><code>class muda::DeviceBCOOMatrix::MatrixFormatConverter&lt; T, N &gt; (\n    details::MatrixFormatConverter &lt; T, N &gt;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_bcoo_matrix.h</code></p>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/","title":"Class muda::DeviceBCOOVector","text":"<p>template &lt;typename T, int N&gt;</p> <p>ClassList &gt; muda &gt; DeviceBCOOVector</p> <p>Inherits the following classes: muda::DeviceDoubletVector</p>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#public-types","title":"Public Types","text":"Type Name typedef Eigen::Matrix&lt; T, N, 1 &gt; SegmentVector"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#public-types-inherited-from-mudadevicedoubletvector","title":"Public Types inherited from muda::DeviceDoubletVector","text":"<p>See muda::DeviceDoubletVector</p> Type Name typedef std::conditional_t&lt; N==1, T, Eigen::Vector&lt; T, N &gt; &gt; ValueT"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#public-static-attributes-inherited-from-mudadevicedoubletvector","title":"Public Static Attributes inherited from muda::DeviceDoubletVector","text":"<p>See muda::DeviceDoubletVector</p> Type Name bool IsSegmentVector   = = (N &gt; 1)"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#public-functions","title":"Public Functions","text":"Type Name DeviceBCOOVector () = default DeviceBCOOVector (const DeviceBCOOVector &amp;) = default DeviceBCOOVector (DeviceBCOOVector &amp;&amp;) = default auto non_zeros () const DeviceBCOOVector &amp; operator= (const DeviceBCOOVector &amp;) = default DeviceBCOOVector &amp; operator= (DeviceBCOOVector &amp;&amp;) = default ~DeviceBCOOVector () = default"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#public-functions-inherited-from-mudadevicedoubletvector","title":"Public Functions inherited from muda::DeviceDoubletVector","text":"<p>See muda::DeviceDoubletVector</p> Type Name DeviceDoubletVector () = default void clear ()  auto count () const auto cview () const auto cviewer () const auto doublet_capacity () const auto doublet_count () const auto indices ()  auto indices () const void reserve_doublets (size_t nonzero_count)  void reshape (int num_segment)  void resize (int num_segment, size_t nonzero_count)  void resize_doublets (size_t nonzero_count)  auto values ()  auto values () const auto view ()  auto view () const auto viewer ()  auto viewer () const ~DeviceDoubletVector () = default"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#protected-attributes-inherited-from-mudadevicedoubletvector","title":"Protected Attributes inherited from muda::DeviceDoubletVector","text":"<p>See muda::DeviceDoubletVector</p> Type Name int m_count   = = 0 muda::DeviceBuffer&lt; int &gt; m_indices muda::DeviceBuffer&lt; ValueT &gt; m_values"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#typedef-segmentvector","title":"typedef SegmentVector","text":"<pre><code>using muda::DeviceBCOOVector&lt; T, N &gt;::SegmentVector =  Eigen::Matrix&lt;T, N, 1&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#function-devicebcoovector-13","title":"function DeviceBCOOVector [1/3]","text":"<pre><code>muda::DeviceBCOOVector::DeviceBCOOVector () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#function-devicebcoovector-23","title":"function DeviceBCOOVector [2/3]","text":"<pre><code>muda::DeviceBCOOVector::DeviceBCOOVector (\n    const DeviceBCOOVector &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#function-devicebcoovector-33","title":"function DeviceBCOOVector [3/3]","text":"<pre><code>muda::DeviceBCOOVector::DeviceBCOOVector (\n    DeviceBCOOVector &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#function-non_zeros","title":"function non_zeros","text":"<pre><code>inline auto muda::DeviceBCOOVector::non_zeros () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#function-operator","title":"function operator=","text":"<pre><code>DeviceBCOOVector &amp; muda::DeviceBCOOVector::operator= (\n    const DeviceBCOOVector &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceBCOOVector &amp; muda::DeviceBCOOVector::operator= (\n    DeviceBCOOVector &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#function-devicebcoovector","title":"function ~DeviceBCOOVector","text":"<pre><code>muda::DeviceBCOOVector::~DeviceBCOOVector () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_c_o_o_vector/#friend-matrixformatconverter-t-n","title":"friend MatrixFormatConverter&lt; T, N &gt;","text":"<pre><code>class muda::DeviceBCOOVector::MatrixFormatConverter&lt; T, N &gt; (\n    details::MatrixFormatConverter &lt; T, N &gt;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_bcoo_vector.h</code></p>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/","title":"Class muda::DeviceBSRMatrix","text":"<p>template &lt;typename Ty, int N&gt;</p> <p>ClassList &gt; muda &gt; DeviceBSRMatrix</p>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#public-types","title":"Public Types","text":"Type Name typedef std::conditional_t&lt; N==1, Ty, Eigen::Matrix&lt; Ty, N, N &gt; &gt; ValueT"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool IsBlockMatrix   = = (N &gt; 1)"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#public-functions","title":"Public Functions","text":"Type Name DeviceBSRMatrix () = default DeviceBSRMatrix (const DeviceBSRMatrix &amp;)  DeviceBSRMatrix (DeviceBSRMatrix &amp;&amp;)  auto T () const auto T ()  void clear ()  auto col_indices ()  auto col_indices () const auto cols () const auto cview () const cusparseSpMatDescr_t descr () const cusparseMatDescr_t legacy_descr () const auto non_zeros () const operator BSRMatrixView&lt; Ty, N &gt; ()  operator CBSRMatrixView&lt; Ty, N &gt; () const DeviceBSRMatrix &amp; operator= (const DeviceBSRMatrix &amp;)  DeviceBSRMatrix &amp; operator= (DeviceBSRMatrix &amp;&amp;)  void reserve (int non_zero_blocks)  void reserve_offsets (int size)  void reshape (int row, int col)  void resize (int non_zero_blocks)  auto row_offsets ()  auto row_offsets () const auto rows () const auto values ()  auto values () const auto view ()  auto view () const ~DeviceBSRMatrix ()"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#public-static-functions","title":"Public Static Functions","text":"Type Name int block_size ()"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#protected-attributes","title":"Protected Attributes","text":"Type Name int m_col   = = 0 muda::DeviceBuffer&lt; int &gt; m_col_indices cusparseSpMatDescr_t m_descr   = = nullptr cusparseMatDescr_t m_legacy_descr   = = nullptr int m_row   = = 0 muda::DeviceBuffer&lt; int &gt; m_row_offsets muda::DeviceBuffer&lt; ValueT &gt; m_values"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#typedef-valuet","title":"typedef ValueT","text":"<pre><code>using muda::DeviceBSRMatrix&lt; Ty, N &gt;::ValueT =  std::conditional_t&lt;N == 1, Ty, Eigen::Matrix&lt;Ty, N, N&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#variable-isblockmatrix","title":"variable IsBlockMatrix","text":"<pre><code>bool muda::DeviceBSRMatrix&lt; Ty, N &gt;::IsBlockMatrix;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-devicebsrmatrix-13","title":"function DeviceBSRMatrix [1/3]","text":"<pre><code>muda::DeviceBSRMatrix::DeviceBSRMatrix () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-devicebsrmatrix-23","title":"function DeviceBSRMatrix [2/3]","text":"<pre><code>muda::DeviceBSRMatrix::DeviceBSRMatrix (\n    const DeviceBSRMatrix &amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-devicebsrmatrix-33","title":"function DeviceBSRMatrix [3/3]","text":"<pre><code>muda::DeviceBSRMatrix::DeviceBSRMatrix (\n    DeviceBSRMatrix &amp;&amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-t-12","title":"function T [1/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::T () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-t-22","title":"function T [2/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::T () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-clear","title":"function clear","text":"<pre><code>void muda::DeviceBSRMatrix::clear () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-col_indices-12","title":"function col_indices [1/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::col_indices () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-col_indices-22","title":"function col_indices [2/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::col_indices () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-cols","title":"function cols","text":"<pre><code>inline auto muda::DeviceBSRMatrix::cols () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-cview","title":"function cview","text":"<pre><code>inline auto muda::DeviceBSRMatrix::cview () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-descr","title":"function descr","text":"<pre><code>cusparseSpMatDescr_t muda::DeviceBSRMatrix::descr () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-legacy_descr","title":"function legacy_descr","text":"<pre><code>cusparseMatDescr_t muda::DeviceBSRMatrix::legacy_descr () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-non_zeros","title":"function non_zeros","text":"<pre><code>inline auto muda::DeviceBSRMatrix::non_zeros () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-operator-bsrmatrixview-ty-n","title":"function operator BSRMatrixView&lt; Ty, N &gt;","text":"<pre><code>inline muda::DeviceBSRMatrix::operator BSRMatrixView&lt; Ty, N &gt; () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-operator-cbsrmatrixview-ty-n","title":"function operator CBSRMatrixView&lt; Ty, N &gt;","text":"<pre><code>inline muda::DeviceBSRMatrix::operator CBSRMatrixView&lt; Ty, N &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-operator","title":"function operator=","text":"<pre><code>DeviceBSRMatrix &amp; muda::DeviceBSRMatrix::operator= (\n    const DeviceBSRMatrix &amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceBSRMatrix &amp; muda::DeviceBSRMatrix::operator= (\n    DeviceBSRMatrix &amp;&amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-reserve","title":"function reserve","text":"<pre><code>void muda::DeviceBSRMatrix::reserve (\n    int non_zero_blocks\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-reserve_offsets","title":"function reserve_offsets","text":"<pre><code>void muda::DeviceBSRMatrix::reserve_offsets (\n    int size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-reshape","title":"function reshape","text":"<pre><code>void muda::DeviceBSRMatrix::reshape (\n    int row,\n    int col\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-resize","title":"function resize","text":"<pre><code>void muda::DeviceBSRMatrix::resize (\n    int non_zero_blocks\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-row_offsets-12","title":"function row_offsets [1/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::row_offsets () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-row_offsets-22","title":"function row_offsets [2/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::row_offsets () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-rows","title":"function rows","text":"<pre><code>inline auto muda::DeviceBSRMatrix::rows () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-values-12","title":"function values [1/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::values () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-values-22","title":"function values [2/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::values () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-view-12","title":"function view [1/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-view-22","title":"function view [2/2]","text":"<pre><code>inline auto muda::DeviceBSRMatrix::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-devicebsrmatrix","title":"function ~DeviceBSRMatrix","text":"<pre><code>muda::DeviceBSRMatrix::~DeviceBSRMatrix () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#function-block_size","title":"function block_size","text":"<pre><code>static inline int muda::DeviceBSRMatrix::block_size () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#variable-m_col","title":"variable m_col","text":"<pre><code>int muda::DeviceBSRMatrix&lt; Ty, N &gt;::m_col;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#variable-m_col_indices","title":"variable m_col_indices","text":"<pre><code>muda::DeviceBuffer&lt;int&gt; muda::DeviceBSRMatrix&lt; Ty, N &gt;::m_col_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#variable-m_descr","title":"variable m_descr","text":"<pre><code>cusparseSpMatDescr_t muda::DeviceBSRMatrix&lt; Ty, N &gt;::m_descr;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#variable-m_legacy_descr","title":"variable m_legacy_descr","text":"<pre><code>cusparseMatDescr_t muda::DeviceBSRMatrix&lt; Ty, N &gt;::m_legacy_descr;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#variable-m_row","title":"variable m_row","text":"<pre><code>int muda::DeviceBSRMatrix&lt; Ty, N &gt;::m_row;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#variable-m_row_offsets","title":"variable m_row_offsets","text":"<pre><code>muda::DeviceBuffer&lt;int&gt; muda::DeviceBSRMatrix&lt; Ty, N &gt;::m_row_offsets;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#variable-m_values","title":"variable m_values","text":"<pre><code>muda::DeviceBuffer&lt;ValueT&gt; muda::DeviceBSRMatrix&lt; Ty, N &gt;::m_values;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_device_b_s_r_matrix/#friend-matrixformatconverter","title":"friend MatrixFormatConverter","text":"<pre><code>template&lt;typename U, int M&gt;\nclass muda::DeviceBSRMatrix::MatrixFormatConverter (\n    details::MatrixFormatConverter\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_bsr_matrix.h</code></p>"},{"location":"muda/classmuda_1_1_device_buffer/","title":"Class muda::DeviceBuffer","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; DeviceBuffer</p> <p>A <code>std::vector</code> like wrapper of cuda device memory, allows user to:More...</p> <ul> <li><code>#include &lt;device_buffer.h&gt;</code></li> </ul>"},{"location":"muda/classmuda_1_1_device_buffer/#public-types","title":"Public Types","text":"Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_device_buffer/#public-functions","title":"Public Functions","text":"Type Name DeviceBuffer (size_t n)  DeviceBuffer ()  DeviceBuffer (const DeviceBuffer&lt; T &gt; &amp; other)  DeviceBuffer (DeviceBuffer &amp;&amp; other)  DeviceBuffer (CBufferView&lt; T &gt; other)  DeviceBuffer (const std::vector&lt; T &gt; &amp; host)  auto capacity () const void clear ()  void copy_from (const std::vector&lt; T &gt; &amp; host)  void copy_to (std::vector&lt; T &gt; &amp; host) const CDense1D&lt; T &gt; cviewer () const T * data ()  const T * data () const void fill (const T &amp; v)  operator BufferView&lt; T &gt; ()  operator CBufferView&lt; T &gt; () const DeviceBuffer &amp; operator= (const DeviceBuffer&lt; T &gt; &amp; other)  DeviceBuffer &amp; operator= (DeviceBuffer&lt; T &gt; &amp;&amp; other)  DeviceBuffer &amp; operator= (CBufferView&lt; T &gt; other)  DeviceBuffer &amp; operator= (const std::vector&lt; T &gt; &amp; other)  void reserve (size_t new_capacity)  void resize (size_t new_size)  void resize (size_t new_size, const T &amp; value)  void shrink_to_fit ()  auto size () const BufferView&lt; T &gt; view (size_t offset, size_t size=~0)  BufferView&lt; T &gt; view ()  CBufferView&lt; T &gt; view (size_t offset, size_t size=~0) const CBufferView&lt; T &gt; view () const Dense1D&lt; T &gt; viewer ()  ~DeviceBuffer ()"},{"location":"muda/classmuda_1_1_device_buffer/#detailed-description","title":"Detailed Description","text":"<ul> <li>resize </li> <li>reserve </li> <li>clear </li> <li>fill </li> <li>shrink_to_fit </li> <li>make view or subview from it </li> <li>make a safe viewer from it</li> </ul> <p>See also: </p>"},{"location":"muda/classmuda_1_1_device_buffer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_buffer/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::DeviceBuffer&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_buffer/#function-devicebuffer-16","title":"function DeviceBuffer [1/6]","text":"<pre><code>muda::DeviceBuffer::DeviceBuffer (\n    size_t n\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-devicebuffer-26","title":"function DeviceBuffer [2/6]","text":"<pre><code>muda::DeviceBuffer::DeviceBuffer () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-devicebuffer-36","title":"function DeviceBuffer [3/6]","text":"<pre><code>muda::DeviceBuffer::DeviceBuffer (\n    const DeviceBuffer &lt; T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-devicebuffer-46","title":"function DeviceBuffer [4/6]","text":"<pre><code>muda::DeviceBuffer::DeviceBuffer (\n    DeviceBuffer &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-devicebuffer-56","title":"function DeviceBuffer [5/6]","text":"<pre><code>muda::DeviceBuffer::DeviceBuffer (\n    CBufferView &lt; T &gt; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-devicebuffer-66","title":"function DeviceBuffer [6/6]","text":"<pre><code>muda::DeviceBuffer::DeviceBuffer (\n    const std::vector&lt; T &gt; &amp; host\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-capacity","title":"function capacity","text":"<pre><code>inline auto muda::DeviceBuffer::capacity () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-clear","title":"function clear","text":"<pre><code>void muda::DeviceBuffer::clear () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-copy_from","title":"function copy_from","text":"<pre><code>void muda::DeviceBuffer::copy_from (\n    const std::vector&lt; T &gt; &amp; host\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-copy_to","title":"function copy_to","text":"<pre><code>void muda::DeviceBuffer::copy_to (\n    std::vector&lt; T &gt; &amp; host\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-cviewer","title":"function cviewer","text":"<pre><code>CDense1D &lt; T &gt; muda::DeviceBuffer::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-data-12","title":"function data [1/2]","text":"<pre><code>inline T * muda::DeviceBuffer::data () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-data-22","title":"function data [2/2]","text":"<pre><code>inline const T * muda::DeviceBuffer::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-fill","title":"function fill","text":"<pre><code>void muda::DeviceBuffer::fill (\n    const T &amp; v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-operator-bufferview-t","title":"function operator BufferView&lt; T &gt;","text":"<pre><code>inline muda::DeviceBuffer::operator BufferView&lt; T &gt; () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-operator-cbufferview-t","title":"function operator CBufferView&lt; T &gt;","text":"<pre><code>inline muda::DeviceBuffer::operator CBufferView&lt; T &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-operator","title":"function operator=","text":"<pre><code>DeviceBuffer &amp; muda::DeviceBuffer::operator= (\n    const DeviceBuffer &lt; T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceBuffer &amp; muda::DeviceBuffer::operator= (\n    DeviceBuffer &lt; T &gt; &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-operator_2","title":"function operator=","text":"<pre><code>DeviceBuffer &amp; muda::DeviceBuffer::operator= (\n    CBufferView &lt; T &gt; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-operator_3","title":"function operator=","text":"<pre><code>DeviceBuffer &amp; muda::DeviceBuffer::operator= (\n    const std::vector&lt; T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-reserve","title":"function reserve","text":"<pre><code>void muda::DeviceBuffer::reserve (\n    size_t new_capacity\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-resize-12","title":"function resize [1/2]","text":"<pre><code>void muda::DeviceBuffer::resize (\n    size_t new_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-resize-22","title":"function resize [2/2]","text":"<pre><code>void muda::DeviceBuffer::resize (\n    size_t new_size,\n    const T &amp; value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-shrink_to_fit","title":"function shrink_to_fit","text":"<pre><code>void muda::DeviceBuffer::shrink_to_fit () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-size","title":"function size","text":"<pre><code>inline auto muda::DeviceBuffer::size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-view-14","title":"function view [1/4]","text":"<pre><code>BufferView &lt; T &gt; muda::DeviceBuffer::view (\n    size_t offset,\n    size_t size=~0\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-view-24","title":"function view [2/4]","text":"<pre><code>BufferView &lt; T &gt; muda::DeviceBuffer::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-view-34","title":"function view [3/4]","text":"<pre><code>CBufferView &lt; T &gt; muda::DeviceBuffer::view (\n    size_t offset,\n    size_t size=~0\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-view-44","title":"function view [4/4]","text":"<pre><code>CBufferView &lt; T &gt; muda::DeviceBuffer::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-viewer","title":"function viewer","text":"<pre><code>Dense1D &lt; T &gt; muda::DeviceBuffer::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer/#function-devicebuffer","title":"function ~DeviceBuffer","text":"<pre><code>muda::DeviceBuffer::~DeviceBuffer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/device_buffer.h</code></p>"},{"location":"muda/classmuda_1_1_device_buffer2_d/","title":"Class muda::DeviceBuffer2D","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; DeviceBuffer2D</p>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#public-types","title":"Public Types","text":"Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_device_buffer2_d/#public-functions","title":"Public Functions","text":"Type Name DeviceBuffer2D (const Extent2D &amp; n)  DeviceBuffer2D ()  DeviceBuffer2D (const DeviceBuffer2D&lt; T &gt; &amp; other)  DeviceBuffer2D (DeviceBuffer2D &amp;&amp; other)  DeviceBuffer2D (CBuffer2DView&lt; T &gt; other)  auto capacity () const void clear ()  void copy_from (const std::vector&lt; T &gt; &amp; host)  void copy_to (std::vector&lt; T &gt; &amp; host) const CDense2D&lt; T &gt; cviewer () const T * data ()  const T * data () const auto extent () const void fill (const T &amp; v)  operator Buffer2DView&lt; T &gt; ()  operator CBuffer2DView&lt; T &gt; () const DeviceBuffer2D &amp; operator= (const DeviceBuffer2D&lt; T &gt; &amp; other)  DeviceBuffer2D &amp; operator= (DeviceBuffer2D&lt; T &gt; &amp;&amp; other)  DeviceBuffer2D &amp; operator= (CBuffer2DView&lt; T &gt; other)  auto pitch_bytes () const void reserve (Extent2D new_capacity)  void resize (Extent2D new_extent)  void resize (Extent2D new_extent, const T &amp; value)  void shrink_to_fit ()  auto total_size () const Buffer2DView&lt; T &gt; view (Offset2D offset, Extent2D extent={})  Buffer2DView&lt; T &gt; view ()  CBuffer2DView&lt; T &gt; view (Offset2D offset, Extent2D extent={}) const CBuffer2DView&lt; T &gt; view () const Dense2D&lt; T &gt; viewer ()  ~DeviceBuffer2D ()"},{"location":"muda/classmuda_1_1_device_buffer2_d/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_buffer2_d/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::DeviceBuffer2D&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-devicebuffer2d-15","title":"function DeviceBuffer2D [1/5]","text":"<pre><code>muda::DeviceBuffer2D::DeviceBuffer2D (\n    const Extent2D &amp; n\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-devicebuffer2d-25","title":"function DeviceBuffer2D [2/5]","text":"<pre><code>muda::DeviceBuffer2D::DeviceBuffer2D () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-devicebuffer2d-35","title":"function DeviceBuffer2D [3/5]","text":"<pre><code>muda::DeviceBuffer2D::DeviceBuffer2D (\n    const DeviceBuffer2D &lt; T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-devicebuffer2d-45","title":"function DeviceBuffer2D [4/5]","text":"<pre><code>muda::DeviceBuffer2D::DeviceBuffer2D (\n    DeviceBuffer2D &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-devicebuffer2d-55","title":"function DeviceBuffer2D [5/5]","text":"<pre><code>muda::DeviceBuffer2D::DeviceBuffer2D (\n    CBuffer2DView &lt; T &gt; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-capacity","title":"function capacity","text":"<pre><code>inline auto muda::DeviceBuffer2D::capacity () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-clear","title":"function clear","text":"<pre><code>void muda::DeviceBuffer2D::clear () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-copy_from","title":"function copy_from","text":"<pre><code>void muda::DeviceBuffer2D::copy_from (\n    const std::vector&lt; T &gt; &amp; host\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-copy_to","title":"function copy_to","text":"<pre><code>void muda::DeviceBuffer2D::copy_to (\n    std::vector&lt; T &gt; &amp; host\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-cviewer","title":"function cviewer","text":"<pre><code>inline CDense2D &lt; T &gt; muda::DeviceBuffer2D::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-data-12","title":"function data [1/2]","text":"<pre><code>inline T * muda::DeviceBuffer2D::data () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-data-22","title":"function data [2/2]","text":"<pre><code>inline const T * muda::DeviceBuffer2D::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-extent","title":"function extent","text":"<pre><code>inline auto muda::DeviceBuffer2D::extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-fill","title":"function fill","text":"<pre><code>void muda::DeviceBuffer2D::fill (\n    const T &amp; v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-operator-buffer2dview-t","title":"function operator Buffer2DView&lt; T &gt;","text":"<pre><code>inline muda::DeviceBuffer2D::operator Buffer2DView&lt; T &gt; () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-operator-cbuffer2dview-t","title":"function operator CBuffer2DView&lt; T &gt;","text":"<pre><code>inline muda::DeviceBuffer2D::operator CBuffer2DView&lt; T &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-operator","title":"function operator=","text":"<pre><code>DeviceBuffer2D &amp; muda::DeviceBuffer2D::operator= (\n    const DeviceBuffer2D &lt; T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceBuffer2D &amp; muda::DeviceBuffer2D::operator= (\n    DeviceBuffer2D &lt; T &gt; &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-operator_2","title":"function operator=","text":"<pre><code>DeviceBuffer2D &amp; muda::DeviceBuffer2D::operator= (\n    CBuffer2DView &lt; T &gt; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-pitch_bytes","title":"function pitch_bytes","text":"<pre><code>inline auto muda::DeviceBuffer2D::pitch_bytes () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-reserve","title":"function reserve","text":"<pre><code>void muda::DeviceBuffer2D::reserve (\n    Extent2D new_capacity\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-resize-12","title":"function resize [1/2]","text":"<pre><code>void muda::DeviceBuffer2D::resize (\n    Extent2D new_extent\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-resize-22","title":"function resize [2/2]","text":"<pre><code>void muda::DeviceBuffer2D::resize (\n    Extent2D new_extent,\n    const T &amp; value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-shrink_to_fit","title":"function shrink_to_fit","text":"<pre><code>void muda::DeviceBuffer2D::shrink_to_fit () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-total_size","title":"function total_size","text":"<pre><code>inline auto muda::DeviceBuffer2D::total_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-view-14","title":"function view [1/4]","text":"<pre><code>inline Buffer2DView &lt; T &gt; muda::DeviceBuffer2D::view (\n    Offset2D offset,\n    Extent2D extent={}\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-view-24","title":"function view [2/4]","text":"<pre><code>inline Buffer2DView &lt; T &gt; muda::DeviceBuffer2D::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-view-34","title":"function view [3/4]","text":"<pre><code>inline CBuffer2DView &lt; T &gt; muda::DeviceBuffer2D::view (\n    Offset2D offset,\n    Extent2D extent={}\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-view-44","title":"function view [4/4]","text":"<pre><code>inline CBuffer2DView &lt; T &gt; muda::DeviceBuffer2D::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-viewer","title":"function viewer","text":"<pre><code>inline Dense2D &lt; T &gt; muda::DeviceBuffer2D::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer2_d/#function-devicebuffer2d","title":"function ~DeviceBuffer2D","text":"<pre><code>muda::DeviceBuffer2D::~DeviceBuffer2D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_fwd.h</code></p>"},{"location":"muda/classmuda_1_1_device_buffer3_d/","title":"Class muda::DeviceBuffer3D","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; DeviceBuffer3D</p>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#public-types","title":"Public Types","text":"Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_device_buffer3_d/#public-functions","title":"Public Functions","text":"Type Name DeviceBuffer3D (const Extent3D &amp; n)  DeviceBuffer3D ()  DeviceBuffer3D (const DeviceBuffer3D&lt; T &gt; &amp; other)  DeviceBuffer3D (DeviceBuffer3D &amp;&amp; other)  DeviceBuffer3D (CBuffer3DView&lt; T &gt; other)  auto capacity () const void clear ()  void copy_from (const std::vector&lt; T &gt; &amp; host)  void copy_to (std::vector&lt; T &gt; &amp; host) const CDense3D&lt; T &gt; cviewer () const T * data ()  const T * data () const auto extent () const void fill (const T &amp; v)  operator Buffer3DView&lt; T &gt; ()  operator CBuffer3DView&lt; T &gt; () const DeviceBuffer3D &amp; operator= (const DeviceBuffer3D&lt; T &gt; &amp; other)  DeviceBuffer3D &amp; operator= (DeviceBuffer3D&lt; T &gt; &amp;&amp; other)  DeviceBuffer3D &amp; operator= (CBuffer3DView&lt; T &gt; other)  auto pitch_bytes () const auto pitch_bytes_area () const void reserve (Extent3D new_capacity)  void resize (Extent3D new_size)  void resize (Extent3D new_size, const T &amp; value)  void shrink_to_fit ()  auto total_size () const Buffer3DView&lt; T &gt; view (Offset3D offset, Extent3D extent={})  Buffer3DView&lt; T &gt; view ()  CBuffer3DView&lt; T &gt; view (Offset3D offset, Extent3D extent={}) const CBuffer3DView&lt; T &gt; view () const Dense3D&lt; T &gt; viewer ()  ~DeviceBuffer3D ()"},{"location":"muda/classmuda_1_1_device_buffer3_d/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_buffer3_d/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::DeviceBuffer3D&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-devicebuffer3d-15","title":"function DeviceBuffer3D [1/5]","text":"<pre><code>muda::DeviceBuffer3D::DeviceBuffer3D (\n    const Extent3D &amp; n\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-devicebuffer3d-25","title":"function DeviceBuffer3D [2/5]","text":"<pre><code>muda::DeviceBuffer3D::DeviceBuffer3D () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-devicebuffer3d-35","title":"function DeviceBuffer3D [3/5]","text":"<pre><code>muda::DeviceBuffer3D::DeviceBuffer3D (\n    const DeviceBuffer3D &lt; T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-devicebuffer3d-45","title":"function DeviceBuffer3D [4/5]","text":"<pre><code>muda::DeviceBuffer3D::DeviceBuffer3D (\n    DeviceBuffer3D &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-devicebuffer3d-55","title":"function DeviceBuffer3D [5/5]","text":"<pre><code>muda::DeviceBuffer3D::DeviceBuffer3D (\n    CBuffer3DView &lt; T &gt; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-capacity","title":"function capacity","text":"<pre><code>inline auto muda::DeviceBuffer3D::capacity () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-clear","title":"function clear","text":"<pre><code>void muda::DeviceBuffer3D::clear () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-copy_from","title":"function copy_from","text":"<pre><code>void muda::DeviceBuffer3D::copy_from (\n    const std::vector&lt; T &gt; &amp; host\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-copy_to","title":"function copy_to","text":"<pre><code>void muda::DeviceBuffer3D::copy_to (\n    std::vector&lt; T &gt; &amp; host\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-cviewer","title":"function cviewer","text":"<pre><code>inline CDense3D &lt; T &gt; muda::DeviceBuffer3D::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-data-12","title":"function data [1/2]","text":"<pre><code>inline T * muda::DeviceBuffer3D::data () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-data-22","title":"function data [2/2]","text":"<pre><code>inline const T * muda::DeviceBuffer3D::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-extent","title":"function extent","text":"<pre><code>inline auto muda::DeviceBuffer3D::extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-fill","title":"function fill","text":"<pre><code>void muda::DeviceBuffer3D::fill (\n    const T &amp; v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-operator-buffer3dview-t","title":"function operator Buffer3DView&lt; T &gt;","text":"<pre><code>inline muda::DeviceBuffer3D::operator Buffer3DView&lt; T &gt; () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-operator-cbuffer3dview-t","title":"function operator CBuffer3DView&lt; T &gt;","text":"<pre><code>inline muda::DeviceBuffer3D::operator CBuffer3DView&lt; T &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-operator","title":"function operator=","text":"<pre><code>DeviceBuffer3D &amp; muda::DeviceBuffer3D::operator= (\n    const DeviceBuffer3D &lt; T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceBuffer3D &amp; muda::DeviceBuffer3D::operator= (\n    DeviceBuffer3D &lt; T &gt; &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-operator_2","title":"function operator=","text":"<pre><code>DeviceBuffer3D &amp; muda::DeviceBuffer3D::operator= (\n    CBuffer3DView &lt; T &gt; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-pitch_bytes","title":"function pitch_bytes","text":"<pre><code>inline auto muda::DeviceBuffer3D::pitch_bytes () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-pitch_bytes_area","title":"function pitch_bytes_area","text":"<pre><code>inline auto muda::DeviceBuffer3D::pitch_bytes_area () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-reserve","title":"function reserve","text":"<pre><code>void muda::DeviceBuffer3D::reserve (\n    Extent3D new_capacity\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-resize-12","title":"function resize [1/2]","text":"<pre><code>void muda::DeviceBuffer3D::resize (\n    Extent3D new_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-resize-22","title":"function resize [2/2]","text":"<pre><code>void muda::DeviceBuffer3D::resize (\n    Extent3D new_size,\n    const T &amp; value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-shrink_to_fit","title":"function shrink_to_fit","text":"<pre><code>void muda::DeviceBuffer3D::shrink_to_fit () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-total_size","title":"function total_size","text":"<pre><code>inline auto muda::DeviceBuffer3D::total_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-view-14","title":"function view [1/4]","text":"<pre><code>inline Buffer3DView &lt; T &gt; muda::DeviceBuffer3D::view (\n    Offset3D offset,\n    Extent3D extent={}\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-view-24","title":"function view [2/4]","text":"<pre><code>inline Buffer3DView &lt; T &gt; muda::DeviceBuffer3D::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-view-34","title":"function view [3/4]","text":"<pre><code>inline CBuffer3DView &lt; T &gt; muda::DeviceBuffer3D::view (\n    Offset3D offset,\n    Extent3D extent={}\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-view-44","title":"function view [4/4]","text":"<pre><code>inline CBuffer3DView &lt; T &gt; muda::DeviceBuffer3D::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-viewer","title":"function viewer","text":"<pre><code>inline Dense3D &lt; T &gt; muda::DeviceBuffer3D::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_buffer3_d/#function-devicebuffer3d","title":"function ~DeviceBuffer3D","text":"<pre><code>muda::DeviceBuffer3D::~DeviceBuffer3D () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_fwd.h</code></p>"},{"location":"muda/classmuda_1_1_device_dense_matrix/","title":"Class muda::DeviceDenseMatrix","text":"<p>template &lt;typename Ty&gt;</p> <p>ClassList &gt; muda &gt; DeviceDenseMatrix</p>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#public-types","title":"Public Types","text":"Type Name typedef Ty value_type"},{"location":"muda/classmuda_1_1_device_dense_matrix/#public-functions","title":"Public Functions","text":"Type Name DeviceDenseMatrix () = default DeviceDenseMatrix (size_t row, size_t col, bool sym=false)  DeviceDenseMatrix (const DeviceDenseMatrix &amp;) = default DeviceDenseMatrix (DeviceDenseMatrix &amp;&amp;)  DeviceDenseMatrix (const Eigen::MatrixX&lt; Ty &gt; &amp;)  DenseMatrixView&lt; Ty &gt; T ()  CDenseMatrixView&lt; Ty &gt; T () const auto buffer_view () const auto buffer_view ()  size_t col () const void copy_to (Eigen::MatrixX&lt; Ty &gt; &amp; mat) const void copy_to (std::vector&lt; Ty &gt; &amp; vec) const CDenseMatrixView&lt; Ty &gt; cview () const CDenseMatrixViewer&lt; Ty &gt; cviewer () const void fill (Ty value)  operator CDenseMatrixView&lt; Ty &gt; () const operator DenseMatrixView&lt; Ty &gt; ()  DeviceDenseMatrix &amp; operator= (const DeviceDenseMatrix &amp;) = default DeviceDenseMatrix &amp; operator= (DeviceDenseMatrix &amp;&amp;)  DeviceDenseMatrix &amp; operator= (const Eigen::MatrixX&lt; Ty &gt; &amp;)  void reshape (size_t row, size_t col)  size_t row () const void sym (bool sym=true)  bool sym () const DenseMatrixView&lt; Ty &gt; view ()  CDenseMatrixView&lt; Ty &gt; view () const DenseMatrixViewer&lt; Ty &gt; viewer ()"},{"location":"muda/classmuda_1_1_device_dense_matrix/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_dense_matrix/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::DeviceDenseMatrix&lt; Ty &gt;::value_type =  Ty;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-devicedensematrix-15","title":"function DeviceDenseMatrix [1/5]","text":"<pre><code>muda::DeviceDenseMatrix::DeviceDenseMatrix () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-devicedensematrix-25","title":"function DeviceDenseMatrix [2/5]","text":"<pre><code>muda::DeviceDenseMatrix::DeviceDenseMatrix (\n    size_t row,\n    size_t col,\n    bool sym=false\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-devicedensematrix-35","title":"function DeviceDenseMatrix [3/5]","text":"<pre><code>muda::DeviceDenseMatrix::DeviceDenseMatrix (\n    const DeviceDenseMatrix &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-devicedensematrix-45","title":"function DeviceDenseMatrix [4/5]","text":"<pre><code>muda::DeviceDenseMatrix::DeviceDenseMatrix (\n    DeviceDenseMatrix &amp;&amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-devicedensematrix-55","title":"function DeviceDenseMatrix [5/5]","text":"<pre><code>muda::DeviceDenseMatrix::DeviceDenseMatrix (\n    const Eigen::MatrixX&lt; Ty &gt; &amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-t-12","title":"function T [1/2]","text":"<pre><code>DenseMatrixView &lt; Ty &gt; muda::DeviceDenseMatrix::T () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-t-22","title":"function T [2/2]","text":"<pre><code>CDenseMatrixView &lt; Ty &gt; muda::DeviceDenseMatrix::T () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-buffer_view-12","title":"function buffer_view [1/2]","text":"<pre><code>inline auto muda::DeviceDenseMatrix::buffer_view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-buffer_view-22","title":"function buffer_view [2/2]","text":"<pre><code>inline auto muda::DeviceDenseMatrix::buffer_view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-col","title":"function col","text":"<pre><code>inline size_t muda::DeviceDenseMatrix::col () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-copy_to-12","title":"function copy_to [1/2]","text":"<pre><code>void muda::DeviceDenseMatrix::copy_to (\n    Eigen::MatrixX&lt; Ty &gt; &amp; mat\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-copy_to-22","title":"function copy_to [2/2]","text":"<pre><code>void muda::DeviceDenseMatrix::copy_to (\n    std::vector&lt; Ty &gt; &amp; vec\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-cview","title":"function cview","text":"<pre><code>inline CDenseMatrixView &lt; Ty &gt; muda::DeviceDenseMatrix::cview () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-cviewer","title":"function cviewer","text":"<pre><code>inline CDenseMatrixViewer &lt; Ty &gt; muda::DeviceDenseMatrix::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-fill","title":"function fill","text":"<pre><code>void muda::DeviceDenseMatrix::fill (\n    Ty value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-operator-cdensematrixview-ty","title":"function operator CDenseMatrixView&lt; Ty &gt;","text":"<pre><code>muda::DeviceDenseMatrix::operator CDenseMatrixView&lt; Ty &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-operator-densematrixview-ty","title":"function operator DenseMatrixView&lt; Ty &gt;","text":"<pre><code>muda::DeviceDenseMatrix::operator DenseMatrixView&lt; Ty &gt; () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-operator","title":"function operator=","text":"<pre><code>DeviceDenseMatrix &amp; muda::DeviceDenseMatrix::operator= (\n    const DeviceDenseMatrix &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceDenseMatrix &amp; muda::DeviceDenseMatrix::operator= (\n    DeviceDenseMatrix &amp;&amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-operator_2","title":"function operator=","text":"<pre><code>DeviceDenseMatrix &amp; muda::DeviceDenseMatrix::operator= (\n    const Eigen::MatrixX&lt; Ty &gt; &amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-reshape","title":"function reshape","text":"<pre><code>void muda::DeviceDenseMatrix::reshape (\n    size_t row,\n    size_t col\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-row","title":"function row","text":"<pre><code>inline size_t muda::DeviceDenseMatrix::row () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-sym-12","title":"function sym [1/2]","text":"<pre><code>inline void muda::DeviceDenseMatrix::sym (\n    bool sym=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-sym-22","title":"function sym [2/2]","text":"<pre><code>inline bool muda::DeviceDenseMatrix::sym () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-view-12","title":"function view [1/2]","text":"<pre><code>DenseMatrixView &lt; Ty &gt; muda::DeviceDenseMatrix::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-view-22","title":"function view [2/2]","text":"<pre><code>CDenseMatrixView &lt; Ty &gt; muda::DeviceDenseMatrix::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_matrix/#function-viewer","title":"function viewer","text":"<pre><code>inline DenseMatrixViewer &lt; Ty &gt; muda::DeviceDenseMatrix::viewer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_dense_matrix.h</code></p>"},{"location":"muda/classmuda_1_1_device_dense_vector/","title":"Class muda::DeviceDenseVector","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; DeviceDenseVector</p>"},{"location":"muda/classmuda_1_1_device_dense_vector/#public-functions","title":"Public Functions","text":"Type Name DeviceDenseVector () = default DeviceDenseVector (size_t size)  DeviceDenseVector (const DeviceDenseVector &amp;)  DeviceDenseVector (DeviceDenseVector &amp;&amp;)  DeviceDenseVector (const Eigen::VectorX&lt; T &gt; &amp; vec)  auto buffer_view () const auto buffer_view ()  auto capacity () const void copy_to (Eigen::VectorX&lt; T &gt; &amp; vec) const void copy_to (std::vector&lt; T &gt; &amp; vec) const CDenseVectorView&lt; T &gt; cview () const cusparseDnVecDescr_t descr () const void fill (T value)  operator CDenseVectorView&lt; T &gt; () const operator DenseVectorView&lt; T &gt; ()  DeviceDenseVector &amp; operator= (const DeviceDenseVector &amp;)  DeviceDenseVector &amp; operator= (DeviceDenseVector &amp;&amp;)  DeviceDenseVector &amp; operator= (const Eigen::VectorX&lt; T &gt; &amp; vec)  void reserve (size_t size)  void resize (size_t size)  auto size () const CDenseVectorView&lt; T &gt; view () const DenseVectorView&lt; T &gt; view ()  DenseVectorViewer&lt; T &gt; viewer ()  CDenseVectorViewer&lt; T &gt; viewer () const ~DeviceDenseVector ()"},{"location":"muda/classmuda_1_1_device_dense_vector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_dense_vector/#function-devicedensevector-15","title":"function DeviceDenseVector [1/5]","text":"<pre><code>muda::DeviceDenseVector::DeviceDenseVector () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-devicedensevector-25","title":"function DeviceDenseVector [2/5]","text":"<pre><code>muda::DeviceDenseVector::DeviceDenseVector (\n    size_t size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-devicedensevector-35","title":"function DeviceDenseVector [3/5]","text":"<pre><code>muda::DeviceDenseVector::DeviceDenseVector (\n    const DeviceDenseVector &amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-devicedensevector-45","title":"function DeviceDenseVector [4/5]","text":"<pre><code>muda::DeviceDenseVector::DeviceDenseVector (\n    DeviceDenseVector &amp;&amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-devicedensevector-55","title":"function DeviceDenseVector [5/5]","text":"<pre><code>muda::DeviceDenseVector::DeviceDenseVector (\n    const Eigen::VectorX&lt; T &gt; &amp; vec\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-buffer_view-12","title":"function buffer_view [1/2]","text":"<pre><code>inline auto muda::DeviceDenseVector::buffer_view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-buffer_view-22","title":"function buffer_view [2/2]","text":"<pre><code>inline auto muda::DeviceDenseVector::buffer_view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-capacity","title":"function capacity","text":"<pre><code>inline auto muda::DeviceDenseVector::capacity () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-copy_to-12","title":"function copy_to [1/2]","text":"<pre><code>void muda::DeviceDenseVector::copy_to (\n    Eigen::VectorX&lt; T &gt; &amp; vec\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-copy_to-22","title":"function copy_to [2/2]","text":"<pre><code>void muda::DeviceDenseVector::copy_to (\n    std::vector&lt; T &gt; &amp; vec\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-cview","title":"function cview","text":"<pre><code>inline CDenseVectorView &lt; T &gt; muda::DeviceDenseVector::cview () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-descr","title":"function descr","text":"<pre><code>inline cusparseDnVecDescr_t muda::DeviceDenseVector::descr () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-fill","title":"function fill","text":"<pre><code>void muda::DeviceDenseVector::fill (\n    T value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-operator-cdensevectorview-t","title":"function operator CDenseVectorView&lt; T &gt;","text":"<pre><code>inline muda::DeviceDenseVector::operator CDenseVectorView&lt; T &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-operator-densevectorview-t","title":"function operator DenseVectorView&lt; T &gt;","text":"<pre><code>inline muda::DeviceDenseVector::operator DenseVectorView&lt; T &gt; () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-operator","title":"function operator=","text":"<pre><code>DeviceDenseVector &amp; muda::DeviceDenseVector::operator= (\n    const DeviceDenseVector &amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceDenseVector &amp; muda::DeviceDenseVector::operator= (\n    DeviceDenseVector &amp;&amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-operator_2","title":"function operator=","text":"<pre><code>DeviceDenseVector &amp; muda::DeviceDenseVector::operator= (\n    const Eigen::VectorX&lt; T &gt; &amp; vec\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-reserve","title":"function reserve","text":"<pre><code>void muda::DeviceDenseVector::reserve (\n    size_t size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-resize","title":"function resize","text":"<pre><code>void muda::DeviceDenseVector::resize (\n    size_t size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-size","title":"function size","text":"<pre><code>inline auto muda::DeviceDenseVector::size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-view-12","title":"function view [1/2]","text":"<pre><code>CDenseVectorView &lt; T &gt; muda::DeviceDenseVector::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-view-22","title":"function view [2/2]","text":"<pre><code>DenseVectorView &lt; T &gt; muda::DeviceDenseVector::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-viewer-12","title":"function viewer [1/2]","text":"<pre><code>inline DenseVectorViewer &lt; T &gt; muda::DeviceDenseVector::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-viewer-22","title":"function viewer [2/2]","text":"<pre><code>inline CDenseVectorViewer &lt; T &gt; muda::DeviceDenseVector::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_dense_vector/#function-devicedensevector","title":"function ~DeviceDenseVector","text":"<pre><code>muda::DeviceDenseVector::~DeviceDenseVector () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_dense_vector.h</code></p>"},{"location":"muda/classmuda_1_1_device_doublet_vector/","title":"Class muda::DeviceDoubletVector","text":"<p>template &lt;typename T, int N&gt;</p> <p>ClassList &gt; muda &gt; DeviceDoubletVector</p> <p>Inherited by the following classes: muda::DeviceBCOOVector,  muda::DeviceBCOOVector</p>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#public-types","title":"Public Types","text":"Type Name typedef std::conditional_t&lt; N==1, T, Eigen::Vector&lt; T, N &gt; &gt; ValueT"},{"location":"muda/classmuda_1_1_device_doublet_vector/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool IsSegmentVector   = = (N &gt; 1)"},{"location":"muda/classmuda_1_1_device_doublet_vector/#public-functions","title":"Public Functions","text":"Type Name DeviceDoubletVector () = default void clear ()  auto count () const auto cview () const auto cviewer () const auto doublet_capacity () const auto doublet_count () const auto indices ()  auto indices () const void reserve_doublets (size_t nonzero_count)  void reshape (int num_segment)  void resize (int num_segment, size_t nonzero_count)  void resize_doublets (size_t nonzero_count)  auto values ()  auto values () const auto view ()  auto view () const auto viewer ()  auto viewer () const ~DeviceDoubletVector () = default"},{"location":"muda/classmuda_1_1_device_doublet_vector/#protected-attributes","title":"Protected Attributes","text":"Type Name int m_count   = = 0 muda::DeviceBuffer&lt; int &gt; m_indices muda::DeviceBuffer&lt; ValueT &gt; m_values"},{"location":"muda/classmuda_1_1_device_doublet_vector/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_doublet_vector/#typedef-valuet","title":"typedef ValueT","text":"<pre><code>using muda::DeviceDoubletVector&lt; T, N &gt;::ValueT =  std::conditional_t&lt;N == 1, T, Eigen::Vector&lt;T, N&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_device_doublet_vector/#variable-issegmentvector","title":"variable IsSegmentVector","text":"<pre><code>bool muda::DeviceDoubletVector&lt; T, N &gt;::IsSegmentVector;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-devicedoubletvector","title":"function DeviceDoubletVector","text":"<pre><code>muda::DeviceDoubletVector::DeviceDoubletVector () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-clear","title":"function clear","text":"<pre><code>inline void muda::DeviceDoubletVector::clear () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-count","title":"function count","text":"<pre><code>inline auto muda::DeviceDoubletVector::count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-cview","title":"function cview","text":"<pre><code>inline auto muda::DeviceDoubletVector::cview () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-cviewer","title":"function cviewer","text":"<pre><code>inline auto muda::DeviceDoubletVector::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-doublet_capacity","title":"function doublet_capacity","text":"<pre><code>inline auto muda::DeviceDoubletVector::doublet_capacity () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-doublet_count","title":"function doublet_count","text":"<pre><code>inline auto muda::DeviceDoubletVector::doublet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-indices-12","title":"function indices [1/2]","text":"<pre><code>inline auto muda::DeviceDoubletVector::indices () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-indices-22","title":"function indices [2/2]","text":"<pre><code>inline auto muda::DeviceDoubletVector::indices () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-reserve_doublets","title":"function reserve_doublets","text":"<pre><code>inline void muda::DeviceDoubletVector::reserve_doublets (\n    size_t nonzero_count\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-reshape","title":"function reshape","text":"<pre><code>inline void muda::DeviceDoubletVector::reshape (\n    int num_segment\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-resize","title":"function resize","text":"<pre><code>inline void muda::DeviceDoubletVector::resize (\n    int num_segment,\n    size_t nonzero_count\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-resize_doublets","title":"function resize_doublets","text":"<pre><code>inline void muda::DeviceDoubletVector::resize_doublets (\n    size_t nonzero_count\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-values-12","title":"function values [1/2]","text":"<pre><code>inline auto muda::DeviceDoubletVector::values () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-values-22","title":"function values [2/2]","text":"<pre><code>inline auto muda::DeviceDoubletVector::values () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-view-12","title":"function view [1/2]","text":"<pre><code>inline auto muda::DeviceDoubletVector::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-view-22","title":"function view [2/2]","text":"<pre><code>inline auto muda::DeviceDoubletVector::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-viewer-12","title":"function viewer [1/2]","text":"<pre><code>inline auto muda::DeviceDoubletVector::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-viewer-22","title":"function viewer [2/2]","text":"<pre><code>inline auto muda::DeviceDoubletVector::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#function-devicedoubletvector_1","title":"function ~DeviceDoubletVector","text":"<pre><code>muda::DeviceDoubletVector::~DeviceDoubletVector () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_device_doublet_vector/#variable-m_count","title":"variable m_count","text":"<pre><code>int muda::DeviceDoubletVector&lt; T, N &gt;::m_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#variable-m_indices","title":"variable m_indices","text":"<pre><code>muda::DeviceBuffer&lt;int&gt; muda::DeviceDoubletVector&lt; T, N &gt;::m_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#variable-m_values","title":"variable m_values","text":"<pre><code>muda::DeviceBuffer&lt;ValueT&gt; muda::DeviceDoubletVector&lt; T, N &gt;::m_values;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_doublet_vector/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_device_doublet_vector/#friend-matrixformatconverter","title":"friend MatrixFormatConverter","text":"<pre><code>template&lt;typename U, int M&gt;\nclass muda::DeviceDoubletVector::MatrixFormatConverter (\n    details::MatrixFormatConverter\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_doublet_vector.h</code></p>"},{"location":"muda/classmuda_1_1_device_histogram/","title":"Class muda::DeviceHistogram","text":"<p>ClassList &gt; muda &gt; DeviceHistogram</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_histogram/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_histogram/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_histogram/#public-functions","title":"Public Functions","text":"Type Name DeviceHistogram &amp; HistogramEven (SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT lower_level, LevelT upper_level, OffsetT num_samples)  DeviceHistogram &amp; HistogramEven (SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT lower_level, LevelT upper_level, OffsetT num_row_samples, OffsetT num_rows, size_t row_stride_bytes)  DeviceHistogram &amp; HistogramEven (void * d_temp_storage, size_t &amp; temp_storage_bytes, SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT lower_level, LevelT upper_level, OffsetT num_samples)  DeviceHistogram &amp; HistogramEven (void * d_temp_storage, size_t &amp; temp_storage_bytes, SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT lower_level, LevelT upper_level, OffsetT num_row_samples, OffsetT num_rows, size_t row_stride_bytes)  DeviceHistogram &amp; HistogramRange (SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT * d_levels, OffsetT num_samples)  DeviceHistogram &amp; HistogramRange (SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT * d_levels, OffsetT num_row_samples, OffsetT num_rows, size_t row_stride_bytes)  DeviceHistogram &amp; HistogramRange (void * d_temp_storage, size_t &amp; temp_storage_bytes, SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT * d_levels, OffsetT num_samples)  DeviceHistogram &amp; HistogramRange (void * d_temp_storage, size_t &amp; temp_storage_bytes, SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT * d_levels, OffsetT num_row_samples, OffsetT num_rows, size_t row_stride_bytes)  DeviceHistogram &amp; MultiHistogramEven (SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT lower_level, LevelT upper_level, OffsetT num_pixels)  DeviceHistogram &amp; MultiHistogramEven (SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT lower_level, LevelT upper_level, OffsetT num_row_pixels, OffsetT num_rows, size_t row_stride_bytes)  DeviceHistogram &amp; MultiHistogramEven (void * d_temp_storage, size_t &amp; temp_storage_bytes, SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT lower_level, LevelT upper_level, OffsetT num_pixels)  DeviceHistogram &amp; MultiHistogramEven (void * d_temp_storage, size_t &amp; temp_storage_bytes, SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT lower_level, LevelT upper_level, OffsetT num_row_pixels, OffsetT num_rows, size_t row_stride_bytes)  DeviceHistogram &amp; MultiHistogramRange (SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT * d_levels, OffsetT num_pixels)  DeviceHistogram &amp; MultiHistogramRange (SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT * d_levels, OffsetT num_row_pixels, OffsetT num_rows, size_t row_stride_bytes)  DeviceHistogram &amp; MultiHistogramRange (void * d_temp_storage, size_t &amp; temp_storage_bytes, SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT * d_levels, OffsetT num_pixels)  DeviceHistogram &amp; MultiHistogramRange (void * d_temp_storage, size_t &amp; temp_storage_bytes, SampleIteratorT d_samples, CounterT * d_histogram, int num_levels, LevelT * d_levels, OffsetT num_row_pixels, OffsetT num_rows, size_t row_stride_bytes)"},{"location":"muda/classmuda_1_1_device_histogram/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_histogram/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_histogram/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_histogram/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_histogram/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_histogram/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_histogram/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_histogram/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_histogram/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_histogram/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_histogram/#function-histogrameven-14","title":"function HistogramEven [1/4]","text":"<pre><code>template&lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::HistogramEven (\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT lower_level,\n    LevelT upper_level,\n    OffsetT num_samples\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-histogrameven-24","title":"function HistogramEven [2/4]","text":"<pre><code>template&lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::HistogramEven (\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT lower_level,\n    LevelT upper_level,\n    OffsetT num_row_samples,\n    OffsetT num_rows,\n    size_t row_stride_bytes\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-histogrameven-34","title":"function HistogramEven [3/4]","text":"<pre><code>template&lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::HistogramEven (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT lower_level,\n    LevelT upper_level,\n    OffsetT num_samples\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-histogrameven-44","title":"function HistogramEven [4/4]","text":"<pre><code>template&lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::HistogramEven (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT lower_level,\n    LevelT upper_level,\n    OffsetT num_row_samples,\n    OffsetT num_rows,\n    size_t row_stride_bytes\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-histogramrange-14","title":"function HistogramRange [1/4]","text":"<pre><code>template&lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::HistogramRange (\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT * d_levels,\n    OffsetT num_samples\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-histogramrange-24","title":"function HistogramRange [2/4]","text":"<pre><code>template&lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::HistogramRange (\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT * d_levels,\n    OffsetT num_row_samples,\n    OffsetT num_rows,\n    size_t row_stride_bytes\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-histogramrange-34","title":"function HistogramRange [3/4]","text":"<pre><code>template&lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::HistogramRange (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT * d_levels,\n    OffsetT num_samples\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-histogramrange-44","title":"function HistogramRange [4/4]","text":"<pre><code>template&lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::HistogramRange (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT * d_levels,\n    OffsetT num_row_samples,\n    OffsetT num_rows,\n    size_t row_stride_bytes\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-multihistogrameven-14","title":"function MultiHistogramEven [1/4]","text":"<pre><code>template&lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::MultiHistogramEven (\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT lower_level,\n    LevelT upper_level,\n    OffsetT num_pixels\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-multihistogrameven-24","title":"function MultiHistogramEven [2/4]","text":"<pre><code>template&lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::MultiHistogramEven (\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT lower_level,\n    LevelT upper_level,\n    OffsetT num_row_pixels,\n    OffsetT num_rows,\n    size_t row_stride_bytes\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-multihistogrameven-34","title":"function MultiHistogramEven [3/4]","text":"<pre><code>template&lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::MultiHistogramEven (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT lower_level,\n    LevelT upper_level,\n    OffsetT num_pixels\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-multihistogrameven-44","title":"function MultiHistogramEven [4/4]","text":"<pre><code>template&lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::MultiHistogramEven (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT lower_level,\n    LevelT upper_level,\n    OffsetT num_row_pixels,\n    OffsetT num_rows,\n    size_t row_stride_bytes\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-multihistogramrange-14","title":"function MultiHistogramRange [1/4]","text":"<pre><code>template&lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::MultiHistogramRange (\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT * d_levels,\n    OffsetT num_pixels\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-multihistogramrange-24","title":"function MultiHistogramRange [2/4]","text":"<pre><code>template&lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::MultiHistogramRange (\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT * d_levels,\n    OffsetT num_row_pixels,\n    OffsetT num_rows,\n    size_t row_stride_bytes\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-multihistogramrange-34","title":"function MultiHistogramRange [3/4]","text":"<pre><code>template&lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::MultiHistogramRange (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT * d_levels,\n    OffsetT num_pixels\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_histogram/#function-multihistogramrange-44","title":"function MultiHistogramRange [4/4]","text":"<pre><code>template&lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\ninline DeviceHistogram &amp; muda::DeviceHistogram::MultiHistogramRange (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    SampleIteratorT d_samples,\n    CounterT * d_histogram,\n    int num_levels,\n    LevelT * d_levels,\n    OffsetT num_row_pixels,\n    OffsetT num_rows,\n    size_t row_stride_bytes\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_histogram.h</code></p>"},{"location":"muda/classmuda_1_1_device_merge_sort/","title":"Class muda::DeviceMergeSort","text":"<p>ClassList &gt; muda &gt; DeviceMergeSort</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_merge_sort/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_merge_sort/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_merge_sort/#public-functions","title":"Public Functions","text":"Type Name DeviceMergeSort &amp; SortKeys (KeyIteratorT d_keys, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; SortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeyIteratorT d_keys, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; SortKeysCopy (KeyInputIteratorT d_input_keys, KeyIteratorT d_output_keys, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; SortKeysCopy (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeyInputIteratorT d_input_keys, KeyIteratorT d_output_keys, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; SortPairs (KeyIteratorT d_keys, ValueIteratorT d_items, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; SortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeyIteratorT d_keys, ValueIteratorT d_items, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; SortPairsCopy (KeyInputIteratorT d_input_keys, ValueInputIteratorT d_input_items, KeyIteratorT d_output_keys, ValueIteratorT d_output_items, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; SortPairsCopy (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeyInputIteratorT d_input_keys, ValueInputIteratorT d_input_items, KeyIteratorT d_output_keys, ValueIteratorT d_output_items, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; StableSortKeys (KeyIteratorT d_keys, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; StableSortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeyIteratorT d_keys, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; StableSortPairs (KeyIteratorT d_keys, ValueIteratorT d_items, OffsetT num_items, CompareOpT compare_op)  DeviceMergeSort &amp; StableSortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeyIteratorT d_keys, ValueIteratorT d_items, OffsetT num_items, CompareOpT compare_op)"},{"location":"muda/classmuda_1_1_device_merge_sort/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_merge_sort/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_merge_sort/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_merge_sort/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_merge_sort/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_merge_sort/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_merge_sort/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_merge_sort/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_merge_sort/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_merge_sort/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_merge_sort/#function-sortkeys-12","title":"function SortKeys [1/2]","text":"<pre><code>template&lt;typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::SortKeys (\n    KeyIteratorT d_keys,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-sortkeys-22","title":"function SortKeys [2/2]","text":"<pre><code>template&lt;typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::SortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeyIteratorT d_keys,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-sortkeyscopy-12","title":"function SortKeysCopy [1/2]","text":"<pre><code>template&lt;typename KeyInputIteratorT, typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::SortKeysCopy (\n    KeyInputIteratorT d_input_keys,\n    KeyIteratorT d_output_keys,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-sortkeyscopy-22","title":"function SortKeysCopy [2/2]","text":"<pre><code>template&lt;typename KeyInputIteratorT, typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::SortKeysCopy (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeyInputIteratorT d_input_keys,\n    KeyIteratorT d_output_keys,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-sortpairs-12","title":"function SortPairs [1/2]","text":"<pre><code>template&lt;typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::SortPairs (\n    KeyIteratorT d_keys,\n    ValueIteratorT d_items,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-sortpairs-22","title":"function SortPairs [2/2]","text":"<pre><code>template&lt;typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::SortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeyIteratorT d_keys,\n    ValueIteratorT d_items,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-sortpairscopy-12","title":"function SortPairsCopy [1/2]","text":"<pre><code>template&lt;typename KeyInputIteratorT, typename ValueInputIteratorT, typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::SortPairsCopy (\n    KeyInputIteratorT d_input_keys,\n    ValueInputIteratorT d_input_items,\n    KeyIteratorT d_output_keys,\n    ValueIteratorT d_output_items,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-sortpairscopy-22","title":"function SortPairsCopy [2/2]","text":"<pre><code>template&lt;typename KeyInputIteratorT, typename ValueInputIteratorT, typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::SortPairsCopy (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeyInputIteratorT d_input_keys,\n    ValueInputIteratorT d_input_items,\n    KeyIteratorT d_output_keys,\n    ValueIteratorT d_output_items,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-stablesortkeys-12","title":"function StableSortKeys [1/2]","text":"<pre><code>template&lt;typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::StableSortKeys (\n    KeyIteratorT d_keys,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-stablesortkeys-22","title":"function StableSortKeys [2/2]","text":"<pre><code>template&lt;typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::StableSortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeyIteratorT d_keys,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-stablesortpairs-12","title":"function StableSortPairs [1/2]","text":"<pre><code>template&lt;typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::StableSortPairs (\n    KeyIteratorT d_keys,\n    ValueIteratorT d_items,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_merge_sort/#function-stablesortpairs-22","title":"function StableSortPairs [2/2]","text":"<pre><code>template&lt;typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\ninline DeviceMergeSort &amp; muda::DeviceMergeSort::StableSortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeyIteratorT d_keys,\n    ValueIteratorT d_items,\n    OffsetT num_items,\n    CompareOpT compare_op\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_merge_sort.h</code></p>"},{"location":"muda/classmuda_1_1_device_partition/","title":"Class muda::DevicePartition","text":"<p>ClassList &gt; muda &gt; DevicePartition</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_partition/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_partition/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_partition/#public-functions","title":"Public Functions","text":"Type Name DevicePartition &amp; Flagged (InputIteratorT d_in, FlagIterator d_flags, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items)  DevicePartition &amp; Flagged (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, FlagIterator d_flags, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items)  DevicePartition &amp; If (InputIteratorT d_in, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items, SelectOp select_op)  DevicePartition &amp; If (InputIteratorT d_in, FirstOutputIteratorT d_first_part_out, SecondOutputIteratorT d_second_part_out, UnselectedOutputIteratorT d_unselected_out, NumSelectedIteratorT d_num_selected_out, int num_items, SelectFirstPartOp select_first_part_op, SelectSecondPartOp select_second_part_op)  DevicePartition &amp; If (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items, SelectOp select_op)  DevicePartition &amp; If (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, FirstOutputIteratorT d_first_part_out, SecondOutputIteratorT d_second_part_out, UnselectedOutputIteratorT d_unselected_out, NumSelectedIteratorT d_num_selected_out, int num_items, SelectFirstPartOp select_first_part_op, SelectSecondPartOp select_second_part_op)"},{"location":"muda/classmuda_1_1_device_partition/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_partition/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_partition/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_partition/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_partition/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_partition/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_partition/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_partition/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_partition/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_partition/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_partition/#function-flagged-12","title":"function Flagged [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename FlagIterator, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\ninline DevicePartition &amp; muda::DevicePartition::Flagged (\n    InputIteratorT d_in,\n    FlagIterator d_flags,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_partition/#function-flagged-22","title":"function Flagged [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename FlagIterator, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\ninline DevicePartition &amp; muda::DevicePartition::Flagged (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    FlagIterator d_flags,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_partition/#function-if-14","title":"function If [1/4]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT, typename SelectOp&gt;\ninline DevicePartition &amp; muda::DevicePartition::If (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items,\n    SelectOp select_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_partition/#function-if-24","title":"function If [2/4]","text":"<pre><code>template&lt;typename InputIteratorT, typename FirstOutputIteratorT, typename SecondOutputIteratorT, typename UnselectedOutputIteratorT, typename NumSelectedIteratorT, typename SelectFirstPartOp, typename SelectSecondPartOp&gt;\ninline DevicePartition &amp; muda::DevicePartition::If (\n    InputIteratorT d_in,\n    FirstOutputIteratorT d_first_part_out,\n    SecondOutputIteratorT d_second_part_out,\n    UnselectedOutputIteratorT d_unselected_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items,\n    SelectFirstPartOp select_first_part_op,\n    SelectSecondPartOp select_second_part_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_partition/#function-if-34","title":"function If [3/4]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT, typename SelectOp&gt;\ninline DevicePartition &amp; muda::DevicePartition::If (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items,\n    SelectOp select_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_partition/#function-if-44","title":"function If [4/4]","text":"<pre><code>template&lt;typename InputIteratorT, typename FirstOutputIteratorT, typename SecondOutputIteratorT, typename UnselectedOutputIteratorT, typename NumSelectedIteratorT, typename SelectFirstPartOp, typename SelectSecondPartOp&gt;\ninline DevicePartition &amp; muda::DevicePartition::If (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    FirstOutputIteratorT d_first_part_out,\n    SecondOutputIteratorT d_second_part_out,\n    UnselectedOutputIteratorT d_unselected_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items,\n    SelectFirstPartOp select_first_part_op,\n    SelectSecondPartOp select_second_part_op\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_partition.h</code></p>"},{"location":"muda/classmuda_1_1_device_radix_sort/","title":"Class muda::DeviceRadixSort","text":"<p>ClassList &gt; muda &gt; DeviceRadixSort</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_radix_sort/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_radix_sort/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_radix_sort/#public-functions","title":"Public Functions","text":"Type Name DeviceRadixSort &amp; SortKeys (const KeyT * d_keys_in, KeyT * d_keys_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortKeys (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortKeysDescending (const KeyT * d_keys_in, KeyT * d_keys_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortKeysDescending (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortKeysDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortKeysDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortPairs (const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortPairs (DeviceVector&lt; std::byte &gt; &amp; external_buffer, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortPairsDescending (const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortPairsDescending (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortPairsDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)  DeviceRadixSort &amp; SortPairsDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT) *8)"},{"location":"muda/classmuda_1_1_device_radix_sort/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_radix_sort/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_radix_sort/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_radix_sort/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_radix_sort/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_radix_sort/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_radix_sort/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_radix_sort/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_radix_sort/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_radix_sort/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortkeys-14","title":"function SortKeys [1/4]","text":"<pre><code>template&lt;typename KeyT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortKeys (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortkeys-24","title":"function SortKeys [2/4]","text":"<pre><code>template&lt;typename KeyT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortKeys (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortkeys-34","title":"function SortKeys [3/4]","text":"<pre><code>template&lt;typename KeyT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortkeys-44","title":"function SortKeys [4/4]","text":"<pre><code>template&lt;typename KeyT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortkeysdescending-14","title":"function SortKeysDescending [1/4]","text":"<pre><code>template&lt;typename KeyT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortKeysDescending (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortkeysdescending-24","title":"function SortKeysDescending [2/4]","text":"<pre><code>template&lt;typename KeyT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortKeysDescending (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortkeysdescending-34","title":"function SortKeysDescending [3/4]","text":"<pre><code>template&lt;typename KeyT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortKeysDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortkeysdescending-44","title":"function SortKeysDescending [4/4]","text":"<pre><code>template&lt;typename KeyT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortKeysDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortpairs-14","title":"function SortPairs [1/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortPairs (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortpairs-24","title":"function SortPairs [2/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortPairs (\n    DeviceVector &lt; std::byte &gt; &amp; external_buffer,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortpairs-34","title":"function SortPairs [3/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortpairs-44","title":"function SortPairs [4/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortpairsdescending-14","title":"function SortPairsDescending [1/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortPairsDescending (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortpairsdescending-24","title":"function SortPairsDescending [2/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortPairsDescending (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortpairsdescending-34","title":"function SortPairsDescending [3/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortPairsDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_radix_sort/#function-sortpairsdescending-44","title":"function SortPairsDescending [4/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\ninline DeviceRadixSort &amp; muda::DeviceRadixSort::SortPairsDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    NumItemsT num_items,\n    int begin_bit=0,\n    int end_bit=sizeof(KeyT) *8\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_radix_sort.h</code></p>"},{"location":"muda/classmuda_1_1_device_reduce/","title":"Class muda::DeviceReduce","text":"<p>ClassList &gt; muda &gt; DeviceReduce</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_reduce/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_reduce/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_reduce/#public-functions","title":"Public Functions","text":"Type Name DeviceReduce &amp; ArgMax (InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceReduce &amp; ArgMax (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceReduce &amp; ArgMin (InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceReduce &amp; ArgMin (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceReduce &amp; Max (InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceReduce &amp; Max (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceReduce &amp; Min (InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceReduce &amp; Min (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceReduce &amp; Reduce (InputIteratorT d_in, OutputIteratorT d_out, int num_items, ReductionOpT reduction_op, T init)  DeviceReduce &amp; Reduce (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_items, ReductionOpT reduction_op, T init)  DeviceReduce &amp; ReduceByKey (KeysInputIteratorT d_keys_in, UniqueOutputIteratorT d_unique_out, ValuesInputIteratorT d_values_in, AggregatesOutputIteratorT d_aggregates_out, NumRunsOutputIteratorT d_num_runs_out, ReductionOpT reduction_op, int num_items)  DeviceReduce &amp; ReduceByKey (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeysInputIteratorT d_keys_in, UniqueOutputIteratorT d_unique_out, ValuesInputIteratorT d_values_in, AggregatesOutputIteratorT d_aggregates_out, NumRunsOutputIteratorT d_num_runs_out, ReductionOpT reduction_op, int num_items)  DeviceReduce &amp; Sum (InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceReduce &amp; Sum (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_items)"},{"location":"muda/classmuda_1_1_device_reduce/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_reduce/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_reduce/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_reduce/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_reduce/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_reduce/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_reduce/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_reduce/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_reduce/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_reduce/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_reduce/#function-argmax-12","title":"function ArgMax [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::ArgMax (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-argmax-22","title":"function ArgMax [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::ArgMax (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-argmin-12","title":"function ArgMin [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::ArgMin (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-argmin-22","title":"function ArgMin [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::ArgMin (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-max-12","title":"function Max [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::Max (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-max-22","title":"function Max [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::Max (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-min-12","title":"function Min [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::Min (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-min-22","title":"function Min [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::Min (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-reduce-12","title":"function Reduce [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename ReductionOpT, typename T&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::Reduce (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items,\n    ReductionOpT reduction_op,\n    T init\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-reduce-22","title":"function Reduce [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename ReductionOpT, typename T&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::Reduce (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items,\n    ReductionOpT reduction_op,\n    T init\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-reducebykey-12","title":"function ReduceByKey [1/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename UniqueOutputIteratorT, typename ValuesInputIteratorT, typename AggregatesOutputIteratorT, typename NumRunsOutputIteratorT, typename ReductionOpT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::ReduceByKey (\n    KeysInputIteratorT d_keys_in,\n    UniqueOutputIteratorT d_unique_out,\n    ValuesInputIteratorT d_values_in,\n    AggregatesOutputIteratorT d_aggregates_out,\n    NumRunsOutputIteratorT d_num_runs_out,\n    ReductionOpT reduction_op,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-reducebykey-22","title":"function ReduceByKey [2/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename UniqueOutputIteratorT, typename ValuesInputIteratorT, typename AggregatesOutputIteratorT, typename NumRunsOutputIteratorT, typename ReductionOpT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::ReduceByKey (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeysInputIteratorT d_keys_in,\n    UniqueOutputIteratorT d_unique_out,\n    ValuesInputIteratorT d_values_in,\n    AggregatesOutputIteratorT d_aggregates_out,\n    NumRunsOutputIteratorT d_num_runs_out,\n    ReductionOpT reduction_op,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-sum-12","title":"function Sum [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::Sum (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_reduce/#function-sum-22","title":"function Sum [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceReduce &amp; muda::DeviceReduce::Sum (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_reduce.h</code></p>"},{"location":"muda/classmuda_1_1_device_run_length_encode/","title":"Class muda::DeviceRunLengthEncode","text":"<p>ClassList &gt; muda &gt; DeviceRunLengthEncode</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_run_length_encode/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_run_length_encode/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_run_length_encode/#public-functions","title":"Public Functions","text":"Type Name DeviceRunLengthEncode &amp; Encode (InputIteratorT d_in, UniqueOutputIteratorT d_unique_out, LengthsOutputIteratorT d_counts_out, NumRunsOutputIteratorT d_num_runs_out, int num_items)  DeviceRunLengthEncode &amp; Encode (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, UniqueOutputIteratorT d_unique_out, LengthsOutputIteratorT d_counts_out, NumRunsOutputIteratorT d_num_runs_out, int num_items)  DeviceRunLengthEncode &amp; NonTrivialRuns (InputIteratorT d_in, OffsetsOutputIteratorT d_offsets_out, LengthsOutputIteratorT d_lengths_out, NumRunsOutputIteratorT d_num_runs_out, int num_items)  DeviceRunLengthEncode &amp; NonTrivialRuns (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OffsetsOutputIteratorT d_offsets_out, LengthsOutputIteratorT d_lengths_out, NumRunsOutputIteratorT d_num_runs_out, int num_items)"},{"location":"muda/classmuda_1_1_device_run_length_encode/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_run_length_encode/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_run_length_encode/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_run_length_encode/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_run_length_encode/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_run_length_encode/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_run_length_encode/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_run_length_encode/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_run_length_encode/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_run_length_encode/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_run_length_encode/#function-encode-12","title":"function Encode [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename UniqueOutputIteratorT, typename LengthsOutputIteratorT, typename NumRunsOutputIteratorT&gt;\ninline DeviceRunLengthEncode &amp; muda::DeviceRunLengthEncode::Encode (\n    InputIteratorT d_in,\n    UniqueOutputIteratorT d_unique_out,\n    LengthsOutputIteratorT d_counts_out,\n    NumRunsOutputIteratorT d_num_runs_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_run_length_encode/#function-encode-22","title":"function Encode [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename UniqueOutputIteratorT, typename LengthsOutputIteratorT, typename NumRunsOutputIteratorT&gt;\ninline DeviceRunLengthEncode &amp; muda::DeviceRunLengthEncode::Encode (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    UniqueOutputIteratorT d_unique_out,\n    LengthsOutputIteratorT d_counts_out,\n    NumRunsOutputIteratorT d_num_runs_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_run_length_encode/#function-nontrivialruns-12","title":"function NonTrivialRuns [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OffsetsOutputIteratorT, typename LengthsOutputIteratorT, typename NumRunsOutputIteratorT&gt;\ninline DeviceRunLengthEncode &amp; muda::DeviceRunLengthEncode::NonTrivialRuns (\n    InputIteratorT d_in,\n    OffsetsOutputIteratorT d_offsets_out,\n    LengthsOutputIteratorT d_lengths_out,\n    NumRunsOutputIteratorT d_num_runs_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_run_length_encode/#function-nontrivialruns-22","title":"function NonTrivialRuns [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OffsetsOutputIteratorT, typename LengthsOutputIteratorT, typename NumRunsOutputIteratorT&gt;\ninline DeviceRunLengthEncode &amp; muda::DeviceRunLengthEncode::NonTrivialRuns (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OffsetsOutputIteratorT d_offsets_out,\n    LengthsOutputIteratorT d_lengths_out,\n    NumRunsOutputIteratorT d_num_runs_out,\n    int num_items\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_run_length_encode.h</code></p>"},{"location":"muda/classmuda_1_1_device_scan/","title":"Class muda::DeviceScan","text":"<p>ClassList &gt; muda &gt; DeviceScan</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_scan/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_scan/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_scan/#public-functions","title":"Public Functions","text":"Type Name DeviceScan &amp; ExclusiveScan (InputIteratorT d_in, OutputIteratorT d_out, ScanOpT scan_op, InitValueT init_value, int num_items)  DeviceScan &amp; ExclusiveScan (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, ScanOpT scan_op, InitValueT init_value, int num_items)  DeviceScan &amp; ExclusiveScanByKey (KeysInputIteratorT d_keys_in, ValuesInputIteratorT d_values_in, ValuesOutputIteratorT d_values_out, ScanOpT scan_op, InitValueT init_value, int num_items, EqualityOpT equality_op=EqualityOpT())  DeviceScan &amp; ExclusiveScanByKey (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeysInputIteratorT d_keys_in, ValuesInputIteratorT d_values_in, ValuesOutputIteratorT d_values_out, ScanOpT scan_op, InitValueT init_value, int num_items, EqualityOpT equality_op=EqualityOpT())  DeviceScan &amp; ExclusiveSum (InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceScan &amp; ExclusiveSum (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceScan &amp; ExclusiveSumByKey (KeysInputIteratorT d_keys_in, ValuesInputIteratorT d_values_in, ValuesOutputIteratorT d_values_out, int num_items, EqualityOpT equality_op=EqualityOpT())  DeviceScan &amp; ExclusiveSumByKey (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeysInputIteratorT d_keys_in, ValuesInputIteratorT d_values_in, ValuesOutputIteratorT d_values_out, int num_items, EqualityOpT equality_op=EqualityOpT())  DeviceScan &amp; InclusiveScan (InputIteratorT d_in, OutputIteratorT d_out, ScanOpT scan_op, int num_items)  DeviceScan &amp; InclusiveScan (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, ScanOpT scan_op, int num_items)  DeviceScan &amp; InclusiveScanByKey (KeysInputIteratorT d_keys_in, ValuesInputIteratorT d_values_in, ValuesOutputIteratorT d_values_out, ScanOpT scan_op, int num_items, EqualityOpT equality_op=EqualityOpT())  DeviceScan &amp; InclusiveScanByKey (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeysInputIteratorT d_keys_in, ValuesInputIteratorT d_values_in, ValuesOutputIteratorT d_values_out, ScanOpT scan_op, int num_items, EqualityOpT equality_op=EqualityOpT())  DeviceScan &amp; InclusiveSum (InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceScan &amp; InclusiveSum (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceScan &amp; InclusiveSumByKey (KeysInputIteratorT d_keys_in, ValuesInputIteratorT d_values_in, ValuesOutputIteratorT d_values_out, int num_items, EqualityOpT equality_op=EqualityOpT())  DeviceScan &amp; InclusiveSumByKey (void * d_temp_storage, size_t &amp; temp_storage_bytes, KeysInputIteratorT d_keys_in, ValuesInputIteratorT d_values_in, ValuesOutputIteratorT d_values_out, int num_items, EqualityOpT equality_op=EqualityOpT())"},{"location":"muda/classmuda_1_1_device_scan/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_scan/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_scan/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_scan/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_scan/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_scan/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_scan/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_scan/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_scan/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_scan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_scan/#function-exclusivescan-12","title":"function ExclusiveScan [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename ScanOpT, typename InitValueT&gt;\ninline DeviceScan &amp; muda::DeviceScan::ExclusiveScan (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    ScanOpT scan_op,\n    InitValueT init_value,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-exclusivescan-22","title":"function ExclusiveScan [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename ScanOpT, typename InitValueT&gt;\ninline DeviceScan &amp; muda::DeviceScan::ExclusiveScan (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    ScanOpT scan_op,\n    InitValueT init_value,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-exclusivescanbykey-12","title":"function ExclusiveScanByKey [1/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename ScanOpT, typename InitValueT, typename EqualityOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::ExclusiveScanByKey (\n    KeysInputIteratorT d_keys_in,\n    ValuesInputIteratorT d_values_in,\n    ValuesOutputIteratorT d_values_out,\n    ScanOpT scan_op,\n    InitValueT init_value,\n    int num_items,\n    EqualityOpT equality_op=EqualityOpT()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-exclusivescanbykey-22","title":"function ExclusiveScanByKey [2/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename ScanOpT, typename InitValueT, typename EqualityOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::ExclusiveScanByKey (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeysInputIteratorT d_keys_in,\n    ValuesInputIteratorT d_values_in,\n    ValuesOutputIteratorT d_values_out,\n    ScanOpT scan_op,\n    InitValueT init_value,\n    int num_items,\n    EqualityOpT equality_op=EqualityOpT()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-exclusivesum-12","title":"function ExclusiveSum [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceScan &amp; muda::DeviceScan::ExclusiveSum (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-exclusivesum-22","title":"function ExclusiveSum [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceScan &amp; muda::DeviceScan::ExclusiveSum (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-exclusivesumbykey-12","title":"function ExclusiveSumByKey [1/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename EqualityOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::ExclusiveSumByKey (\n    KeysInputIteratorT d_keys_in,\n    ValuesInputIteratorT d_values_in,\n    ValuesOutputIteratorT d_values_out,\n    int num_items,\n    EqualityOpT equality_op=EqualityOpT()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-exclusivesumbykey-22","title":"function ExclusiveSumByKey [2/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename EqualityOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::ExclusiveSumByKey (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeysInputIteratorT d_keys_in,\n    ValuesInputIteratorT d_values_in,\n    ValuesOutputIteratorT d_values_out,\n    int num_items,\n    EqualityOpT equality_op=EqualityOpT()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-inclusivescan-12","title":"function InclusiveScan [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename ScanOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::InclusiveScan (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    ScanOpT scan_op,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-inclusivescan-22","title":"function InclusiveScan [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename ScanOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::InclusiveScan (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    ScanOpT scan_op,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-inclusivescanbykey-12","title":"function InclusiveScanByKey [1/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename ScanOpT, typename EqualityOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::InclusiveScanByKey (\n    KeysInputIteratorT d_keys_in,\n    ValuesInputIteratorT d_values_in,\n    ValuesOutputIteratorT d_values_out,\n    ScanOpT scan_op,\n    int num_items,\n    EqualityOpT equality_op=EqualityOpT()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-inclusivescanbykey-22","title":"function InclusiveScanByKey [2/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename ScanOpT, typename EqualityOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::InclusiveScanByKey (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeysInputIteratorT d_keys_in,\n    ValuesInputIteratorT d_values_in,\n    ValuesOutputIteratorT d_values_out,\n    ScanOpT scan_op,\n    int num_items,\n    EqualityOpT equality_op=EqualityOpT()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-inclusivesum-12","title":"function InclusiveSum [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceScan &amp; muda::DeviceScan::InclusiveSum (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-inclusivesum-22","title":"function InclusiveSum [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceScan &amp; muda::DeviceScan::InclusiveSum (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-inclusivesumbykey-12","title":"function InclusiveSumByKey [1/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename EqualityOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::InclusiveSumByKey (\n    KeysInputIteratorT d_keys_in,\n    ValuesInputIteratorT d_values_in,\n    ValuesOutputIteratorT d_values_out,\n    int num_items,\n    EqualityOpT equality_op=EqualityOpT()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_scan/#function-inclusivesumbykey-22","title":"function InclusiveSumByKey [2/2]","text":"<pre><code>template&lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename EqualityOpT&gt;\ninline DeviceScan &amp; muda::DeviceScan::InclusiveSumByKey (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    KeysInputIteratorT d_keys_in,\n    ValuesInputIteratorT d_values_in,\n    ValuesOutputIteratorT d_values_out,\n    int num_items,\n    EqualityOpT equality_op=EqualityOpT()\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_scan.h</code></p>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/","title":"Class muda::DeviceSegmentedRadixSort","text":"<p>ClassList &gt; muda &gt; DeviceSegmentedRadixSort</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#public-functions","title":"Public Functions","text":"Type Name DeviceSegmentedRadixSort &amp; SortKeys (const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortKeys (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortKeysDescending (const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortKeysDescending (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortKeysDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortKeysDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortPairs (const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortPairs (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortPairsDescending (const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortPairsDescending (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortPairsDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)  DeviceSegmentedRadixSort &amp; SortPairsDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit, int end_bit)"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortkeys-14","title":"function SortKeys [1/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortKeys (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortkeys-24","title":"function SortKeys [2/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortKeys (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortkeys-34","title":"function SortKeys [3/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortkeys-44","title":"function SortKeys [4/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortkeysdescending-14","title":"function SortKeysDescending [1/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortKeysDescending (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortkeysdescending-24","title":"function SortKeysDescending [2/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortKeysDescending (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortkeysdescending-34","title":"function SortKeysDescending [3/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortKeysDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortkeysdescending-44","title":"function SortKeysDescending [4/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortKeysDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortpairs-14","title":"function SortPairs [1/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortPairs (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortpairs-24","title":"function SortPairs [2/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortPairs (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortpairs-34","title":"function SortPairs [3/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortpairs-44","title":"function SortPairs [4/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortpairsdescending-14","title":"function SortPairsDescending [1/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortPairsDescending (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortpairsdescending-24","title":"function SortPairsDescending [2/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortPairsDescending (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortpairsdescending-34","title":"function SortPairsDescending [3/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortPairsDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_radix_sort/#function-sortpairsdescending-44","title":"function SortPairsDescending [4/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedRadixSort &amp; muda::DeviceSegmentedRadixSort::SortPairsDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    int begin_bit,\n    int end_bit\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_segmented_radix_sort.h</code></p>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/","title":"Class muda::DeviceSegmentedReduce","text":"<p>ClassList &gt; muda &gt; DeviceSegmentedReduce</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#public-functions","title":"Public Functions","text":"Type Name DeviceSegmentedReduce &amp; ArgMax (InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedReduce &amp; ArgMax (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_items)  DeviceSegmentedReduce &amp; ArgMax (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedReduce &amp; ArgMin (InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedReduce &amp; ArgMin (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedReduce &amp; Max (InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedReduce &amp; Max (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedReduce &amp; Min (InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedReduce &amp; Min (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedReduce &amp; Reduce (InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, ReductionOp reduction_op, T initial_value)  DeviceSegmentedReduce &amp; Reduce (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, ReductionOp reduction_op, T initial_value)  DeviceSegmentedReduce &amp; Sum (InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedReduce &amp; Sum (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-argmax-13","title":"function ArgMax [1/3]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::ArgMax (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-argmax-23","title":"function ArgMax [2/3]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::ArgMax (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-argmax-33","title":"function ArgMax [3/3]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::ArgMax (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-argmin-12","title":"function ArgMin [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::ArgMin (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-argmin-22","title":"function ArgMin [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::ArgMin (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-max-12","title":"function Max [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::Max (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-max-22","title":"function Max [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::Max (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-min-12","title":"function Min [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::Min (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-min-22","title":"function Min [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::Min (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-reduce-12","title":"function Reduce [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT, typename ReductionOp, typename T&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::Reduce (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    ReductionOp reduction_op,\n    T initial_value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-reduce-22","title":"function Reduce [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT, typename ReductionOp, typename T&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::Reduce (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets,\n    ReductionOp reduction_op,\n    T initial_value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-sum-12","title":"function Sum [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::Sum (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_reduce/#function-sum-22","title":"function Sum [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedReduce &amp; muda::DeviceSegmentedReduce::Sum (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_segmented_reduce.h</code></p>"},{"location":"muda/classmuda_1_1_device_segmented_sort/","title":"Class muda::DeviceSegmentedSort","text":"<p>ClassList &gt; muda &gt; DeviceSegmentedSort</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_segmented_sort/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_segmented_sort/#public-functions","title":"Public Functions","text":"Type Name DeviceSegmentedSort &amp; SortKeys (const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortKeys (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortKeysDescending (const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortKeysDescending (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortKeysDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortKeysDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortPairs (const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortPairs (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortPairsDescending (const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortPairsDescending (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortPairsDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; SortPairsDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortKeys (const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortKeys (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortKeys (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortKeysDescending (const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortKeysDescending (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortKeysDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortKeysDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortPairs (const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortPairs (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortPairs (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortPairsDescending (const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortPairsDescending (cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortPairsDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, const KeyT * d_keys_in, KeyT * d_keys_out, const ValueT * d_values_in, ValueT * d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)  DeviceSegmentedSort &amp; StableSortPairsDescending (void * d_temp_storage, size_t &amp; temp_storage_bytes, cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys, cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets)"},{"location":"muda/classmuda_1_1_device_segmented_sort/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_segmented_sort/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_segmented_sort/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_segmented_sort/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_segmented_sort/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_segmented_sort/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_segmented_sort/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_segmented_sort/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_segmented_sort/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_segmented_sort/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortkeys-14","title":"function SortKeys [1/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortKeys (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortkeys-24","title":"function SortKeys [2/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortKeys (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortkeys-34","title":"function SortKeys [3/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortkeys-44","title":"function SortKeys [4/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortkeysdescending-14","title":"function SortKeysDescending [1/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortKeysDescending (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortkeysdescending-24","title":"function SortKeysDescending [2/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortKeysDescending (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortkeysdescending-34","title":"function SortKeysDescending [3/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortKeysDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortkeysdescending-44","title":"function SortKeysDescending [4/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortKeysDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortpairs-14","title":"function SortPairs [1/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortPairs (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortpairs-24","title":"function SortPairs [2/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortPairs (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortpairs-34","title":"function SortPairs [3/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortpairs-44","title":"function SortPairs [4/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortpairsdescending-14","title":"function SortPairsDescending [1/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortPairsDescending (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortpairsdescending-24","title":"function SortPairsDescending [2/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortPairsDescending (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortpairsdescending-34","title":"function SortPairsDescending [3/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortPairsDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-sortpairsdescending-44","title":"function SortPairsDescending [4/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::SortPairsDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortkeys-14","title":"function StableSortKeys [1/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortKeys (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortkeys-24","title":"function StableSortKeys [2/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortKeys (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortkeys-34","title":"function StableSortKeys [3/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortkeys-44","title":"function StableSortKeys [4/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortKeys (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortkeysdescending-14","title":"function StableSortKeysDescending [1/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortKeysDescending (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortkeysdescending-24","title":"function StableSortKeysDescending [2/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortKeysDescending (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortkeysdescending-34","title":"function StableSortKeysDescending [3/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortKeysDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortkeysdescending-44","title":"function StableSortKeysDescending [4/4]","text":"<pre><code>template&lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortKeysDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortpairs-14","title":"function StableSortPairs [1/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortPairs (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortpairs-24","title":"function StableSortPairs [2/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortPairs (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortpairs-34","title":"function StableSortPairs [3/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortpairs-44","title":"function StableSortPairs [4/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortPairs (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortpairsdescending-14","title":"function StableSortPairsDescending [1/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortPairsDescending (\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortpairsdescending-24","title":"function StableSortPairsDescending [2/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortPairsDescending (\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortpairsdescending-34","title":"function StableSortPairsDescending [3/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortPairsDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const KeyT * d_keys_in,\n    KeyT * d_keys_out,\n    const ValueT * d_values_in,\n    ValueT * d_values_out,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_segmented_sort/#function-stablesortpairsdescending-44","title":"function StableSortPairsDescending [4/4]","text":"<pre><code>template&lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\ninline DeviceSegmentedSort &amp; muda::DeviceSegmentedSort::StableSortPairsDescending (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    cub::DoubleBuffer&lt; KeyT &gt; &amp; d_keys,\n    cub::DoubleBuffer&lt; ValueT &gt; &amp; d_values,\n    int num_items,\n    int num_segments,\n    BeginOffsetIteratorT d_begin_offsets,\n    EndOffsetIteratorT d_end_offsets\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_segmented_sort.h</code></p>"},{"location":"muda/classmuda_1_1_device_select/","title":"Class muda::DeviceSelect","text":"<p>ClassList &gt; muda &gt; DeviceSelect</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_select/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_select/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_select/#public-functions","title":"Public Functions","text":"Type Name DeviceSelect &amp; Flagged (InputIteratorT d_in, FlagIterator d_flags, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items)  DeviceSelect &amp; Flagged (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, FlagIterator d_flags, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items)  DeviceSelect &amp; If (InputIteratorT d_in, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items, SelectOp select_op)  DeviceSelect &amp; If (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items, SelectOp select_op)  DeviceSelect &amp; Unique (InputIteratorT d_in, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items)  DeviceSelect &amp; Unique (void * d_temp_storage, size_t &amp; temp_storage_bytes, InputIteratorT d_in, OutputIteratorT d_out, NumSelectedIteratorT d_num_selected_out, int num_items)"},{"location":"muda/classmuda_1_1_device_select/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_select/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_select/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_select/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_select/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_select/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_select/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_select/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_select/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_select/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_select/#function-flagged-12","title":"function Flagged [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename FlagIterator, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\ninline DeviceSelect &amp; muda::DeviceSelect::Flagged (\n    InputIteratorT d_in,\n    FlagIterator d_flags,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_select/#function-flagged-22","title":"function Flagged [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename FlagIterator, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\ninline DeviceSelect &amp; muda::DeviceSelect::Flagged (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    FlagIterator d_flags,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_select/#function-if-12","title":"function If [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT, typename SelectOp&gt;\ninline DeviceSelect &amp; muda::DeviceSelect::If (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items,\n    SelectOp select_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_select/#function-if-22","title":"function If [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT, typename SelectOp&gt;\ninline DeviceSelect &amp; muda::DeviceSelect::If (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items,\n    SelectOp select_op\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_select/#function-unique-12","title":"function Unique [1/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\ninline DeviceSelect &amp; muda::DeviceSelect::Unique (\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_select/#function-unique-22","title":"function Unique [2/2]","text":"<pre><code>template&lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\ninline DeviceSelect &amp; muda::DeviceSelect::Unique (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    InputIteratorT d_in,\n    OutputIteratorT d_out,\n    NumSelectedIteratorT d_num_selected_out,\n    int num_items\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_select.h</code></p>"},{"location":"muda/classmuda_1_1_device_spmv/","title":"Class muda::DeviceSpmv","text":"<p>ClassList &gt; muda &gt; DeviceSpmv</p> <p>Inherits the following classes: muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_device_spmv/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_device_spmv/#public-attributes-inherited-from-mudacubwrapper","title":"Public Attributes inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name Stream * m_muda_stream   = = nullptr"},{"location":"muda/classmuda_1_1_device_spmv/#public-functions","title":"Public Functions","text":"Type Name DeviceSpmv &amp; CsrMV (const ValueT * d_values, const int * d_row_offsets, const int * d_column_indices, const ValueT * d_vector_x, ValueT * d_vector_y, int num_rows, int num_cols, int num_nonzeros)  DeviceSpmv &amp; CsrMV (void * d_temp_storage, size_t &amp; temp_storage_bytes, const ValueT * d_values, const int * d_row_offsets, const int * d_column_indices, const ValueT * d_vector_x, ValueT * d_vector_y, int num_rows, int num_cols, int num_nonzeros)"},{"location":"muda/classmuda_1_1_device_spmv/#public-functions-inherited-from-mudacubwrapper","title":"Public Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name CubWrapper (Stream &amp; stream=Stream::Default())  void kernel_name (std::string_view) = delete"},{"location":"muda/classmuda_1_1_device_spmv/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_device_spmv/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_device_spmv/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_device_spmv/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_device_spmv/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_device_spmv/#protected-functions-inherited-from-mudacubwrapper","title":"Protected Functions inherited from muda::CubWrapper","text":"<p>See muda::CubWrapper</p> Type Name std::byte * prepare_buffer (size_t reqSize)"},{"location":"muda/classmuda_1_1_device_spmv/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_device_spmv/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_device_spmv/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_spmv/#function-csrmv-12","title":"function CsrMV [1/2]","text":"<pre><code>template&lt;typename ValueT&gt;\ninline DeviceSpmv &amp; muda::DeviceSpmv::CsrMV (\n    const ValueT * d_values,\n    const int * d_row_offsets,\n    const int * d_column_indices,\n    const ValueT * d_vector_x,\n    ValueT * d_vector_y,\n    int num_rows,\n    int num_cols,\n    int num_nonzeros\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_spmv/#function-csrmv-22","title":"function CsrMV [2/2]","text":"<pre><code>template&lt;typename ValueT&gt;\ninline DeviceSpmv &amp; muda::DeviceSpmv::CsrMV (\n    void * d_temp_storage,\n    size_t &amp; temp_storage_bytes,\n    const ValueT * d_values,\n    const int * d_row_offsets,\n    const int * d_column_indices,\n    const ValueT * d_vector_x,\n    ValueT * d_vector_y,\n    int num_rows,\n    int num_cols,\n    int num_nonzeros\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_spmv.h</code></p>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/","title":"Class muda::DeviceTripletMatrix","text":"<p>template &lt;typename T, int N&gt;</p> <p>ClassList &gt; muda &gt; DeviceTripletMatrix</p> <p>Inherited by the following classes: muda::DeviceBCOOMatrix,  muda::DeviceBCOOMatrix,  muda::DeviceBCOOMatrix</p>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#public-types","title":"Public Types","text":"Type Name typedef std::conditional_t&lt; N==1, T, Eigen::Matrix&lt; T, N, N &gt; &gt; ValueT"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool IsBlockMatrix   = = (N &gt; 1)"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#public-functions","title":"Public Functions","text":"Type Name DeviceTripletMatrix () = default DeviceTripletMatrix (const DeviceTripletMatrix &amp;) = default DeviceTripletMatrix (DeviceTripletMatrix &amp;&amp;) = default void clear ()  auto col_indices ()  auto col_indices () const auto cols () const auto cview () const auto cviewer () const operator CTripletMatrixView&lt; T, N &gt; () const operator TripletMatrixView&lt; T, N &gt; ()  DeviceTripletMatrix &amp; operator= (const DeviceTripletMatrix &amp;) = default DeviceTripletMatrix &amp; operator= (DeviceTripletMatrix &amp;&amp;) = default void reserve_triplets (size_t nonzero_count)  void reshape (int row, int col)  void resize (int row, int col, size_t nonzero_count)  void resize_triplets (size_t nonzero_count)  auto row_indices ()  auto row_indices () const auto rows () const auto triplet_capacity () const auto triplet_count () const auto values ()  auto values () const auto view ()  auto view () const auto viewer ()  ~DeviceTripletMatrix () = default"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#public-static-functions","title":"Public Static Functions","text":"Type Name int block_dim ()"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#protected-attributes","title":"Protected Attributes","text":"Type Name DeviceBuffer&lt; int &gt; m_col_indices int m_cols   = = 0 DeviceBuffer&lt; int &gt; m_row_indices int m_rows   = = 0 DeviceBuffer&lt; ValueT &gt; m_values"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_triplet_matrix/#typedef-valuet","title":"typedef ValueT","text":"<pre><code>using muda::DeviceTripletMatrix&lt; T, N &gt;::ValueT =  std::conditional_t&lt;N == 1, T, Eigen::Matrix&lt;T, N, N&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_device_triplet_matrix/#variable-isblockmatrix","title":"variable IsBlockMatrix","text":"<pre><code>bool muda::DeviceTripletMatrix&lt; T, N &gt;::IsBlockMatrix;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-devicetripletmatrix-13","title":"function DeviceTripletMatrix [1/3]","text":"<pre><code>muda::DeviceTripletMatrix::DeviceTripletMatrix () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-devicetripletmatrix-23","title":"function DeviceTripletMatrix [2/3]","text":"<pre><code>muda::DeviceTripletMatrix::DeviceTripletMatrix (\n    const DeviceTripletMatrix &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-devicetripletmatrix-33","title":"function DeviceTripletMatrix [3/3]","text":"<pre><code>muda::DeviceTripletMatrix::DeviceTripletMatrix (\n    DeviceTripletMatrix &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-clear","title":"function clear","text":"<pre><code>inline void muda::DeviceTripletMatrix::clear () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-col_indices-12","title":"function col_indices [1/2]","text":"<pre><code>inline auto muda::DeviceTripletMatrix::col_indices () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-col_indices-22","title":"function col_indices [2/2]","text":"<pre><code>inline auto muda::DeviceTripletMatrix::col_indices () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-cols","title":"function cols","text":"<pre><code>inline auto muda::DeviceTripletMatrix::cols () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-cview","title":"function cview","text":"<pre><code>inline auto muda::DeviceTripletMatrix::cview () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-cviewer","title":"function cviewer","text":"<pre><code>inline auto muda::DeviceTripletMatrix::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-operator-ctripletmatrixview-t-n","title":"function operator CTripletMatrixView&lt; T, N &gt;","text":"<pre><code>inline muda::DeviceTripletMatrix::operator CTripletMatrixView&lt; T, N &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-operator-tripletmatrixview-t-n","title":"function operator TripletMatrixView&lt; T, N &gt;","text":"<pre><code>inline muda::DeviceTripletMatrix::operator TripletMatrixView&lt; T, N &gt; () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-operator","title":"function operator=","text":"<pre><code>DeviceTripletMatrix &amp; muda::DeviceTripletMatrix::operator= (\n    const DeviceTripletMatrix &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceTripletMatrix &amp; muda::DeviceTripletMatrix::operator= (\n    DeviceTripletMatrix &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-reserve_triplets","title":"function reserve_triplets","text":"<pre><code>inline void muda::DeviceTripletMatrix::reserve_triplets (\n    size_t nonzero_count\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-reshape","title":"function reshape","text":"<pre><code>inline void muda::DeviceTripletMatrix::reshape (\n    int row,\n    int col\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-resize","title":"function resize","text":"<pre><code>inline void muda::DeviceTripletMatrix::resize (\n    int row,\n    int col,\n    size_t nonzero_count\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-resize_triplets","title":"function resize_triplets","text":"<pre><code>inline void muda::DeviceTripletMatrix::resize_triplets (\n    size_t nonzero_count\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-row_indices-12","title":"function row_indices [1/2]","text":"<pre><code>inline auto muda::DeviceTripletMatrix::row_indices () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-row_indices-22","title":"function row_indices [2/2]","text":"<pre><code>inline auto muda::DeviceTripletMatrix::row_indices () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-rows","title":"function rows","text":"<pre><code>inline auto muda::DeviceTripletMatrix::rows () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-triplet_capacity","title":"function triplet_capacity","text":"<pre><code>inline auto muda::DeviceTripletMatrix::triplet_capacity () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-triplet_count","title":"function triplet_count","text":"<pre><code>inline auto muda::DeviceTripletMatrix::triplet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-values-12","title":"function values [1/2]","text":"<pre><code>inline auto muda::DeviceTripletMatrix::values () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-values-22","title":"function values [2/2]","text":"<pre><code>inline auto muda::DeviceTripletMatrix::values () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-view-12","title":"function view [1/2]","text":"<pre><code>inline auto muda::DeviceTripletMatrix::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-view-22","title":"function view [2/2]","text":"<pre><code>inline auto muda::DeviceTripletMatrix::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-viewer","title":"function viewer","text":"<pre><code>inline auto muda::DeviceTripletMatrix::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-devicetripletmatrix","title":"function ~DeviceTripletMatrix","text":"<pre><code>muda::DeviceTripletMatrix::~DeviceTripletMatrix () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_triplet_matrix/#function-block_dim","title":"function block_dim","text":"<pre><code>static inline int muda::DeviceTripletMatrix::block_dim () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_device_triplet_matrix/#variable-m_col_indices","title":"variable m_col_indices","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::DeviceTripletMatrix&lt; T, N &gt;::m_col_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#variable-m_cols","title":"variable m_cols","text":"<pre><code>int muda::DeviceTripletMatrix&lt; T, N &gt;::m_cols;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#variable-m_row_indices","title":"variable m_row_indices","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::DeviceTripletMatrix&lt; T, N &gt;::m_row_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#variable-m_rows","title":"variable m_rows","text":"<pre><code>int muda::DeviceTripletMatrix&lt; T, N &gt;::m_rows;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#variable-m_values","title":"variable m_values","text":"<pre><code>DeviceBuffer&lt;ValueT&gt; muda::DeviceTripletMatrix&lt; T, N &gt;::m_values;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_triplet_matrix/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_device_triplet_matrix/#friend-matrixformatconverter","title":"friend MatrixFormatConverter","text":"<pre><code>template&lt;typename U, int M&gt;\nclass muda::DeviceTripletMatrix::MatrixFormatConverter (\n    details::MatrixFormatConverter\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_triplet_matrix.h</code></p>"},{"location":"muda/classmuda_1_1_device_var/","title":"Class muda::DeviceVar","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; DeviceVar</p>"},{"location":"muda/classmuda_1_1_device_var/#public-types","title":"Public Types","text":"Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_device_var/#public-functions","title":"Public Functions","text":"Type Name DeviceVar ()  DeviceVar (const T &amp; value)  DeviceVar (const DeviceVar &amp; other)  DeviceVar (DeviceVar &amp;&amp; other)  void copy_from (CVarView&lt; T &gt; other)  CDense&lt; T &gt; cviewer () const T * data ()  const T * data () const operator CVarView&lt; T &gt; () const operator T () const operator VarView&lt; T &gt; ()  DeviceVar &amp; operator= (const DeviceVar&lt; T &gt; &amp; other)  DeviceVar &amp; operator= (DeviceVar&lt; T &gt; &amp;&amp; other)  DeviceVar &amp; operator= (CVarView&lt; T &gt; other)  DeviceVar &amp; operator= (const T &amp; val)  VarView&lt; T &gt; view ()  CVarView&lt; T &gt; view () const Dense&lt; T &gt; viewer ()  ~DeviceVar ()"},{"location":"muda/classmuda_1_1_device_var/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_var/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::DeviceVar&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_var/#function-devicevar-14","title":"function DeviceVar [1/4]","text":"<pre><code>muda::DeviceVar::DeviceVar () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-devicevar-24","title":"function DeviceVar [2/4]","text":"<pre><code>muda::DeviceVar::DeviceVar (\n    const T &amp; value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-devicevar-34","title":"function DeviceVar [3/4]","text":"<pre><code>muda::DeviceVar::DeviceVar (\n    const DeviceVar &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-devicevar-44","title":"function DeviceVar [4/4]","text":"<pre><code>muda::DeviceVar::DeviceVar (\n    DeviceVar &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-copy_from","title":"function copy_from","text":"<pre><code>void muda::DeviceVar::copy_from (\n    CVarView &lt; T &gt; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-cviewer","title":"function cviewer","text":"<pre><code>CDense &lt; T &gt; muda::DeviceVar::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-data-12","title":"function data [1/2]","text":"<pre><code>inline T * muda::DeviceVar::data () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-data-22","title":"function data [2/2]","text":"<pre><code>inline const T * muda::DeviceVar::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-operator-cvarview-t","title":"function operator CVarView&lt; T &gt;","text":"<pre><code>inline muda::DeviceVar::operator CVarView&lt; T &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-operator-t","title":"function operator T","text":"<pre><code>muda::DeviceVar::operator T () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-operator-varview-t","title":"function operator VarView&lt; T &gt;","text":"<pre><code>inline muda::DeviceVar::operator VarView&lt; T &gt; () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-operator","title":"function operator=","text":"<pre><code>DeviceVar &amp; muda::DeviceVar::operator= (\n    const DeviceVar &lt; T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceVar &amp; muda::DeviceVar::operator= (\n    DeviceVar &lt; T &gt; &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-operator_2","title":"function operator=","text":"<pre><code>DeviceVar &amp; muda::DeviceVar::operator= (\n    CVarView &lt; T &gt; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-operator_3","title":"function operator=","text":"<pre><code>DeviceVar &amp; muda::DeviceVar::operator= (\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-view-12","title":"function view [1/2]","text":"<pre><code>inline VarView &lt; T &gt; muda::DeviceVar::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-view-22","title":"function view [2/2]","text":"<pre><code>inline CVarView &lt; T &gt; muda::DeviceVar::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-viewer","title":"function viewer","text":"<pre><code>Dense &lt; T &gt; muda::DeviceVar::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_var/#function-devicevar","title":"function ~DeviceVar","text":"<pre><code>muda::DeviceVar::~DeviceVar () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_fwd.h</code></p>"},{"location":"muda/classmuda_1_1_device_vector/","title":"Class muda::DeviceVector","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; DeviceVector</p> <p>Inherits the following classes: thrust::device_vector&lt; T, thrust::device_allocator&lt; T &gt; &gt;</p>"},{"location":"muda/classmuda_1_1_device_vector/#public-types","title":"Public Types","text":"Type Name typedef thrust::device_vector&lt; T, thrust::device_allocator&lt; T &gt; &gt; Base"},{"location":"muda/classmuda_1_1_device_vector/#public-functions","title":"Public Functions","text":"Type Name void copy_to (std::vector&lt; T &gt; &amp; v) const auto cviewer () const operator BufferView&lt; T &gt; () const operator CBufferView&lt; T &gt; () const DeviceVector &amp; operator= (CBufferView&lt; T &gt; v)  auto view ()  auto view () const auto viewer ()"},{"location":"muda/classmuda_1_1_device_vector/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_device_vector/#typedef-base","title":"typedef Base","text":"<pre><code>using muda::DeviceVector&lt; T &gt;::Base =  thrust::device_vector&lt;T, thrust::device_allocator&lt;T&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_device_vector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_device_vector/#function-copy_to","title":"function copy_to","text":"<pre><code>inline void muda::DeviceVector::copy_to (\n    std::vector&lt; T &gt; &amp; v\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_vector/#function-cviewer","title":"function cviewer","text":"<pre><code>inline auto muda::DeviceVector::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_vector/#function-operator-bufferview-t","title":"function operator BufferView&lt; T &gt;","text":"<pre><code>inline muda::DeviceVector::operator BufferView&lt; T &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_vector/#function-operator-cbufferview-t","title":"function operator CBufferView&lt; T &gt;","text":"<pre><code>inline muda::DeviceVector::operator CBufferView&lt; T &gt; () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_vector/#function-operator","title":"function operator=","text":"<pre><code>inline DeviceVector &amp; muda::DeviceVector::operator= (\n    CBufferView &lt; T &gt; v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_device_vector/#function-view-12","title":"function view [1/2]","text":"<pre><code>inline auto muda::DeviceVector::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_device_vector/#function-view-22","title":"function view [2/2]","text":"<pre><code>inline auto muda::DeviceVector::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_device_vector/#function-viewer","title":"function viewer","text":"<pre><code>inline auto muda::DeviceVector::viewer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/device_buffer.h</code></p>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/","title":"Class muda::DoubletVectorViewT","text":"<p>template &lt;bool IsConst, typename T, int N&gt;</p> <p>ClassList &gt; muda &gt; DoubletVectorViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#public-types","title":"Public Types","text":"Type Name typedef DoubletVectorViewT&lt; true, T, N &gt; ConstView typedef CDoubletVectorViewer&lt; T, N &gt; ConstViewer typedef DoubletVectorViewT&lt; false, T, N &gt; NonConstView typedef DoubletVectorViewer&lt; T, N &gt; NonConstViewer typedef Eigen::Matrix&lt; T, N, 1 &gt; SegmentVector typedef DoubletVectorViewT&lt; IsConst, T, N &gt; ThisView typedef std::conditional_t&lt; IsConst, ConstViewer, NonConstViewer &gt; ThisViewer"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC DoubletVectorViewT () = default MUDA_GENERIC DoubletVectorViewT (int total_segment_count, int doublet_index_offset, int doublet_count, int total_doublet_count, int subvector_offset, int subvector_extent, auto_const_t&lt; int &gt; * segment_indices, auto_const_t&lt; SegmentVector &gt; * segment_values)  MUDA_GENERIC DoubletVectorViewT (int total_segment_count, int total_doublet_count, auto_const_t&lt; int &gt; * segment_indices, auto_const_t&lt; SegmentVector &gt; * segment_values)  MUDA_GENERIC DoubletVectorViewT (const DoubletVectorViewT&lt; OtherIsConst, T, N &gt; &amp; other) noexcept MUDA_GENERIC ConstView as_const () noexcept const MUDA_GENERIC ConstViewer cviewer () noexcept const MUDA_GENERIC int doublet_count () noexcept const MUDA_GENERIC int extent () noexcept const MUDA_GENERIC auto subvector (int offset, int extent) noexcept const MUDA_GENERIC int subvector_offset () noexcept const MUDA_GENERIC ThisView subview (int offset, int count) noexcept const MUDA_GENERIC ThisView subview (int offset) noexcept const MUDA_GENERIC int total_doublet_count () noexcept const MUDA_GENERIC int total_extent () noexcept const MUDA_GENERIC ThisViewer viewer () noexcept"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name int m_doublet_count   = = 0 int m_doublet_index_offset   = = 0 auto_const_t&lt; int &gt; * m_segment_indices auto_const_t&lt; SegmentVector &gt; * m_segment_values int m_subvector_extent   = = 0 int m_subvector_offset   = = 0 int m_total_doublet_count   = = 0 int m_total_segment_count   = = 0"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::ConstView =  DoubletVectorViewT&lt;true, T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::ConstViewer =  CDoubletVectorViewer&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#typedef-nonconstview","title":"typedef NonConstView","text":"<pre><code>using muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::NonConstView =  DoubletVectorViewT&lt;false, T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::NonConstViewer =  DoubletVectorViewer&lt;T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#typedef-segmentvector","title":"typedef SegmentVector","text":"<pre><code>using muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::SegmentVector =  Eigen::Matrix&lt;T, N, 1&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::ThisView =  DoubletVectorViewT&lt;IsConst, T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::ThisViewer =  std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-doubletvectorviewt-25","title":"function DoubletVectorViewT [2/5]","text":"<pre><code>MUDA_GENERIC muda::DoubletVectorViewT::DoubletVectorViewT () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-doubletvectorviewt-35","title":"function DoubletVectorViewT [3/5]","text":"<pre><code>inline MUDA_GENERIC muda::DoubletVectorViewT::DoubletVectorViewT (\n    int total_segment_count,\n    int doublet_index_offset,\n    int doublet_count,\n    int total_doublet_count,\n    int subvector_offset,\n    int subvector_extent,\n    auto_const_t&lt; int &gt; * segment_indices,\n    auto_const_t&lt; SegmentVector &gt; * segment_values\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-doubletvectorviewt-45","title":"function DoubletVectorViewT [4/5]","text":"<pre><code>inline MUDA_GENERIC muda::DoubletVectorViewT::DoubletVectorViewT (\n    int total_segment_count,\n    int total_doublet_count,\n    auto_const_t&lt; int &gt; * segment_indices,\n    auto_const_t&lt; SegmentVector &gt; * segment_values\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-doubletvectorviewt-55","title":"function DoubletVectorViewT [5/5]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::DoubletVectorViewT::DoubletVectorViewT (\n    const DoubletVectorViewT &lt; OtherIsConst, T, N &gt; &amp; other\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC ConstView muda::DoubletVectorViewT::as_const () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-cviewer","title":"function cviewer","text":"<pre><code>inline MUDA_GENERIC ConstViewer muda::DoubletVectorViewT::cviewer () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-doublet_count","title":"function doublet_count","text":"<pre><code>inline MUDA_GENERIC int muda::DoubletVectorViewT::doublet_count () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-extent","title":"function extent","text":"<pre><code>inline MUDA_GENERIC int muda::DoubletVectorViewT::extent () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-subvector","title":"function subvector","text":"<pre><code>inline MUDA_GENERIC auto muda::DoubletVectorViewT::subvector (\n    int offset,\n    int extent\n) noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-subvector_offset","title":"function subvector_offset","text":"<pre><code>inline MUDA_GENERIC int muda::DoubletVectorViewT::subvector_offset () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-subview-12","title":"function subview [1/2]","text":"<pre><code>inline MUDA_GENERIC ThisView muda::DoubletVectorViewT::subview (\n    int offset,\n    int count\n) noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-subview-22","title":"function subview [2/2]","text":"<pre><code>inline MUDA_GENERIC ThisView muda::DoubletVectorViewT::subview (\n    int offset\n) noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-total_doublet_count","title":"function total_doublet_count","text":"<pre><code>inline MUDA_GENERIC int muda::DoubletVectorViewT::total_doublet_count () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-total_extent","title":"function total_extent","text":"<pre><code>inline MUDA_GENERIC int muda::DoubletVectorViewT::total_extent () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#function-viewer","title":"function viewer","text":"<pre><code>inline MUDA_GENERIC ThisViewer muda::DoubletVectorViewT::viewer () noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#variable-m_doublet_count","title":"variable m_doublet_count","text":"<pre><code>int muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::m_doublet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#variable-m_doublet_index_offset","title":"variable m_doublet_index_offset","text":"<pre><code>int muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::m_doublet_index_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#variable-m_segment_indices","title":"variable m_segment_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::m_segment_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#variable-m_segment_values","title":"variable m_segment_values","text":"<pre><code>auto_const_t&lt;SegmentVector&gt;* muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::m_segment_values;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#variable-m_subvector_extent","title":"variable m_subvector_extent","text":"<pre><code>int muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::m_subvector_extent;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#variable-m_subvector_offset","title":"variable m_subvector_offset","text":"<pre><code>int muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::m_subvector_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#variable-m_total_doublet_count","title":"variable m_total_doublet_count","text":"<pre><code>int muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::m_total_doublet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_view_t/#variable-m_total_segment_count","title":"variable m_total_segment_count","text":"<pre><code>int muda::DoubletVectorViewT&lt; IsConst, T, N &gt;::m_total_segment_count;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/doublet_vector_view.h</code></p>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/","title":"Class muda::DoubletVectorViewerT","text":"<p>template &lt;bool IsConst, typename T, int N&gt;</p> <p>ClassList &gt; muda &gt; DoubletVectorViewerT</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#classes","title":"Classes","text":"Type Name struct CDoublet class Proxy"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#public-types","title":"Public Types","text":"Type Name typedef DoubletVectorViewerT&lt; true, T, N &gt; ConstViewer typedef DoubletVectorViewerT&lt; false, T, N &gt; NonConstViewer typedef DoubletVectorViewerT&lt; IsConst, T, N &gt; ThisViewer typedef std::conditional_t&lt; N==1, T, Eigen::Matrix&lt; T, N, 1 &gt; &gt; ValueT"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC DoubletVectorViewerT () = default MUDA_GENERIC DoubletVectorViewerT (int total_segment_count, int doublet_index_offset, int doublet_count, int total_doublet_count, int subvector_offset, int subvector_extent, auto_const_t&lt; int &gt; * segment_indices, auto_const_t&lt; ValueT &gt; * segment_values)  MUDA_GENERIC DoubletVectorViewerT (const DoubletVectorViewerT&lt; OtherIsConst, T, N &gt; &amp; other) noexcept MUDA_GENERIC ConstViewer as_const () noexcept const MUDA_GENERIC int doublet_count () noexcept const MUDA_GENERIC auto operator() (int i) const MUDA_GENERIC int total_doublet_count () noexcept const"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#protected-attributes","title":"Protected Attributes","text":"Type Name int m_doublet_count   = = 0 int m_doublet_index_offset   = = 0 auto_const_t&lt; int &gt; * m_segment_indices auto_const_t&lt; ValueT &gt; * m_segment_values int m_subvector_extent   = = 0 int m_subvector_offset   = = 0 int m_total_doublet_count   = = 0 int m_total_segment_count   = = 0"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC CDoublet at (int i) const MUDA_INLINE MUDA_GENERIC void check_in_subvector (int i) noexcept const MUDA_INLINE MUDA_GENERIC int get_index (int i) noexcept const"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::ConstViewer =  DoubletVectorViewerT&lt;true, T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::NonConstViewer =  DoubletVectorViewerT&lt;false, T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::ThisViewer =  DoubletVectorViewerT&lt;IsConst, T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#typedef-valuet","title":"typedef ValueT","text":"<pre><code>using muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::ValueT =  std::conditional_t&lt;N == 1, T, Eigen::Matrix&lt;T, N, 1&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-doubletvectorviewert-24","title":"function DoubletVectorViewerT [2/4]","text":"<pre><code>MUDA_GENERIC muda::DoubletVectorViewerT::DoubletVectorViewerT () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-doubletvectorviewert-34","title":"function DoubletVectorViewerT [3/4]","text":"<pre><code>inline MUDA_GENERIC muda::DoubletVectorViewerT::DoubletVectorViewerT (\n    int total_segment_count,\n    int doublet_index_offset,\n    int doublet_count,\n    int total_doublet_count,\n    int subvector_offset,\n    int subvector_extent,\n    auto_const_t&lt; int &gt; * segment_indices,\n    auto_const_t&lt; ValueT &gt; * segment_values\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-doubletvectorviewert-44","title":"function DoubletVectorViewerT [4/4]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::DoubletVectorViewerT::DoubletVectorViewerT (\n    const DoubletVectorViewerT &lt; OtherIsConst, T, N &gt; &amp; other\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC ConstViewer muda::DoubletVectorViewerT::as_const () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-doublet_count","title":"function doublet_count","text":"<pre><code>inline MUDA_GENERIC int muda::DoubletVectorViewerT::doublet_count () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-operator","title":"function operator()","text":"<pre><code>inline MUDA_GENERIC auto muda::DoubletVectorViewerT::operator() (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-total_doublet_count","title":"function total_doublet_count","text":"<pre><code>inline MUDA_GENERIC int muda::DoubletVectorViewerT::total_doublet_count () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#variable-m_doublet_count","title":"variable m_doublet_count","text":"<pre><code>int muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::m_doublet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#variable-m_doublet_index_offset","title":"variable m_doublet_index_offset","text":"<pre><code>int muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::m_doublet_index_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#variable-m_segment_indices","title":"variable m_segment_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::m_segment_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#variable-m_segment_values","title":"variable m_segment_values","text":"<pre><code>auto_const_t&lt;ValueT&gt;* muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::m_segment_values;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#variable-m_subvector_extent","title":"variable m_subvector_extent","text":"<pre><code>int muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::m_subvector_extent;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#variable-m_subvector_offset","title":"variable m_subvector_offset","text":"<pre><code>int muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::m_subvector_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#variable-m_total_doublet_count","title":"variable m_total_doublet_count","text":"<pre><code>int muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::m_total_doublet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#variable-m_total_segment_count","title":"variable m_total_segment_count","text":"<pre><code>int muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::m_total_segment_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-at","title":"function at","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC CDoublet muda::DoubletVectorViewerT::at (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-check_in_subvector","title":"function check_in_subvector","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::DoubletVectorViewerT::check_in_subvector (\n    int i\n) noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t/#function-get_index","title":"function get_index","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC int muda::DoubletVectorViewerT::get_index (\n    int i\n) noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/doublet_vector_viewer.h</code></p>"},{"location":"muda/structmuda_1_1_doublet_vector_viewer_t_1_1_c_doublet/","title":"Struct muda::DoubletVectorViewerT::CDoublet","text":"<p>ClassList &gt; muda &gt; DoubletVectorViewerT &gt; CDoublet</p>"},{"location":"muda/structmuda_1_1_doublet_vector_viewer_t_1_1_c_doublet/#public-attributes","title":"Public Attributes","text":"Type Name int index const ValueT &amp; value"},{"location":"muda/structmuda_1_1_doublet_vector_viewer_t_1_1_c_doublet/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC CDoublet (int index, const ValueT &amp; segment)"},{"location":"muda/structmuda_1_1_doublet_vector_viewer_t_1_1_c_doublet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/structmuda_1_1_doublet_vector_viewer_t_1_1_c_doublet/#variable-index","title":"variable index","text":"<pre><code>int muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::CDoublet::index;\n</code></pre>"},{"location":"muda/structmuda_1_1_doublet_vector_viewer_t_1_1_c_doublet/#variable-value","title":"variable value","text":"<pre><code>const ValueT&amp; muda::DoubletVectorViewerT&lt; IsConst, T, N &gt;::CDoublet::value;\n</code></pre>"},{"location":"muda/structmuda_1_1_doublet_vector_viewer_t_1_1_c_doublet/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1_doublet_vector_viewer_t_1_1_c_doublet/#function-cdoublet","title":"function CDoublet","text":"<pre><code>inline MUDA_GENERIC muda::DoubletVectorViewerT::CDoublet::CDoublet (\n    int index,\n    const ValueT &amp; segment\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/doublet_vector_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t_1_1_proxy/","title":"Class muda::DoubletVectorViewerT::Proxy","text":"<p>ClassList &gt; muda &gt; DoubletVectorViewerT &gt; Proxy</p>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t_1_1_proxy/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC auto read ()  MUDA_GENERIC void write (int segment_i, const ValueT &amp; value)  MUDA_GENERIC ~Proxy () = default"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t_1_1_proxy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t_1_1_proxy/#function-read","title":"function read","text":"<pre><code>inline MUDA_GENERIC auto muda::DoubletVectorViewerT::Proxy::read () \n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t_1_1_proxy/#function-write","title":"function write","text":"<pre><code>inline MUDA_GENERIC void muda::DoubletVectorViewerT::Proxy::write (\n    int segment_i,\n    const ValueT &amp; value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_doublet_vector_viewer_t_1_1_proxy/#function-proxy","title":"function ~Proxy","text":"<pre><code>MUDA_GENERIC muda::DoubletVectorViewerT::Proxy::~Proxy () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/doublet_vector_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_empty/","title":"Class muda::Empty","text":"<p>ClassList &gt; muda &gt; Empty</p> <p>Inherits the following classes: muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_empty/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_empty/#public-functions","title":"Public Functions","text":"Type Name Empty (::cudaStream_t stream=nullptr)"},{"location":"muda/classmuda_1_1_empty/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_empty/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_empty/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_empty/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_empty/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_empty/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_empty/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_empty/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_empty/#function-empty","title":"function Empty","text":"<pre><code>inline muda::Empty::Empty (\n    ::cudaStream_t stream=nullptr\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/launch_base.h</code></p>"},{"location":"muda/classmuda_1_1_event/","title":"Class muda::Event","text":"<p>ClassList &gt; muda &gt; Event</p> <p>RAII wrapper for cudaEvent. </p> <ul> <li><code>#include &lt;event.h&gt;</code></li> </ul>"},{"location":"muda/classmuda_1_1_event/#public-types","title":"Public Types","text":"Type Name enum unsigned int Bit enum QueryResult"},{"location":"muda/classmuda_1_1_event/#public-functions","title":"Public Functions","text":"Type Name Event (Flags&lt; Bit &gt; flag=Bit::eDisableTiming)  Event (const Event &amp;) = delete Event (Event &amp;&amp; o)  operator cudaEvent_t ()  Event &amp; operator= (const Event &amp;) = delete Event &amp; operator= (Event &amp;&amp; o)  QueryResult query () const cudaEvent_t viewer () const ~Event ()"},{"location":"muda/classmuda_1_1_event/#public-static-functions","title":"Public Static Functions","text":"Type Name float elapsed_time (cudaEvent_t start, cudaEvent_t stop)"},{"location":"muda/classmuda_1_1_event/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_event/#enum-bit","title":"enum Bit","text":"<pre><code>enum muda::Event::Bit {\n    eDefault = cudaEventDefault,\n    eBlockingSync = cudaEventBlockingSync,\n    eDisableTiming = cudaEventDisableTiming,\n    eInterprocess = cudaEventInterprocess\n};\n</code></pre>"},{"location":"muda/classmuda_1_1_event/#enum-queryresult","title":"enum QueryResult","text":"<pre><code>enum muda::Event::QueryResult {\n    eFinished = cudaSuccess,\n    eNotReady = cudaErrorNotReady\n};\n</code></pre>"},{"location":"muda/classmuda_1_1_event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_event/#function-event-13","title":"function Event [1/3]","text":"<pre><code>muda::Event::Event (\n    Flags &lt; Bit &gt; flag=Bit::eDisableTiming\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_event/#function-event-23","title":"function Event [2/3]","text":"<pre><code>muda::Event::Event (\n    const Event &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_event/#function-event-33","title":"function Event [3/3]","text":"<pre><code>muda::Event::Event (\n    Event &amp;&amp; o\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_event/#function-operator-cudaevent_t","title":"function operator cudaEvent_t","text":"<pre><code>inline muda::Event::operator cudaEvent_t () \n</code></pre>"},{"location":"muda/classmuda_1_1_event/#function-operator","title":"function operator=","text":"<pre><code>Event &amp; muda::Event::operator= (\n    const Event &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_event/#function-operator_1","title":"function operator=","text":"<pre><code>Event &amp; muda::Event::operator= (\n    Event &amp;&amp; o\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_event/#function-query","title":"function query","text":"<pre><code>QueryResult muda::Event::query () const\n</code></pre>"},{"location":"muda/classmuda_1_1_event/#function-viewer","title":"function viewer","text":"<pre><code>inline cudaEvent_t muda::Event::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_event/#function-event","title":"function ~Event","text":"<pre><code>muda::Event::~Event () \n</code></pre>"},{"location":"muda/classmuda_1_1_event/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_event/#function-elapsed_time","title":"function elapsed_time","text":"<pre><code>static float muda::Event::elapsed_time (\n    cudaEvent_t start,\n    cudaEvent_t stop\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/event.h</code></p>"},{"location":"muda/classmuda_1_1_event_record_node/","title":"Class muda::EventRecordNode","text":"<p>ClassList &gt; muda &gt; EventRecordNode</p> <p>Inherits the following classes: muda::GraphNode</p>"},{"location":"muda/classmuda_1_1_event_record_node/#public-types","title":"Public Types","text":"Type Name typedef EventRecordNode this_type"},{"location":"muda/classmuda_1_1_event_record_node/#public-types-inherited-from-mudagraphnode","title":"Public Types inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name typedef GraphNode this_type"},{"location":"muda/classmuda_1_1_event_record_node/#public-functions-inherited-from-mudagraphnode","title":"Public Functions inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name GraphNode ()  cudaGraphNode_t handle () const"},{"location":"muda/classmuda_1_1_event_record_node/#protected-attributes-inherited-from-mudagraphnode","title":"Protected Attributes inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name cudaGraphNode_t m_handle"},{"location":"muda/classmuda_1_1_event_record_node/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_event_record_node/#typedef-this_type","title":"typedef this_type","text":"<pre><code>using muda::EventRecordNode::this_type =  EventRecordNode;\n</code></pre>"},{"location":"muda/classmuda_1_1_event_record_node/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_event_record_node/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::EventRecordNode::Graph (\n    Graph\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/event_node.h</code></p>"},{"location":"muda/classmuda_1_1_event_wait_node/","title":"Class muda::EventWaitNode","text":"<p>ClassList &gt; muda &gt; EventWaitNode</p> <p>Inherits the following classes: muda::GraphNode</p>"},{"location":"muda/classmuda_1_1_event_wait_node/#public-types","title":"Public Types","text":"Type Name typedef EventWaitNode this_type"},{"location":"muda/classmuda_1_1_event_wait_node/#public-types-inherited-from-mudagraphnode","title":"Public Types inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name typedef GraphNode this_type"},{"location":"muda/classmuda_1_1_event_wait_node/#public-functions-inherited-from-mudagraphnode","title":"Public Functions inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name GraphNode ()  cudaGraphNode_t handle () const"},{"location":"muda/classmuda_1_1_event_wait_node/#protected-attributes-inherited-from-mudagraphnode","title":"Protected Attributes inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name cudaGraphNode_t m_handle"},{"location":"muda/classmuda_1_1_event_wait_node/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_event_wait_node/#typedef-this_type","title":"typedef this_type","text":"<pre><code>using muda::EventWaitNode::this_type =  EventWaitNode;\n</code></pre>"},{"location":"muda/classmuda_1_1_event_wait_node/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_event_wait_node/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::EventWaitNode::Graph (\n    Graph\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/event_node.h</code></p>"},{"location":"muda/classmuda_1_1_extent2_d/","title":"Class muda::Extent2D","text":"<p>ClassList &gt; muda &gt; Extent2D</p>"},{"location":"muda/classmuda_1_1_extent2_d/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Extent2D ()  MUDA_GENERIC Extent2D (size_t height, size_t width)  MUDA_GENERIC cudaExtent cuda_extent () const MUDA_GENERIC size_t height () const MUDA_GENERIC bool valid () const MUDA_GENERIC size_t width () const"},{"location":"muda/classmuda_1_1_extent2_d/#public-static-functions","title":"Public Static Functions","text":"Type Name MUDA_GENERIC Extent2D Zero ()"},{"location":"muda/classmuda_1_1_extent2_d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_extent2_d/#function-extent2d-12","title":"function Extent2D [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::Extent2D::Extent2D () \n</code></pre>"},{"location":"muda/classmuda_1_1_extent2_d/#function-extent2d-22","title":"function Extent2D [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::Extent2D::Extent2D (\n    size_t height,\n    size_t width\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_extent2_d/#function-cuda_extent","title":"function cuda_extent","text":"<pre><code>template&lt;typename T&gt;\ninline MUDA_GENERIC cudaExtent muda::Extent2D::cuda_extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_extent2_d/#function-height","title":"function height","text":"<pre><code>inline MUDA_GENERIC size_t muda::Extent2D::height () const\n</code></pre>"},{"location":"muda/classmuda_1_1_extent2_d/#function-valid","title":"function valid","text":"<pre><code>inline MUDA_GENERIC bool muda::Extent2D::valid () const\n</code></pre>"},{"location":"muda/classmuda_1_1_extent2_d/#function-width","title":"function width","text":"<pre><code>inline MUDA_GENERIC size_t muda::Extent2D::width () const\n</code></pre>"},{"location":"muda/classmuda_1_1_extent2_d/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_extent2_d/#function-zero","title":"function Zero","text":"<pre><code>static inline MUDA_GENERIC Extent2D muda::Extent2D::Zero () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/extent.h</code></p>"},{"location":"muda/classmuda_1_1_extent3_d/","title":"Class muda::Extent3D","text":"<p>ClassList &gt; muda &gt; Extent3D</p>"},{"location":"muda/classmuda_1_1_extent3_d/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Extent3D ()  MUDA_GENERIC Extent3D (size_t depth, size_t height, size_t width)  MUDA_GENERIC cudaExtent cuda_extent () const MUDA_GENERIC size_t depth () const MUDA_GENERIC size_t height () const MUDA_GENERIC bool valid () const MUDA_GENERIC size_t width () const"},{"location":"muda/classmuda_1_1_extent3_d/#public-static-functions","title":"Public Static Functions","text":"Type Name MUDA_GENERIC Extent3D Zero ()"},{"location":"muda/classmuda_1_1_extent3_d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_extent3_d/#function-extent3d-12","title":"function Extent3D [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::Extent3D::Extent3D () \n</code></pre>"},{"location":"muda/classmuda_1_1_extent3_d/#function-extent3d-22","title":"function Extent3D [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::Extent3D::Extent3D (\n    size_t depth,\n    size_t height,\n    size_t width\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_extent3_d/#function-cuda_extent","title":"function cuda_extent","text":"<pre><code>template&lt;typename T&gt;\ninline MUDA_GENERIC cudaExtent muda::Extent3D::cuda_extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_extent3_d/#function-depth","title":"function depth","text":"<pre><code>inline MUDA_GENERIC size_t muda::Extent3D::depth () const\n</code></pre>"},{"location":"muda/classmuda_1_1_extent3_d/#function-height","title":"function height","text":"<pre><code>inline MUDA_GENERIC size_t muda::Extent3D::height () const\n</code></pre>"},{"location":"muda/classmuda_1_1_extent3_d/#function-valid","title":"function valid","text":"<pre><code>inline MUDA_GENERIC bool muda::Extent3D::valid () const\n</code></pre>"},{"location":"muda/classmuda_1_1_extent3_d/#function-width","title":"function width","text":"<pre><code>inline MUDA_GENERIC size_t muda::Extent3D::width () const\n</code></pre>"},{"location":"muda/classmuda_1_1_extent3_d/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_extent3_d/#function-zero","title":"function Zero","text":"<pre><code>static inline MUDA_GENERIC Extent3D muda::Extent3D::Zero () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/extent.h</code></p>"},{"location":"muda/classmuda_1_1_field/","title":"Class muda::Field","text":"<p>ClassList &gt; muda &gt; Field</p>"},{"location":"muda/classmuda_1_1_field/#public-types","title":"Public Types","text":"Type Name typedef FieldEntryLayout Layout"},{"location":"muda/classmuda_1_1_field/#public-functions","title":"Public Functions","text":"Type Name Field ()  size_t num_sub_fields () const SubField &amp; operator[] (std::string_view name)  ~Field ()"},{"location":"muda/classmuda_1_1_field/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_field/#typedef-layout","title":"typedef Layout","text":"<pre><code>using muda::Field::Layout =  FieldEntryLayout;\n</code></pre>"},{"location":"muda/classmuda_1_1_field/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field/#function-field","title":"function Field","text":"<pre><code>muda::Field::Field () \n</code></pre>"},{"location":"muda/classmuda_1_1_field/#function-num_sub_fields","title":"function num_sub_fields","text":"<pre><code>inline size_t muda::Field::num_sub_fields () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field/#function-operator","title":"function operator[]","text":"<pre><code>SubField &amp; muda::Field::operator[] (\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field/#function-field_1","title":"function ~Field","text":"<pre><code>muda::Field::~Field () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field.h</code></p>"},{"location":"muda/classmuda_1_1_field_build_options/","title":"Class muda::FieldBuildOptions","text":"<p>ClassList &gt; muda &gt; FieldBuildOptions</p>"},{"location":"muda/classmuda_1_1_field_build_options/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t max_alignment   = = sizeof(std::max_align_t) uint32_t min_alignment   = = sizeof(int)"},{"location":"muda/classmuda_1_1_field_build_options/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_field_build_options/#variable-max_alignment","title":"variable max_alignment","text":"<pre><code>uint32_t muda::FieldBuildOptions::max_alignment;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_build_options/#variable-min_alignment","title":"variable min_alignment","text":"<pre><code>uint32_t muda::FieldBuildOptions::min_alignment;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_build_options.h</code></p>"},{"location":"muda/classmuda_1_1_field_builder/","title":"Class muda::FieldBuilder","text":"<p>template &lt;FieldEntryLayout Layout&gt;</p> <p>ClassList &gt; muda &gt; FieldBuilder</p>"},{"location":"muda/classmuda_1_1_field_builder/#classes","title":"Classes","text":"Type Name class EntryProxy"},{"location":"muda/classmuda_1_1_field_builder/#public-functions","title":"Public Functions","text":"Type Name void build () Finish building the field. EntryProxy entry (std::string_view name)  EntryProxy entry ()  ~FieldBuilder ()"},{"location":"muda/classmuda_1_1_field_builder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_builder/#function-build","title":"function build","text":"<p>Finish building the field. <pre><code>void muda::FieldBuilder::build () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>options</code> </li> </ul>"},{"location":"muda/classmuda_1_1_field_builder/#function-entry-12","title":"function entry [1/2]","text":"<pre><code>EntryProxy muda::FieldBuilder::entry (\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder/#function-entry-22","title":"function entry [2/2]","text":"<pre><code>EntryProxy muda::FieldBuilder::entry () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder/#function-fieldbuilder","title":"function ~FieldBuilder","text":"<pre><code>muda::FieldBuilder::~FieldBuilder () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_builder.h</code></p>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/","title":"Class muda::FieldBuilder::EntryProxy","text":"<p>ClassList &gt; muda &gt; FieldBuilder &gt; EntryProxy</p>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#public-functions","title":"Public Functions","text":"Type Name EntryProxy (FieldBuilder&lt; Layout &gt; &amp; builder, std::string_view name)  FieldEntry&lt; T, Layout, M, N &gt; &amp; matrix ()  FieldEntry&lt; T, Layout, 2, 2 &gt; &amp; matrix2x2 ()  FieldEntry&lt; T, Layout, 3, 3 &gt; &amp; matrix3x3 ()  FieldEntry&lt; T, Layout, 4, 4 &gt; &amp; matrix4x4 ()  FieldEntry&lt; T, Layout, 1, 1 &gt; &amp; scalar ()  FieldEntry&lt; T, Layout, N, 1 &gt; &amp; vector ()  FieldEntry&lt; T, Layout, 2, 1 &gt; &amp; vector2 ()  FieldEntry&lt; T, Layout, 3, 1 &gt; &amp; vector3 ()  FieldEntry&lt; T, Layout, 4, 1 &gt; &amp; vector4 ()"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-entryproxy","title":"function EntryProxy","text":"<pre><code>inline muda::FieldBuilder::EntryProxy::EntryProxy (\n    FieldBuilder &lt; Layout &gt; &amp; builder,\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-matrix","title":"function matrix","text":"<pre><code>template&lt;typename T, int M, int N&gt;\nFieldEntry &lt; T, Layout, M, N &gt; &amp; muda::FieldBuilder::EntryProxy::matrix () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-matrix2x2","title":"function matrix2x2","text":"<pre><code>template&lt;typename T&gt;\nFieldEntry &lt; T, Layout, 2, 2 &gt; &amp; muda::FieldBuilder::EntryProxy::matrix2x2 () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-matrix3x3","title":"function matrix3x3","text":"<pre><code>template&lt;typename T&gt;\nFieldEntry &lt; T, Layout, 3, 3 &gt; &amp; muda::FieldBuilder::EntryProxy::matrix3x3 () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-matrix4x4","title":"function matrix4x4","text":"<pre><code>template&lt;typename T&gt;\nFieldEntry &lt; T, Layout, 4, 4 &gt; &amp; muda::FieldBuilder::EntryProxy::matrix4x4 () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-scalar","title":"function scalar","text":"<pre><code>template&lt;typename T&gt;\nFieldEntry &lt; T, Layout, 1, 1 &gt; &amp; muda::FieldBuilder::EntryProxy::scalar () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-vector","title":"function vector","text":"<pre><code>template&lt;typename T, int N&gt;\nFieldEntry &lt; T, Layout, N, 1 &gt; &amp; muda::FieldBuilder::EntryProxy::vector () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-vector2","title":"function vector2","text":"<pre><code>template&lt;typename T&gt;\nFieldEntry &lt; T, Layout, 2, 1 &gt; &amp; muda::FieldBuilder::EntryProxy::vector2 () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-vector3","title":"function vector3","text":"<pre><code>template&lt;typename T&gt;\nFieldEntry &lt; T, Layout, 3, 1 &gt; &amp; muda::FieldBuilder::EntryProxy::vector3 () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_builder_1_1_entry_proxy/#function-vector4","title":"function vector4","text":"<pre><code>template&lt;typename T&gt;\nFieldEntry &lt; T, Layout, 4, 1 &gt; &amp; muda::FieldBuilder::EntryProxy::vector4 () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_builder.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry/","title":"Class muda::FieldEntry","text":"<p>template &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; FieldEntry</p> <p>Inherits the following classes: muda::FieldEntryBase</p>"},{"location":"muda/classmuda_1_1_field_entry/#public-types","title":"Public Types","text":"Type Name typedef typename FieldEntryView&lt; T, Layout, M, N &gt;::ElementType ElementType"},{"location":"muda/classmuda_1_1_field_entry/#public-functions","title":"Public Functions","text":"Type Name FieldEntry (SubField &amp; field, FieldEntryLayoutInfo layout, FieldEntryType type, std::string_view name)  FieldEntry (SubField &amp; field, FieldEntryLayoutInfo layout, FieldEntryType type, uint2 shape, std::string_view name)  virtual void async_copy_to_new_place (HostDeviceConfigView&lt; FieldEntryCore &gt; new_place) override const void copy_from (const DeviceBuffer&lt; ElementType &gt; &amp; src)  void copy_from (const std::vector&lt; ElementType &gt; &amp; src)  void copy_from (const FieldEntry&lt; T, SrcLayout, M, N &gt; &amp; src)  void copy_to (DeviceBuffer&lt; ElementType &gt; &amp; dst) const void copy_to (std::vector&lt; ElementType &gt; &amp; dst) const CFieldEntryViewer&lt; T, Layout, M, N &gt; cviewer () const void fill (const ElementType &amp; value)  FieldEntryView&lt; T, Layout, M, N &gt; view ()  CFieldEntryView&lt; T, Layout, M, N &gt; view () const auto view (int offset)  auto view (int offset) const auto view (int offset, int count)  auto view (int offset, int count) const FieldEntryViewer&lt; T, Layout, M, N &gt; viewer ()"},{"location":"muda/classmuda_1_1_field_entry/#public-functions-inherited-from-mudafieldentrybase","title":"Public Functions inherited from muda::FieldEntryBase","text":"<p>See muda::FieldEntryBase</p> Type Name FieldEntryBase (SubField &amp; field, FieldEntryLayoutInfo layout_info, FieldEntryType type, uint2 shape, uint32_t m_elem_byte_size, std::string_view name)  MUDA_GENERIC auto count () const MUDA_GENERIC auto elem_byte_size () const MUDA_GENERIC auto layout () const MUDA_GENERIC auto layout_info () const MUDA_GENERIC auto name () const MUDA_GENERIC auto shape () const MUDA_GENERIC auto struct_stride () const ~FieldEntryBase () = default"},{"location":"muda/classmuda_1_1_field_entry/#protected-attributes-inherited-from-mudafieldentrybase","title":"Protected Attributes inherited from muda::FieldEntryBase","text":"<p>See muda::FieldEntryBase</p> Type Name FieldEntryCore m_core SubField &amp; m_field HostDeviceConfig&lt; FieldEntryCore &gt; m_host_device_core std::string m_name"},{"location":"muda/classmuda_1_1_field_entry/#protected-functions-inherited-from-mudafieldentrybase","title":"Protected Functions inherited from muda::FieldEntryBase","text":"<p>See muda::FieldEntryBase</p> Type Name FieldEntryBase (const FieldEntryBase &amp;) = delete virtual void async_copy_to_new_place (HostDeviceConfigView&lt; FieldEntryCore &gt; vfc) const = 0 MUDA_GENERIC const auto &amp; core () const FieldEntryBase &amp; operator= (const FieldEntryBase &amp;) = delete"},{"location":"muda/classmuda_1_1_field_entry/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry/#typedef-elementtype","title":"typedef ElementType","text":"<pre><code>using muda::FieldEntry&lt; T, Layout, M, N &gt;::ElementType =  typename FieldEntryView&lt;T, Layout, M, N&gt;::ElementType;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry/#function-fieldentry-12","title":"function FieldEntry [1/2]","text":"<pre><code>inline muda::FieldEntry::FieldEntry (\n    SubField &amp; field,\n    FieldEntryLayoutInfo layout,\n    FieldEntryType type,\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-fieldentry-22","title":"function FieldEntry [2/2]","text":"<pre><code>inline muda::FieldEntry::FieldEntry (\n    SubField &amp; field,\n    FieldEntryLayoutInfo layout,\n    FieldEntryType type,\n    uint2 shape,\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-async_copy_to_new_place","title":"function async_copy_to_new_place","text":"<pre><code>inline virtual void muda::FieldEntry::async_copy_to_new_place (\n    HostDeviceConfigView &lt; FieldEntryCore &gt; new_place\n) override const\n</code></pre> <p>Implements muda::FieldEntryBase::async_copy_to_new_place</p>"},{"location":"muda/classmuda_1_1_field_entry/#function-copy_from-13","title":"function copy_from [1/3]","text":"<pre><code>void muda::FieldEntry::copy_from (\n    const DeviceBuffer &lt; ElementType &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-copy_from-23","title":"function copy_from [2/3]","text":"<pre><code>void muda::FieldEntry::copy_from (\n    const std::vector&lt; ElementType &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-copy_from-33","title":"function copy_from [3/3]","text":"<pre><code>template&lt;FieldEntryLayout SrcLayout&gt;\nvoid muda::FieldEntry::copy_from (\n    const FieldEntry &lt; T, SrcLayout, M, N &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-copy_to-12","title":"function copy_to [1/2]","text":"<pre><code>void muda::FieldEntry::copy_to (\n    DeviceBuffer &lt; ElementType &gt; &amp; dst\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-copy_to-22","title":"function copy_to [2/2]","text":"<pre><code>void muda::FieldEntry::copy_to (\n    std::vector&lt; ElementType &gt; &amp; dst\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-cviewer","title":"function cviewer","text":"<pre><code>inline CFieldEntryViewer &lt; T, Layout, M, N &gt; muda::FieldEntry::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-fill","title":"function fill","text":"<pre><code>void muda::FieldEntry::fill (\n    const ElementType &amp; value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-view-16","title":"function view [1/6]","text":"<pre><code>inline FieldEntryView &lt; T, Layout, M, N &gt; muda::FieldEntry::view () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-view-26","title":"function view [2/6]","text":"<pre><code>inline CFieldEntryView &lt; T, Layout, M, N &gt; muda::FieldEntry::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-view-36","title":"function view [3/6]","text":"<pre><code>inline auto muda::FieldEntry::view (\n    int offset\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-view-46","title":"function view [4/6]","text":"<pre><code>inline auto muda::FieldEntry::view (\n    int offset\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-view-56","title":"function view [5/6]","text":"<pre><code>inline auto muda::FieldEntry::view (\n    int offset,\n    int count\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-view-66","title":"function view [6/6]","text":"<pre><code>inline auto muda::FieldEntry::view (\n    int offset,\n    int count\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry/#function-viewer","title":"function viewer","text":"<pre><code>inline FieldEntryViewer &lt; T, Layout, M, N &gt; muda::FieldEntry::viewer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_base/","title":"Class muda::FieldEntryBase","text":"<p>ClassList &gt; muda &gt; FieldEntryBase</p> <p>Inherited by the following classes: muda::FieldEntry</p>"},{"location":"muda/classmuda_1_1_field_entry_base/#public-functions","title":"Public Functions","text":"Type Name FieldEntryBase (SubField &amp; field, FieldEntryLayoutInfo layout_info, FieldEntryType type, uint2 shape, uint32_t m_elem_byte_size, std::string_view name)  MUDA_GENERIC auto count () const MUDA_GENERIC auto elem_byte_size () const MUDA_GENERIC auto layout () const MUDA_GENERIC auto layout_info () const MUDA_GENERIC auto name () const MUDA_GENERIC auto shape () const MUDA_GENERIC auto struct_stride () const ~FieldEntryBase () = default"},{"location":"muda/classmuda_1_1_field_entry_base/#protected-attributes","title":"Protected Attributes","text":"Type Name FieldEntryCore m_core SubField &amp; m_field HostDeviceConfig&lt; FieldEntryCore &gt; m_host_device_core std::string m_name"},{"location":"muda/classmuda_1_1_field_entry_base/#protected-functions","title":"Protected Functions","text":"Type Name FieldEntryBase (const FieldEntryBase &amp;) = delete virtual void async_copy_to_new_place (HostDeviceConfigView&lt; FieldEntryCore &gt; vfc) const = 0 MUDA_GENERIC const auto &amp; core () const FieldEntryBase &amp; operator= (const FieldEntryBase &amp;) = delete"},{"location":"muda/classmuda_1_1_field_entry_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_base/#function-fieldentrybase-12","title":"function FieldEntryBase [1/2]","text":"<pre><code>inline muda::FieldEntryBase::FieldEntryBase (\n    SubField &amp; field,\n    FieldEntryLayoutInfo layout_info,\n    FieldEntryType type,\n    uint2 shape,\n    uint32_t m_elem_byte_size,\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-count","title":"function count","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryBase::count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-elem_byte_size","title":"function elem_byte_size","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryBase::elem_byte_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-layout","title":"function layout","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryBase::layout () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-layout_info","title":"function layout_info","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryBase::layout_info () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-name","title":"function name","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryBase::name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-shape","title":"function shape","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryBase::shape () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-struct_stride","title":"function struct_stride","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryBase::struct_stride () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-fieldentrybase","title":"function ~FieldEntryBase","text":"<pre><code>muda::FieldEntryBase::~FieldEntryBase () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_base/#variable-m_core","title":"variable m_core","text":"<pre><code>FieldEntryCore muda::FieldEntryBase::m_core;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#variable-m_field","title":"variable m_field","text":"<pre><code>SubField&amp; muda::FieldEntryBase::m_field;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#variable-m_host_device_core","title":"variable m_host_device_core","text":"<pre><code>HostDeviceConfig&lt;FieldEntryCore&gt; muda::FieldEntryBase::m_host_device_core;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#variable-m_name","title":"variable m_name","text":"<pre><code>std::string muda::FieldEntryBase::m_name;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_base/#function-fieldentrybase-22","title":"function FieldEntryBase [2/2]","text":"<pre><code>muda::FieldEntryBase::FieldEntryBase (\n    const FieldEntryBase &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-async_copy_to_new_place","title":"function async_copy_to_new_place","text":"<pre><code>virtual void muda::FieldEntryBase::async_copy_to_new_place (\n    HostDeviceConfigView &lt; FieldEntryCore &gt; vfc\n) const = 0\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-core","title":"function core","text":"<pre><code>inline MUDA_GENERIC const auto &amp; muda::FieldEntryBase::core () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base/#function-operator","title":"function operator=","text":"<pre><code>FieldEntryBase &amp; muda::FieldEntryBase::operator= (\n    const FieldEntryBase &amp;\n) = delete\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_base_data/","title":"Class muda::FieldEntryBaseData","text":"<p>ClassList &gt; muda &gt; FieldEntryBaseData</p>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t elem_byte_size   = = ~0 uint32_t elem_count   = = ~0 uint32_t elem_count_based_stride FieldEntryLayoutInfo layout_info union muda::FieldEntryBaseData FieldEntryBaseData uint32_t offset_in_base_struct   = = ~0 uint32_t offset_in_struct   = = ~0 uint2 shape uint32_t struct_stride   = = ~0 FieldEntryType type   = = FieldEntryType::None"},{"location":"muda/classmuda_1_1_field_entry_base_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-elem_byte_size","title":"variable elem_byte_size","text":"<pre><code>uint32_t muda::FieldEntryBaseData::elem_byte_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-elem_count","title":"variable elem_count","text":"<pre><code>uint32_t muda::FieldEntryBaseData::elem_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-elem_count_based_stride","title":"variable elem_count_based_stride","text":"<pre><code>uint32_t muda::FieldEntryBaseData::elem_count_based_stride;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-layout_info","title":"variable layout_info","text":"<pre><code>FieldEntryLayoutInfo muda::FieldEntryBaseData::layout_info;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-fieldentrybasedata","title":"variable FieldEntryBaseData","text":"<pre><code>union muda::FieldEntryBaseData muda::FieldEntryBaseData;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-offset_in_base_struct","title":"variable offset_in_base_struct","text":"<pre><code>uint32_t muda::FieldEntryBaseData::offset_in_base_struct;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-offset_in_struct","title":"variable offset_in_struct","text":"<pre><code>uint32_t muda::FieldEntryBaseData::offset_in_struct;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-shape","title":"variable shape","text":"<pre><code>uint2 muda::FieldEntryBaseData::shape;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-struct_stride","title":"variable struct_stride","text":"<pre><code>uint32_t muda::FieldEntryBaseData::struct_stride;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_base_data/#variable-type","title":"variable type","text":"<pre><code>FieldEntryType muda::FieldEntryBaseData::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_base_data.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_core/","title":"Class muda::FieldEntryCore","text":"<p>ClassList &gt; muda &gt; FieldEntryCore</p>"},{"location":"muda/classmuda_1_1_field_entry_core/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC FieldEntryCore ()  MUDA_GENERIC FieldEntryCore (std::byte * buffer, const FieldEntryBaseData &amp; info, details::StringPointer name)  MUDA_GENERIC FieldEntryCore (const FieldEntryCore &amp; rhs) = default MUDA_GENERIC std::byte * aos_elem_addr (int i) const MUDA_GENERIC std::byte * aos_elem_addr (int i, int j) const MUDA_GENERIC std::byte * aos_elem_addr (int i, int row_index, int col_index) const MUDA_GENERIC std::byte * aos_struct_begin (int i) const MUDA_GENERIC std::byte * aosoa_elem_addr (int i) const MUDA_GENERIC std::byte * aosoa_elem_addr (int i, int j) const MUDA_GENERIC std::byte * aosoa_elem_addr (int i, int row_index, int col_index) const MUDA_GENERIC uint32_t aosoa_inner_index (int i) const MUDA_GENERIC std::byte * aosoa_struct_begin (int i) const MUDA_GENERIC T &amp; cast (std::byte * data)  MUDA_GENERIC const T &amp; cast (const std::byte * data) const MUDA_GENERIC auto count () const MUDA_GENERIC T * data (int i) const MUDA_GENERIC T * data (int i, int j) const MUDA_GENERIC T * data (int i, int row_index, int col_index) const MUDA_GENERIC std::byte * elem_addr (int i) const MUDA_GENERIC std::byte * elem_addr (int i, int j) const MUDA_GENERIC std::byte * elem_addr (int i, int row_index, int col_index) const MUDA_GENERIC auto elem_byte_size () const MUDA_GENERIC auto layout () const MUDA_GENERIC auto layout_info () const MUDA_GENERIC auto name () const MUDA_GENERIC auto name_string_pointer () const MUDA_GENERIC auto shape () const MUDA_GENERIC std::byte * soa_elem_addr (int i) const MUDA_GENERIC std::byte * soa_elem_addr (int i, int j) const MUDA_GENERIC std::byte * soa_elem_addr (int i, int row_index, int col_index) const MUDA_GENERIC auto struct_stride () const"},{"location":"muda/classmuda_1_1_field_entry_core/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_core/#function-fieldentrycore-13","title":"function FieldEntryCore [1/3]","text":"<pre><code>inline MUDA_GENERIC muda::FieldEntryCore::FieldEntryCore () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-fieldentrycore-23","title":"function FieldEntryCore [2/3]","text":"<pre><code>inline MUDA_GENERIC muda::FieldEntryCore::FieldEntryCore (\n    std::byte * buffer,\n    const FieldEntryBaseData &amp; info,\n    details::StringPointer name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-fieldentrycore-33","title":"function FieldEntryCore [3/3]","text":"<pre><code>MUDA_GENERIC muda::FieldEntryCore::FieldEntryCore (\n    const FieldEntryCore &amp; rhs\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-aos_elem_addr-13","title":"function aos_elem_addr [1/3]","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::aos_elem_addr (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-aos_elem_addr-23","title":"function aos_elem_addr [2/3]","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::aos_elem_addr (\n    int i,\n    int j\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-aos_elem_addr-33","title":"function aos_elem_addr [3/3]","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::aos_elem_addr (\n    int i,\n    int row_index,\n    int col_index\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-aos_struct_begin","title":"function aos_struct_begin","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::aos_struct_begin (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-aosoa_elem_addr-13","title":"function aosoa_elem_addr [1/3]","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::aosoa_elem_addr (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-aosoa_elem_addr-23","title":"function aosoa_elem_addr [2/3]","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::aosoa_elem_addr (\n    int i,\n    int j\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-aosoa_elem_addr-33","title":"function aosoa_elem_addr [3/3]","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::aosoa_elem_addr (\n    int i,\n    int row_index,\n    int col_index\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-aosoa_inner_index","title":"function aosoa_inner_index","text":"<pre><code>MUDA_GENERIC uint32_t muda::FieldEntryCore::aosoa_inner_index (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-aosoa_struct_begin","title":"function aosoa_struct_begin","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::aosoa_struct_begin (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-cast-12","title":"function cast [1/2]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC T &amp; muda::FieldEntryCore::cast (\n    std::byte * data\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-cast-22","title":"function cast [2/2]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC const T &amp; muda::FieldEntryCore::cast (\n    const std::byte * data\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-count","title":"function count","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryCore::count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-data-13","title":"function data [1/3]","text":"<pre><code>template&lt;typename T, FieldEntryLayout Layout&gt;\ninline MUDA_GENERIC T * muda::FieldEntryCore::data (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-data-23","title":"function data [2/3]","text":"<pre><code>template&lt;typename T, FieldEntryLayout Layout&gt;\ninline MUDA_GENERIC T * muda::FieldEntryCore::data (\n    int i,\n    int j\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-data-33","title":"function data [3/3]","text":"<pre><code>template&lt;typename T, FieldEntryLayout Layout&gt;\ninline MUDA_GENERIC T * muda::FieldEntryCore::data (\n    int i,\n    int row_index,\n    int col_index\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-elem_addr-13","title":"function elem_addr [1/3]","text":"<pre><code>template&lt;FieldEntryLayout Layout&gt;\nMUDA_GENERIC std::byte * muda::FieldEntryCore::elem_addr (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-elem_addr-23","title":"function elem_addr [2/3]","text":"<pre><code>template&lt;FieldEntryLayout Layout&gt;\nMUDA_GENERIC std::byte * muda::FieldEntryCore::elem_addr (\n    int i,\n    int j\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-elem_addr-33","title":"function elem_addr [3/3]","text":"<pre><code>template&lt;FieldEntryLayout Layout&gt;\nMUDA_GENERIC std::byte * muda::FieldEntryCore::elem_addr (\n    int i,\n    int row_index,\n    int col_index\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-elem_byte_size","title":"function elem_byte_size","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryCore::elem_byte_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-layout","title":"function layout","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryCore::layout () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-layout_info","title":"function layout_info","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryCore::layout_info () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-name","title":"function name","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryCore::name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-name_string_pointer","title":"function name_string_pointer","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryCore::name_string_pointer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-shape","title":"function shape","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryCore::shape () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-soa_elem_addr-13","title":"function soa_elem_addr [1/3]","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::soa_elem_addr (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-soa_elem_addr-23","title":"function soa_elem_addr [2/3]","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::soa_elem_addr (\n    int i,\n    int j\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-soa_elem_addr-33","title":"function soa_elem_addr [3/3]","text":"<pre><code>MUDA_GENERIC std::byte * muda::FieldEntryCore::soa_elem_addr (\n    int i,\n    int row_index,\n    int col_index\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_core/#function-struct_stride","title":"function struct_stride","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryCore::struct_stride () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_core.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_launch/","title":"Class muda::FieldEntryLaunch","text":"<p>ClassList &gt; muda &gt; FieldEntryLaunch</p> <p>Inherits the following classes: muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_field_entry_launch/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_field_entry_launch/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC FieldEntryLaunch (cudaStream_t stream=nullptr)  MUDA_HOST FieldEntryLaunch &amp; copy (FieldEntryView&lt; T, DstLayout, M, N &gt; dst, CFieldEntryView&lt; T, SrcLayout, M, N &gt; src)  MUDA_HOST FieldEntryLaunch &amp; copy (BufferView&lt; typename CFieldEntryView&lt; T, SrcLayout, M, N &gt;::ElementType &gt; dst, CFieldEntryView&lt; T, SrcLayout, M, N &gt; src)  MUDA_HOST FieldEntryLaunch &amp; copy (FieldEntryView&lt; T, DstLayout, M, N &gt; dst, CBufferView&lt; typename FieldEntryView&lt; T, DstLayout, M, N &gt;::ElementType &gt; src)  MUDA_HOST FieldEntryLaunch &amp; fill (FieldEntryView&lt; T, DstLayout, M, N &gt; dst, const typename FieldEntryView&lt; T, DstLayout, M, N &gt;::ElementType &amp; value)"},{"location":"muda/classmuda_1_1_field_entry_launch/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_field_entry_launch/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_field_entry_launch/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_field_entry_launch/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_field_entry_launch/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_field_entry_launch/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_field_entry_launch/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_field_entry_launch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_launch/#function-fieldentrylaunch","title":"function FieldEntryLaunch","text":"<pre><code>inline MUDA_GENERIC muda::FieldEntryLaunch::FieldEntryLaunch (\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_launch/#function-copy-13","title":"function copy [1/3]","text":"<pre><code>template&lt;typename T, FieldEntryLayout DstLayout, FieldEntryLayout SrcLayout, int M, int N&gt;\nMUDA_HOST FieldEntryLaunch &amp; muda::FieldEntryLaunch::copy (\n    FieldEntryView &lt; T, DstLayout, M, N &gt; dst,\n    CFieldEntryView &lt; T, SrcLayout, M, N &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_launch/#function-copy-23","title":"function copy [2/3]","text":"<pre><code>template&lt;typename T, FieldEntryLayout SrcLayout, int M, int N&gt;\nMUDA_HOST FieldEntryLaunch &amp; muda::FieldEntryLaunch::copy (\n    BufferView &lt; typename CFieldEntryView &lt; T, SrcLayout, M, N &gt;::ElementType &gt; dst,\n    CFieldEntryView &lt; T, SrcLayout, M, N &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_launch/#function-copy-33","title":"function copy [3/3]","text":"<pre><code>template&lt;typename T, FieldEntryLayout DstLayout, int M, int N&gt;\nMUDA_HOST FieldEntryLaunch &amp; muda::FieldEntryLaunch::copy (\n    FieldEntryView &lt; T, DstLayout, M, N &gt; dst,\n    CBufferView &lt; typename FieldEntryView &lt; T, DstLayout, M, N &gt;::ElementType &gt; src\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_launch/#function-fill","title":"function fill","text":"<pre><code>template&lt;typename T, FieldEntryLayout DstLayout, int M, int N&gt;\nMUDA_HOST FieldEntryLaunch &amp; muda::FieldEntryLaunch::fill (\n    FieldEntryView &lt; T, DstLayout, M, N &gt; dst,\n    const typename FieldEntryView &lt; T, DstLayout, M, N &gt;::ElementType &amp; value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_launch.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_layout_info/","title":"Class muda::FieldEntryLayoutInfo","text":"<p>ClassList &gt; muda &gt; FieldEntryLayoutInfo</p>"},{"location":"muda/classmuda_1_1_field_entry_layout_info/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC FieldEntryLayoutInfo (Layout layout, uint32_t innermost_array_size=32)  MUDA_GENERIC FieldEntryLayoutInfo ()  MUDA_GENERIC auto innermost_array_size () const MUDA_GENERIC auto layout () const"},{"location":"muda/classmuda_1_1_field_entry_layout_info/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_layout_info/#function-fieldentrylayoutinfo-12","title":"function FieldEntryLayoutInfo [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::FieldEntryLayoutInfo::FieldEntryLayoutInfo (\n    Layout layout,\n    uint32_t innermost_array_size=32\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_layout_info/#function-fieldentrylayoutinfo-22","title":"function FieldEntryLayoutInfo [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::FieldEntryLayoutInfo::FieldEntryLayoutInfo () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_layout_info/#function-innermost_array_size","title":"function innermost_array_size","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryLayoutInfo::innermost_array_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_layout_info/#function-layout","title":"function layout","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryLayoutInfo::layout () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_layout.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_view/","title":"Class muda::FieldEntryView","text":"<p>template &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; FieldEntryView</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_view.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_view_base/","title":"Class muda::FieldEntryViewBase","text":"<p>template &lt;bool IsConst, typename T, FieldEntryLayout Layout, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; FieldEntryViewBase</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_view.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_view_core/","title":"Class muda::FieldEntryViewCore","text":"<p>template &lt;bool IsConst, typename T, FieldEntryLayout Layout, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; FieldEntryViewCore</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#public-types","title":"Public Types","text":"Type Name typedef typename ViewerCore::ConstMatMap ConstMatMap typedef CFieldEntryViewer&lt; T, Layout, M, N &gt; ConstViewer typedef typename ViewerCore::MatStride MatStride typedef typename ViewerCore::NonConstMatMap NonConstMatMap typedef FieldEntryViewer&lt; T, Layout, M, N &gt; NonConstViewer typedef typename ViewerCore::ThisMatMap ThisMatMap typedef std::conditional_t&lt; IsConst, ConstViewer, NonConstViewer &gt; ThisViewer typedef typename Base::template auto_const_t&lt; U &gt; auto_const_t"},{"location":"muda/classmuda_1_1_field_entry_view_core/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_field_entry_view_core/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_field_entry_view_core/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC FieldEntryViewCore () = default MUDA_GENERIC FieldEntryViewCore (HostDeviceConfigView&lt; FieldEntryCore &gt; core, int offset, int size)  MUDA_GENERIC auto cviewer () const MUDA_GENERIC auto elem_byte_size () const MUDA_GENERIC auto layout () const MUDA_GENERIC auto layout_info () const MUDA_GENERIC auto name () const MUDA_GENERIC auto offset () const MUDA_GENERIC auto shape () const MUDA_GENERIC auto size () const MUDA_GENERIC auto struct_stride () const MUDA_GENERIC auto total_count () const MUDA_GENERIC auto viewer ()"},{"location":"muda/classmuda_1_1_field_entry_view_core/#protected-attributes","title":"Protected Attributes","text":"Type Name HostDeviceConfigView&lt; FieldEntryCore &gt; m_core int m_offset   = = 0 int m_size   = = 0 MatStride m_stride"},{"location":"muda/classmuda_1_1_field_entry_view_core/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_GENERIC FieldEntryViewCore (HostDeviceConfigView&lt; FieldEntryCore &gt; core, int offset, int size, AsIterator)  MUDA_GENERIC T * data (int i) const MUDA_GENERIC T * data (int i, int j) const MUDA_GENERIC T * data (int i, int row_index, int col_index) const"},{"location":"muda/classmuda_1_1_field_entry_view_core/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_view_core/#typedef-constmatmap","title":"typedef ConstMatMap","text":"<pre><code>using muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::ConstMatMap =  typename ViewerCore::ConstMatMap;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::ConstViewer =  CFieldEntryViewer&lt;T, Layout, M, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#typedef-matstride","title":"typedef MatStride","text":"<pre><code>using muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::MatStride =  typename ViewerCore::MatStride;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#typedef-nonconstmatmap","title":"typedef NonConstMatMap","text":"<pre><code>using muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::NonConstMatMap =  typename ViewerCore::NonConstMatMap;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::NonConstViewer =  FieldEntryViewer&lt;T, Layout, M, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#typedef-thismatmap","title":"typedef ThisMatMap","text":"<pre><code>using muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::ThisMatMap =  typename ViewerCore::ThisMatMap;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::ThisViewer =  std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#typedef-auto_const_t","title":"typedef auto_const_t","text":"<pre><code>using muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::auto_const_t =  typename Base::template auto_const_t&lt;U&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-fieldentryviewcore-23","title":"function FieldEntryViewCore [2/3]","text":"<pre><code>MUDA_GENERIC muda::FieldEntryViewCore::FieldEntryViewCore () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-fieldentryviewcore-33","title":"function FieldEntryViewCore [3/3]","text":"<pre><code>inline MUDA_GENERIC muda::FieldEntryViewCore::FieldEntryViewCore (\n    HostDeviceConfigView &lt; FieldEntryCore &gt; core,\n    int offset,\n    int size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-cviewer","title":"function cviewer","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-elem_byte_size","title":"function elem_byte_size","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::elem_byte_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-layout","title":"function layout","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::layout () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-layout_info","title":"function layout_info","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::layout_info () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-name","title":"function name","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-offset","title":"function offset","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-shape","title":"function shape","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::shape () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-size","title":"function size","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-struct_stride","title":"function struct_stride","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::struct_stride () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-total_count","title":"function total_count","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::total_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-viewer","title":"function viewer","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewCore::viewer () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_view_core/#variable-m_core","title":"variable m_core","text":"<pre><code>HostDeviceConfigView&lt;FieldEntryCore&gt; muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::m_core;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#variable-m_offset","title":"variable m_offset","text":"<pre><code>int muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::m_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#variable-m_size","title":"variable m_size","text":"<pre><code>int muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::m_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#variable-m_stride","title":"variable m_stride","text":"<pre><code>MatStride muda::FieldEntryViewCore&lt; IsConst, T, Layout, M, N &gt;::m_stride;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-fieldentryviewcore-13","title":"function FieldEntryViewCore [1/3]","text":"<pre><code>inline MUDA_GENERIC muda::FieldEntryViewCore::FieldEntryViewCore (\n    HostDeviceConfigView &lt; FieldEntryCore &gt; core,\n    int offset,\n    int size,\n    AsIterator\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-data-13","title":"function data [1/3]","text":"<pre><code>inline MUDA_GENERIC T * muda::FieldEntryViewCore::data (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-data-23","title":"function data [2/3]","text":"<pre><code>inline MUDA_GENERIC T * muda::FieldEntryViewCore::data (\n    int i,\n    int j\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_view_core/#function-data-33","title":"function data [3/3]","text":"<pre><code>inline MUDA_GENERIC T * muda::FieldEntryViewCore::data (\n    int i,\n    int row_index,\n    int col_index\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_view.h</code></p>"},{"location":"muda/structmuda_1_1_field_entry_view_core_1_1_as_iterator/","title":"Struct muda::FieldEntryViewCore::AsIterator","text":"<p>ClassList &gt; muda &gt; FieldEntryViewCore &gt; AsIterator</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_view.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_viewer/","title":"Class muda::FieldEntryViewer","text":"<p>template &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; FieldEntryViewer</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_viewer_base/","title":"Class muda::FieldEntryViewerBase","text":"<p>template &lt;bool IsConst, typename T, FieldEntryLayout Layout, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; FieldEntryViewerBase</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/","title":"Class muda::FieldEntryViewerCore","text":"<p>template &lt;bool IsConst, typename T, FieldEntryLayout Layout, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; FieldEntryViewerCore</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#public-types","title":"Public Types","text":"Type Name typedef Eigen::Map&lt; const Eigen::Matrix&lt; T, M, N &gt;, 0, MatStride &gt; ConstMatMap typedef details::field::MatStride MatStride typedef Eigen::Map&lt; Eigen::Matrix&lt; T, M, N &gt;, 0, MatStride &gt; NonConstMatMap typedef std::conditional_t&lt; IsConst, ConstMatMap, NonConstMatMap &gt; ThisMatMap"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC FieldEntryViewerCore ()  MUDA_GENERIC FieldEntryViewerCore (HostDeviceConfigView&lt; FieldEntryCore &gt; core, int offset, int size)  MUDA_GENERIC FieldEntryViewerCore (const FieldEntryViewerCore &amp;) = default MUDA_GENERIC T * data (int i) const MUDA_GENERIC T * data (int i, int j) const MUDA_GENERIC T * data (int i, int row_index, int col_index) const MUDA_GENERIC auto elem_byte_size () const MUDA_GENERIC auto entry_name () const MUDA_GENERIC auto layout () const MUDA_GENERIC auto layout_info () const MUDA_GENERIC auto offset () const MUDA_GENERIC auto shape () const MUDA_GENERIC auto size () const MUDA_GENERIC auto struct_stride () const MUDA_GENERIC auto total_count () const"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#protected-types","title":"Protected Types","text":"Type Name typedef typename Base::template auto_const_t&lt; U &gt; auto_const_t"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#protected-attributes","title":"Protected Attributes","text":"Type Name HostDeviceConfigView&lt; FieldEntryCore &gt; m_core int m_offset   = = 0 int m_size   = = 0 MatStride m_stride"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#typedef-constmatmap","title":"typedef ConstMatMap","text":"<pre><code>using muda::FieldEntryViewerCore&lt; IsConst, T, Layout, M, N &gt;::ConstMatMap =  Eigen::Map&lt;const Eigen::Matrix&lt;T, M, N&gt;, 0, MatStride&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#typedef-matstride","title":"typedef MatStride","text":"<pre><code>using muda::FieldEntryViewerCore&lt; IsConst, T, Layout, M, N &gt;::MatStride =  details::field::MatStride;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#typedef-nonconstmatmap","title":"typedef NonConstMatMap","text":"<pre><code>using muda::FieldEntryViewerCore&lt; IsConst, T, Layout, M, N &gt;::NonConstMatMap =  Eigen::Map&lt;Eigen::Matrix&lt;T, M, N&gt;, 0, MatStride&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#typedef-thismatmap","title":"typedef ThisMatMap","text":"<pre><code>using muda::FieldEntryViewerCore&lt; IsConst, T, Layout, M, N &gt;::ThisMatMap =  std::conditional_t&lt;IsConst, ConstMatMap, NonConstMatMap&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-fieldentryviewercore-13","title":"function FieldEntryViewerCore [1/3]","text":"<pre><code>inline MUDA_GENERIC muda::FieldEntryViewerCore::FieldEntryViewerCore () \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-fieldentryviewercore-23","title":"function FieldEntryViewerCore [2/3]","text":"<pre><code>inline MUDA_GENERIC muda::FieldEntryViewerCore::FieldEntryViewerCore (\n    HostDeviceConfigView &lt; FieldEntryCore &gt; core,\n    int offset,\n    int size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-fieldentryviewercore-33","title":"function FieldEntryViewerCore [3/3]","text":"<pre><code>MUDA_GENERIC muda::FieldEntryViewerCore::FieldEntryViewerCore (\n    const FieldEntryViewerCore &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-data-13","title":"function data [1/3]","text":"<pre><code>inline MUDA_GENERIC T * muda::FieldEntryViewerCore::data (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-data-23","title":"function data [2/3]","text":"<pre><code>inline MUDA_GENERIC T * muda::FieldEntryViewerCore::data (\n    int i,\n    int j\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-data-33","title":"function data [3/3]","text":"<pre><code>inline MUDA_GENERIC T * muda::FieldEntryViewerCore::data (\n    int i,\n    int row_index,\n    int col_index\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-elem_byte_size","title":"function elem_byte_size","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewerCore::elem_byte_size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-entry_name","title":"function entry_name","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewerCore::entry_name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-layout","title":"function layout","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewerCore::layout () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-layout_info","title":"function layout_info","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewerCore::layout_info () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-offset","title":"function offset","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewerCore::offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-shape","title":"function shape","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewerCore::shape () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-size","title":"function size","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewerCore::size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-struct_stride","title":"function struct_stride","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewerCore::struct_stride () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#function-total_count","title":"function total_count","text":"<pre><code>inline MUDA_GENERIC auto muda::FieldEntryViewerCore::total_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#typedef-auto_const_t","title":"typedef auto_const_t","text":"<pre><code>using muda::FieldEntryViewerCore&lt; IsConst, T, Layout, M, N &gt;::auto_const_t =  typename Base::template auto_const_t&lt;U&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#variable-m_core","title":"variable m_core","text":"<pre><code>HostDeviceConfigView&lt;FieldEntryCore&gt; muda::FieldEntryViewerCore&lt; IsConst, T, Layout, M, N &gt;::m_core;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#variable-m_offset","title":"variable m_offset","text":"<pre><code>int muda::FieldEntryViewerCore&lt; IsConst, T, Layout, M, N &gt;::m_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#variable-m_size","title":"variable m_size","text":"<pre><code>int muda::FieldEntryViewerCore&lt; IsConst, T, Layout, M, N &gt;::m_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_field_entry_viewer_core/#variable-m_stride","title":"variable m_stride","text":"<pre><code>MatStride muda::FieldEntryViewerCore&lt; IsConst, T, Layout, M, N &gt;::m_stride;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_flags/","title":"Class muda::Flags","text":"<p>template &lt;typename BitType&gt;</p> <p>ClassList &gt; muda &gt; Flags</p>"},{"location":"muda/classmuda_1_1_flags/#public-types","title":"Public Types","text":"Type Name typedef BitType bit_type typedef typename ::std::underlying_type&lt; bit_type &gt;::type mask_type"},{"location":"muda/classmuda_1_1_flags/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC MUDA_CONSTEXPR Flags ()  MUDA_GENERIC MUDA_CONSTEXPR Flags (BitType bit)  MUDA_GENERIC MUDA_CONSTEXPR Flags (Flags&lt; BitType &gt; const &amp; rhs)  MUDA_GENERIC MUDA_CONSTEXPR Flags (mask_type flags)  MUDA_GENERIC MUDA_CONSTEXPR bool has (BitType bit) const MUDA_GENERIC MUDA_CONSTEXPR operator bool () const MUDA_GENERIC MUDA_CONSTEXPR operator mask_type () const MUDA_GENERIC MUDA_CONSTEXPR bool operator! () const MUDA_GENERIC MUDA_CONSTEXPR bool operator!= (Flags&lt; BitType &gt; const &amp; rhs) const MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; operator&amp; (Flags&lt; BitType &gt; const &amp; rhs) const MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; &amp; operator&amp;= (Flags&lt; BitType &gt; const &amp; rhs)  MUDA_GENERIC MUDA_CONSTEXPR bool operator&lt; (Flags&lt; BitType &gt; const &amp; rhs) const MUDA_GENERIC MUDA_CONSTEXPR bool operator&lt;= (Flags&lt; BitType &gt; const &amp; rhs) const MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; &amp; operator= (Flags&lt; BitType &gt; const &amp; rhs)  MUDA_GENERIC MUDA_CONSTEXPR bool operator== (Flags&lt; BitType &gt; const &amp; rhs) const MUDA_GENERIC MUDA_CONSTEXPR bool operator&gt; (Flags&lt; BitType &gt; const &amp; rhs) const MUDA_GENERIC MUDA_CONSTEXPR bool operator&gt;= (Flags&lt; BitType &gt; const &amp; rhs) const MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; operator^ (Flags&lt; BitType &gt; const &amp; rhs) const MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; &amp; operator^= (Flags&lt; BitType &gt; const &amp; rhs)  MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; operator| (Flags&lt; BitType &gt; const &amp; rhs) const MUDA_GENERIC MUDA_CONSTEXPR Flags&lt; BitType &gt; &amp; operator|= (Flags&lt; BitType &gt; const &amp; rhs)"},{"location":"muda/classmuda_1_1_flags/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_flags/#typedef-bit_type","title":"typedef bit_type","text":"<pre><code>using muda::Flags&lt; BitType &gt;::bit_type =  BitType;\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#typedef-mask_type","title":"typedef mask_type","text":"<pre><code>using muda::Flags&lt; BitType &gt;::mask_type =  typename ::std::underlying_type&lt;bit_type&gt;::type;\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_flags/#function-flags-14","title":"function Flags [1/4]","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR muda::Flags::Flags () \n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-flags-24","title":"function Flags [2/4]","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR muda::Flags::Flags (\n    BitType bit\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-flags-34","title":"function Flags [3/4]","text":"<pre><code>MUDA_GENERIC MUDA_CONSTEXPR muda::Flags::Flags (\n    Flags &lt; BitType &gt; const &amp; rhs\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-flags-44","title":"function Flags [4/4]","text":"<pre><code>inline explicit MUDA_GENERIC MUDA_CONSTEXPR muda::Flags::Flags (\n    mask_type flags\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-has","title":"function has","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR bool muda::Flags::has (\n    BitType bit\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit MUDA_GENERIC MUDA_CONSTEXPR muda::Flags::operator bool () const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator-mask_type","title":"function operator mask_type","text":"<pre><code>inline explicit MUDA_GENERIC MUDA_CONSTEXPR muda::Flags::operator mask_type () const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator","title":"function operator!","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR bool muda::Flags::operator! () const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_1","title":"function operator!=","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR bool muda::Flags::operator!= (\n    Flags &lt; BitType &gt; const &amp; rhs\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_2","title":"function operator&amp;","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; muda::Flags::operator&amp; (\n    Flags &lt; BitType &gt; const &amp; rhs\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_3","title":"function operator&amp;=","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; &amp; muda::Flags::operator&amp;= (\n    Flags &lt; BitType &gt; const &amp; rhs\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_4","title":"function operator&lt;","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR bool muda::Flags::operator&lt; (\n    Flags &lt; BitType &gt; const &amp; rhs\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_5","title":"function operator&lt;=","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR bool muda::Flags::operator&lt;= (\n    Flags &lt; BitType &gt; const &amp; rhs\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_6","title":"function operator=","text":"<pre><code>MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; &amp; muda::Flags::operator= (\n    Flags &lt; BitType &gt; const &amp; rhs\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_7","title":"function operator==","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR bool muda::Flags::operator== (\n    Flags &lt; BitType &gt; const &amp; rhs\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_8","title":"function operator&gt;","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR bool muda::Flags::operator&gt; (\n    Flags &lt; BitType &gt; const &amp; rhs\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_9","title":"function operator&gt;=","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR bool muda::Flags::operator&gt;= (\n    Flags &lt; BitType &gt; const &amp; rhs\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_10","title":"function operator^","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; muda::Flags::operator^ (\n    Flags &lt; BitType &gt; const &amp; rhs\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_11","title":"function operator^=","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; &amp; muda::Flags::operator^= (\n    Flags &lt; BitType &gt; const &amp; rhs\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_12","title":"function operator|","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; muda::Flags::operator| (\n    Flags &lt; BitType &gt; const &amp; rhs\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_flags/#function-operator_13","title":"function operator|=","text":"<pre><code>inline MUDA_GENERIC MUDA_CONSTEXPR Flags &lt; BitType &gt; &amp; muda::Flags::operator|= (\n    Flags &lt; BitType &gt; const &amp; rhs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/flag.h</code></p>"},{"location":"muda/classmuda_1_1_graph/","title":"Class muda::Graph","text":"<p>ClassList &gt; muda &gt; Graph</p>"},{"location":"muda/classmuda_1_1_graph/#public-functions","title":"Public Functions","text":"Type Name Graph ()  Graph (const Graph &amp;) = delete Graph (Graph &amp;&amp;)  void add_dependency (S&lt; GraphNode &gt; from, S&lt; GraphNode &gt; to)  S&lt; EventRecordNode &gt; add_event_record_node (cudaEvent_t e, const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps)  S&lt; EventRecordNode &gt; add_event_record_node (cudaEvent_t e)  S&lt; EventWaitNode &gt; add_event_wait_node (cudaEvent_t e, const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps)  S&lt; EventWaitNode &gt; add_event_wait_node (cudaEvent_t e)  S&lt; HostNode &gt; add_host_node (const S&lt; HostNodeParms&lt; T &gt; &gt; &amp; hostParms, const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps)  S&lt; HostNode &gt; add_host_node (const S&lt; HostNodeParms&lt; T &gt; &gt; &amp; hostParms)  S&lt; KernelNode &gt; add_kernel_node (const S&lt; KernelNodeParms&lt; T &gt; &gt; &amp; kernelParms, const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps)  S&lt; KernelNode &gt; add_kernel_node (const S&lt; KernelNodeParms&lt; T &gt; &gt; &amp; kernelParms)  S&lt; MemcpyNode &gt; add_memcpy_node (void * dst, const void * src, size_t size_bytes, cudaMemcpyKind kind, const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps)  S&lt; MemcpyNode &gt; add_memcpy_node (void * dst, const void * src, size_t size_bytes, cudaMemcpyKind kind)  S&lt; MemcpyNode &gt; add_memcpy_node (const cudaMemcpy3DParms &amp; parms)  S&lt; MemcpyNode &gt; add_memcpy_node (const cudaMemcpy3DParms &amp; parms, const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps)  S&lt; MemsetNode &gt; add_memset_node (const cudaMemsetParams &amp; parms, const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps)  S&lt; MemsetNode &gt; add_memset_node (const cudaMemsetParams &amp; parms)  cudaGraph_t handle () const cudaGraph_t handle ()  MUDA_NODISCARD S&lt; GraphExec &gt; instantiate ()  MUDA_NODISCARD S&lt; GraphExec &gt; instantiate (Flags&lt; GraphInstantiateFlagBit &gt; flags)  Graph &amp; operator= (const Graph &amp;) = delete Graph &amp; operator= (Graph &amp;&amp;)  ~Graph ()"},{"location":"muda/classmuda_1_1_graph/#public-static-functions","title":"Public Static Functions","text":"Type Name auto create ()"},{"location":"muda/classmuda_1_1_graph/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_graph/#function-graph-13","title":"function Graph [1/3]","text":"<pre><code>muda::Graph::Graph () \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-graph-23","title":"function Graph [2/3]","text":"<pre><code>muda::Graph::Graph (\n    const Graph &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-graph-33","title":"function Graph [3/3]","text":"<pre><code>muda::Graph::Graph (\n    Graph &amp;&amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_dependency","title":"function add_dependency","text":"<pre><code>void muda::Graph::add_dependency (\n    S&lt; GraphNode &gt; from,\n    S&lt; GraphNode &gt; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_event_record_node-12","title":"function add_event_record_node [1/2]","text":"<pre><code>S&lt; EventRecordNode &gt; muda::Graph::add_event_record_node (\n    cudaEvent_t e,\n    const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_event_record_node-22","title":"function add_event_record_node [2/2]","text":"<pre><code>S&lt; EventRecordNode &gt; muda::Graph::add_event_record_node (\n    cudaEvent_t e\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_event_wait_node-12","title":"function add_event_wait_node [1/2]","text":"<pre><code>S&lt; EventWaitNode &gt; muda::Graph::add_event_wait_node (\n    cudaEvent_t e,\n    const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_event_wait_node-22","title":"function add_event_wait_node [2/2]","text":"<pre><code>S&lt; EventWaitNode &gt; muda::Graph::add_event_wait_node (\n    cudaEvent_t e\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_host_node-12","title":"function add_host_node [1/2]","text":"<pre><code>template&lt;typename T&gt;\nS&lt; HostNode &gt; muda::Graph::add_host_node (\n    const S&lt; HostNodeParms &lt; T &gt; &gt; &amp; hostParms,\n    const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_host_node-22","title":"function add_host_node [2/2]","text":"<pre><code>template&lt;typename T&gt;\nS&lt; HostNode &gt; muda::Graph::add_host_node (\n    const S&lt; HostNodeParms &lt; T &gt; &gt; &amp; hostParms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_kernel_node-12","title":"function add_kernel_node [1/2]","text":"<pre><code>template&lt;typename T&gt;\nS&lt; KernelNode &gt; muda::Graph::add_kernel_node (\n    const S&lt; KernelNodeParms &lt; T &gt; &gt; &amp; kernelParms,\n    const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_kernel_node-22","title":"function add_kernel_node [2/2]","text":"<pre><code>template&lt;typename T&gt;\nS&lt; KernelNode &gt; muda::Graph::add_kernel_node (\n    const S&lt; KernelNodeParms &lt; T &gt; &gt; &amp; kernelParms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_memcpy_node-14","title":"function add_memcpy_node [1/4]","text":"<pre><code>S&lt; MemcpyNode &gt; muda::Graph::add_memcpy_node (\n    void * dst,\n    const void * src,\n    size_t size_bytes,\n    cudaMemcpyKind kind,\n    const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_memcpy_node-24","title":"function add_memcpy_node [2/4]","text":"<pre><code>S&lt; MemcpyNode &gt; muda::Graph::add_memcpy_node (\n    void * dst,\n    const void * src,\n    size_t size_bytes,\n    cudaMemcpyKind kind\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_memcpy_node-34","title":"function add_memcpy_node [3/4]","text":"<pre><code>S&lt; MemcpyNode &gt; muda::Graph::add_memcpy_node (\n    const cudaMemcpy3DParms &amp; parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_memcpy_node-44","title":"function add_memcpy_node [4/4]","text":"<pre><code>S&lt; MemcpyNode &gt; muda::Graph::add_memcpy_node (\n    const cudaMemcpy3DParms &amp; parms,\n    const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_memset_node-12","title":"function add_memset_node [1/2]","text":"<pre><code>S&lt; MemsetNode &gt; muda::Graph::add_memset_node (\n    const cudaMemsetParams &amp; parms,\n    const std::vector&lt; S&lt; GraphNode &gt; &gt; &amp; deps\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-add_memset_node-22","title":"function add_memset_node [2/2]","text":"<pre><code>S&lt; MemsetNode &gt; muda::Graph::add_memset_node (\n    const cudaMemsetParams &amp; parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-handle-12","title":"function handle [1/2]","text":"<pre><code>inline cudaGraph_t muda::Graph::handle () const\n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-handle-22","title":"function handle [2/2]","text":"<pre><code>inline cudaGraph_t muda::Graph::handle () \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-instantiate-12","title":"function instantiate [1/2]","text":"<pre><code>MUDA_NODISCARD S&lt; GraphExec &gt; muda::Graph::instantiate () \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-instantiate-22","title":"function instantiate [2/2]","text":"<pre><code>MUDA_NODISCARD S&lt; GraphExec &gt; muda::Graph::instantiate (\n    Flags &lt; GraphInstantiateFlagBit &gt; flags\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-operator","title":"function operator=","text":"<pre><code>Graph &amp; muda::Graph::operator= (\n    const Graph &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-operator_1","title":"function operator=","text":"<pre><code>Graph &amp; muda::Graph::operator= (\n    Graph &amp;&amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#function-graph","title":"function ~Graph","text":"<pre><code>muda::Graph::~Graph () \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_graph/#function-create","title":"function create","text":"<pre><code>static inline auto muda::Graph::create () \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_graph/#friend-graphexec","title":"friend GraphExec","text":"<pre><code>class muda::Graph::GraphExec (\n    GraphExec\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph/#friend-shared_ptr-graph","title":"friend shared_ptr&lt; Graph &gt;","text":"<pre><code>class muda::Graph::shared_ptr&lt; Graph &gt; (\n    std::shared_ptr&lt; Graph &gt;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph.h</code></p>"},{"location":"muda/classmuda_1_1_graph_exec/","title":"Class muda::GraphExec","text":"<p>ClassList &gt; muda &gt; GraphExec</p>"},{"location":"muda/classmuda_1_1_graph_exec/#public-functions","title":"Public Functions","text":"Type Name GraphExec ()  GraphExec (const GraphExec &amp;) = delete GraphExec (GraphExec &amp;&amp; other)  cudaGraphExec_t handle () const void launch (cudaStream_t stream=nullptr)  GraphExec &amp; operator= (const GraphExec &amp;) = delete GraphExec &amp; operator= (GraphExec &amp;&amp; other)  void set_event_record_node_parms (S&lt; EventRecordNode &gt; node, cudaEvent_t event)  void set_event_wait_node_parms (S&lt; EventWaitNode &gt; node, cudaEvent_t event)  void set_kernel_node_parms (S&lt; KernelNode &gt; node, const S&lt; KernelNodeParms&lt; T &gt; &gt; &amp; new_parms)  void set_memcpy_node_parms (S&lt; MemcpyNode &gt; node, void * dst, const void * src, size_t size_bytes, cudaMemcpyKind kind)  void set_memcpy_node_parms (S&lt; MemcpyNode &gt; node, const cudaMemcpy3DParms &amp; parms)  void set_memset_node_parms (S&lt; MemsetNode &gt; node, const cudaMemsetParams &amp; parms)  void upload (cudaStream_t stream=nullptr)  GraphViewer viewer () const ~GraphExec ()"},{"location":"muda/classmuda_1_1_graph_exec/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_graph_exec/#function-graphexec-13","title":"function GraphExec [1/3]","text":"<pre><code>muda::GraphExec::GraphExec () \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-graphexec-23","title":"function GraphExec [2/3]","text":"<pre><code>muda::GraphExec::GraphExec (\n    const GraphExec &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-graphexec-33","title":"function GraphExec [3/3]","text":"<pre><code>muda::GraphExec::GraphExec (\n    GraphExec &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-handle","title":"function handle","text":"<pre><code>inline cudaGraphExec_t muda::GraphExec::handle () const\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-launch","title":"function launch","text":"<pre><code>void muda::GraphExec::launch (\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-operator","title":"function operator=","text":"<pre><code>GraphExec &amp; muda::GraphExec::operator= (\n    const GraphExec &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-operator_1","title":"function operator=","text":"<pre><code>GraphExec &amp; muda::GraphExec::operator= (\n    GraphExec &amp;&amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-set_event_record_node_parms","title":"function set_event_record_node_parms","text":"<pre><code>void muda::GraphExec::set_event_record_node_parms (\n    S&lt; EventRecordNode &gt; node,\n    cudaEvent_t event\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-set_event_wait_node_parms","title":"function set_event_wait_node_parms","text":"<pre><code>void muda::GraphExec::set_event_wait_node_parms (\n    S&lt; EventWaitNode &gt; node,\n    cudaEvent_t event\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-set_kernel_node_parms","title":"function set_kernel_node_parms","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::GraphExec::set_kernel_node_parms (\n    S&lt; KernelNode &gt; node,\n    const S&lt; KernelNodeParms &lt; T &gt; &gt; &amp; new_parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-set_memcpy_node_parms-12","title":"function set_memcpy_node_parms [1/2]","text":"<pre><code>void muda::GraphExec::set_memcpy_node_parms (\n    S&lt; MemcpyNode &gt; node,\n    void * dst,\n    const void * src,\n    size_t size_bytes,\n    cudaMemcpyKind kind\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-set_memcpy_node_parms-22","title":"function set_memcpy_node_parms [2/2]","text":"<pre><code>void muda::GraphExec::set_memcpy_node_parms (\n    S&lt; MemcpyNode &gt; node,\n    const cudaMemcpy3DParms &amp; parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-set_memset_node_parms","title":"function set_memset_node_parms","text":"<pre><code>void muda::GraphExec::set_memset_node_parms (\n    S&lt; MemsetNode &gt; node,\n    const cudaMemsetParams &amp; parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-upload","title":"function upload","text":"<pre><code>void muda::GraphExec::upload (\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-viewer","title":"function viewer","text":"<pre><code>GraphViewer muda::GraphExec::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#function-graphexec","title":"function ~GraphExec","text":"<pre><code>muda::GraphExec::~GraphExec () \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_exec/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_graph_exec/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::GraphExec::Graph (\n    Graph\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_exec.h</code></p>"},{"location":"muda/classmuda_1_1_graph_launch/","title":"Class muda::GraphLaunch","text":"<p>ClassList &gt; muda &gt; GraphLaunch</p> <p>Inherits the following classes: muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_graph_launch/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_graph_launch/#public-functions","title":"Public Functions","text":"Type Name GraphLaunch (cudaStream_t stream=nullptr)  GraphLaunch &amp; launch (const GraphViewer &amp; graph)  ~GraphLaunch () = default"},{"location":"muda/classmuda_1_1_graph_launch/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_graph_launch/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_graph_launch/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_graph_launch/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_graph_launch/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_graph_launch/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_graph_launch/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_graph_launch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_graph_launch/#function-graphlaunch","title":"function GraphLaunch","text":"<pre><code>inline muda::GraphLaunch::GraphLaunch (\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_launch/#function-launch","title":"function launch","text":"<pre><code>GraphLaunch &amp; muda::GraphLaunch::launch (\n    const GraphViewer &amp; graph\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_launch/#function-graphlaunch_1","title":"function ~GraphLaunch","text":"<pre><code>muda::GraphLaunch::~GraphLaunch () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_launch.h</code></p>"},{"location":"muda/classmuda_1_1_graph_node/","title":"Class muda::GraphNode","text":"<p>ClassList &gt; muda &gt; GraphNode</p> <p>Inherited by the following classes: muda::EventRecordNode,  muda::EventWaitNode,  muda::HostNode,  muda::KernelNode,  muda::MemcpyNode,  muda::MemsetNode</p>"},{"location":"muda/classmuda_1_1_graph_node/#public-types","title":"Public Types","text":"Type Name typedef GraphNode this_type"},{"location":"muda/classmuda_1_1_graph_node/#public-functions","title":"Public Functions","text":"Type Name GraphNode ()  cudaGraphNode_t handle () const"},{"location":"muda/classmuda_1_1_graph_node/#protected-attributes","title":"Protected Attributes","text":"Type Name cudaGraphNode_t m_handle"},{"location":"muda/classmuda_1_1_graph_node/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_graph_node/#typedef-this_type","title":"typedef this_type","text":"<pre><code>using muda::GraphNode::this_type =  GraphNode;\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_node/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_graph_node/#function-graphnode","title":"function GraphNode","text":"<pre><code>inline muda::GraphNode::GraphNode () \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_node/#function-handle","title":"function handle","text":"<pre><code>inline cudaGraphNode_t muda::GraphNode::handle () const\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_node/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_graph_node/#variable-m_handle","title":"variable m_handle","text":"<pre><code>cudaGraphNode_t muda::GraphNode::m_handle;\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_node/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_graph_node/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::GraphNode::Graph (\n    Graph\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_node/#friend-graphexec","title":"friend GraphExec","text":"<pre><code>class muda::GraphNode::GraphExec (\n    GraphExec\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_base.h</code></p>"},{"location":"muda/classmuda_1_1_graph_viewer/","title":"Class muda::GraphViewer","text":"<p>ClassList &gt; muda &gt; GraphViewer</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_graph_viewer/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_graph_viewer/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC GraphViewer () = default MUDA_GENERIC GraphViewer (cudaGraphExec_t graph, Flags&lt; GraphInstantiateFlagBit &gt; flags)  MUDA_DEVICE void fire_and_forget () const MUDA_GENERIC auto handle () const MUDA_GENERIC void launch (cudaStream_t stream=nullptr) const MUDA_DEVICE void tail_launch () const"},{"location":"muda/classmuda_1_1_graph_viewer/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_graph_viewer/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_graph_viewer/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_graph_viewer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_graph_viewer/#function-graphviewer-12","title":"function GraphViewer [1/2]","text":"<pre><code>MUDA_GENERIC muda::GraphViewer::GraphViewer () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_viewer/#function-graphviewer-22","title":"function GraphViewer [2/2]","text":"<pre><code>MUDA_GENERIC muda::GraphViewer::GraphViewer (\n    cudaGraphExec_t graph,\n    Flags &lt; GraphInstantiateFlagBit &gt; flags\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_graph_viewer/#function-fire_and_forget","title":"function fire_and_forget","text":"<pre><code>MUDA_DEVICE void muda::GraphViewer::fire_and_forget () const\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_viewer/#function-handle","title":"function handle","text":"<pre><code>inline MUDA_GENERIC auto muda::GraphViewer::handle () const\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_viewer/#function-launch","title":"function launch","text":"<pre><code>MUDA_GENERIC void muda::GraphViewer::launch (\n    cudaStream_t stream=nullptr\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_graph_viewer/#function-tail_launch","title":"function tail_launch","text":"<pre><code>MUDA_DEVICE void muda::GraphViewer::tail_launch () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_host_call/","title":"Class muda::HostCall","text":"<p>ClassList &gt; muda &gt; HostCall</p> <p>Inherits the following classes: muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_host_call/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_host_call/#public-functions","title":"Public Functions","text":"Type Name MUDA_HOST HostCall (cudaStream_t stream=nullptr)  MUDA_HOST HostCall &amp; apply (F &amp;&amp; f, UserTag tag={})  MUDA_NODISCARD MUDA_HOST auto as_node_parms (F &amp;&amp; f, UserTag tag={})"},{"location":"muda/classmuda_1_1_host_call/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_host_call/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_host_call/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_host_call/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_host_call/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_host_call/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_host_call/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_host_call/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_host_call/#function-hostcall","title":"function HostCall","text":"<pre><code>inline MUDA_HOST muda::HostCall::HostCall (\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_call/#function-apply","title":"function apply","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\ninline MUDA_HOST HostCall &amp; muda::HostCall::apply (\n    F &amp;&amp; f,\n    UserTag tag={}\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_call/#function-as_node_parms","title":"function as_node_parms","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\ninline MUDA_NODISCARD MUDA_HOST auto muda::HostCall::as_node_parms (\n    F &amp;&amp; f,\n    UserTag tag={}\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>F</code> </li> <li><code>UserTag</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>f</code> </li> <li><code>tag</code> </li> </ul> <p>Returns:</p> <p>The documentation for this class was generated from the following file <code>src/muda/launch/host_call.h</code></p>"},{"location":"muda/classmuda_1_1_host_device_config/","title":"Class muda::HostDeviceConfig","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; HostDeviceConfig</p>"},{"location":"muda/classmuda_1_1_host_device_config/#public-types","title":"Public Types","text":"Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_host_device_config/#public-functions","title":"Public Functions","text":"Type Name HostDeviceConfig () = default HostDeviceConfig (const T &amp; value)  HostDeviceConfig (const HostDeviceConfig &amp;) = default HostDeviceConfig (HostDeviceConfig &amp;&amp;)  auto buffer_view ()  auto buffer_view () const const T * device_data () const const T * host_data () const T * host_data ()  HostDeviceConfig &amp; operator= (const HostDeviceConfig&lt; T &gt; &amp;) = default HostDeviceConfig &amp; operator= (HostDeviceConfig&lt; T &gt; &amp;&amp;) = default HostDeviceConfig &amp; operator= (const T &amp; val)  auto view () const"},{"location":"muda/classmuda_1_1_host_device_config/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_host_device_config/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::HostDeviceConfig&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_host_device_config/#function-hostdeviceconfig-14","title":"function HostDeviceConfig [1/4]","text":"<pre><code>muda::HostDeviceConfig::HostDeviceConfig () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-hostdeviceconfig-24","title":"function HostDeviceConfig [2/4]","text":"<pre><code>inline muda::HostDeviceConfig::HostDeviceConfig (\n    const T &amp; value\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-hostdeviceconfig-34","title":"function HostDeviceConfig [3/4]","text":"<pre><code>muda::HostDeviceConfig::HostDeviceConfig (\n    const HostDeviceConfig &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-hostdeviceconfig-44","title":"function HostDeviceConfig [4/4]","text":"<pre><code>muda::HostDeviceConfig::HostDeviceConfig (\n    HostDeviceConfig &amp;&amp;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-buffer_view-12","title":"function buffer_view [1/2]","text":"<pre><code>inline auto muda::HostDeviceConfig::buffer_view () \n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-buffer_view-22","title":"function buffer_view [2/2]","text":"<pre><code>inline auto muda::HostDeviceConfig::buffer_view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-device_data","title":"function device_data","text":"<pre><code>inline const T * muda::HostDeviceConfig::device_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-host_data-12","title":"function host_data [1/2]","text":"<pre><code>inline const T * muda::HostDeviceConfig::host_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-host_data-22","title":"function host_data [2/2]","text":"<pre><code>inline T * muda::HostDeviceConfig::host_data () \n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-operator","title":"function operator=","text":"<pre><code>HostDeviceConfig &amp; muda::HostDeviceConfig::operator= (\n    const HostDeviceConfig &lt; T &gt; &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-operator_1","title":"function operator=","text":"<pre><code>HostDeviceConfig &amp; muda::HostDeviceConfig::operator= (\n    HostDeviceConfig &lt; T &gt; &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-operator_2","title":"function operator=","text":"<pre><code>inline HostDeviceConfig &amp; muda::HostDeviceConfig::operator= (\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config/#function-view","title":"function view","text":"<pre><code>inline auto muda::HostDeviceConfig::view () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/host_device_config.h</code></p>"},{"location":"muda/classmuda_1_1_host_device_config_view/","title":"Class muda::HostDeviceConfigView","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; HostDeviceConfigView</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_host_device_config_view/#public-types","title":"Public Types","text":"Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_host_device_config_view/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_host_device_config_view/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_host_device_config_view/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC HostDeviceConfigView (const T * host_data, const T * device_data)  MUDA_GENERIC const T * data () const MUDA_GENERIC const T * device_data () const MUDA_GENERIC const T * host_data () const MUDA_GENERIC const T &amp; operator* () const MUDA_GENERIC const T * operator-&gt; () const"},{"location":"muda/classmuda_1_1_host_device_config_view/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_host_device_config_view/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::HostDeviceConfigView&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config_view/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_host_device_config_view/#function-hostdeviceconfigview","title":"function HostDeviceConfigView","text":"<pre><code>inline MUDA_GENERIC muda::HostDeviceConfigView::HostDeviceConfigView (\n    const T * host_data,\n    const T * device_data\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config_view/#function-data","title":"function data","text":"<pre><code>inline MUDA_GENERIC const T * muda::HostDeviceConfigView::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config_view/#function-device_data","title":"function device_data","text":"<pre><code>inline MUDA_GENERIC const T * muda::HostDeviceConfigView::device_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config_view/#function-host_data","title":"function host_data","text":"<pre><code>inline MUDA_GENERIC const T * muda::HostDeviceConfigView::host_data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config_view/#function-operator","title":"function operator*","text":"<pre><code>inline MUDA_GENERIC const T &amp; muda::HostDeviceConfigView::operator* () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_device_config_view/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline MUDA_GENERIC const T * muda::HostDeviceConfigView::operator-&gt; () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/host_device_config.h</code></p>"},{"location":"muda/classmuda_1_1_host_node/","title":"Class muda::HostNode","text":"<p>ClassList &gt; muda &gt; HostNode</p> <p>Inherits the following classes: muda::GraphNode</p>"},{"location":"muda/classmuda_1_1_host_node/#public-types","title":"Public Types","text":"Type Name typedef HostNode this_type"},{"location":"muda/classmuda_1_1_host_node/#public-types-inherited-from-mudagraphnode","title":"Public Types inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name typedef GraphNode this_type"},{"location":"muda/classmuda_1_1_host_node/#public-functions-inherited-from-mudagraphnode","title":"Public Functions inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name GraphNode ()  cudaGraphNode_t handle () const"},{"location":"muda/classmuda_1_1_host_node/#protected-attributes-inherited-from-mudagraphnode","title":"Protected Attributes inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name cudaGraphNode_t m_handle"},{"location":"muda/classmuda_1_1_host_node/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_host_node/#typedef-this_type","title":"typedef this_type","text":"<pre><code>using muda::HostNode::this_type =  HostNode;\n</code></pre>"},{"location":"muda/classmuda_1_1_host_node/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_host_node/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::HostNode::Graph (\n    Graph\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/host_node.h</code></p>"},{"location":"muda/classmuda_1_1_host_node_parms/","title":"Class muda::HostNodeParms","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; HostNodeParms</p> <p>Inherits the following classes: muda::NodeParms</p>"},{"location":"muda/classmuda_1_1_host_node_parms/#public-types","title":"Public Types","text":"Type Name typedef HostNodeParms this_type"},{"location":"muda/classmuda_1_1_host_node_parms/#public-attributes","title":"Public Attributes","text":"Type Name T hostData"},{"location":"muda/classmuda_1_1_host_node_parms/#public-functions","title":"Public Functions","text":"Type Name HostNodeParms (const T &amp; f)  auto fn () const void fn (cudaHostFn_t fn)  const cudaHostNodeParams * handle () const cudaHostNodeParams * handle ()  auto userdata () const void userdata (void * userdata)"},{"location":"muda/classmuda_1_1_host_node_parms/#public-functions-inherited-from-mudanodeparms","title":"Public Functions inherited from muda::NodeParms","text":"<p>See muda::NodeParms</p> Type Name NodeParms () = default virtual ~NodeParms () = default"},{"location":"muda/classmuda_1_1_host_node_parms/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_host_node_parms/#typedef-this_type","title":"typedef this_type","text":"<pre><code>using muda::HostNodeParms&lt; T &gt;::this_type =  HostNodeParms;\n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_host_node_parms/#variable-hostdata","title":"variable hostData","text":"<pre><code>T muda::HostNodeParms&lt; T &gt;::hostData;\n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_host_node_parms/#function-hostnodeparms","title":"function HostNodeParms","text":"<pre><code>inline muda::HostNodeParms::HostNodeParms (\n    const T &amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#function-fn-12","title":"function fn [1/2]","text":"<pre><code>inline auto muda::HostNodeParms::fn () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#function-fn-22","title":"function fn [2/2]","text":"<pre><code>inline void muda::HostNodeParms::fn (\n    cudaHostFn_t fn\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#function-handle-12","title":"function handle [1/2]","text":"<pre><code>inline const cudaHostNodeParams * muda::HostNodeParms::handle () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#function-handle-22","title":"function handle [2/2]","text":"<pre><code>inline cudaHostNodeParams * muda::HostNodeParms::handle () \n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#function-userdata-12","title":"function userdata [1/2]","text":"<pre><code>inline auto muda::HostNodeParms::userdata () const\n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#function-userdata-22","title":"function userdata [2/2]","text":"<pre><code>inline void muda::HostNodeParms::userdata (\n    void * userdata\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_host_node_parms/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::HostNodeParms::Graph (\n    Graph\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#friend-shared_ptr-this_type","title":"friend shared_ptr&lt; this_type &gt;","text":"<pre><code>class muda::HostNodeParms::shared_ptr&lt; this_type &gt; (\n    std::shared_ptr&lt; this_type &gt;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#friend-unique_ptr-this_type","title":"friend unique_ptr&lt; this_type &gt;","text":"<pre><code>class muda::HostNodeParms::unique_ptr&lt; this_type &gt; (\n    std::unique_ptr&lt; this_type &gt;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_host_node_parms/#friend-weak_ptr-this_type","title":"friend weak_ptr&lt; this_type &gt;","text":"<pre><code>class muda::HostNodeParms::weak_ptr&lt; this_type &gt; (\n    std::weak_ptr&lt; this_type &gt;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/host_node.h</code></p>"},{"location":"muda/classmuda_1_1_host_vector/","title":"Class muda::HostVector","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; HostVector</p> <p>Inherits the following classes: thrust::host_vector&lt; T, std::allocator&lt; T &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/device_buffer.h</code></p>"},{"location":"muda/classmuda_1_1_id_with_type/","title":"Class muda::IdWithType","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; IdWithType</p>"},{"location":"muda/classmuda_1_1_id_with_type/#public-types","title":"Public Types","text":"Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_id_with_type/#public-static-attributes","title":"Public Static Attributes","text":"Type Name auto invalid_id   = = std::numeric_limits&lt;value_type&gt;::max()"},{"location":"muda/classmuda_1_1_id_with_type/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC IdWithType (value_type value) noexcept MUDA_GENERIC IdWithType () noexcept MUDA_GENERIC bool is_valid () noexcept const MUDA_GENERIC value_type value () noexcept const"},{"location":"muda/classmuda_1_1_id_with_type/#protected-attributes","title":"Protected Attributes","text":"Type Name value_type m_value   = {invalid_id}"},{"location":"muda/classmuda_1_1_id_with_type/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_id_with_type/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::IdWithType&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_id_with_type/#variable-invalid_id","title":"variable invalid_id","text":"<pre><code>auto muda::IdWithType&lt; T &gt;::invalid_id;\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_id_with_type/#function-idwithtype-12","title":"function IdWithType [1/2]","text":"<pre><code>inline explicit MUDA_GENERIC muda::IdWithType::IdWithType (\n    value_type value\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#function-idwithtype-22","title":"function IdWithType [2/2]","text":"<pre><code>inline explicit MUDA_GENERIC muda::IdWithType::IdWithType () noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#function-is_valid","title":"function is_valid","text":"<pre><code>inline MUDA_GENERIC bool muda::IdWithType::is_valid () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#function-value","title":"function value","text":"<pre><code>inline MUDA_GENERIC value_type muda::IdWithType::value () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_id_with_type/#variable-m_value","title":"variable m_value","text":"<pre><code>value_type muda::IdWithType&lt; T &gt;::m_value;\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_id_with_type/#friend-operator","title":"friend operator!=","text":"<pre><code>inline MUDA_GENERIC friend bool muda::IdWithType::operator!= (\n    const IdWithType &amp; lhs,\n    const IdWithType &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#friend-operator_1","title":"friend operator&lt;","text":"<pre><code>inline MUDA_GENERIC friend bool muda::IdWithType::operator&lt; (\n    const IdWithType &amp; lhs,\n    const IdWithType &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#friend-operator_2","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; muda::IdWithType::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const IdWithType &amp; id\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#friend-operator_3","title":"friend operator==","text":"<pre><code>inline MUDA_GENERIC friend bool muda::IdWithType::operator== (\n    const IdWithType &amp; lhs,\n    const IdWithType &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_id_with_type/#friend-operator_4","title":"friend operator&gt;","text":"<pre><code>inline MUDA_GENERIC friend bool muda::IdWithType::operator&gt; (\n    const IdWithType &amp; lhs,\n    const IdWithType &amp; rhs\n) noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/id_with_type.h</code></p>"},{"location":"muda/classmuda_1_1_kernel/","title":"Class muda::Kernel","text":"<p>template &lt;typename F&gt;</p> <p>ClassList &gt; muda &gt; Kernel</p>"},{"location":"muda/classmuda_1_1_kernel/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Kernel (dim3 grid_dim, dim3 m_block_dim, size_t shared_memory_size, cudaStream_t stream, F f)  MUDA_GENERIC Kernel (F f)  MUDA_GENERIC Kernel (dim3 grid_dim, dim3 m_block_dim, F f)  MUDA_GENERIC Kernel (dim3 grid_dim, dim3 m_block_dim, size_t shared_memory_size, F f)  MUDA_GENERIC Kernel (dim3 grid_dim, dim3 m_block_dim, cudaStream_t stream, F f)  MUDA_GENERIC Kernel (cudaStream_t stream, F f)  MUDA_GENERIC Kernel (const Kernel &amp;) = delete MUDA_GENERIC Kernel (Kernel &amp;&amp;) = delete MUDA_GENERIC void operator() (Args &amp;&amp;... args)  MUDA_GENERIC Kernel &amp; operator= (const Kernel &amp;) = delete MUDA_GENERIC Kernel &amp; operator= (Kernel &amp;&amp;) = delete"},{"location":"muda/classmuda_1_1_kernel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_kernel/#function-kernel-18","title":"function Kernel [1/8]","text":"<pre><code>inline MUDA_GENERIC muda::Kernel::Kernel (\n    dim3 grid_dim,\n    dim3 m_block_dim,\n    size_t shared_memory_size,\n    cudaStream_t stream,\n    F f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-kernel-28","title":"function Kernel [2/8]","text":"<pre><code>inline MUDA_GENERIC muda::Kernel::Kernel (\n    F f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-kernel-38","title":"function Kernel [3/8]","text":"<pre><code>inline MUDA_GENERIC muda::Kernel::Kernel (\n    dim3 grid_dim,\n    dim3 m_block_dim,\n    F f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-kernel-48","title":"function Kernel [4/8]","text":"<pre><code>inline MUDA_GENERIC muda::Kernel::Kernel (\n    dim3 grid_dim,\n    dim3 m_block_dim,\n    size_t shared_memory_size,\n    F f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-kernel-58","title":"function Kernel [5/8]","text":"<pre><code>inline MUDA_GENERIC muda::Kernel::Kernel (\n    dim3 grid_dim,\n    dim3 m_block_dim,\n    cudaStream_t stream,\n    F f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-kernel-68","title":"function Kernel [6/8]","text":"<pre><code>inline MUDA_GENERIC muda::Kernel::Kernel (\n    cudaStream_t stream,\n    F f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-kernel-78","title":"function Kernel [7/8]","text":"<pre><code>MUDA_GENERIC muda::Kernel::Kernel (\n    const Kernel &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-kernel-88","title":"function Kernel [8/8]","text":"<pre><code>MUDA_GENERIC muda::Kernel::Kernel (\n    Kernel &amp;&amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-operator","title":"function operator()","text":"<pre><code>template&lt;typename... Args&gt;\ninline MUDA_GENERIC void muda::Kernel::operator() (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-operator_1","title":"function operator=","text":"<pre><code>MUDA_GENERIC Kernel &amp; muda::Kernel::operator= (\n    const Kernel &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_kernel/#function-operator_2","title":"function operator=","text":"<pre><code>MUDA_GENERIC Kernel &amp; muda::Kernel::operator= (\n    Kernel &amp;&amp;\n) = delete\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/kernel.h</code></p>"},{"location":"muda/classmuda_1_1_kernel_label/","title":"Class muda::KernelLabel","text":"<p>ClassList &gt; muda &gt; KernelLabel</p>"},{"location":"muda/classmuda_1_1_kernel_label/#public-functions","title":"Public Functions","text":"Type Name KernelLabel (std::string_view name, std::string_view file=\"\", int line=-1)  ~KernelLabel ()"},{"location":"muda/classmuda_1_1_kernel_label/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_kernel_label/#function-kernellabel","title":"function KernelLabel","text":"<pre><code>inline muda::KernelLabel::KernelLabel (\n    std::string_view name,\n    std::string_view file=\"\",\n    int line=-1\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_label/#function-kernellabel_1","title":"function ~KernelLabel","text":"<pre><code>inline muda::KernelLabel::~KernelLabel () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/kernel_label.h</code></p>"},{"location":"muda/classmuda_1_1_kernel_node/","title":"Class muda::KernelNode","text":"<p>ClassList &gt; muda &gt; KernelNode</p> <p>Inherits the following classes: muda::GraphNode</p>"},{"location":"muda/classmuda_1_1_kernel_node/#public-types","title":"Public Types","text":"Type Name typedef KernelNode this_type"},{"location":"muda/classmuda_1_1_kernel_node/#public-types-inherited-from-mudagraphnode","title":"Public Types inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name typedef GraphNode this_type"},{"location":"muda/classmuda_1_1_kernel_node/#public-functions-inherited-from-mudagraphnode","title":"Public Functions inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name GraphNode ()  cudaGraphNode_t handle () const"},{"location":"muda/classmuda_1_1_kernel_node/#protected-attributes-inherited-from-mudagraphnode","title":"Protected Attributes inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name cudaGraphNode_t m_handle"},{"location":"muda/classmuda_1_1_kernel_node/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_kernel_node/#typedef-this_type","title":"typedef this_type","text":"<pre><code>using muda::KernelNode::this_type =  KernelNode;\n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_kernel_node/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::KernelNode::Graph (\n    Graph\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/kernel_node.h</code></p>"},{"location":"muda/classmuda_1_1_kernel_node_parms/","title":"Class muda::KernelNodeParms","text":"<p>template &lt;typename U&gt;</p> <p>ClassList &gt; muda &gt; KernelNodeParms</p> <p>Inherits the following classes: muda::NodeParms</p>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#public-types","title":"Public Types","text":"Type Name typedef KernelNodeParms this_type"},{"location":"muda/classmuda_1_1_kernel_node_parms/#public-attributes","title":"Public Attributes","text":"Type Name U kernelParmData"},{"location":"muda/classmuda_1_1_kernel_node_parms/#public-functions","title":"Public Functions","text":"Type Name KernelNodeParms (Args &amp;&amp;... args)  KernelNodeParms ()  auto block_dim ()  void block_dim (const dim3 &amp; v)  auto extra ()  void extra (void ** v)  auto func ()  void func (void * v)  auto grid_dim ()  void grid_dim (const dim3 &amp; v)  const cudaKernelNodeParams * handle () const auto kernel_params ()  void kernel_params (const std::vector&lt; void * &gt; &amp; v)  void parse (std::function&lt; std::vector&lt; void * &gt;(U &amp;)&gt; pred)  auto shared_mem_bytes ()  void shared_mem_bytes (unsigned int v)"},{"location":"muda/classmuda_1_1_kernel_node_parms/#public-functions-inherited-from-mudanodeparms","title":"Public Functions inherited from muda::NodeParms","text":"<p>See muda::NodeParms</p> Type Name NodeParms () = default virtual ~NodeParms () = default"},{"location":"muda/classmuda_1_1_kernel_node_parms/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_kernel_node_parms/#typedef-this_type","title":"typedef this_type","text":"<pre><code>using muda::KernelNodeParms&lt; U &gt;::this_type =  KernelNodeParms;\n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_kernel_node_parms/#variable-kernelparmdata","title":"variable kernelParmData","text":"<pre><code>U muda::KernelNodeParms&lt; U &gt;::kernelParmData;\n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-kernelnodeparms-12","title":"function KernelNodeParms [1/2]","text":"<pre><code>template&lt;typename... Args&gt;\ninline muda::KernelNodeParms::KernelNodeParms (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-kernelnodeparms-22","title":"function KernelNodeParms [2/2]","text":"<pre><code>inline muda::KernelNodeParms::KernelNodeParms () \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-block_dim-12","title":"function block_dim [1/2]","text":"<pre><code>inline auto muda::KernelNodeParms::block_dim () \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-block_dim-22","title":"function block_dim [2/2]","text":"<pre><code>inline void muda::KernelNodeParms::block_dim (\n    const dim3 &amp; v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-extra-12","title":"function extra [1/2]","text":"<pre><code>inline auto muda::KernelNodeParms::extra () \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-extra-22","title":"function extra [2/2]","text":"<pre><code>inline void muda::KernelNodeParms::extra (\n    void ** v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-func-12","title":"function func [1/2]","text":"<pre><code>inline auto muda::KernelNodeParms::func () \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-func-22","title":"function func [2/2]","text":"<pre><code>inline void muda::KernelNodeParms::func (\n    void * v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-grid_dim-12","title":"function grid_dim [1/2]","text":"<pre><code>inline auto muda::KernelNodeParms::grid_dim () \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-grid_dim-22","title":"function grid_dim [2/2]","text":"<pre><code>inline void muda::KernelNodeParms::grid_dim (\n    const dim3 &amp; v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-handle","title":"function handle","text":"<pre><code>inline const cudaKernelNodeParams * muda::KernelNodeParms::handle () const\n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-kernel_params-12","title":"function kernel_params [1/2]","text":"<pre><code>inline auto muda::KernelNodeParms::kernel_params () \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-kernel_params-22","title":"function kernel_params [2/2]","text":"<pre><code>inline void muda::KernelNodeParms::kernel_params (\n    const std::vector&lt; void * &gt; &amp; v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-parse","title":"function parse","text":"<pre><code>inline void muda::KernelNodeParms::parse (\n    std::function&lt; std::vector&lt; void * &gt;(U &amp;)&gt; pred\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-shared_mem_bytes-12","title":"function shared_mem_bytes [1/2]","text":"<pre><code>inline auto muda::KernelNodeParms::shared_mem_bytes () \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#function-shared_mem_bytes-22","title":"function shared_mem_bytes [2/2]","text":"<pre><code>inline void muda::KernelNodeParms::shared_mem_bytes (\n    unsigned int v\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_kernel_node_parms/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::KernelNodeParms::Graph (\n    Graph\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#friend-shared_ptr-this_type","title":"friend shared_ptr&lt; this_type &gt;","text":"<pre><code>class muda::KernelNodeParms::shared_ptr&lt; this_type &gt; (\n    std::shared_ptr&lt; this_type &gt;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#friend-unique_ptr-this_type","title":"friend unique_ptr&lt; this_type &gt;","text":"<pre><code>class muda::KernelNodeParms::unique_ptr&lt; this_type &gt; (\n    std::unique_ptr&lt; this_type &gt;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_kernel_node_parms/#friend-weak_ptr-this_type","title":"friend weak_ptr&lt; this_type &gt;","text":"<pre><code>class muda::KernelNodeParms::weak_ptr&lt; this_type &gt; (\n    std::weak_ptr&lt; this_type &gt;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/kernel_node.h</code></p>"},{"location":"muda/classmuda_1_1_launch/","title":"Class muda::Launch","text":"<p>ClassList &gt; muda &gt; Launch</p> <p>A wrapper of raw cuda kernel launch in muda style , removing the<code>&lt;&lt;&lt;&gt;&gt;&gt;</code> usage, for better intellisense support.More...</p> <ul> <li><code>#include &lt;launch.h&gt;</code></li> </ul> <p>Inherits the following classes: muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_launch/#public-types","title":"Public Types","text":"Type Name typedef KernelNodeParms&lt; details::LaunchCallable&lt; raw_type_t&lt; F &gt; &gt; &gt; NodeParms"},{"location":"muda/classmuda_1_1_launch/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_launch/#public-functions","title":"Public Functions","text":"Type Name MUDA_HOST Launch (dim3 gridDim, dim3 blockDim, size_t sharedMemSize=0, cudaStream_t stream=nullptr)  MUDA_HOST Launch (int gridDim=1, int blockDim=1, size_t sharedMemSize=0, cudaStream_t stream=nullptr)  MUDA_HOST Launch (dim3 blockDim, size_t sharedMemSize=0, cudaStream_t stream=nullptr)  MUDA_HOST Launch &amp; apply (F &amp;&amp; f)  MUDA_HOST Launch &amp; apply (F &amp;&amp; f, Tag&lt; UserTag &gt;)  MUDA_HOST Launch &amp; apply (const dim3 &amp; active_dim, F &amp;&amp; f)  MUDA_HOST Launch &amp; apply (const dim3 &amp; active_dim, F &amp;&amp; f, Tag&lt; UserTag &gt;)  MUDA_HOST MUDA_NODISCARD auto as_node_parms (F &amp;&amp; f)  MUDA_HOST MUDA_NODISCARD auto as_node_parms (F &amp;&amp; f, Tag&lt; UserTag &gt;)  MUDA_HOST MUDA_NODISCARD auto as_node_parms (const dim3 &amp; active_dim, F &amp;&amp; f)  MUDA_HOST MUDA_NODISCARD auto as_node_parms (const dim3 &amp; active_dim, F &amp;&amp; f, Tag&lt; UserTag &gt;)"},{"location":"muda/classmuda_1_1_launch/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_launch/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_launch/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_launch/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_launch/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_launch/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_launch/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_launch/#detailed-description","title":"Detailed Description","text":"<p>A raw cuda kernel define and launch:  <pre><code>__global__ void cuda_kernel() {}\n\nint main()\n{\n    cuda_kernel&lt;&lt;&lt;4,64&gt;&gt;&gt;();\n}\n</code></pre></p> <p>The muda style kernel launch:  <pre><code>// muda kernel launch\nLaunch(4,64)\n    .kernel_name(\"kernel_name\") // optional\n    .apply([]__device__(){}); // kernel body\n</code></pre></p> <p>A more complicated but more convincing example, to show why using muda style kernel launch is better than raw cuda kernel launch.  <pre><code>DeviceBuffer3D&lt;float&gt; volume{10,10,10};\nLaunch(dim3{8,8,8}) // blockDim\n    .kernel_name(\"write_volume\") // optional, for better debug info\n    .apply(volume.extent(), \n        [\n            volume = volume.viewer().name(\"volume\") // name is optional, for better debug info\n        ] __device__(int3 xyz) mutable\n        {\n            volume(xyz) = 1.0f;\n        });\n</code></pre></p> <p>See also: device_buffer_3d.h parallel_for.h </p>"},{"location":"muda/classmuda_1_1_launch/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_launch/#typedef-nodeparms","title":"typedef NodeParms","text":"<pre><code>using muda::Launch::NodeParms =  KernelNodeParms&lt;details::LaunchCallable&lt;raw_type_t&lt;F&gt;&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_launch/#function-launch-13","title":"function Launch [1/3]","text":"<pre><code>inline MUDA_HOST muda::Launch::Launch (\n    dim3 gridDim,\n    dim3 blockDim,\n    size_t sharedMemSize=0,\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-launch-23","title":"function Launch [2/3]","text":"<pre><code>inline MUDA_HOST muda::Launch::Launch (\n    int gridDim=1,\n    int blockDim=1,\n    size_t sharedMemSize=0,\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-launch-33","title":"function Launch [3/3]","text":"<pre><code>inline MUDA_HOST muda::Launch::Launch (\n    dim3 blockDim,\n    size_t sharedMemSize=0,\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-apply-14","title":"function apply [1/4]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST Launch &amp; muda::Launch::apply (\n    F &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-apply-24","title":"function apply [2/4]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST Launch &amp; muda::Launch::apply (\n    F &amp;&amp; f,\n    Tag &lt; UserTag &gt;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-apply-34","title":"function apply [3/4]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST Launch &amp; muda::Launch::apply (\n    const dim3 &amp; active_dim,\n    F &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-apply-44","title":"function apply [4/4]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST Launch &amp; muda::Launch::apply (\n    const dim3 &amp; active_dim,\n    F &amp;&amp; f,\n    Tag &lt; UserTag &gt;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-as_node_parms-14","title":"function as_node_parms [1/4]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST MUDA_NODISCARD auto muda::Launch::as_node_parms (\n    F &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-as_node_parms-24","title":"function as_node_parms [2/4]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST MUDA_NODISCARD auto muda::Launch::as_node_parms (\n    F &amp;&amp; f,\n    Tag &lt; UserTag &gt;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-as_node_parms-34","title":"function as_node_parms [3/4]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST MUDA_NODISCARD auto muda::Launch::as_node_parms (\n    const dim3 &amp; active_dim,\n    F &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch/#function-as_node_parms-44","title":"function as_node_parms [4/4]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST MUDA_NODISCARD auto muda::Launch::as_node_parms (\n    const dim3 &amp; active_dim,\n    F &amp;&amp; f,\n    Tag &lt; UserTag &gt;\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/launch.h</code></p>"},{"location":"muda/classmuda_1_1_launch_base/","title":"Class muda::LaunchBase","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; LaunchBase</p> <p>Inherits the following classes: muda::LaunchCore</p> <p>Inherited by the following classes: muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper,  muda::CubWrapper</p>"},{"location":"muda/classmuda_1_1_launch_base/#public-types","title":"Public Types","text":"Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_launch_base/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_launch_base/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_launch_base/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_launch_base/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_launch_base/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_launch_base/#protected-functions","title":"Protected Functions","text":"Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_launch_base/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_launch_base/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_launch_base/#typedef-derived_type","title":"typedef derived_type","text":"<pre><code>using muda::LaunchBase&lt; T &gt;::derived_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_launch_base/#function-launchbase-22","title":"function LaunchBase [2/2]","text":"<pre><code>MUDA_GENERIC muda::LaunchBase::LaunchBase (\n    ::cudaStream_t stream\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-callback","title":"function callback","text":"<pre><code>T &amp; muda::LaunchBase::callback (\n    const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-file_line","title":"function file_line","text":"<pre><code>T &amp; muda::LaunchBase::file_line (\n    std::string_view file,\n    int line\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-kernel_name","title":"function kernel_name","text":"<pre><code>T &amp; muda::LaunchBase::kernel_name (\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-next-12","title":"function next [1/2]","text":"<pre><code>template&lt;typename Next&gt;\nNext muda::LaunchBase::next (\n    Next n\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-next-22","title":"function next [2/2]","text":"<pre><code>template&lt;typename Next, typename... Args&gt;\nNext muda::LaunchBase::next (\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-pop_range","title":"function pop_range","text":"<pre><code>T &amp; muda::LaunchBase::pop_range () \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-push_range","title":"function push_range","text":"<pre><code>T &amp; muda::LaunchBase::push_range (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-record-13","title":"function record [1/3]","text":"<pre><code>T &amp; muda::LaunchBase::record (\n    cudaEvent_t e,\n    int flag=cudaEventRecordDefault\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-record-23","title":"function record [2/3]","text":"<pre><code>T &amp; muda::LaunchBase::record (\n    ComputeGraphVar &lt; cudaEvent_t &gt; &amp; e,\n    const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-record-33","title":"function record [3/3]","text":"<pre><code>template&lt;typename... ViewT&gt;\nT &amp; muda::LaunchBase::record (\n    ComputeGraphVar &lt; cudaEvent_t &gt; &amp; e,\n    ComputeGraphVar &lt; ViewT &gt; &amp;... vars\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-wait-14","title":"function wait [1/4]","text":"<pre><code>T &amp; muda::LaunchBase::wait (\n    cudaEvent_t e,\n    int flag=cudaEventWaitDefault\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-wait-24","title":"function wait [2/4]","text":"<pre><code>T &amp; muda::LaunchBase::wait (\n    const ComputeGraphVar &lt; cudaEvent_t &gt; &amp; e,\n    const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-wait-34","title":"function wait [3/4]","text":"<pre><code>template&lt;typename... ViewT&gt;\nT &amp; muda::LaunchBase::wait (\n    const ComputeGraphVar &lt; cudaEvent_t &gt; &amp; e,\n    ComputeGraphVar &lt; ViewT &gt; &amp;... vars\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-wait-44","title":"function wait [4/4]","text":"<pre><code>T &amp; muda::LaunchBase::wait () \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-when","title":"function when","text":"<pre><code>T &amp; muda::LaunchBase::when (\n    cudaEvent_t e,\n    int flag=cudaEventWaitDefault\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#function-launchbase","title":"function ~LaunchBase","text":"<pre><code>muda::LaunchBase::~LaunchBase () \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_base/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_launch_base/#function-pop_kernel_label","title":"function pop_kernel_label","text":"<pre><code>T &amp; muda::LaunchBase::pop_kernel_label () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/launch_base.h</code></p>"},{"location":"muda/classmuda_1_1_launch_core/","title":"Class muda::LaunchCore","text":"<p>ClassList &gt; muda &gt; LaunchCore</p> <p>Inherited by the following classes: muda::LaunchBase,  muda::LaunchBase,  muda::LaunchBase,  muda::LaunchBase,  muda::LaunchBase,  muda::LaunchBase,  muda::LaunchBase,  muda::LaunchBase,  muda::LaunchBase,  muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_launch_core/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_launch_core/#public-static-functions","title":"Public Static Functions","text":"Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_launch_core/#protected-types","title":"Protected Types","text":"Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_launch_core/#protected-attributes","title":"Protected Attributes","text":"Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_launch_core/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_launch_core/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_launch_core/#function-launchcore","title":"function LaunchCore","text":"<pre><code>MUDA_GENERIC muda::LaunchCore::LaunchCore (\n    ::cudaStream_t stream\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-callback","title":"function callback","text":"<pre><code>void muda::LaunchCore::callback (\n    const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-init_stream","title":"function init_stream","text":"<pre><code>inline void muda::LaunchCore::init_stream (\n    ::cudaStream_t s\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-pop_range","title":"function pop_range","text":"<pre><code>void muda::LaunchCore::pop_range () \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-push_range","title":"function push_range","text":"<pre><code>void muda::LaunchCore::push_range (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-record-13","title":"function record [1/3]","text":"<pre><code>void muda::LaunchCore::record (\n    cudaEvent_t e,\n    int flag=cudaEventRecordDefault\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-record-23","title":"function record [2/3]","text":"<pre><code>void muda::LaunchCore::record (\n    ComputeGraphVar &lt; cudaEvent_t &gt; &amp; e,\n    const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-record-33","title":"function record [3/3]","text":"<pre><code>template&lt;typename... ViewT&gt;\nvoid muda::LaunchCore::record (\n    ComputeGraphVar &lt; cudaEvent_t &gt; &amp; e,\n    ComputeGraphVar &lt; ViewT &gt; &amp;... vars\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-wait-14","title":"function wait [1/4]","text":"<pre><code>void muda::LaunchCore::wait (\n    cudaEvent_t e,\n    int flag=cudaEventWaitDefault\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-wait-24","title":"function wait [2/4]","text":"<pre><code>void muda::LaunchCore::wait (\n    const ComputeGraphVar &lt; cudaEvent_t &gt; &amp; e,\n    const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-wait-34","title":"function wait [3/4]","text":"<pre><code>template&lt;typename... ViewT&gt;\nvoid muda::LaunchCore::wait (\n    const ComputeGraphVar &lt; cudaEvent_t &gt; &amp; e,\n    ComputeGraphVar &lt; ViewT &gt; &amp;... vars\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-wait-44","title":"function wait [4/4]","text":"<pre><code>void muda::LaunchCore::wait () \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-when","title":"function when","text":"<pre><code>void muda::LaunchCore::when (\n    cudaEvent_t e,\n    int flag=cudaEventWaitDefault\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-launchcore_1","title":"function ~LaunchCore","text":"<pre><code>muda::LaunchCore::~LaunchCore () \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_launch_core/#function-file_line","title":"function file_line","text":"<pre><code>static void muda::LaunchCore::file_line (\n    std::string_view file,\n    int line\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-kernel_name","title":"function kernel_name","text":"<pre><code>static void muda::LaunchCore::kernel_name (\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-wait_device","title":"function wait_device","text":"<pre><code>static void muda::LaunchCore::wait_device () \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-wait_event","title":"function wait_event","text":"<pre><code>static void muda::LaunchCore::wait_event (\n    cudaEvent_t event\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-wait_stream","title":"function wait_stream","text":"<pre><code>static void muda::LaunchCore::wait_stream (\n    ::cudaStream_t stream\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"muda/classmuda_1_1_launch_core/#typedef-s","title":"typedef S","text":"<pre><code>using muda::LaunchCore::S =  std::shared_ptr&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_launch_core/#variable-m_stream","title":"variable m_stream","text":"<pre><code>::cudaStream_t muda::LaunchCore::m_stream;\n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_launch_core/#function-pop_kernel_label","title":"function pop_kernel_label","text":"<pre><code>MUDA_HOST void muda::LaunchCore::pop_kernel_label () \n</code></pre>"},{"location":"muda/classmuda_1_1_launch_core/#function-stream","title":"function stream","text":"<pre><code>inline MUDA_GENERIC::cudaStream_t muda::LaunchCore::stream () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/launch_base.h</code></p>"},{"location":"muda/classmuda_1_1_linear_system_algorithm/","title":"Class muda::LinearSystemAlgorithm","text":"<p>ClassList &gt; muda &gt; LinearSystemAlgorithm</p>"},{"location":"muda/classmuda_1_1_linear_system_algorithm/#public-static-attributes","title":"Public Static Attributes","text":"Type Name cusparseSpMVAlg_t SPMV_ALG_DEFAULT   = = (cusparseSpMVAlg_t)0"},{"location":"muda/classmuda_1_1_linear_system_algorithm/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_linear_system_algorithm/#variable-spmv_alg_default","title":"variable SPMV_ALG_DEFAULT","text":"<pre><code>cusparseSpMVAlg_t muda::LinearSystemAlgorithm::SPMV_ALG_DEFAULT;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/type_mapper/algo_mapper.h</code></p>"},{"location":"muda/classmuda_1_1_linear_system_context/","title":"Class muda::LinearSystemContext","text":"<p>ClassList &gt; muda &gt; LinearSystemContext</p>"},{"location":"muda/classmuda_1_1_linear_system_context/#public-functions","title":"Public Functions","text":"Type Name LinearSystemContext (const LinearSystemContextCreateInfo &amp; info={})  LinearSystemContext (const LinearSystemContext &amp;) = delete LinearSystemContext (LinearSystemContext &amp;&amp;) = delete void axpby (const T &amp; alpha, CDenseVectorView&lt; T &gt; x, const T &amp; beta, DenseVectorView&lt; T &gt; y)  void axpby (CVarView&lt; T &gt; alpha, CDenseVectorView&lt; T &gt; x, CVarView&lt; T &gt; beta, DenseVectorView&lt; T &gt; y)  void convert (const DeviceTripletMatrix&lt; T, N &gt; &amp; from, DeviceBCOOMatrix&lt; T, N &gt; &amp; to)  void convert (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceDenseMatrix&lt; T &gt; &amp; to, bool clear_dense_matrix=true)  void convert (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceCOOMatrix&lt; T &gt; &amp; to)  void convert (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceBSRMatrix&lt; T, N &gt; &amp; to)  void convert (const DeviceDoubletVector&lt; T, N &gt; &amp; from, DeviceBCOOVector&lt; T, N &gt; &amp; to)  void convert (const DeviceBCOOVector&lt; T, N &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  void convert (const DeviceDoubletVector&lt; T, N &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  void convert (const DeviceBSRMatrix&lt; T, N &gt; &amp; from, DeviceCSRMatrix&lt; T &gt; &amp; to)  void convert (const DeviceTripletMatrix&lt; T, 1 &gt; &amp; from, DeviceCOOMatrix&lt; T &gt; &amp; to)  void convert (const DeviceCOOMatrix&lt; T &gt; &amp; from, DeviceDenseMatrix&lt; T &gt; &amp; to, bool clear_dense_matrix=true)  void convert (const DeviceCOOMatrix&lt; T &gt; &amp; from, DeviceCSRMatrix&lt; T &gt; &amp; to)  void convert (DeviceCOOMatrix&lt; T &gt; &amp;&amp; from, DeviceCSRMatrix&lt; T &gt; &amp; to)  void convert (const DeviceDoubletVector&lt; T, 1 &gt; &amp; from, DeviceCOOVector&lt; T &gt; &amp; to)  void convert (const DeviceCOOVector&lt; T &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  void convert (const DeviceDoubletVector&lt; T, 1 &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  T dot (CDenseVectorView&lt; T &gt; x, CDenseVectorView&lt; T &gt; y)  void dot (CDenseVectorView&lt; T &gt; x, CDenseVectorView&lt; T &gt; y, VarView&lt; T &gt; result)  void dot (CDenseVectorView&lt; T &gt; x, CDenseVectorView&lt; T &gt; y, T * result)  void label (std::string_view label)  std::string_view label () const void mv (CDenseMatrixView&lt; T &gt; A, const T &amp; alpha, CDenseVectorView&lt; T &gt; x, const T &amp; beta, DenseVectorView&lt; T &gt; y)  void mv (CDenseMatrixView&lt; T &gt; A, CVarView&lt; T &gt; alpha, CDenseVectorView&lt; T &gt; x, CVarView&lt; T &gt; beta, DenseVectorView&lt; T &gt; y)  void mv (CDenseMatrixView&lt; T &gt; A, CDenseVectorView&lt; T &gt; x, DenseVectorView&lt; T &gt; y)  T norm (CDenseVectorView&lt; T &gt; x)  void norm (CDenseVectorView&lt; T &gt; x, VarView&lt; T &gt; result)  void norm (CDenseVectorView&lt; T &gt; x, T * result)  LinearSystemContext &amp; operator= (const LinearSystemContext &amp;) = delete LinearSystemContext &amp; operator= (LinearSystemContext &amp;&amp;) = delete void plus (CDenseVectorView&lt; T &gt; x, CDenseVectorView&lt; T &gt; y, DenseVectorView&lt; T &gt; z)  auto &amp; reorder ()  auto reserve_ratio () const void reserve_ratio (float ratio)  void solve (DenseMatrixView&lt; T &gt; A_to_fact, DenseVectorView&lt; T &gt; b_to_x)  void solve (DenseVectorView&lt; T &gt; x, CCSRMatrixView&lt; T &gt; A, CDenseVectorView&lt; T &gt; b)  void spmv (const T &amp; a, CBSRMatrixView&lt; T, N &gt; A, CDenseVectorView&lt; T &gt; x, const T &amp; b, DenseVectorView&lt; T &gt; &amp; y)  void spmv (CBSRMatrixView&lt; T, N &gt; A, CDenseVectorView&lt; T &gt; x, DenseVectorView&lt; T &gt; y)  void spmv (const T &amp; a, CCSRMatrixView&lt; T &gt; A, CDenseVectorView&lt; T &gt; x, const T &amp; b, DenseVectorView&lt; T &gt; &amp; y)  void spmv (CCSRMatrixView&lt; T &gt; A, CDenseVectorView&lt; T &gt; x, DenseVectorView&lt; T &gt; y)  void spmv (const T &amp; a, CTripletMatrixView&lt; T, N &gt; A, CDenseVectorView&lt; T &gt; x, const T &amp; b, DenseVectorView&lt; T &gt; &amp; y)  void spmv (CTripletMatrixView&lt; T, N &gt; A, CDenseVectorView&lt; T &gt; x, DenseVectorView&lt; T &gt; y)  void spmv (const T &amp; a, CCOOMatrixView&lt; T &gt; A, CDenseVectorView&lt; T &gt; x, const T &amp; b, DenseVectorView&lt; T &gt; &amp; y)  void spmv (CCOOMatrixView&lt; T &gt; A, CDenseVectorView&lt; T &gt; x, DenseVectorView&lt; T &gt; y)  auto stream () const void stream (cudaStream_t stream)  void sync ()  auto &amp; tolerance ()  ~LinearSystemContext ()"},{"location":"muda/classmuda_1_1_linear_system_context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_linear_system_context/#function-linearsystemcontext-13","title":"function LinearSystemContext [1/3]","text":"<pre><code>muda::LinearSystemContext::LinearSystemContext (\n    const LinearSystemContextCreateInfo &amp; info={}\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-linearsystemcontext-23","title":"function LinearSystemContext [2/3]","text":"<pre><code>muda::LinearSystemContext::LinearSystemContext (\n    const LinearSystemContext &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-linearsystemcontext-33","title":"function LinearSystemContext [3/3]","text":"<pre><code>muda::LinearSystemContext::LinearSystemContext (\n    LinearSystemContext &amp;&amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-axpby-12","title":"function axpby [1/2]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::axpby (\n    const T &amp; alpha,\n    CDenseVectorView &lt; T &gt; x,\n    const T &amp; beta,\n    DenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-axpby-22","title":"function axpby [2/2]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::axpby (\n    CVarView &lt; T &gt; alpha,\n    CDenseVectorView &lt; T &gt; x,\n    CVarView &lt; T &gt; beta,\n    DenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-115","title":"function convert [1/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceTripletMatrix &lt; T, N &gt; &amp; from,\n    DeviceBCOOMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-215","title":"function convert [2/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceDenseMatrix &lt; T &gt; &amp; to,\n    bool clear_dense_matrix=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-315","title":"function convert [3/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceCOOMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-415","title":"function convert [4/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceBSRMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-515","title":"function convert [5/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceDoubletVector &lt; T, N &gt; &amp; from,\n    DeviceBCOOVector &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-615","title":"function convert [6/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceBCOOVector &lt; T, N &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-715","title":"function convert [7/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceDoubletVector &lt; T, N &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-815","title":"function convert [8/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceBSRMatrix &lt; T, N &gt; &amp; from,\n    DeviceCSRMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-915","title":"function convert [9/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceTripletMatrix &lt; T, 1 &gt; &amp; from,\n    DeviceCOOMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-1015","title":"function convert [10/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceCOOMatrix &lt; T &gt; &amp; from,\n    DeviceDenseMatrix &lt; T &gt; &amp; to,\n    bool clear_dense_matrix=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-1115","title":"function convert [11/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceCOOMatrix &lt; T &gt; &amp; from,\n    DeviceCSRMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-1215","title":"function convert [12/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::convert (\n    DeviceCOOMatrix &lt; T &gt; &amp;&amp; from,\n    DeviceCSRMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-1315","title":"function convert [13/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceDoubletVector &lt; T, 1 &gt; &amp; from,\n    DeviceCOOVector &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-1415","title":"function convert [14/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceCOOVector &lt; T &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-convert-1515","title":"function convert [15/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::convert (\n    const DeviceDoubletVector &lt; T, 1 &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-dot-13","title":"function dot [1/3]","text":"<pre><code>template&lt;typename T&gt;\nT muda::LinearSystemContext::dot (\n    CDenseVectorView &lt; T &gt; x,\n    CDenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-dot-23","title":"function dot [2/3]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::dot (\n    CDenseVectorView &lt; T &gt; x,\n    CDenseVectorView &lt; T &gt; y,\n    VarView &lt; T &gt; result\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-dot-33","title":"function dot [3/3]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::dot (\n    CDenseVectorView &lt; T &gt; x,\n    CDenseVectorView &lt; T &gt; y,\n    T * result\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-label-12","title":"function label [1/2]","text":"<pre><code>inline void muda::LinearSystemContext::label (\n    std::string_view label\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-label-22","title":"function label [2/2]","text":"<pre><code>inline std::string_view muda::LinearSystemContext::label () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-mv-13","title":"function mv [1/3]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::mv (\n    CDenseMatrixView &lt; T &gt; A,\n    const T &amp; alpha,\n    CDenseVectorView &lt; T &gt; x,\n    const T &amp; beta,\n    DenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-mv-23","title":"function mv [2/3]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::mv (\n    CDenseMatrixView &lt; T &gt; A,\n    CVarView &lt; T &gt; alpha,\n    CDenseVectorView &lt; T &gt; x,\n    CVarView &lt; T &gt; beta,\n    DenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-mv-33","title":"function mv [3/3]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::mv (\n    CDenseMatrixView &lt; T &gt; A,\n    CDenseVectorView &lt; T &gt; x,\n    DenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-norm-13","title":"function norm [1/3]","text":"<pre><code>template&lt;typename T&gt;\nT muda::LinearSystemContext::norm (\n    CDenseVectorView &lt; T &gt; x\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-norm-23","title":"function norm [2/3]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::norm (\n    CDenseVectorView &lt; T &gt; x,\n    VarView &lt; T &gt; result\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-norm-33","title":"function norm [3/3]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::norm (\n    CDenseVectorView &lt; T &gt; x,\n    T * result\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-operator","title":"function operator=","text":"<pre><code>LinearSystemContext &amp; muda::LinearSystemContext::operator= (\n    const LinearSystemContext &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-operator_1","title":"function operator=","text":"<pre><code>LinearSystemContext &amp; muda::LinearSystemContext::operator= (\n    LinearSystemContext &amp;&amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-plus","title":"function plus","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::plus (\n    CDenseVectorView &lt; T &gt; x,\n    CDenseVectorView &lt; T &gt; y,\n    DenseVectorView &lt; T &gt; z\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-reorder","title":"function reorder","text":"<pre><code>inline auto &amp; muda::LinearSystemContext::reorder () \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-reserve_ratio-12","title":"function reserve_ratio [1/2]","text":"<pre><code>inline auto muda::LinearSystemContext::reserve_ratio () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-reserve_ratio-22","title":"function reserve_ratio [2/2]","text":"<pre><code>inline void muda::LinearSystemContext::reserve_ratio (\n    float ratio\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-solve-12","title":"function solve [1/2]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::solve (\n    DenseMatrixView &lt; T &gt; A_to_fact,\n    DenseVectorView &lt; T &gt; b_to_x\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-solve-22","title":"function solve [2/2]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::solve (\n    DenseVectorView &lt; T &gt; x,\n    CCSRMatrixView &lt; T &gt; A,\n    CDenseVectorView &lt; T &gt; b\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-spmv-18","title":"function spmv [1/8]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::spmv (\n    const T &amp; a,\n    CBSRMatrixView &lt; T, N &gt; A,\n    CDenseVectorView &lt; T &gt; x,\n    const T &amp; b,\n    DenseVectorView &lt; T &gt; &amp; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-spmv-28","title":"function spmv [2/8]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::spmv (\n    CBSRMatrixView &lt; T, N &gt; A,\n    CDenseVectorView &lt; T &gt; x,\n    DenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-spmv-38","title":"function spmv [3/8]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::spmv (\n    const T &amp; a,\n    CCSRMatrixView &lt; T &gt; A,\n    CDenseVectorView &lt; T &gt; x,\n    const T &amp; b,\n    DenseVectorView &lt; T &gt; &amp; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-spmv-48","title":"function spmv [4/8]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::spmv (\n    CCSRMatrixView &lt; T &gt; A,\n    CDenseVectorView &lt; T &gt; x,\n    DenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-spmv-58","title":"function spmv [5/8]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::spmv (\n    const T &amp; a,\n    CTripletMatrixView &lt; T, N &gt; A,\n    CDenseVectorView &lt; T &gt; x,\n    const T &amp; b,\n    DenseVectorView &lt; T &gt; &amp; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-spmv-68","title":"function spmv [6/8]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::LinearSystemContext::spmv (\n    CTripletMatrixView &lt; T, N &gt; A,\n    CDenseVectorView &lt; T &gt; x,\n    DenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-spmv-78","title":"function spmv [7/8]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::spmv (\n    const T &amp; a,\n    CCOOMatrixView &lt; T &gt; A,\n    CDenseVectorView &lt; T &gt; x,\n    const T &amp; b,\n    DenseVectorView &lt; T &gt; &amp; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-spmv-88","title":"function spmv [8/8]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::LinearSystemContext::spmv (\n    CCOOMatrixView &lt; T &gt; A,\n    CDenseVectorView &lt; T &gt; x,\n    DenseVectorView &lt; T &gt; y\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-stream-12","title":"function stream [1/2]","text":"<pre><code>inline auto muda::LinearSystemContext::stream () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-stream-22","title":"function stream [2/2]","text":"<pre><code>void muda::LinearSystemContext::stream (\n    cudaStream_t stream\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-sync","title":"function sync","text":"<pre><code>void muda::LinearSystemContext::sync () \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-tolerance","title":"function tolerance","text":"<pre><code>inline auto &amp; muda::LinearSystemContext::tolerance () \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context/#function-linearsystemcontext","title":"function ~LinearSystemContext","text":"<pre><code>muda::LinearSystemContext::~LinearSystemContext () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/linear_system_context.h</code></p>"},{"location":"muda/classmuda_1_1_linear_system_context_create_info/","title":"Class muda::LinearSystemContextCreateInfo","text":"<p>ClassList &gt; muda &gt; LinearSystemContextCreateInfo</p>"},{"location":"muda/classmuda_1_1_linear_system_context_create_info/#public-attributes","title":"Public Attributes","text":"Type Name size_t buffer_byte_size_base   = = 256_M cudaStream_t stream   = = nullptr"},{"location":"muda/classmuda_1_1_linear_system_context_create_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_linear_system_context_create_info/#variable-buffer_byte_size_base","title":"variable buffer_byte_size_base","text":"<pre><code>size_t muda::LinearSystemContextCreateInfo::buffer_byte_size_base;\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_context_create_info/#variable-stream","title":"variable stream","text":"<pre><code>cudaStream_t muda::LinearSystemContextCreateInfo::stream;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/linear_system_context.h</code></p>"},{"location":"muda/classmuda_1_1_linear_system_handles/","title":"Class muda::LinearSystemHandles","text":"<p>ClassList &gt; muda &gt; LinearSystemHandles</p>"},{"location":"muda/classmuda_1_1_linear_system_handles/#public-functions","title":"Public Functions","text":"Type Name LinearSystemHandles (cudaStream_t s)  cublasHandle_t cublas () const cusolverDnHandle_t cusolver_dn () const cusolverSpHandle_t cusolver_sp () const cusparseHandle_t cusparse () const auto reserve_ratio () const MUDA_INLINE void set_pointer_mode_device ()  MUDA_INLINE void set_pointer_mode_host ()  void stream (cudaStream_t s)  cudaStream_t stream () const ~LinearSystemHandles ()"},{"location":"muda/classmuda_1_1_linear_system_handles/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_linear_system_handles/#function-linearsystemhandles","title":"function LinearSystemHandles","text":"<pre><code>inline muda::LinearSystemHandles::LinearSystemHandles (\n    cudaStream_t s\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-cublas","title":"function cublas","text":"<pre><code>inline cublasHandle_t muda::LinearSystemHandles::cublas () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-cusolver_dn","title":"function cusolver_dn","text":"<pre><code>inline cusolverDnHandle_t muda::LinearSystemHandles::cusolver_dn () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-cusolver_sp","title":"function cusolver_sp","text":"<pre><code>inline cusolverSpHandle_t muda::LinearSystemHandles::cusolver_sp () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-cusparse","title":"function cusparse","text":"<pre><code>inline cusparseHandle_t muda::LinearSystemHandles::cusparse () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-reserve_ratio","title":"function reserve_ratio","text":"<pre><code>inline auto muda::LinearSystemHandles::reserve_ratio () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-set_pointer_mode_device","title":"function set_pointer_mode_device","text":"<pre><code>inline MUDA_INLINE void muda::LinearSystemHandles::set_pointer_mode_device () \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-set_pointer_mode_host","title":"function set_pointer_mode_host","text":"<pre><code>inline MUDA_INLINE void muda::LinearSystemHandles::set_pointer_mode_host () \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-stream-12","title":"function stream [1/2]","text":"<pre><code>inline void muda::LinearSystemHandles::stream (\n    cudaStream_t s\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-stream-22","title":"function stream [2/2]","text":"<pre><code>inline cudaStream_t muda::LinearSystemHandles::stream () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_handles/#function-linearsystemhandles_1","title":"function ~LinearSystemHandles","text":"<pre><code>inline muda::LinearSystemHandles::~LinearSystemHandles () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/linear_system_handles.h</code></p>"},{"location":"muda/classmuda_1_1_linear_system_solve_reorder/","title":"Class muda::LinearSystemSolveReorder","text":"<p>ClassList &gt; muda &gt; LinearSystemSolveReorder</p>"},{"location":"muda/classmuda_1_1_linear_system_solve_reorder/#public-functions","title":"Public Functions","text":"Type Name void reoder_method (LinearSystemReorderMethod method)  LinearSystemReorderMethod reorder_method () const int reorder_method_int () const"},{"location":"muda/classmuda_1_1_linear_system_solve_reorder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_linear_system_solve_reorder/#function-reoder_method","title":"function reoder_method","text":"<pre><code>inline void muda::LinearSystemSolveReorder::reoder_method (\n    LinearSystemReorderMethod method\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_solve_reorder/#function-reorder_method","title":"function reorder_method","text":"<pre><code>inline LinearSystemReorderMethod muda::LinearSystemSolveReorder::reorder_method () const\n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_solve_reorder/#function-reorder_method_int","title":"function reorder_method_int","text":"<pre><code>inline int muda::LinearSystemSolveReorder::reorder_method_int () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/linear_system_solve_reorder.h</code></p>"},{"location":"muda/classmuda_1_1_linear_system_solve_tolerance/","title":"Class muda::LinearSystemSolveTolerance","text":"<p>ClassList &gt; muda &gt; LinearSystemSolveTolerance</p>"},{"location":"muda/classmuda_1_1_linear_system_solve_tolerance/#public-functions","title":"Public Functions","text":"Type Name void solve_sparse_error_threshold (double threshold)  T solve_sparse_error_threshold ()"},{"location":"muda/classmuda_1_1_linear_system_solve_tolerance/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_linear_system_solve_tolerance/#function-solve_sparse_error_threshold-12","title":"function solve_sparse_error_threshold [1/2]","text":"<pre><code>inline void muda::LinearSystemSolveTolerance::solve_sparse_error_threshold (\n    double threshold\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_linear_system_solve_tolerance/#function-solve_sparse_error_threshold-22","title":"function solve_sparse_error_threshold [2/2]","text":"<pre><code>template&lt;typename T&gt;\ninline T muda::LinearSystemSolveTolerance::solve_sparse_error_threshold () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/linear_system_solve_tolerance.h</code></p>"},{"location":"muda/classmuda_1_1_log_proxy/","title":"Class muda::LogProxy","text":"<p>ClassList &gt; muda &gt; LogProxy</p>"},{"location":"muda/classmuda_1_1_log_proxy/#public-functions","title":"Public Functions","text":"Type Name MUDA_DEVICE LogProxy () = default MUDA_DEVICE LogProxy (LoggerViewer &amp; viewer)  MUDA_DEVICE LogProxy (const LogProxy &amp; other)  PROXY_OPERATOR (Int8, int8_t)  PROXY_OPERATOR (Int16, int16_t)  PROXY_OPERATOR (Int32, int32_t)  PROXY_OPERATOR (Int64, int64_t)  PROXY_OPERATOR (UInt8, uint8_t)  PROXY_OPERATOR (UInt16, uint16_t)  PROXY_OPERATOR (UInt32, uint32_t)  PROXY_OPERATOR (UInt64, uint64_t)  PROXY_OPERATOR (Float, float)  PROXY_OPERATOR (Double, double)  MUDA_DEVICE LogProxy &amp; operator&lt;&lt; (const char * str)  MUDA_DEVICE bool push_data (const details::LoggerMetaData &amp; meta, const void * data)  MUDA_DEVICE void push_fmt_arg (const T &amp; obj, LoggerFmtArg fmt_arg_func)  MUDA_DEVICE LogProxy &amp; push_string (const char * str)"},{"location":"muda/classmuda_1_1_log_proxy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_log_proxy/#function-logproxy-13","title":"function LogProxy [1/3]","text":"<pre><code>MUDA_DEVICE muda::LogProxy::LogProxy () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-logproxy-23","title":"function LogProxy [2/3]","text":"<pre><code>MUDA_DEVICE muda::LogProxy::LogProxy (\n    LoggerViewer &amp; viewer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-logproxy-33","title":"function LogProxy [3/3]","text":"<pre><code>inline MUDA_DEVICE muda::LogProxy::LogProxy (\n    const LogProxy &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-110","title":"function PROXY_OPERATOR [1/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    Int8,\n    int8_t\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-210","title":"function PROXY_OPERATOR [2/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    Int16,\n    int16_t\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-310","title":"function PROXY_OPERATOR [3/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    Int32,\n    int32_t\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-410","title":"function PROXY_OPERATOR [4/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    Int64,\n    int64_t\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-510","title":"function PROXY_OPERATOR [5/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    UInt8,\n    uint8_t\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-610","title":"function PROXY_OPERATOR [6/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    UInt16,\n    uint16_t\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-710","title":"function PROXY_OPERATOR [7/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    UInt32,\n    uint32_t\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-810","title":"function PROXY_OPERATOR [8/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    UInt64,\n    uint64_t\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-910","title":"function PROXY_OPERATOR [9/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    Float,\n    float\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-proxy_operator-1010","title":"function PROXY_OPERATOR [10/10]","text":"<pre><code>muda::LogProxy::PROXY_OPERATOR (\n    Double,\n    double\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_DEVICE LogProxy &amp; muda::LogProxy::operator&lt;&lt; (\n    const char * str\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-push_data","title":"function push_data","text":"<pre><code>MUDA_DEVICE bool muda::LogProxy::push_data (\n    const details::LoggerMetaData &amp; meta,\n    const void * data\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-push_fmt_arg","title":"function push_fmt_arg","text":"<pre><code>template&lt;typename T&gt;\nMUDA_DEVICE void muda::LogProxy::push_fmt_arg (\n    const T &amp; obj,\n    LoggerFmtArg fmt_arg_func\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_log_proxy/#function-push_string","title":"function push_string","text":"<pre><code>template&lt;bool IsFmt&gt;\nMUDA_DEVICE LogProxy &amp; muda::LogProxy::push_string (\n    const char * str\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_logger/","title":"Class muda::Logger","text":"<p>ClassList &gt; muda &gt; Logger</p>"},{"location":"muda/classmuda_1_1_logger/#public-functions","title":"Public Functions","text":"Type Name Logger (LoggerViewer * global_viewer, size_t meta_size=DEFAULT_META_SIZE, size_t buffer_size=DEFAULT_BUFFER_SIZE)  Logger (size_t meta_size=DEFAULT_META_SIZE, size_t buffer_size=DEFAULT_BUFFER_SIZE)  Logger (const Logger &amp;) = delete Logger (Logger &amp;&amp;) noexcept MUDA_NODISCARD bool is_buffer_full () const MUDA_NODISCARD bool is_meta_data_full () const Logger &amp; operator= (const Logger &amp;) = delete Logger &amp; operator= (Logger &amp;&amp;) noexcept void retrieve (std::ostream &amp; o=std::cout)  MUDA_NODISCARD LoggerDataContainer retrieve_meta ()  MUDA_NODISCARD LoggerViewer viewer () const ~Logger ()"},{"location":"muda/classmuda_1_1_logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_logger/#function-logger-14","title":"function Logger [1/4]","text":"<pre><code>muda::Logger::Logger (\n    LoggerViewer * global_viewer,\n    size_t meta_size=DEFAULT_META_SIZE,\n    size_t buffer_size=DEFAULT_BUFFER_SIZE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-logger-24","title":"function Logger [2/4]","text":"<pre><code>inline muda::Logger::Logger (\n    size_t meta_size=DEFAULT_META_SIZE,\n    size_t buffer_size=DEFAULT_BUFFER_SIZE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-logger-34","title":"function Logger [3/4]","text":"<pre><code>muda::Logger::Logger (\n    const Logger &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-logger-44","title":"function Logger [4/4]","text":"<pre><code>muda::Logger::Logger (\n    Logger &amp;&amp;\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-is_buffer_full","title":"function is_buffer_full","text":"<pre><code>inline MUDA_NODISCARD bool muda::Logger::is_buffer_full () const\n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-is_meta_data_full","title":"function is_meta_data_full","text":"<pre><code>inline MUDA_NODISCARD bool muda::Logger::is_meta_data_full () const\n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-operator","title":"function operator=","text":"<pre><code>Logger &amp; muda::Logger::operator= (\n    const Logger &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-operator_1","title":"function operator=","text":"<pre><code>Logger &amp; muda::Logger::operator= (\n    Logger &amp;&amp;\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-retrieve","title":"function retrieve","text":"<pre><code>void muda::Logger::retrieve (\n    std::ostream &amp; o=std::cout\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-retrieve_meta","title":"function retrieve_meta","text":"<pre><code>MUDA_NODISCARD LoggerDataContainer muda::Logger::retrieve_meta () \n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-viewer","title":"function viewer","text":"<pre><code>inline MUDA_NODISCARD LoggerViewer muda::Logger::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_logger/#function-logger","title":"function ~Logger","text":"<pre><code>muda::Logger::~Logger () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger.h</code></p>"},{"location":"muda/classmuda_1_1_logger_data_container/","title":"Class muda::LoggerDataContainer","text":"<p>ClassList &gt; muda &gt; LoggerDataContainer</p>"},{"location":"muda/classmuda_1_1_logger_data_container/#public-functions","title":"Public Functions","text":"Type Name span&lt; LoggerMetaData &gt; meta_data ()"},{"location":"muda/classmuda_1_1_logger_data_container/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_logger_data_container/#function-meta_data","title":"function meta_data","text":"<pre><code>inline span&lt; LoggerMetaData &gt; muda::LoggerDataContainer::meta_data () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger.h</code></p>"},{"location":"muda/classmuda_1_1_logger_meta_data/","title":"Class muda::LoggerMetaData","text":"<p>ClassList &gt; muda &gt; LoggerMetaData</p>"},{"location":"muda/classmuda_1_1_logger_meta_data/#public-attributes","title":"Public Attributes","text":"Type Name void * data LoggerFmtArg fmt_arg uint32_t id LoggerBasicType type"},{"location":"muda/classmuda_1_1_logger_meta_data/#public-functions","title":"Public Functions","text":"Type Name const T &amp; as ()"},{"location":"muda/classmuda_1_1_logger_meta_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_logger_meta_data/#variable-data","title":"variable data","text":"<pre><code>void* muda::LoggerMetaData::data;\n</code></pre>"},{"location":"muda/classmuda_1_1_logger_meta_data/#variable-fmt_arg","title":"variable fmt_arg","text":"<pre><code>LoggerFmtArg muda::LoggerMetaData::fmt_arg;\n</code></pre>"},{"location":"muda/classmuda_1_1_logger_meta_data/#variable-id","title":"variable id","text":"<pre><code>uint32_t muda::LoggerMetaData::id;\n</code></pre>"},{"location":"muda/classmuda_1_1_logger_meta_data/#variable-type","title":"variable type","text":"<pre><code>LoggerBasicType muda::LoggerMetaData::type;\n</code></pre>"},{"location":"muda/classmuda_1_1_logger_meta_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_logger_meta_data/#function-as","title":"function as","text":"<pre><code>template&lt;typename T&gt;\nconst T &amp; muda::LoggerMetaData::as () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger.h</code></p>"},{"location":"muda/classmuda_1_1_logger_viewer/","title":"Class muda::LoggerViewer","text":"<p>ClassList &gt; muda &gt; LoggerViewer</p>"},{"location":"muda/classmuda_1_1_logger_viewer/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC operator bool () const MUDA_DEVICE LogProxy operator&lt;&lt; (const T &amp; t)  MUDA_DEVICE LogProxy operator&lt;&lt; (const char * s)  MUDA_DEVICE LogProxy proxy ()  MUDA_DEVICE LogProxy push_string (const char * str)"},{"location":"muda/classmuda_1_1_logger_viewer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_logger_viewer/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline MUDA_GENERIC muda::LoggerViewer::operator bool () const\n</code></pre>"},{"location":"muda/classmuda_1_1_logger_viewer/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\nMUDA_DEVICE LogProxy muda::LoggerViewer::operator&lt;&lt; (\n    const T &amp; t\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_logger_viewer/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>MUDA_DEVICE LogProxy muda::LoggerViewer::operator&lt;&lt; (\n    const char * s\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_logger_viewer/#function-proxy","title":"function proxy","text":"<pre><code>inline MUDA_DEVICE LogProxy muda::LoggerViewer::proxy () \n</code></pre>"},{"location":"muda/classmuda_1_1_logger_viewer/#function-push_string","title":"function push_string","text":"<pre><code>template&lt;bool IsFmt&gt;\nMUDA_DEVICE LogProxy muda::LoggerViewer::push_string (\n    const char * str\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_logger_viewer/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_logger_viewer/#friend-logproxy","title":"friend LogProxy","text":"<pre><code>class muda::LoggerViewer::LogProxy (\n    LogProxy\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_logger_viewer/#friend-logger","title":"friend Logger","text":"<pre><code>class muda::LoggerViewer::Logger (\n    Logger\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_matrix_format_converter/","title":"Class muda::MatrixFormatConverter","text":"<p>ClassList &gt; muda &gt; MatrixFormatConverter</p>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#public-functions","title":"Public Functions","text":"Type Name MatrixFormatConverter (LinearSystemHandles &amp; handles)  void convert (const DeviceTripletMatrix&lt; T, N &gt; &amp; from, DeviceBCOOMatrix&lt; T, N &gt; &amp; to)  void convert (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceDenseMatrix&lt; T &gt; &amp; to, bool clear_dense_matrix=true)  void convert (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceCOOMatrix&lt; T &gt; &amp; to)  void convert (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceBSRMatrix&lt; T, N &gt; &amp; to)  void convert (const DeviceDoubletVector&lt; T, N &gt; &amp; from, DeviceBCOOVector&lt; T, N &gt; &amp; to)  void convert (const DeviceBCOOVector&lt; T, N &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  void convert (const DeviceDoubletVector&lt; T, N &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  void convert (const DeviceBSRMatrix&lt; T, N &gt; &amp; from, DeviceCSRMatrix&lt; T &gt; &amp; to)  void convert (const DeviceTripletMatrix&lt; T, 1 &gt; &amp; from, DeviceCOOMatrix&lt; T &gt; &amp; to)  void convert (const DeviceCOOMatrix&lt; T &gt; &amp; from, DeviceDenseMatrix&lt; T &gt; &amp; to, bool clear_dense_matrix=true)  void convert (const DeviceCOOMatrix&lt; T &gt; &amp; from, DeviceCSRMatrix&lt; T &gt; &amp; to)  void convert (DeviceCOOMatrix&lt; T &gt; &amp;&amp; from, DeviceCSRMatrix&lt; T &gt; &amp; to)  void convert (const DeviceDoubletVector&lt; T, 1 &gt; &amp; from, DeviceCOOVector&lt; T &gt; &amp; to)  void convert (const DeviceCOOVector&lt; T &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  void convert (const DeviceDoubletVector&lt; T, 1 &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  ~MatrixFormatConverter ()"},{"location":"muda/classmuda_1_1_matrix_format_converter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-matrixformatconverter","title":"function MatrixFormatConverter","text":"<pre><code>inline muda::MatrixFormatConverter::MatrixFormatConverter (\n    LinearSystemHandles &amp; handles\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-115","title":"function convert [1/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceTripletMatrix &lt; T, N &gt; &amp; from,\n    DeviceBCOOMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-215","title":"function convert [2/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceDenseMatrix &lt; T &gt; &amp; to,\n    bool clear_dense_matrix=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-315","title":"function convert [3/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceCOOMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-415","title":"function convert [4/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceBSRMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-515","title":"function convert [5/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceDoubletVector &lt; T, N &gt; &amp; from,\n    DeviceBCOOVector &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-615","title":"function convert [6/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceBCOOVector &lt; T, N &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-715","title":"function convert [7/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceDoubletVector &lt; T, N &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-815","title":"function convert [8/15]","text":"<pre><code>template&lt;typename T, int N&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceBSRMatrix &lt; T, N &gt; &amp; from,\n    DeviceCSRMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-915","title":"function convert [9/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceTripletMatrix &lt; T, 1 &gt; &amp; from,\n    DeviceCOOMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-1015","title":"function convert [10/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceCOOMatrix &lt; T &gt; &amp; from,\n    DeviceDenseMatrix &lt; T &gt; &amp; to,\n    bool clear_dense_matrix=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-1115","title":"function convert [11/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceCOOMatrix &lt; T &gt; &amp; from,\n    DeviceCSRMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-1215","title":"function convert [12/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::MatrixFormatConverter::convert (\n    DeviceCOOMatrix &lt; T &gt; &amp;&amp; from,\n    DeviceCSRMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-1315","title":"function convert [13/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceDoubletVector &lt; T, 1 &gt; &amp; from,\n    DeviceCOOVector &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-1415","title":"function convert [14/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceCOOVector &lt; T &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-convert-1515","title":"function convert [15/15]","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::MatrixFormatConverter::convert (\n    const DeviceDoubletVector &lt; T, 1 &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_format_converter/#function-matrixformatconverter_1","title":"function ~MatrixFormatConverter","text":"<pre><code>muda::MatrixFormatConverter::~MatrixFormatConverter () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/matrix_format_converter.h</code></p>"},{"location":"muda/classmuda_1_1_matrix_map_info/","title":"Class muda::MatrixMapInfo","text":"<p>template &lt;typename T, int M, int N&gt;</p> <p>ClassList &gt; muda &gt; MatrixMapInfo</p> <p>For MapMatrix e.g. Eigen::Map&lt; ... &gt; </p> <ul> <li><code>#include &lt;matrix_map_info.h&gt;</code></li> </ul>"},{"location":"muda/classmuda_1_1_matrix_map_info/#public-attributes","title":"Public Attributes","text":"Type Name T * begin int inner_stride int outer_stride"},{"location":"muda/classmuda_1_1_matrix_map_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_matrix_map_info/#variable-begin","title":"variable begin","text":"<pre><code>T* muda::MatrixMapInfo&lt; T, M, N &gt;::begin;\n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_map_info/#variable-inner_stride","title":"variable inner_stride","text":"<pre><code>int muda::MatrixMapInfo&lt; T, M, N &gt;::inner_stride;\n</code></pre>"},{"location":"muda/classmuda_1_1_matrix_map_info/#variable-outer_stride","title":"variable outer_stride","text":"<pre><code>int muda::MatrixMapInfo&lt; T, M, N &gt;::outer_stride;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/matrix_map_info.h</code></p>"},{"location":"muda/classmuda_1_1_memcpy_node/","title":"Class muda::MemcpyNode","text":"<p>ClassList &gt; muda &gt; MemcpyNode</p> <p>Inherits the following classes: muda::GraphNode</p>"},{"location":"muda/classmuda_1_1_memcpy_node/#public-types","title":"Public Types","text":"Type Name typedef MemcpyNode this_type"},{"location":"muda/classmuda_1_1_memcpy_node/#public-types-inherited-from-mudagraphnode","title":"Public Types inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name typedef GraphNode this_type"},{"location":"muda/classmuda_1_1_memcpy_node/#public-functions-inherited-from-mudagraphnode","title":"Public Functions inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name GraphNode ()  cudaGraphNode_t handle () const"},{"location":"muda/classmuda_1_1_memcpy_node/#protected-attributes-inherited-from-mudagraphnode","title":"Protected Attributes inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name cudaGraphNode_t m_handle"},{"location":"muda/classmuda_1_1_memcpy_node/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_memcpy_node/#typedef-this_type","title":"typedef this_type","text":"<pre><code>using muda::MemcpyNode::this_type =  MemcpyNode;\n</code></pre>"},{"location":"muda/classmuda_1_1_memcpy_node/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_memcpy_node/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::MemcpyNode::Graph (\n    Graph\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/memory_node.h</code></p>"},{"location":"muda/classmuda_1_1_memory/","title":"Class muda::Memory","text":"<p>ClassList &gt; muda &gt; Memory</p> <p>Inherits the following classes: muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_memory/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_memory/#public-functions","title":"Public Functions","text":"Type Name MUDA_HOST Memory (cudaStream_t stream=nullptr)  MUDA_HOST Memory &amp; alloc (T ** ptr, size_t byte_size, bool async=DEFAULT_ASYNC_ALLOC_FREE)  MUDA_HOST Memory &amp; alloc (T ** ptr, size_t * pitch, size_t width_bytes, size_t height, bool async=DEFAULT_ASYNC_ALLOC_FREE)  MUDA_HOST Memory &amp; alloc (cudaPitchedPtr * pitched_ptr, const cudaExtent &amp; extent, bool async=DEFAULT_ASYNC_ALLOC_FREE)  MUDA_HOST Memory &amp; alloc_1d (T ** ptr, size_t byte_size, bool async=DEFAULT_ASYNC_ALLOC_FREE)  MUDA_HOST Memory &amp; alloc_2d (T ** ptr, size_t * pitch, size_t width_bytes, size_t height, bool async=DEFAULT_ASYNC_ALLOC_FREE)  MUDA_HOST Memory &amp; alloc_3d (cudaPitchedPtr * pitched_ptr, const cudaExtent &amp; extent, bool async=DEFAULT_ASYNC_ALLOC_FREE)  MUDA_HOST Memory &amp; copy (void * dst, const void * src, size_t byte_size, cudaMemcpyKind kind)  MUDA_HOST Memory &amp; copy (void * dst, size_t dst_pitch, const void * src, size_t src_pitch, size_t width_bytes, size_t height, cudaMemcpyKind kind)  MUDA_HOST Memory &amp; copy (const cudaMemcpy3DParms &amp; parms)  MUDA_HOST Memory &amp; download (void * dst, const void * src, size_t byte_size)  MUDA_HOST Memory &amp; download (void * dst, size_t dst_pitch, const void * src, size_t src_pitch, size_t width_bytes, size_t height)  MUDA_HOST Memory &amp; download (cudaMemcpy3DParms parms)  MUDA_HOST Memory &amp; free (void * ptr, bool async=DEFAULT_ASYNC_ALLOC_FREE)  MUDA_HOST Memory &amp; free (cudaPitchedPtr pitched_ptr, bool async=DEFAULT_ASYNC_ALLOC_FREE)  MUDA_HOST Memory &amp; set (void * data, size_t byte_size, char value=0)  MUDA_HOST Memory &amp; set (void * data, size_t pitch, size_t width_bytes, size_t height, char value=0)  MUDA_HOST Memory &amp; set (cudaPitchedPtr pitched_ptr, cudaExtent extent, char value=0)  MUDA_HOST Memory &amp; transfer (void * dst, const void * src, size_t byte_size)  MUDA_HOST Memory &amp; transfer (void * dst, size_t dst_pitch, const void * src, size_t src_pitch, size_t width_bytes, size_t height)  MUDA_HOST Memory &amp; transfer (cudaMemcpy3DParms parms)  MUDA_HOST Memory &amp; upload (void * dst, const void * src, size_t byte_size)  MUDA_HOST Memory &amp; upload (void * dst, size_t dst_pitch, const void * src, size_t src_pitch, size_t width_bytes, size_t height)  MUDA_HOST Memory &amp; upload (cudaMemcpy3DParms parms)"},{"location":"muda/classmuda_1_1_memory/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_memory/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_memory/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_memory/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_memory/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_memory/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_memory/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_memory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_memory/#function-memory","title":"function Memory","text":"<pre><code>inline MUDA_HOST muda::Memory::Memory (\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-alloc-13","title":"function alloc [1/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST Memory &amp; muda::Memory::alloc (\n    T ** ptr,\n    size_t byte_size,\n    bool async=DEFAULT_ASYNC_ALLOC_FREE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-alloc-23","title":"function alloc [2/3]","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST Memory &amp; muda::Memory::alloc (\n    T ** ptr,\n    size_t * pitch,\n    size_t width_bytes,\n    size_t height,\n    bool async=DEFAULT_ASYNC_ALLOC_FREE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-alloc-33","title":"function alloc [3/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::alloc (\n    cudaPitchedPtr * pitched_ptr,\n    const cudaExtent &amp; extent,\n    bool async=DEFAULT_ASYNC_ALLOC_FREE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-alloc_1d","title":"function alloc_1d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST Memory &amp; muda::Memory::alloc_1d (\n    T ** ptr,\n    size_t byte_size,\n    bool async=DEFAULT_ASYNC_ALLOC_FREE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-alloc_2d","title":"function alloc_2d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST Memory &amp; muda::Memory::alloc_2d (\n    T ** ptr,\n    size_t * pitch,\n    size_t width_bytes,\n    size_t height,\n    bool async=DEFAULT_ASYNC_ALLOC_FREE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-alloc_3d","title":"function alloc_3d","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::alloc_3d (\n    cudaPitchedPtr * pitched_ptr,\n    const cudaExtent &amp; extent,\n    bool async=DEFAULT_ASYNC_ALLOC_FREE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-copy-13","title":"function copy [1/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::copy (\n    void * dst,\n    const void * src,\n    size_t byte_size,\n    cudaMemcpyKind kind\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-copy-23","title":"function copy [2/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::copy (\n    void * dst,\n    size_t dst_pitch,\n    const void * src,\n    size_t src_pitch,\n    size_t width_bytes,\n    size_t height,\n    cudaMemcpyKind kind\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-copy-33","title":"function copy [3/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::copy (\n    const cudaMemcpy3DParms &amp; parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-download-13","title":"function download [1/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::download (\n    void * dst,\n    const void * src,\n    size_t byte_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-download-23","title":"function download [2/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::download (\n    void * dst,\n    size_t dst_pitch,\n    const void * src,\n    size_t src_pitch,\n    size_t width_bytes,\n    size_t height\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-download-33","title":"function download [3/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::download (\n    cudaMemcpy3DParms parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-free-12","title":"function free [1/2]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::free (\n    void * ptr,\n    bool async=DEFAULT_ASYNC_ALLOC_FREE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-free-22","title":"function free [2/2]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::free (\n    cudaPitchedPtr pitched_ptr,\n    bool async=DEFAULT_ASYNC_ALLOC_FREE\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-set-13","title":"function set [1/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::set (\n    void * data,\n    size_t byte_size,\n    char value=0\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-set-23","title":"function set [2/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::set (\n    void * data,\n    size_t pitch,\n    size_t width_bytes,\n    size_t height,\n    char value=0\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-set-33","title":"function set [3/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::set (\n    cudaPitchedPtr pitched_ptr,\n    cudaExtent extent,\n    char value=0\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-transfer-13","title":"function transfer [1/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::transfer (\n    void * dst,\n    const void * src,\n    size_t byte_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-transfer-23","title":"function transfer [2/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::transfer (\n    void * dst,\n    size_t dst_pitch,\n    const void * src,\n    size_t src_pitch,\n    size_t width_bytes,\n    size_t height\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-transfer-33","title":"function transfer [3/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::transfer (\n    cudaMemcpy3DParms parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-upload-13","title":"function upload [1/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::upload (\n    void * dst,\n    const void * src,\n    size_t byte_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-upload-23","title":"function upload [2/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::upload (\n    void * dst,\n    size_t dst_pitch,\n    const void * src,\n    size_t src_pitch,\n    size_t width_bytes,\n    size_t height\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_memory/#function-upload-33","title":"function upload [3/3]","text":"<pre><code>MUDA_HOST Memory &amp; muda::Memory::upload (\n    cudaMemcpy3DParms parms\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/memory.h</code></p>"},{"location":"muda/classmuda_1_1_memset_node/","title":"Class muda::MemsetNode","text":"<p>ClassList &gt; muda &gt; MemsetNode</p> <p>Inherits the following classes: muda::GraphNode</p>"},{"location":"muda/classmuda_1_1_memset_node/#public-types","title":"Public Types","text":"Type Name typedef MemsetNode this_type"},{"location":"muda/classmuda_1_1_memset_node/#public-types-inherited-from-mudagraphnode","title":"Public Types inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name typedef GraphNode this_type"},{"location":"muda/classmuda_1_1_memset_node/#public-functions-inherited-from-mudagraphnode","title":"Public Functions inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name GraphNode ()  cudaGraphNode_t handle () const"},{"location":"muda/classmuda_1_1_memset_node/#protected-attributes-inherited-from-mudagraphnode","title":"Protected Attributes inherited from muda::GraphNode","text":"<p>See muda::GraphNode</p> Type Name cudaGraphNode_t m_handle"},{"location":"muda/classmuda_1_1_memset_node/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_memset_node/#typedef-this_type","title":"typedef this_type","text":"<pre><code>using muda::MemsetNode::this_type =  MemsetNode;\n</code></pre>"},{"location":"muda/classmuda_1_1_memset_node/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1_memset_node/#friend-graph","title":"friend Graph","text":"<pre><code>class muda::MemsetNode::Graph (\n    Graph\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/memory_node.h</code></p>"},{"location":"muda/classmuda_1_1_n_d_reshaper/","title":"Class muda::NDReshaper","text":"<p>ClassList &gt; muda &gt; NDReshaper</p>"},{"location":"muda/classmuda_1_1_n_d_reshaper/#public-static-functions","title":"Public Static Functions","text":"Type Name MUDA_HOST void reserve (int grid_dim, int block_dim, cudaStream_t stream, DeviceBuffer&lt; T &gt; &amp; buffer, size_t new_capacity)  MUDA_HOST void reserve (int grid_dim, int block_dim, cudaStream_t stream, DeviceBuffer2D&lt; T &gt; &amp; buffer, Extent2D new_capacity)  MUDA_HOST void reserve (int grid_dim, int block_dim, cudaStream_t stream, DeviceBuffer3D&lt; T &gt; &amp; buffer, Extent3D new_capacity)  MUDA_HOST void resize (int grid_dim, int block_dim, cudaStream_t stream, DeviceBuffer&lt; T &gt; &amp; buffer, size_t new_size, FConstruct &amp;&amp; fct)  MUDA_HOST void resize (int grid_dim, int block_dim, cudaStream_t stream, DeviceBuffer2D&lt; T &gt; &amp; buffer, Extent2D new_extent, FConstruct &amp;&amp; fct)  MUDA_HOST void resize (int grid_dim, int block_dim, cudaStream_t stream, DeviceBuffer3D&lt; T &gt; &amp; buffer, Extent3D new_extent, FConstruct &amp;&amp; fct)  MUDA_HOST void shrink_to_fit (int grid_dim, int block_dim, cudaStream_t stream, DeviceBuffer&lt; T &gt; &amp; buffer)  MUDA_HOST void shrink_to_fit (int grid_dim, int block_dim, cudaStream_t stream, DeviceBuffer2D&lt; T &gt; &amp; buffer)  MUDA_HOST void shrink_to_fit (int grid_dim, int block_dim, cudaStream_t stream, DeviceBuffer3D&lt; T &gt; &amp; buffer)"},{"location":"muda/classmuda_1_1_n_d_reshaper/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_n_d_reshaper/#function-reserve-13","title":"function reserve [1/3]","text":"<pre><code>template&lt;typename T&gt;\nstatic MUDA_HOST void muda::NDReshaper::reserve (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    DeviceBuffer &lt; T &gt; &amp; buffer,\n    size_t new_capacity\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_n_d_reshaper/#function-reserve-23","title":"function reserve [2/3]","text":"<pre><code>template&lt;typename T&gt;\nstatic MUDA_HOST void muda::NDReshaper::reserve (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    DeviceBuffer2D &lt; T &gt; &amp; buffer,\n    Extent2D new_capacity\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_n_d_reshaper/#function-reserve-33","title":"function reserve [3/3]","text":"<pre><code>template&lt;typename T&gt;\nstatic MUDA_HOST void muda::NDReshaper::reserve (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    DeviceBuffer3D &lt; T &gt; &amp; buffer,\n    Extent3D new_capacity\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_n_d_reshaper/#function-resize-13","title":"function resize [1/3]","text":"<pre><code>template&lt;typename T, typename FConstruct&gt;\nstatic MUDA_HOST void muda::NDReshaper::resize (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    DeviceBuffer &lt; T &gt; &amp; buffer,\n    size_t new_size,\n    FConstruct &amp;&amp; fct\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_n_d_reshaper/#function-resize-23","title":"function resize [2/3]","text":"<pre><code>template&lt;typename T, typename FConstruct&gt;\nstatic MUDA_HOST void muda::NDReshaper::resize (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    DeviceBuffer2D &lt; T &gt; &amp; buffer,\n    Extent2D new_extent,\n    FConstruct &amp;&amp; fct\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_n_d_reshaper/#function-resize-33","title":"function resize [3/3]","text":"<pre><code>template&lt;typename T, typename FConstruct&gt;\nstatic MUDA_HOST void muda::NDReshaper::resize (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    DeviceBuffer3D &lt; T &gt; &amp; buffer,\n    Extent3D new_extent,\n    FConstruct &amp;&amp; fct\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_n_d_reshaper/#function-shrink_to_fit-13","title":"function shrink_to_fit [1/3]","text":"<pre><code>template&lt;typename T&gt;\nstatic MUDA_HOST void muda::NDReshaper::shrink_to_fit (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    DeviceBuffer &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_n_d_reshaper/#function-shrink_to_fit-23","title":"function shrink_to_fit [2/3]","text":"<pre><code>template&lt;typename T&gt;\nstatic MUDA_HOST void muda::NDReshaper::shrink_to_fit (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    DeviceBuffer2D &lt; T &gt; &amp; buffer\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_n_d_reshaper/#function-shrink_to_fit-33","title":"function shrink_to_fit [3/3]","text":"<pre><code>template&lt;typename T&gt;\nstatic MUDA_HOST void muda::NDReshaper::shrink_to_fit (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    DeviceBuffer3D &lt; T &gt; &amp; buffer\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/reshape_nd/nd_reshaper.h</code></p>"},{"location":"muda/classmuda_1_1_node_id/","title":"Class muda::NodeId","text":"<p>ClassList &gt; muda &gt; NodeId</p> <p>Inherits the following classes: muda::IdWithType</p>"},{"location":"muda/classmuda_1_1_node_id/#public-types-inherited-from-mudaidwithtype","title":"Public Types inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_node_id/#public-static-attributes-inherited-from-mudaidwithtype","title":"Public Static Attributes inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name auto invalid_id   = = std::numeric_limits&lt;value_type&gt;::max()"},{"location":"muda/classmuda_1_1_node_id/#public-functions-inherited-from-mudaidwithtype","title":"Public Functions inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name MUDA_GENERIC IdWithType (value_type value) noexcept MUDA_GENERIC IdWithType () noexcept MUDA_GENERIC bool is_valid () noexcept const MUDA_GENERIC value_type value () noexcept const"},{"location":"muda/classmuda_1_1_node_id/#protected-attributes-inherited-from-mudaidwithtype","title":"Protected Attributes inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name value_type m_value   = {invalid_id} <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_node_id.h</code></p>"},{"location":"muda/classmuda_1_1_node_parms/","title":"Class muda::NodeParms","text":"<p>ClassList &gt; muda &gt; NodeParms</p> <p>Inherited by the following classes: muda::KernelNodeParms,  muda::KernelNodeParms,  muda::HostNodeParms,  muda::KernelNodeParms</p>"},{"location":"muda/classmuda_1_1_node_parms/#public-functions","title":"Public Functions","text":"Type Name NodeParms () = default virtual ~NodeParms () = default"},{"location":"muda/classmuda_1_1_node_parms/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_node_parms/#function-nodeparms","title":"function NodeParms","text":"<pre><code>muda::NodeParms::NodeParms () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_node_parms/#function-nodeparms_1","title":"function ~NodeParms","text":"<pre><code>virtual muda::NodeParms::~NodeParms () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_base.h</code></p>"},{"location":"muda/classmuda_1_1_offset2_d/","title":"Class muda::Offset2D","text":"<p>ClassList &gt; muda &gt; Offset2D</p>"},{"location":"muda/classmuda_1_1_offset2_d/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Offset2D ()  MUDA_GENERIC Offset2D (size_t offset_in_height, size_t offset_in_width)  MUDA_GENERIC cudaPos cuda_pos () const MUDA_GENERIC size_t offset_in_height () const MUDA_GENERIC size_t offset_in_width () const"},{"location":"muda/classmuda_1_1_offset2_d/#public-static-functions","title":"Public Static Functions","text":"Type Name MUDA_GENERIC Offset2D Zero ()"},{"location":"muda/classmuda_1_1_offset2_d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_offset2_d/#function-offset2d-12","title":"function Offset2D [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::Offset2D::Offset2D () \n</code></pre>"},{"location":"muda/classmuda_1_1_offset2_d/#function-offset2d-22","title":"function Offset2D [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::Offset2D::Offset2D (\n    size_t offset_in_height,\n    size_t offset_in_width\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_offset2_d/#function-cuda_pos","title":"function cuda_pos","text":"<pre><code>template&lt;typename T&gt;\ninline MUDA_GENERIC cudaPos muda::Offset2D::cuda_pos () const\n</code></pre>"},{"location":"muda/classmuda_1_1_offset2_d/#function-offset_in_height","title":"function offset_in_height","text":"<pre><code>inline MUDA_GENERIC size_t muda::Offset2D::offset_in_height () const\n</code></pre>"},{"location":"muda/classmuda_1_1_offset2_d/#function-offset_in_width","title":"function offset_in_width","text":"<pre><code>inline MUDA_GENERIC size_t muda::Offset2D::offset_in_width () const\n</code></pre>"},{"location":"muda/classmuda_1_1_offset2_d/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_offset2_d/#function-zero","title":"function Zero","text":"<pre><code>static inline MUDA_GENERIC Offset2D muda::Offset2D::Zero () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/extent.h</code></p>"},{"location":"muda/classmuda_1_1_offset3_d/","title":"Class muda::Offset3D","text":"<p>ClassList &gt; muda &gt; Offset3D</p>"},{"location":"muda/classmuda_1_1_offset3_d/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC Offset3D ()  MUDA_GENERIC Offset3D (size_t offset_in_depth, size_t offset_in_height, size_t offset_in_width)  MUDA_GENERIC cudaPos cuda_pos () const MUDA_GENERIC size_t offset_in_depth () const MUDA_GENERIC size_t offset_in_height () const MUDA_GENERIC size_t offset_in_width () const"},{"location":"muda/classmuda_1_1_offset3_d/#public-static-functions","title":"Public Static Functions","text":"Type Name MUDA_GENERIC Offset3D Zero ()"},{"location":"muda/classmuda_1_1_offset3_d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_offset3_d/#function-offset3d-12","title":"function Offset3D [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::Offset3D::Offset3D () \n</code></pre>"},{"location":"muda/classmuda_1_1_offset3_d/#function-offset3d-22","title":"function Offset3D [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::Offset3D::Offset3D (\n    size_t offset_in_depth,\n    size_t offset_in_height,\n    size_t offset_in_width\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_offset3_d/#function-cuda_pos","title":"function cuda_pos","text":"<pre><code>template&lt;typename T&gt;\ninline MUDA_GENERIC cudaPos muda::Offset3D::cuda_pos () const\n</code></pre>"},{"location":"muda/classmuda_1_1_offset3_d/#function-offset_in_depth","title":"function offset_in_depth","text":"<pre><code>inline MUDA_GENERIC size_t muda::Offset3D::offset_in_depth () const\n</code></pre>"},{"location":"muda/classmuda_1_1_offset3_d/#function-offset_in_height","title":"function offset_in_height","text":"<pre><code>inline MUDA_GENERIC size_t muda::Offset3D::offset_in_height () const\n</code></pre>"},{"location":"muda/classmuda_1_1_offset3_d/#function-offset_in_width","title":"function offset_in_width","text":"<pre><code>inline MUDA_GENERIC size_t muda::Offset3D::offset_in_width () const\n</code></pre>"},{"location":"muda/classmuda_1_1_offset3_d/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_offset3_d/#function-zero","title":"function Zero","text":"<pre><code>static inline MUDA_GENERIC Offset3D muda::Offset3D::Zero () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/extent.h</code></p>"},{"location":"muda/classmuda_1_1_parallel_for/","title":"Class muda::ParallelFor","text":"<p>ClassList &gt; muda &gt; ParallelFor</p> <p>a frequently used parallel for loop, DynamicBlockDim andGridStrideLoop strategy are provided, and can be switched seamlessly to each other.</p> <ul> <li><code>#include &lt;parallel_for.h&gt;</code></li> </ul> <p>Inherits the following classes: muda::LaunchBase</p>"},{"location":"muda/classmuda_1_1_parallel_for/#public-types","title":"Public Types","text":"Type Name typedef KernelNodeParms&lt; details::ParallelForCallable&lt; raw_type_t&lt; F &gt; &gt; &gt; NodeParms"},{"location":"muda/classmuda_1_1_parallel_for/#public-types-inherited-from-mudalaunchbase","title":"Public Types inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name typedef T derived_type"},{"location":"muda/classmuda_1_1_parallel_for/#public-functions","title":"Public Functions","text":"Type Name MUDA_HOST ParallelFor (size_t shared_mem_size=0, cudaStream_t stream=nullptr) Calculate grid dim automatically to cover the range, automatially choose the block size to achieve max occupancy. MUDA_HOST ParallelFor (int blockDim, size_t shared_mem_size=0, cudaStream_t stream=nullptr) Calculate grid dim automatically to cover the range, but you need mannally set the block size. MUDA_HOST ParallelFor (int gridDim, int blockDim, size_t shared_mem_size=0, cudaStream_t stream=nullptr) Use Gride Stride Loop to cover the range, you need mannally set the grid size and block size. Gride Stride Loop: if grid_dim * block_dim &lt; count, there will be a loop in every thread, to process multiple indices. MUDA_HOST ParallelFor &amp; apply (int count, F &amp;&amp; f)  MUDA_HOST ParallelFor &amp; apply (int count, F &amp;&amp; f, Tag&lt; UserTag &gt;)  MUDA_HOST MUDA_NODISCARD auto as_node_parms (int count, F &amp;&amp; f)  MUDA_HOST MUDA_NODISCARD auto as_node_parms (int count, F &amp;&amp; f, Tag&lt; UserTag &gt;)  MUDA_GENERIC int calculate_block_dim (int count) const MUDA_GENERIC int calculate_grid_dim (int count) const MUDA_GENERIC void check_input (int count) const MUDA_HOST void invoke (int count, F &amp;&amp; f)"},{"location":"muda/classmuda_1_1_parallel_for/#public-functions-inherited-from-mudalaunchbase","title":"Public Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name MUDA_GENERIC LaunchBase (::cudaStream_t stream)  T &amp; callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  T &amp; file_line (std::string_view file, int line)  T &amp; kernel_name (std::string_view name)  Next next (Next n)  Next next (Args &amp;&amp;... args)  T &amp; pop_range ()  T &amp; push_range (const std::string &amp; name)  T &amp; record (cudaEvent_t e, int flag=cudaEventRecordDefault)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  T &amp; wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  T &amp; wait ()  T &amp; when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchBase ()"},{"location":"muda/classmuda_1_1_parallel_for/#public-functions-inherited-from-mudalaunchcore","title":"Public Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_GENERIC LaunchCore (::cudaStream_t stream)  void callback (const std::function&lt; void(::cudaStream_t, ::cudaError)&gt; &amp; callback)  void init_stream (::cudaStream_t s)  void pop_range ()  void push_range (const std::string &amp; name)  void record (cudaEvent_t e, int flag=cudaEventRecordDefault)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void record (ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait (cudaEvent_t e, int flag=cudaEventWaitDefault)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, const std::vector&lt; ComputeGraphVarBase * &gt; &amp; vars)  void wait (const ComputeGraphVar&lt; cudaEvent_t &gt; &amp; e, ComputeGraphVar&lt; ViewT &gt; &amp;... vars)  void wait ()  void when (cudaEvent_t e, int flag=cudaEventWaitDefault)  ~LaunchCore ()"},{"location":"muda/classmuda_1_1_parallel_for/#public-static-functions","title":"Public Static Functions","text":"Type Name MUDA_GENERIC int calculate_grid_dim (int count, int block_dim)  MUDA_GENERIC static MUDA_NODISCARD int round_up_blocks (int count, int block_dim)"},{"location":"muda/classmuda_1_1_parallel_for/#public-static-functions-inherited-from-mudalaunchcore","title":"Public Static Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name void file_line (std::string_view file, int line)  void kernel_name (std::string_view name)  void wait_device ()  void wait_event (cudaEvent_t event)  void wait_stream (::cudaStream_t stream)"},{"location":"muda/classmuda_1_1_parallel_for/#protected-types-inherited-from-mudalaunchcore","title":"Protected Types inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name typedef std::shared_ptr&lt; T &gt; S"},{"location":"muda/classmuda_1_1_parallel_for/#protected-attributes-inherited-from-mudalaunchcore","title":"Protected Attributes inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name ::cudaStream_t m_stream"},{"location":"muda/classmuda_1_1_parallel_for/#protected-functions-inherited-from-mudalaunchbase","title":"Protected Functions inherited from muda::LaunchBase","text":"<p>See muda::LaunchBase</p> Type Name T &amp; pop_kernel_label ()"},{"location":"muda/classmuda_1_1_parallel_for/#protected-functions-inherited-from-mudalaunchcore","title":"Protected Functions inherited from muda::LaunchCore","text":"<p>See muda::LaunchCore</p> Type Name MUDA_HOST void pop_kernel_label ()  MUDA_GENERIC::cudaStream_t stream () const"},{"location":"muda/classmuda_1_1_parallel_for/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_parallel_for/#typedef-nodeparms","title":"typedef NodeParms","text":"<pre><code>using muda::ParallelFor::NodeParms =  KernelNodeParms&lt;details::ParallelForCallable&lt;raw_type_t&lt;F&gt;&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_parallel_for/#function-parallelfor-13","title":"function ParallelFor [1/3]","text":"<p>Calculate grid dim automatically to cover the range, automatially choose the block size to achieve max occupancy. <pre><code>inline MUDA_HOST muda::ParallelFor::ParallelFor (\n    size_t shared_mem_size=0,\n    cudaStream_t stream=nullptr\n) \n</code></pre></p> <pre><code>DeviceBuffer&lt;int&gt; buffer(256);\nParallelFor()\n    .kernel_name(\"set_buffer\") // optional\n    .apply(buffer.size(), \n        [\n            buffer = buffer.viewer().name(\"buffer\") // name is optional\n        ] __device__(int i) mutable \n        {\n            buffer(i) = 1;\n        });\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-parallelfor-23","title":"function ParallelFor [2/3]","text":"<p>Calculate grid dim automatically to cover the range, but you need mannally set the block size. <pre><code>inline MUDA_HOST muda::ParallelFor::ParallelFor (\n    int blockDim,\n    size_t shared_mem_size=0,\n    cudaStream_t stream=nullptr\n) \n</code></pre></p> <pre><code>DeviceBuffer&lt;int&gt; buffer(256);\nParallelFor(64)\n    .kernel_name(\"set_buffer\") // optional\n    .apply(buffer.size(), \n        [\n            buffer = buffer.viewer().name(\"buffer\") // name is optional\n        ] __device__(int i) mutable \n        {\n            buffer(i) = 1;\n        });\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-parallelfor-33","title":"function ParallelFor [3/3]","text":"<p>Use Gride Stride Loop to cover the range, you need mannally set the grid size and block size. Gride Stride Loop: if grid_dim * block_dim &lt; count, there will be a loop in every thread, to process multiple indices. <pre><code>inline MUDA_HOST muda::ParallelFor::ParallelFor (\n    int gridDim,\n    int blockDim,\n    size_t shared_mem_size=0,\n    cudaStream_t stream=nullptr\n) \n</code></pre></p> <pre><code>DeviceBuffer&lt;int&gt; buffer(256);\nParallelFor(2, 64)\n    .kernel_name(\"set_buffer\") // optional\n    .apply(buffer.size(), \n        [\n            buffer = buffer.viewer().name(\"buffer\") // name is optional\n        ] __device__(int i) mutable \n        {\n            buffer(i) = 1;\n        });\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-apply-12","title":"function apply [1/2]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST ParallelFor &amp; muda::ParallelFor::apply (\n    int count,\n    F &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-apply-22","title":"function apply [2/2]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST ParallelFor &amp; muda::ParallelFor::apply (\n    int count,\n    F &amp;&amp; f,\n    Tag &lt; UserTag &gt;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-as_node_parms-12","title":"function as_node_parms [1/2]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST MUDA_NODISCARD auto muda::ParallelFor::as_node_parms (\n    int count,\n    F &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-as_node_parms-22","title":"function as_node_parms [2/2]","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST MUDA_NODISCARD auto muda::ParallelFor::as_node_parms (\n    int count,\n    F &amp;&amp; f,\n    Tag &lt; UserTag &gt;\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-calculate_block_dim","title":"function calculate_block_dim","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_GENERIC int muda::ParallelFor::calculate_block_dim (\n    int count\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-calculate_grid_dim-12","title":"function calculate_grid_dim [1/2]","text":"<pre><code>MUDA_GENERIC int muda::ParallelFor::calculate_grid_dim (\n    int count\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-check_input","title":"function check_input","text":"<pre><code>MUDA_GENERIC void muda::ParallelFor::check_input (\n    int count\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-invoke","title":"function invoke","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST void muda::ParallelFor::invoke (\n    int count,\n    F &amp;&amp; f\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_parallel_for/#function-calculate_grid_dim-22","title":"function calculate_grid_dim [2/2]","text":"<pre><code>static MUDA_GENERIC int muda::ParallelFor::calculate_grid_dim (\n    int count,\n    int block_dim\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for/#function-round_up_blocks","title":"function round_up_blocks","text":"<pre><code>static inline MUDA_GENERIC static MUDA_NODISCARD int muda::ParallelFor::round_up_blocks (\n    int count,\n    int block_dim\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/parallel_for.h</code></p>"},{"location":"muda/classmuda_1_1_parallel_for_details/","title":"Class muda::ParallelForDetails","text":"<p>ClassList &gt; muda &gt; ParallelForDetails</p>"},{"location":"muda/classmuda_1_1_parallel_for_details/#public-functions","title":"Public Functions","text":"Type Name MUDA_NODISCARD MUDA_DEVICE int active_num_in_block () const MUDA_NODISCARD MUDA_DEVICE int batch_i () const MUDA_NODISCARD MUDA_DEVICE int i () const MUDA_NODISCARD MUDA_DEVICE bool is_final_block () const MUDA_NODISCARD MUDA_DEVICE operator int () const MUDA_NODISCARD MUDA_DEVICE ParallelForType parallel_for_type () const MUDA_NODISCARD MUDA_DEVICE int total_batch () const MUDA_NODISCARD MUDA_DEVICE int total_num () const"},{"location":"muda/classmuda_1_1_parallel_for_details/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_parallel_for_details/#function-active_num_in_block","title":"function active_num_in_block","text":"<pre><code>MUDA_NODISCARD MUDA_DEVICE int muda::ParallelForDetails::active_num_in_block () const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for_details/#function-batch_i","title":"function batch_i","text":"<pre><code>inline MUDA_NODISCARD MUDA_DEVICE int muda::ParallelForDetails::batch_i () const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for_details/#function-i","title":"function i","text":"<pre><code>inline MUDA_NODISCARD MUDA_DEVICE int muda::ParallelForDetails::i () const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for_details/#function-is_final_block","title":"function is_final_block","text":"<pre><code>MUDA_NODISCARD MUDA_DEVICE bool muda::ParallelForDetails::is_final_block () const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for_details/#function-operator-int","title":"function operator int","text":"<pre><code>inline MUDA_NODISCARD MUDA_DEVICE muda::ParallelForDetails::operator int () const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for_details/#function-parallel_for_type","title":"function parallel_for_type","text":"<pre><code>inline MUDA_NODISCARD MUDA_DEVICE ParallelForType muda::ParallelForDetails::parallel_for_type () const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for_details/#function-total_batch","title":"function total_batch","text":"<pre><code>inline MUDA_NODISCARD MUDA_DEVICE int muda::ParallelForDetails::total_batch () const\n</code></pre>"},{"location":"muda/classmuda_1_1_parallel_for_details/#function-total_num","title":"function total_num","text":"<pre><code>inline MUDA_NODISCARD MUDA_DEVICE int muda::ParallelForDetails::total_num () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/parallel_for.h</code></p>"},{"location":"muda/classmuda_1_1_profile/","title":"Class muda::Profile","text":"<p>ClassList &gt; muda &gt; Profile</p>"},{"location":"muda/classmuda_1_1_profile/#public-functions","title":"Public Functions","text":"Type Name Profile ()  Profile (const std::string &amp; name)  ~Profile ()"},{"location":"muda/classmuda_1_1_profile/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_profile/#function-profile-12","title":"function Profile [1/2]","text":"<pre><code>inline muda::Profile::Profile () \n</code></pre>"},{"location":"muda/classmuda_1_1_profile/#function-profile-22","title":"function Profile [2/2]","text":"<pre><code>inline muda::Profile::Profile (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_profile/#function-profile","title":"function ~Profile","text":"<pre><code>inline muda::Profile::~Profile () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/profiler.h</code></p>"},{"location":"muda/classmuda_1_1_range_name/","title":"Class muda::RangeName","text":"<p>ClassList &gt; muda &gt; RangeName</p>"},{"location":"muda/classmuda_1_1_range_name/#public-functions","title":"Public Functions","text":"Type Name RangeName (const std::string &amp; name)  ~RangeName ()"},{"location":"muda/classmuda_1_1_range_name/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_range_name/#function-rangename","title":"function RangeName","text":"<pre><code>inline muda::RangeName::RangeName (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_range_name/#function-rangename_1","title":"function ~RangeName","text":"<pre><code>inline muda::RangeName::~RangeName () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/profiler.h</code></p>"},{"location":"muda/classmuda_1_1_stream/","title":"Class muda::Stream","text":"<p>ClassList &gt; muda &gt; Stream</p> <p>RAII wrapper for cudaStream. </p> <ul> <li><code>#include &lt;stream.h&gt;</code></li> </ul>"},{"location":"muda/classmuda_1_1_stream/#classes","title":"Classes","text":"Type Name class FireAndForget class GraphFireAndForget class GraphTailLaunch class TailLaunch"},{"location":"muda/classmuda_1_1_stream/#public-types","title":"Public Types","text":"Type Name enum unsigned int Flag"},{"location":"muda/classmuda_1_1_stream/#public-functions","title":"Public Functions","text":"Type Name MUDA_NODISCARD Stream (Flag f=Flag::eDefault)  Stream (const Stream &amp;) = delete Stream (Stream &amp;&amp; o)  void begin_capture (cudaStreamCaptureMode mode=cudaStreamCaptureModeThreadLocal) const void end_capture (cudaGraph_t * graph) const operator cudaStream_t () const Stream &amp; operator= (const Stream &amp;) = delete Stream &amp; operator= (Stream &amp;&amp; o)  cudaStream_t view () const void wait () const std::byte * workspace (size_t byte_size)  ~Stream ()"},{"location":"muda/classmuda_1_1_stream/#public-static-functions","title":"Public Static Functions","text":"Type Name Stream &amp; Default ()"},{"location":"muda/classmuda_1_1_stream/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_stream/#enum-flag","title":"enum Flag","text":"<pre><code>enum muda::Stream::Flag {\n    eDefault = cudaStreamDefault,\n    eNonBlocking = cudaStreamNonBlocking\n};\n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_stream/#function-stream-14","title":"function Stream [1/4]","text":"<pre><code>MUDA_NODISCARD muda::Stream::Stream (\n    Flag f=Flag::eDefault\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-stream-24","title":"function Stream [2/4]","text":"<pre><code>muda::Stream::Stream (\n    const Stream &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-stream-34","title":"function Stream [3/4]","text":"<pre><code>muda::Stream::Stream (\n    Stream &amp;&amp; o\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-begin_capture","title":"function begin_capture","text":"<pre><code>void muda::Stream::begin_capture (\n    cudaStreamCaptureMode mode=cudaStreamCaptureModeThreadLocal\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-end_capture","title":"function end_capture","text":"<pre><code>void muda::Stream::end_capture (\n    cudaGraph_t * graph\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-operator-cudastream_t","title":"function operator cudaStream_t","text":"<pre><code>inline muda::Stream::operator cudaStream_t () const\n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-operator","title":"function operator=","text":"<pre><code>Stream &amp; muda::Stream::operator= (\n    const Stream &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-operator_1","title":"function operator=","text":"<pre><code>Stream &amp; muda::Stream::operator= (\n    Stream &amp;&amp; o\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-view","title":"function view","text":"<pre><code>inline cudaStream_t muda::Stream::view () const\n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-wait","title":"function wait","text":"<pre><code>void muda::Stream::wait () const\n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-workspace","title":"function workspace","text":"<pre><code>std::byte * muda::Stream::workspace (\n    size_t byte_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#function-stream","title":"function ~Stream","text":"<pre><code>muda::Stream::~Stream () \n</code></pre>"},{"location":"muda/classmuda_1_1_stream/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_stream/#function-default","title":"function Default","text":"<pre><code>static Stream &amp; muda::Stream::Default () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/stream.h</code></p>"},{"location":"muda/classmuda_1_1_stream_1_1_fire_and_forget/","title":"Class muda::Stream::FireAndForget","text":"<p>ClassList &gt; muda &gt; Stream &gt; FireAndForget</p>"},{"location":"muda/classmuda_1_1_stream_1_1_fire_and_forget/#public-functions","title":"Public Functions","text":"Type Name MUDA_DEVICE FireAndForget ()  MUDA_DEVICE operator cudaStream_t () const"},{"location":"muda/classmuda_1_1_stream_1_1_fire_and_forget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_stream_1_1_fire_and_forget/#function-fireandforget","title":"function FireAndForget","text":"<pre><code>inline MUDA_DEVICE muda::Stream::FireAndForget::FireAndForget () \n</code></pre>"},{"location":"muda/classmuda_1_1_stream_1_1_fire_and_forget/#function-operator-cudastream_t","title":"function operator cudaStream_t","text":"<pre><code>MUDA_DEVICE muda::Stream::FireAndForget::operator cudaStream_t () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/stream.h</code></p>"},{"location":"muda/classmuda_1_1_stream_1_1_graph_fire_and_forget/","title":"Class muda::Stream::GraphFireAndForget","text":"<p>ClassList &gt; muda &gt; Stream &gt; GraphFireAndForget</p>"},{"location":"muda/classmuda_1_1_stream_1_1_graph_fire_and_forget/#public-functions","title":"Public Functions","text":"Type Name MUDA_DEVICE GraphFireAndForget ()  MUDA_DEVICE operator cudaStream_t () const"},{"location":"muda/classmuda_1_1_stream_1_1_graph_fire_and_forget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_stream_1_1_graph_fire_and_forget/#function-graphfireandforget","title":"function GraphFireAndForget","text":"<pre><code>inline MUDA_DEVICE muda::Stream::GraphFireAndForget::GraphFireAndForget () \n</code></pre>"},{"location":"muda/classmuda_1_1_stream_1_1_graph_fire_and_forget/#function-operator-cudastream_t","title":"function operator cudaStream_t","text":"<pre><code>MUDA_DEVICE muda::Stream::GraphFireAndForget::operator cudaStream_t () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/stream.h</code></p>"},{"location":"muda/classmuda_1_1_stream_1_1_graph_tail_launch/","title":"Class muda::Stream::GraphTailLaunch","text":"<p>ClassList &gt; muda &gt; Stream &gt; GraphTailLaunch</p>"},{"location":"muda/classmuda_1_1_stream_1_1_graph_tail_launch/#public-functions","title":"Public Functions","text":"Type Name MUDA_DEVICE GraphTailLaunch ()  MUDA_DEVICE operator cudaStream_t () const"},{"location":"muda/classmuda_1_1_stream_1_1_graph_tail_launch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_stream_1_1_graph_tail_launch/#function-graphtaillaunch","title":"function GraphTailLaunch","text":"<pre><code>inline MUDA_DEVICE muda::Stream::GraphTailLaunch::GraphTailLaunch () \n</code></pre>"},{"location":"muda/classmuda_1_1_stream_1_1_graph_tail_launch/#function-operator-cudastream_t","title":"function operator cudaStream_t","text":"<pre><code>MUDA_DEVICE muda::Stream::GraphTailLaunch::operator cudaStream_t () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/stream.h</code></p>"},{"location":"muda/classmuda_1_1_stream_1_1_tail_launch/","title":"Class muda::Stream::TailLaunch","text":"<p>ClassList &gt; muda &gt; Stream &gt; TailLaunch</p>"},{"location":"muda/classmuda_1_1_stream_1_1_tail_launch/#public-functions","title":"Public Functions","text":"Type Name MUDA_DEVICE TailLaunch ()  MUDA_DEVICE operator cudaStream_t () const"},{"location":"muda/classmuda_1_1_stream_1_1_tail_launch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_stream_1_1_tail_launch/#function-taillaunch","title":"function TailLaunch","text":"<pre><code>inline MUDA_DEVICE muda::Stream::TailLaunch::TailLaunch () \n</code></pre>"},{"location":"muda/classmuda_1_1_stream_1_1_tail_launch/#function-operator-cudastream_t","title":"function operator cudaStream_t","text":"<pre><code>MUDA_DEVICE muda::Stream::TailLaunch::operator cudaStream_t () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/stream.h</code></p>"},{"location":"muda/classmuda_1_1_sub_field/","title":"Class muda::SubField","text":"<p>ClassList &gt; muda &gt; SubField</p>"},{"location":"muda/classmuda_1_1_sub_field/#public-functions","title":"Public Functions","text":"Type Name FieldBuilder&lt; FieldEntryLayout::AoS &gt; AoS (const FieldBuildOptions &amp; options={}) The layout is array of structs (determined at compile time) FieldBuilder&lt; FieldEntryLayout::AoSoA &gt; AoSoA (uint32_t innermost_array_size=32, const FieldBuildOptions &amp; options={}) The layout is array of structs of arrays (determined at compile time) FieldBuilder&lt; FieldEntryLayout::SoA &gt; SoA (const FieldBuildOptions &amp; options={}) The layout is struct of arrays (determined at compile time) SubField (Field &amp; field, std::string_view name)  SubField (const SubField &amp;) = delete SubField (SubField &amp;&amp;) = delete FieldBuilder&lt; Layout &gt; builder (FieldEntryLayoutInfo layout=FieldEntryLayoutInfo, const FieldBuildOptions &amp; options={})  FieldBuilder&lt; FieldEntryLayout::RuntimeLayout &gt; builder (FieldEntryLayoutInfo layout, const FieldBuildOptions &amp; options={}) The layout is determined at runtime. std::string_view name () const SubField &amp; operator= (const SubField &amp;) = delete SubField &amp; operator= (SubField &amp;&amp;) = delete void resize (size_t num_elements)  size_t size () const ~SubField ()"},{"location":"muda/classmuda_1_1_sub_field/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_sub_field/#function-aos","title":"function AoS","text":"<p>The layout is array of structs (determined at compile time) <pre><code>FieldBuilder &lt; FieldEntryLayout::AoS &gt; muda::SubField::AoS (\n    const FieldBuildOptions &amp; options={}\n) \n</code></pre></p> <p>Returns:</p>"},{"location":"muda/classmuda_1_1_sub_field/#function-aosoa","title":"function AoSoA","text":"<p>The layout is array of structs of arrays (determined at compile time) <pre><code>FieldBuilder &lt; FieldEntryLayout::AoSoA &gt; muda::SubField::AoSoA (\n    uint32_t innermost_array_size=32,\n    const FieldBuildOptions &amp; options={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>layout</code> </li> </ul> <p>Returns:</p>"},{"location":"muda/classmuda_1_1_sub_field/#function-soa","title":"function SoA","text":"<p>The layout is struct of arrays (determined at compile time) <pre><code>FieldBuilder &lt; FieldEntryLayout::SoA &gt; muda::SubField::SoA (\n    const FieldBuildOptions &amp; options={}\n) \n</code></pre></p> <p>Returns:</p>"},{"location":"muda/classmuda_1_1_sub_field/#function-subfield-24","title":"function SubField [2/4]","text":"<pre><code>muda::SubField::SubField (\n    Field &amp; field,\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field/#function-subfield-34","title":"function SubField [3/4]","text":"<pre><code>muda::SubField::SubField (\n    const SubField &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field/#function-subfield-44","title":"function SubField [4/4]","text":"<pre><code>muda::SubField::SubField (\n    SubField &amp;&amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field/#function-builder-12","title":"function builder [1/2]","text":"<pre><code>template&lt;FieldEntryLayout Layout&gt;\nFieldBuilder &lt; Layout &gt; muda::SubField::builder (\n    FieldEntryLayoutInfo layout=FieldEntryLayoutInfo {Layout},\n    const FieldBuildOptions &amp; options={}\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field/#function-builder-22","title":"function builder [2/2]","text":"<p>The layout is determined at runtime. <pre><code>FieldBuilder &lt; FieldEntryLayout::RuntimeLayout &gt; muda::SubField::builder (\n    FieldEntryLayoutInfo layout,\n    const FieldBuildOptions &amp; options={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>layout</code> </li> </ul> <p>Returns:</p>"},{"location":"muda/classmuda_1_1_sub_field/#function-name","title":"function name","text":"<pre><code>inline std::string_view muda::SubField::name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field/#function-operator","title":"function operator=","text":"<pre><code>SubField &amp; muda::SubField::operator= (\n    const SubField &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field/#function-operator_1","title":"function operator=","text":"<pre><code>SubField &amp; muda::SubField::operator= (\n    SubField &amp;&amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field/#function-resize","title":"function resize","text":"<pre><code>void muda::SubField::resize (\n    size_t num_elements\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field/#function-size","title":"function size","text":"<pre><code>size_t muda::SubField::size () const\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field/#function-subfield","title":"function ~SubField","text":"<pre><code>muda::SubField::~SubField () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/sub_field.h</code></p>"},{"location":"muda/classmuda_1_1_sub_field_impl/","title":"Class muda::SubFieldImpl","text":"<p>template &lt;FieldEntryLayout Layout&gt;</p> <p>ClassList &gt; muda &gt; SubFieldImpl</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field.h</code></p>"},{"location":"muda/classmuda_1_1_sub_field_interface/","title":"Class muda::SubFieldInterface","text":"<p>ClassList &gt; muda &gt; SubFieldInterface</p> <p>Inherited by the following classes: muda::SubFieldImpl,  muda::SubFieldImpl,  muda::SubFieldImpl</p>"},{"location":"muda/classmuda_1_1_sub_field_interface/#public-functions","title":"Public Functions","text":"Type Name SubFieldInterface (Field &amp; field)  SubFieldInterface (const SubFieldInterface &amp;) = delete SubFieldInterface (SubFieldInterface &amp;&amp;) = delete SubFieldInterface &amp; operator= (const SubFieldInterface &amp;) = delete SubFieldInterface &amp; operator= (SubFieldInterface &amp;&amp;) = delete virtual ~SubFieldInterface ()"},{"location":"muda/classmuda_1_1_sub_field_interface/#protected-attributes","title":"Protected Attributes","text":"Type Name FieldBuildOptions m_build_options std::byte * m_data_buffer   = = nullptr size_t m_data_buffer_size   = = 0 std::vector&lt; U&lt; FieldEntryBase &gt; &gt; m_entries Field &amp; m_field FieldEntryLayoutInfo m_layout_info std::unordered_map&lt; std::string, size_t &gt; m_name_to_index size_t m_num_elements   = = 0 uint32_t m_struct_stride   = = ~0"},{"location":"muda/classmuda_1_1_sub_field_interface/#protected-functions","title":"Protected Functions","text":"Type Name virtual bool allow_inplace_shrink () const virtual void build_impl () = 0 const FieldBuildOptions &amp; build_options () const virtual void calculate_new_cores (std::byte * byte_buffer, size_t total_bytes, size_t element_count, span&lt; FieldEntryCore &gt; new_cores) = 0 const FieldEntryLayoutInfo &amp; layout_info () const size_t num_elements () const virtual size_t require_total_buffer_byte_size (size_t element_count) = 0"},{"location":"muda/classmuda_1_1_sub_field_interface/#protected-static-functions","title":"Protected Static Functions","text":"Type Name uint32_t align (uint32_t offset, uint32_t size, uint32_t min_alignment, uint32_t max_alignment)  uint32_t round_up (uint32_t total, uint32_t N)"},{"location":"muda/classmuda_1_1_sub_field_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_sub_field_interface/#function-subfieldinterface-13","title":"function SubFieldInterface [1/3]","text":"<pre><code>inline muda::SubFieldInterface::SubFieldInterface (\n    Field &amp; field\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-subfieldinterface-23","title":"function SubFieldInterface [2/3]","text":"<pre><code>muda::SubFieldInterface::SubFieldInterface (\n    const SubFieldInterface &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-subfieldinterface-33","title":"function SubFieldInterface [3/3]","text":"<pre><code>muda::SubFieldInterface::SubFieldInterface (\n    SubFieldInterface &amp;&amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-operator","title":"function operator=","text":"<pre><code>SubFieldInterface &amp; muda::SubFieldInterface::operator= (\n    const SubFieldInterface &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-operator_1","title":"function operator=","text":"<pre><code>SubFieldInterface &amp; muda::SubFieldInterface::operator= (\n    SubFieldInterface &amp;&amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-subfieldinterface","title":"function ~SubFieldInterface","text":"<pre><code>virtual muda::SubFieldInterface::~SubFieldInterface () \n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_sub_field_interface/#variable-m_build_options","title":"variable m_build_options","text":"<pre><code>FieldBuildOptions muda::SubFieldInterface::m_build_options;\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#variable-m_data_buffer","title":"variable m_data_buffer","text":"<pre><code>std::byte* muda::SubFieldInterface::m_data_buffer;\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#variable-m_data_buffer_size","title":"variable m_data_buffer_size","text":"<pre><code>size_t muda::SubFieldInterface::m_data_buffer_size;\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#variable-m_entries","title":"variable m_entries","text":"<pre><code>std::vector&lt;U&lt;FieldEntryBase&gt; &gt; muda::SubFieldInterface::m_entries;\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#variable-m_field","title":"variable m_field","text":"<pre><code>Field&amp; muda::SubFieldInterface::m_field;\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#variable-m_layout_info","title":"variable m_layout_info","text":"<pre><code>FieldEntryLayoutInfo muda::SubFieldInterface::m_layout_info;\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#variable-m_name_to_index","title":"variable m_name_to_index","text":"<pre><code>std::unordered_map&lt;std::string, size_t&gt; muda::SubFieldInterface::m_name_to_index;\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#variable-m_num_elements","title":"variable m_num_elements","text":"<pre><code>size_t muda::SubFieldInterface::m_num_elements;\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#variable-m_struct_stride","title":"variable m_struct_stride","text":"<pre><code>uint32_t muda::SubFieldInterface::m_struct_stride;\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_sub_field_interface/#function-allow_inplace_shrink","title":"function allow_inplace_shrink","text":"<pre><code>inline virtual bool muda::SubFieldInterface::allow_inplace_shrink () const\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-build_impl","title":"function build_impl","text":"<pre><code>virtual void muda::SubFieldInterface::build_impl () = 0\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-build_options","title":"function build_options","text":"<pre><code>inline const FieldBuildOptions &amp; muda::SubFieldInterface::build_options () const\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-calculate_new_cores","title":"function calculate_new_cores","text":"<pre><code>virtual void muda::SubFieldInterface::calculate_new_cores (\n    std::byte * byte_buffer,\n    size_t total_bytes,\n    size_t element_count,\n    span&lt; FieldEntryCore &gt; new_cores\n) = 0\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-layout_info","title":"function layout_info","text":"<pre><code>inline const FieldEntryLayoutInfo &amp; muda::SubFieldInterface::layout_info () const\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-num_elements","title":"function num_elements","text":"<pre><code>inline size_t muda::SubFieldInterface::num_elements () const\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-require_total_buffer_byte_size","title":"function require_total_buffer_byte_size","text":"<pre><code>virtual size_t muda::SubFieldInterface::require_total_buffer_byte_size (\n    size_t element_count\n) = 0\n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#protected-static-functions-documentation","title":"Protected Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1_sub_field_interface/#function-align","title":"function align","text":"<pre><code>static uint32_t muda::SubFieldInterface::align (\n    uint32_t offset,\n    uint32_t size,\n    uint32_t min_alignment,\n    uint32_t max_alignment\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_sub_field_interface/#function-round_up","title":"function round_up","text":"<pre><code>static uint32_t muda::SubFieldInterface::round_up (\n    uint32_t total,\n    uint32_t N\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/sub_field_interface.h</code></p>"},{"location":"muda/structmuda_1_1_tag/","title":"Struct muda::Tag","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; Tag</p> <p>The documentation for this class was generated from the following file <code>src/muda/launch/kernel_tag.h</code></p>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/","title":"Class muda::TripletMatrixViewT","text":"<p>template &lt;bool IsConst, typename Ty, int N&gt;</p> <p>ClassList &gt; muda &gt; TripletMatrixViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#public-types","title":"Public Types","text":"Type Name typedef Eigen::Matrix&lt; Ty, N, N &gt; BlockMatrix typedef TripletMatrixViewT&lt; true, Ty, N &gt; ConstView typedef TripletMatrixViewT&lt; false, Ty, N &gt; NonConstView typedef TripletMatrixViewT&lt; IsConst, Ty, N &gt; ThisView"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC TripletMatrixViewT () = default MUDA_GENERIC TripletMatrixViewT (int total_block_rows, int total_block_cols, int triplet_index_offset, int triplet_count, int total_triplet_count, int2 submatrix_offset, int2 submatrix_extent, auto_const_t&lt; int &gt; * block_row_indices, auto_const_t&lt; int &gt; * block_col_indices, auto_const_t&lt; BlockMatrix &gt; * block_values)  MUDA_GENERIC TripletMatrixViewT (int total_block_rows, int total_block_cols, int total_triplet_count, auto_const_t&lt; int &gt; * block_row_indices, auto_const_t&lt; int &gt; * block_col_indices, auto_const_t&lt; BlockMatrix &gt; * block_values)  MUDA_GENERIC TripletMatrixViewT (const TripletMatrixViewT&lt; OtherIsConst, Ty, N &gt; &amp; other)  MUDA_GENERIC ConstView as_const () const MUDA_GENERIC auto cviewer () const MUDA_GENERIC auto extent () const MUDA_GENERIC auto submatrix (int2 offset, int2 extent) const MUDA_GENERIC auto submatrix_offset () const MUDA_GENERIC auto subview (int offset, int count) const MUDA_GENERIC auto subview (int offset) const MUDA_GENERIC auto total_block_cols () const MUDA_GENERIC auto total_block_rows () const MUDA_GENERIC auto total_extent () const MUDA_GENERIC auto total_triplet_count () const MUDA_GENERIC auto tripet_index_offset () const MUDA_GENERIC auto triplet_count () const MUDA_GENERIC auto viewer () const"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; int &gt; * m_block_col_indices   = = nullptr auto_const_t&lt; int &gt; * m_block_row_indices   = = nullptr auto_const_t&lt; BlockMatrix &gt; * m_block_values   = = nullptr int2 m_submatrix_extent   = = {0, 0} int2 m_submatrix_offset   = = {0, 0} int m_total_block_cols   = = 0 int m_total_block_rows   = = 0 int m_total_triplet_count   = = 0 int m_triplet_count   = = 0 int m_triplet_index_offset   = = 0"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#typedef-blockmatrix","title":"typedef BlockMatrix","text":"<pre><code>using muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::BlockMatrix =  Eigen::Matrix&lt;Ty, N, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::ConstView =  TripletMatrixViewT&lt;true, Ty, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#typedef-nonconstview","title":"typedef NonConstView","text":"<pre><code>using muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::NonConstView =  TripletMatrixViewT&lt;false, Ty, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::ThisView =  TripletMatrixViewT&lt;IsConst, Ty, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-tripletmatrixviewt-25","title":"function TripletMatrixViewT [2/5]","text":"<pre><code>MUDA_GENERIC muda::TripletMatrixViewT::TripletMatrixViewT () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-tripletmatrixviewt-35","title":"function TripletMatrixViewT [3/5]","text":"<pre><code>inline MUDA_GENERIC muda::TripletMatrixViewT::TripletMatrixViewT (\n    int total_block_rows,\n    int total_block_cols,\n    int triplet_index_offset,\n    int triplet_count,\n    int total_triplet_count,\n    int2 submatrix_offset,\n    int2 submatrix_extent,\n    auto_const_t&lt; int &gt; * block_row_indices,\n    auto_const_t&lt; int &gt; * block_col_indices,\n    auto_const_t&lt; BlockMatrix &gt; * block_values\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-tripletmatrixviewt-45","title":"function TripletMatrixViewT [4/5]","text":"<pre><code>inline MUDA_GENERIC muda::TripletMatrixViewT::TripletMatrixViewT (\n    int total_block_rows,\n    int total_block_cols,\n    int total_triplet_count,\n    auto_const_t&lt; int &gt; * block_row_indices,\n    auto_const_t&lt; int &gt; * block_col_indices,\n    auto_const_t&lt; BlockMatrix &gt; * block_values\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-tripletmatrixviewt-55","title":"function TripletMatrixViewT [5/5]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::TripletMatrixViewT::TripletMatrixViewT (\n    const TripletMatrixViewT &lt; OtherIsConst, Ty, N &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC ConstView muda::TripletMatrixViewT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-cviewer","title":"function cviewer","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-extent","title":"function extent","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-submatrix","title":"function submatrix","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::submatrix (\n    int2 offset,\n    int2 extent\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-submatrix_offset","title":"function submatrix_offset","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::submatrix_offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-subview-12","title":"function subview [1/2]","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::subview (\n    int offset,\n    int count\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-subview-22","title":"function subview [2/2]","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::subview (\n    int offset\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-total_block_cols","title":"function total_block_cols","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::total_block_cols () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-total_block_rows","title":"function total_block_rows","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::total_block_rows () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-total_extent","title":"function total_extent","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::total_extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-total_triplet_count","title":"function total_triplet_count","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::total_triplet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-tripet_index_offset","title":"function tripet_index_offset","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::tripet_index_offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-triplet_count","title":"function triplet_count","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::triplet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#function-viewer","title":"function viewer","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewT::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_block_col_indices","title":"variable m_block_col_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_block_col_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_block_row_indices","title":"variable m_block_row_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_block_row_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_block_values","title":"variable m_block_values","text":"<pre><code>auto_const_t&lt;BlockMatrix&gt;* muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_block_values;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_submatrix_extent","title":"variable m_submatrix_extent","text":"<pre><code>int2 muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_submatrix_extent;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_submatrix_offset","title":"variable m_submatrix_offset","text":"<pre><code>int2 muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_submatrix_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_total_block_cols","title":"variable m_total_block_cols","text":"<pre><code>int muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_total_block_cols;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_total_block_rows","title":"variable m_total_block_rows","text":"<pre><code>int muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_total_block_rows;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_total_triplet_count","title":"variable m_total_triplet_count","text":"<pre><code>int muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_total_triplet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_triplet_count","title":"variable m_triplet_count","text":"<pre><code>int muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_triplet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_view_t/#variable-m_triplet_index_offset","title":"variable m_triplet_index_offset","text":"<pre><code>int muda::TripletMatrixViewT&lt; IsConst, Ty, N &gt;::m_triplet_index_offset;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/triplet_matrix_view.h</code></p>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/","title":"Class muda::TripletMatrixViewerT","text":"<p>template &lt;bool IsConst, typename T, int N&gt;</p> <p>ClassList &gt; muda &gt; TripletMatrixViewerT</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#classes","title":"Classes","text":"Type Name struct CTriplet class Proxy"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#public-types","title":"Public Types","text":"Type Name typedef TripletMatrixViewerT&lt; true, T, N &gt; ConstViewer typedef TripletMatrixViewerT&lt; false, T, N &gt; NonConstViewer typedef TripletMatrixViewerT&lt; IsConst, T, N &gt; ThisViewer typedef std::conditional_t&lt; N==1, T, Eigen::Matrix&lt; T, N, N &gt; &gt; ValueT"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC TripletMatrixViewerT () = default MUDA_GENERIC TripletMatrixViewerT (int total_block_rows, int total_block_cols, int triplet_index_offset, int triplet_count, int total_triplet_count, int2 submatrix_offset, int2 submatrix_extent, auto_const_t&lt; int &gt; * block_row_indices, auto_const_t&lt; int &gt; * block_col_indices, auto_const_t&lt; ValueT &gt; * block_values)  MUDA_GENERIC TripletMatrixViewerT (const TripletMatrixViewerT&lt; OtherIsConst, T, N &gt; &amp; other)  MUDA_GENERIC ConstViewer as_const () const MUDA_GENERIC auto extent () const MUDA_GENERIC auto operator() (int i) const MUDA_GENERIC auto submatrix_offset () const MUDA_GENERIC auto total_cols () const MUDA_GENERIC auto total_extent () const MUDA_GENERIC auto total_rows () const MUDA_GENERIC auto total_triplet_count () const MUDA_GENERIC auto tripet_index_offset () const MUDA_GENERIC auto triplet_count () const"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; int &gt; * m_col_indices auto_const_t&lt; int &gt; * m_row_indices int2 m_submatrix_extent   = = {0, 0} int2 m_submatrix_offset   = = {0, 0} int m_total_cols   = = 0 int m_total_rows   = = 0 int m_total_triplet_count   = = 0 int m_triplet_count   = = 0 int m_triplet_index_offset   = = 0 auto_const_t&lt; ValueT &gt; * m_values"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_GENERIC MUDA_INLINE CTriplet at (int i) noexcept const MUDA_INLINE MUDA_GENERIC void check_in_submatrix (int i, int j) noexcept const MUDA_INLINE MUDA_GENERIC int get_index (int i) noexcept const"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::ConstViewer =  TripletMatrixViewerT&lt;true, T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::NonConstViewer =  TripletMatrixViewerT&lt;false, T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::ThisViewer =  TripletMatrixViewerT&lt;IsConst, T, N&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#typedef-valuet","title":"typedef ValueT","text":"<pre><code>using muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::ValueT =  std::conditional_t&lt;N == 1, T, Eigen::Matrix&lt;T, N, N&gt;&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-tripletmatrixviewert-24","title":"function TripletMatrixViewerT [2/4]","text":"<pre><code>MUDA_GENERIC muda::TripletMatrixViewerT::TripletMatrixViewerT () = default\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-tripletmatrixviewert-34","title":"function TripletMatrixViewerT [3/4]","text":"<pre><code>inline MUDA_GENERIC muda::TripletMatrixViewerT::TripletMatrixViewerT (\n    int total_block_rows,\n    int total_block_cols,\n    int triplet_index_offset,\n    int triplet_count,\n    int total_triplet_count,\n    int2 submatrix_offset,\n    int2 submatrix_extent,\n    auto_const_t&lt; int &gt; * block_row_indices,\n    auto_const_t&lt; int &gt; * block_col_indices,\n    auto_const_t&lt; ValueT &gt; * block_values\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-tripletmatrixviewert-44","title":"function TripletMatrixViewerT [4/4]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\ninline MUDA_GENERIC muda::TripletMatrixViewerT::TripletMatrixViewerT (\n    const TripletMatrixViewerT &lt; OtherIsConst, T, N &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC ConstViewer muda::TripletMatrixViewerT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-extent","title":"function extent","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-operator","title":"function operator()","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::operator() (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-submatrix_offset","title":"function submatrix_offset","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::submatrix_offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-total_cols","title":"function total_cols","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::total_cols () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-total_extent","title":"function total_extent","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::total_extent () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-total_rows","title":"function total_rows","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::total_rows () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-total_triplet_count","title":"function total_triplet_count","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::total_triplet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-tripet_index_offset","title":"function tripet_index_offset","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::tripet_index_offset () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-triplet_count","title":"function triplet_count","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::triplet_count () const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_col_indices","title":"variable m_col_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_col_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_row_indices","title":"variable m_row_indices","text":"<pre><code>auto_const_t&lt;int&gt;* muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_row_indices;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_submatrix_extent","title":"variable m_submatrix_extent","text":"<pre><code>int2 muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_submatrix_extent;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_submatrix_offset","title":"variable m_submatrix_offset","text":"<pre><code>int2 muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_submatrix_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_total_cols","title":"variable m_total_cols","text":"<pre><code>int muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_total_cols;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_total_rows","title":"variable m_total_rows","text":"<pre><code>int muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_total_rows;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_total_triplet_count","title":"variable m_total_triplet_count","text":"<pre><code>int muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_total_triplet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_triplet_count","title":"variable m_triplet_count","text":"<pre><code>int muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_triplet_count;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_triplet_index_offset","title":"variable m_triplet_index_offset","text":"<pre><code>int muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_triplet_index_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#variable-m_values","title":"variable m_values","text":"<pre><code>auto_const_t&lt;ValueT&gt;* muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::m_values;\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-at","title":"function at","text":"<pre><code>inline MUDA_GENERIC MUDA_INLINE CTriplet muda::TripletMatrixViewerT::at (\n    int i\n) noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-check_in_submatrix","title":"function check_in_submatrix","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::TripletMatrixViewerT::check_in_submatrix (\n    int i,\n    int j\n) noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t/#function-get_index","title":"function get_index","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC int muda::TripletMatrixViewerT::get_index (\n    int i\n) noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/triplet_matrix_viewer.h</code></p>"},{"location":"muda/structmuda_1_1_triplet_matrix_viewer_t_1_1_c_triplet/","title":"Struct muda::TripletMatrixViewerT::CTriplet","text":"<p>ClassList &gt; muda &gt; TripletMatrixViewerT &gt; CTriplet</p>"},{"location":"muda/structmuda_1_1_triplet_matrix_viewer_t_1_1_c_triplet/#public-attributes","title":"Public Attributes","text":"Type Name int col_index int row_index const ValueT &amp; value"},{"location":"muda/structmuda_1_1_triplet_matrix_viewer_t_1_1_c_triplet/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC CTriplet (int row_index, int col_index, const ValueT &amp; block)"},{"location":"muda/structmuda_1_1_triplet_matrix_viewer_t_1_1_c_triplet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/structmuda_1_1_triplet_matrix_viewer_t_1_1_c_triplet/#variable-col_index","title":"variable col_index","text":"<pre><code>int muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::CTriplet::col_index;\n</code></pre>"},{"location":"muda/structmuda_1_1_triplet_matrix_viewer_t_1_1_c_triplet/#variable-row_index","title":"variable row_index","text":"<pre><code>int muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::CTriplet::row_index;\n</code></pre>"},{"location":"muda/structmuda_1_1_triplet_matrix_viewer_t_1_1_c_triplet/#variable-value","title":"variable value","text":"<pre><code>const ValueT&amp; muda::TripletMatrixViewerT&lt; IsConst, T, N &gt;::CTriplet::value;\n</code></pre>"},{"location":"muda/structmuda_1_1_triplet_matrix_viewer_t_1_1_c_triplet/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1_triplet_matrix_viewer_t_1_1_c_triplet/#function-ctriplet","title":"function CTriplet","text":"<pre><code>inline MUDA_GENERIC muda::TripletMatrixViewerT::CTriplet::CTriplet (\n    int row_index,\n    int col_index,\n    const ValueT &amp; block\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/triplet_matrix_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t_1_1_proxy/","title":"Class muda::TripletMatrixViewerT::Proxy","text":"<p>ClassList &gt; muda &gt; TripletMatrixViewerT &gt; Proxy</p>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t_1_1_proxy/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC auto read ()  MUDA_GENERIC void write (int row_index, int col_index, const ValueT &amp; block)  MUDA_GENERIC ~Proxy () = default"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t_1_1_proxy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t_1_1_proxy/#function-read","title":"function read","text":"<pre><code>inline MUDA_GENERIC auto muda::TripletMatrixViewerT::Proxy::read () \n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t_1_1_proxy/#function-write","title":"function write","text":"<pre><code>inline MUDA_GENERIC void muda::TripletMatrixViewerT::Proxy::write (\n    int row_index,\n    int col_index,\n    const ValueT &amp; block\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_triplet_matrix_viewer_t_1_1_proxy/#function-proxy","title":"function ~Proxy","text":"<pre><code>MUDA_GENERIC muda::TripletMatrixViewerT::Proxy::~Proxy () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/triplet_matrix_viewer.h</code></p>"},{"location":"muda/classmuda_1_1_var_id/","title":"Class muda::VarId","text":"<p>ClassList &gt; muda &gt; VarId</p> <p>Inherits the following classes: muda::IdWithType</p>"},{"location":"muda/classmuda_1_1_var_id/#public-types-inherited-from-mudaidwithtype","title":"Public Types inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name typedef T value_type"},{"location":"muda/classmuda_1_1_var_id/#public-static-attributes-inherited-from-mudaidwithtype","title":"Public Static Attributes inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name auto invalid_id   = = std::numeric_limits&lt;value_type&gt;::max()"},{"location":"muda/classmuda_1_1_var_id/#public-functions-inherited-from-mudaidwithtype","title":"Public Functions inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name MUDA_GENERIC IdWithType (value_type value) noexcept MUDA_GENERIC IdWithType () noexcept MUDA_GENERIC bool is_valid () noexcept const MUDA_GENERIC value_type value () noexcept const"},{"location":"muda/classmuda_1_1_var_id/#protected-attributes-inherited-from-mudaidwithtype","title":"Protected Attributes inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name value_type m_value   = {invalid_id} <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_var_id.h</code></p>"},{"location":"muda/classmuda_1_1_var_view_t/","title":"Class muda::VarViewT","text":"<p>template &lt;bool IsConst, typename T&gt;</p> <p>ClassList &gt; muda &gt; VarViewT</p> <p>Inherits the following classes: muda::ViewBase</p>"},{"location":"muda/classmuda_1_1_var_view_t/#public-types","title":"Public Types","text":"Type Name typedef VarViewT&lt; true, T &gt; ConstView typedef CDense&lt; T &gt; ConstViewer typedef Dense&lt; T &gt; NonConstViewer typedef VarViewT&lt; IsConst, T &gt; ThisView typedef typename std::conditional_t&lt; IsConst, ConstViewer, NonConstViewer &gt; ThisViewer typedef size_t difference_type typedef std::random_access_iterator_tag iterator_category typedef T * pointer typedef T &amp; reference typedef T value_type"},{"location":"muda/classmuda_1_1_var_view_t/#public-types-inherited-from-mudaviewbase","title":"Public Types inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_var_view_t/#public-static-attributes-inherited-from-mudaviewbase","title":"Public Static Attributes inherited from muda::ViewBase","text":"<p>See muda::ViewBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_var_view_t/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC VarViewT ()  MUDA_GENERIC VarViewT (auto_const_t&lt; T &gt; * data)  MUDA_GENERIC VarViewT (const VarViewT &amp; other)  MUDA_GENERIC VarViewT (const VarViewT&lt; OtherIsConst, T &gt; &amp; other)  MUDA_GENERIC ConstView as_const () const MUDA_HOST void copy_from (const T * data) const MUDA_HOST void copy_from (const ConstView &amp; val) const MUDA_HOST void copy_to (T * data) const MUDA_GENERIC ConstViewer cviewer () const MUDA_GENERIC auto_const_t&lt; T &gt; * data () const MUDA_HOST void fill (const T &amp; value) const MUDA_GENERIC reference operator* ()  MUDA_GENERIC auto_const_t&lt; T &gt; &amp; operator[] (int i) const MUDA_GENERIC ThisViewer viewer () const"},{"location":"muda/classmuda_1_1_var_view_t/#protected-types","title":"Protected Types","text":"Type Name typedef typename Base::template auto_const_t&lt; U &gt; auto_const_t"},{"location":"muda/classmuda_1_1_var_view_t/#protected-attributes","title":"Protected Attributes","text":"Type Name auto_const_t&lt; T &gt; * m_data   = = nullptr"},{"location":"muda/classmuda_1_1_var_view_t/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_var_view_t/#typedef-constview","title":"typedef ConstView","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::ConstView =  VarViewT&lt;true, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::ConstViewer =  CDense&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::NonConstViewer =  Dense&lt;T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#typedef-thisview","title":"typedef ThisView","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::ThisView =  VarViewT&lt;IsConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::ThisViewer =  typename std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::difference_type =  size_t;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::iterator_category =  std::random_access_iterator_tag;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#typedef-pointer","title":"typedef pointer","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::pointer =  T*;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#typedef-reference","title":"typedef reference","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::reference =  T&amp;;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::value_type =  T;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_var_view_t/#function-varviewt-25","title":"function VarViewT [2/5]","text":"<pre><code>MUDA_GENERIC muda::VarViewT::VarViewT () \n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-varviewt-35","title":"function VarViewT [3/5]","text":"<pre><code>MUDA_GENERIC muda::VarViewT::VarViewT (\n    auto_const_t&lt; T &gt; * data\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-varviewt-45","title":"function VarViewT [4/5]","text":"<pre><code>MUDA_GENERIC muda::VarViewT::VarViewT (\n    const VarViewT &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-varviewt-55","title":"function VarViewT [5/5]","text":"<pre><code>template&lt;bool OtherIsConst&gt;\nMUDA_GENERIC muda::VarViewT::VarViewT (\n    const VarViewT &lt; OtherIsConst, T &gt; &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-as_const","title":"function as_const","text":"<pre><code>MUDA_GENERIC ConstView muda::VarViewT::as_const () const\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-copy_from-12","title":"function copy_from [1/2]","text":"<pre><code>MUDA_HOST void muda::VarViewT::copy_from (\n    const T * data\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-copy_from-22","title":"function copy_from [2/2]","text":"<pre><code>MUDA_HOST void muda::VarViewT::copy_from (\n    const ConstView &amp; val\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-copy_to","title":"function copy_to","text":"<pre><code>MUDA_HOST void muda::VarViewT::copy_to (\n    T * data\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-cviewer","title":"function cviewer","text":"<pre><code>MUDA_GENERIC ConstViewer muda::VarViewT::cviewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-data","title":"function data","text":"<pre><code>MUDA_GENERIC auto_const_t&lt; T &gt; * muda::VarViewT::data () const\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-fill","title":"function fill","text":"<pre><code>MUDA_HOST void muda::VarViewT::fill (\n    const T &amp; value\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-operator","title":"function operator*","text":"<pre><code>inline MUDA_GENERIC reference muda::VarViewT::operator* () \n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-operator_1","title":"function operator[]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; T &gt; &amp; muda::VarViewT::operator[] (\n    int i\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#function-viewer","title":"function viewer","text":"<pre><code>MUDA_GENERIC ThisViewer muda::VarViewT::viewer () const\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"muda/classmuda_1_1_var_view_t/#typedef-auto_const_t","title":"typedef auto_const_t","text":"<pre><code>using muda::VarViewT&lt; IsConst, T &gt;::auto_const_t =  typename Base::template auto_const_t&lt;U&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_var_view_t/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_var_view_t/#variable-m_data","title":"variable m_data","text":"<pre><code>auto_const_t&lt;T&gt;* muda::VarViewT&lt; IsConst, T &gt;::m_data;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_fwd.h</code></p>"},{"location":"muda/classmuda_1_1_view_base/","title":"Class muda::ViewBase","text":"<p>template &lt;bool IsConst_&gt;</p> <p>ClassList &gt; muda &gt; ViewBase</p>"},{"location":"muda/classmuda_1_1_view_base/#public-types","title":"Public Types","text":"Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_view_base/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_view_base/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1_view_base/#typedef-auto_const_t","title":"typedef auto_const_t","text":"<pre><code>using muda::ViewBase&lt; IsConst_ &gt;::auto_const_t =  std::conditional_t&lt;IsConst, const T, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_view_base/#typedef-non_const_enable_t","title":"typedef non_const_enable_t","text":"<pre><code>using muda::ViewBase&lt; IsConst_ &gt;::non_const_enable_t =  std::enable_if_t&lt;IsNonConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_view_base/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_view_base/#variable-isconst","title":"variable IsConst","text":"<pre><code>bool muda::ViewBase&lt; IsConst_ &gt;::IsConst;\n</code></pre>"},{"location":"muda/classmuda_1_1_view_base/#variable-isnonconst","title":"variable IsNonConst","text":"<pre><code>bool muda::ViewBase&lt; IsConst_ &gt;::IsNonConst;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/view/view_base.h</code></p>"},{"location":"muda/classmuda_1_1_viewer_base/","title":"Class muda::ViewerBase","text":"<p>template &lt;bool IsConst_&gt;</p> <p>ClassList &gt; muda &gt; ViewerBase</p>"},{"location":"muda/classmuda_1_1_viewer_base/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1_viewer_base/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1_viewer_base/#protected-types","title":"Protected Types","text":"Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1_viewer_base/#protected-functions","title":"Protected Functions","text":"Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1_viewer_base/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_viewer_base/#variable-isconst","title":"variable IsConst","text":"<pre><code>bool muda::ViewerBase&lt; IsConst_ &gt;::IsConst;\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#variable-isnonconst","title":"variable IsNonConst","text":"<pre><code>bool muda::ViewerBase&lt; IsConst_ &gt;::IsNonConst;\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1_viewer_base/#function-viewerbase-13","title":"function ViewerBase [1/3]","text":"<pre><code>inline MUDA_GENERIC muda::ViewerBase::ViewerBase () \n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-viewerbase-23","title":"function ViewerBase [2/3]","text":"<pre><code>muda::ViewerBase::ViewerBase (\n    const ViewerBase &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-viewerbase-33","title":"function ViewerBase [3/3]","text":"<pre><code>muda::ViewerBase::ViewerBase (\n    ViewerBase &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-copy_label","title":"function copy_label","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::ViewerBase::copy_label (\n    const ViewerBase &amp; other\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-kernel_file","title":"function kernel_file","text":"<pre><code>inline MUDA_GENERIC const char * muda::ViewerBase::kernel_file () const\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-kernel_line","title":"function kernel_line","text":"<pre><code>inline MUDA_GENERIC int muda::ViewerBase::kernel_line () const\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-kernel_name","title":"function kernel_name","text":"<pre><code>inline MUDA_GENERIC const char * muda::ViewerBase::kernel_name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-name-13","title":"function name [1/3]","text":"<pre><code>inline MUDA_GENERIC const char * muda::ViewerBase::name () const\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-operator","title":"function operator=","text":"<pre><code>ViewerBase &amp; muda::ViewerBase::operator= (\n    const ViewerBase &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-operator_1","title":"function operator=","text":"<pre><code>ViewerBase &amp; muda::ViewerBase::operator= (\n    ViewerBase &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"muda/classmuda_1_1_viewer_base/#typedef-auto_const_t","title":"typedef auto_const_t","text":"<pre><code>using muda::ViewerBase&lt; IsConst_ &gt;::auto_const_t =  std::conditional_t&lt;IsConst, const T, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#typedef-non_const_enable_t","title":"typedef non_const_enable_t","text":"<pre><code>using muda::ViewerBase&lt; IsConst_ &gt;::non_const_enable_t =  std::enable_if_t&lt;IsNonConst, T&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"muda/classmuda_1_1_viewer_base/#function-name-23","title":"function name [2/3]","text":"<pre><code>inline MUDA_INLINE MUDA_HOST void muda::ViewerBase::name (\n    const char * n\n) \n</code></pre>"},{"location":"muda/classmuda_1_1_viewer_base/#function-name-33","title":"function name [3/3]","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC void muda::ViewerBase::name (\n    details::StringPointer pointer\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/viewer/viewer_base.h</code></p>"},{"location":"muda/structmuda_1_1always__false/","title":"Struct muda::always_false","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; always_false</p>"},{"location":"muda/structmuda_1_1always__false/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool value   = = false"},{"location":"muda/structmuda_1_1always__false/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/structmuda_1_1always__false/#variable-value","title":"variable value","text":"<pre><code>bool muda::always_false&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/always.h</code></p>"},{"location":"muda/structmuda_1_1always__true/","title":"Struct muda::always_true","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; always_true</p>"},{"location":"muda/structmuda_1_1always__true/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool value   = = true"},{"location":"muda/structmuda_1_1always__true/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/structmuda_1_1always__true/#variable-value","title":"variable value","text":"<pre><code>bool muda::always_true&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/always.h</code></p>"},{"location":"muda/namespacemuda_1_1config/","title":"Namespace muda::config","text":"<p>Namespace List &gt; muda &gt; config</p>"},{"location":"muda/namespacemuda_1_1config/#public-functions","title":"Public Functions","text":"Type Name bool on (bool cond=false)"},{"location":"muda/namespacemuda_1_1config/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1config/#function-on","title":"function on","text":"<pre><code>bool muda::config::on (\n    bool cond=false\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/muda_config.h</code></p>"},{"location":"muda/classmuda_1_1cuda__error/","title":"Class muda::cuda_error","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; cuda_error</p> <p>Inherits the following classes: muda::exception</p>"},{"location":"muda/classmuda_1_1cuda__error/#public-functions","title":"Public Functions","text":"Type Name cuda_error (T error, std::string error_string, const std::string &amp; file, size_t line, const std::string &amp; func)  T error () const const std::string &amp; error_string () const const std::string &amp; file () const const std::string &amp; func () const size_t line () const"},{"location":"muda/classmuda_1_1cuda__error/#public-functions-inherited-from-mudaexception","title":"Public Functions inherited from muda::exception","text":"<p>See muda::exception</p> Type Name exception (const std::string &amp; msg)  virtual char const * what () const"},{"location":"muda/classmuda_1_1cuda__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1cuda__error/#function-cuda_error","title":"function cuda_error","text":"<pre><code>inline muda::cuda_error::cuda_error (\n    T error,\n    std::string error_string,\n    const std::string &amp; file,\n    size_t line,\n    const std::string &amp; func\n) \n</code></pre>"},{"location":"muda/classmuda_1_1cuda__error/#function-error","title":"function error","text":"<pre><code>inline T muda::cuda_error::error () const\n</code></pre>"},{"location":"muda/classmuda_1_1cuda__error/#function-error_string","title":"function error_string","text":"<pre><code>inline const std::string &amp; muda::cuda_error::error_string () const\n</code></pre>"},{"location":"muda/classmuda_1_1cuda__error/#function-file","title":"function file","text":"<pre><code>inline const std::string &amp; muda::cuda_error::file () const\n</code></pre>"},{"location":"muda/classmuda_1_1cuda__error/#function-func","title":"function func","text":"<pre><code>inline const std::string &amp; muda::cuda_error::func () const\n</code></pre>"},{"location":"muda/classmuda_1_1cuda__error/#function-line","title":"function line","text":"<pre><code>inline size_t muda::cuda_error::line () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/check/check.h</code></p>"},{"location":"muda/namespacemuda_1_1details/","title":"Namespace muda::details","text":"<p>Namespace List &gt; muda &gt; details</p>"},{"location":"muda/namespacemuda_1_1details/#namespaces","title":"Namespaces","text":"Type Name namespace buffer namespace eigen namespace field namespace stream"},{"location":"muda/namespacemuda_1_1details/#classes","title":"Classes","text":"Type Name class ComputeGraphAccessor class HostDeviceStringCache struct LaunchCallable &lt;typename F&gt; class LaunchInfoCache class LocalVarId class LocalVarInfo class LoggerMetaData class LoggerOffset class MatrixFormatConverter &lt;typename T, N&gt; class MatrixFormatConverterBase class MatrixFormatConverterType class ParallelForCallable &lt;typename F&gt; struct SoACopyMap class StringPointer class TempBuffer &lt;typename T&gt;"},{"location":"muda/namespacemuda_1_1details/#public-types","title":"Public Types","text":"Type Name typedef TempBuffer&lt; std::byte &gt; ByteTempBuffer typedef thrust::detail::vector_base&lt; T, Alloc &gt; vector_base"},{"location":"muda/namespacemuda_1_1details/#public-functions","title":"Public Functions","text":"Type Name MUDA_HOST void CUDARTAPI delete_function_object (void * userdata)  MUDA_HOST void CUDARTAPI generic_host_call (void * userdata)  MUDA_GLOBAL void generic_kernel (LaunchCallable&lt; F &gt; f)  MUDA_GLOBAL void generic_kernel_with_range (LaunchCallable&lt; F &gt; f)  MUDA_GLOBAL void grid_stride_loop_kernel (ParallelForCallable&lt; F &gt; f)  MUDA_GLOBAL void parallel_for_kernel (ParallelForCallable&lt; F &gt; f)  void stream_error_callback (cudaStream_t stream, cudaError error, void * userdata)"},{"location":"muda/namespacemuda_1_1details/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/namespacemuda_1_1details/#typedef-bytetempbuffer","title":"typedef ByteTempBuffer","text":"<pre><code>using muda::details::ByteTempBuffer =  TempBuffer&lt;std::byte&gt;;\n</code></pre>"},{"location":"muda/namespacemuda_1_1details/#typedef-vector_base","title":"typedef vector_base","text":"<pre><code>using muda::details::vector_base =  thrust::detail::vector_base&lt;T, Alloc&gt;;\n</code></pre>"},{"location":"muda/namespacemuda_1_1details/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1details/#function-delete_function_object","title":"function delete_function_object","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST void CUDARTAPI muda::details::delete_function_object (\n    void * userdata\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details/#function-generic_host_call","title":"function generic_host_call","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_HOST void CUDARTAPI muda::details::generic_host_call (\n    void * userdata\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details/#function-generic_kernel","title":"function generic_kernel","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_GLOBAL void muda::details::generic_kernel (\n    LaunchCallable &lt; F &gt; f\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details/#function-generic_kernel_with_range","title":"function generic_kernel_with_range","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_GLOBAL void muda::details::generic_kernel_with_range (\n    LaunchCallable &lt; F &gt; f\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details/#function-grid_stride_loop_kernel","title":"function grid_stride_loop_kernel","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_GLOBAL void muda::details::grid_stride_loop_kernel (\n    ParallelForCallable &lt; F &gt; f\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details/#function-parallel_for_kernel","title":"function parallel_for_kernel","text":"<pre><code>template&lt;typename F, typename UserTag&gt;\nMUDA_GLOBAL void muda::details::parallel_for_kernel (\n    ParallelForCallable &lt; F &gt; f\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details/#function-stream_error_callback","title":"function stream_error_callback","text":"<pre><code>inline void muda::details::stream_error_callback (\n    cudaStream_t stream,\n    cudaError error,\n    void * userdata\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/agent/kernel_assign.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/","title":"Class muda::details::ComputeGraphAccessor","text":"<p>ClassList &gt; muda &gt; details &gt; ComputeGraphAccessor</p>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#public-functions","title":"Public Functions","text":"Type Name ComputeGraphAccessor ()  ComputeGraphAccessor (ComputeGraph &amp; graph)  ComputeGraphAccessor (ComputeGraph * graph)  cudaStream_t capture_stream () const void check_allow_node_adding () const void check_allow_var_eval () const const std::pair&lt; std::string, ComputeGraphClosure * &gt; &amp; current_closure () const std::pair&lt; std::string, ComputeGraphClosure * &gt; &amp; current_closure ()  T * current_node ()  const ComputeGraphNodeBase * current_node () const ComputeGraphNodeBase * current_node ()  cudaStream_t current_stream () const bool is_topo_built () const void set_capture_node (cudaGraph_t sub_graph)  void set_event_record_node (cudaEvent_t event)  void set_event_wait_node (cudaEvent_t event)  void set_kernel_node (const S&lt; KernelNodeParms&lt; T &gt; &gt; &amp; kernelParms)  void set_memcpy_node (void * dst, const void * src, size_t size_bytes, cudaMemcpyKind kind)  void set_memcpy_node (const cudaMemcpy3DParms &amp; parms)  void set_memset_node (const cudaMemsetParams &amp; parms)"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-computegraphaccessor-13","title":"function ComputeGraphAccessor [1/3]","text":"<pre><code>muda::details::ComputeGraphAccessor::ComputeGraphAccessor () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-computegraphaccessor-23","title":"function ComputeGraphAccessor [2/3]","text":"<pre><code>muda::details::ComputeGraphAccessor::ComputeGraphAccessor (\n    ComputeGraph &amp; graph\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-computegraphaccessor-33","title":"function ComputeGraphAccessor [3/3]","text":"<pre><code>muda::details::ComputeGraphAccessor::ComputeGraphAccessor (\n    ComputeGraph * graph\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-capture_stream","title":"function capture_stream","text":"<pre><code>cudaStream_t muda::details::ComputeGraphAccessor::capture_stream () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-check_allow_node_adding","title":"function check_allow_node_adding","text":"<pre><code>void muda::details::ComputeGraphAccessor::check_allow_node_adding () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-check_allow_var_eval","title":"function check_allow_var_eval","text":"<pre><code>void muda::details::ComputeGraphAccessor::check_allow_var_eval () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-current_closure-12","title":"function current_closure [1/2]","text":"<pre><code>const std::pair&lt; std::string, ComputeGraphClosure * &gt; &amp; muda::details::ComputeGraphAccessor::current_closure () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-current_closure-22","title":"function current_closure [2/2]","text":"<pre><code>std::pair&lt; std::string, ComputeGraphClosure * &gt; &amp; muda::details::ComputeGraphAccessor::current_closure () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-current_node-13","title":"function current_node [1/3]","text":"<pre><code>template&lt;typename T&gt;\nT * muda::details::ComputeGraphAccessor::current_node () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-current_node-23","title":"function current_node [2/3]","text":"<pre><code>const ComputeGraphNodeBase * muda::details::ComputeGraphAccessor::current_node () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-current_node-33","title":"function current_node [3/3]","text":"<pre><code>ComputeGraphNodeBase * muda::details::ComputeGraphAccessor::current_node () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-current_stream","title":"function current_stream","text":"<pre><code>cudaStream_t muda::details::ComputeGraphAccessor::current_stream () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-is_topo_built","title":"function is_topo_built","text":"<pre><code>bool muda::details::ComputeGraphAccessor::is_topo_built () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-set_capture_node","title":"function set_capture_node","text":"<pre><code>void muda::details::ComputeGraphAccessor::set_capture_node (\n    cudaGraph_t sub_graph\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-set_event_record_node","title":"function set_event_record_node","text":"<pre><code>void muda::details::ComputeGraphAccessor::set_event_record_node (\n    cudaEvent_t event\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-set_event_wait_node","title":"function set_event_wait_node","text":"<pre><code>void muda::details::ComputeGraphAccessor::set_event_wait_node (\n    cudaEvent_t event\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-set_kernel_node","title":"function set_kernel_node","text":"<pre><code>template&lt;typename T&gt;\nvoid muda::details::ComputeGraphAccessor::set_kernel_node (\n    const S&lt; KernelNodeParms &lt; T &gt; &gt; &amp; kernelParms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-set_memcpy_node-12","title":"function set_memcpy_node [1/2]","text":"<pre><code>void muda::details::ComputeGraphAccessor::set_memcpy_node (\n    void * dst,\n    const void * src,\n    size_t size_bytes,\n    cudaMemcpyKind kind\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-set_memcpy_node-22","title":"function set_memcpy_node [2/2]","text":"<pre><code>void muda::details::ComputeGraphAccessor::set_memcpy_node (\n    const cudaMemcpy3DParms &amp; parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#function-set_memset_node","title":"function set_memset_node","text":"<pre><code>void muda::details::ComputeGraphAccessor::set_memset_node (\n    const cudaMemsetParams &amp; parms\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_compute_graph_accessor/#friend-computegraphvarbase","title":"friend ComputeGraphVarBase","text":"<pre><code>class muda::details::ComputeGraphAccessor::ComputeGraphVarBase (\n    muda::ComputeGraphVarBase\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_accessor.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/","title":"Class muda::details::HostDeviceStringCache","text":"<p>ClassList &gt; muda &gt; details &gt; HostDeviceStringCache</p>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/#public-functions","title":"Public Functions","text":"Type Name HostDeviceStringCache (size_t buffer_size=4_M)  HostDeviceStringCache (const HostDeviceStringCache &amp;) = delete HostDeviceStringCache (HostDeviceStringCache &amp;&amp;) = default HostDeviceStringCache &amp; operator= (const HostDeviceStringCache &amp;) = delete HostDeviceStringCache &amp; operator= (HostDeviceStringCache &amp;&amp;) = default StringPointer operator[] (std::string_view s)  ~HostDeviceStringCache ()"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/#function-hostdevicestringcache-13","title":"function HostDeviceStringCache [1/3]","text":"<pre><code>inline muda::details::HostDeviceStringCache::HostDeviceStringCache (\n    size_t buffer_size=4_M\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/#function-hostdevicestringcache-23","title":"function HostDeviceStringCache [2/3]","text":"<pre><code>muda::details::HostDeviceStringCache::HostDeviceStringCache (\n    const HostDeviceStringCache &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/#function-hostdevicestringcache-33","title":"function HostDeviceStringCache [3/3]","text":"<pre><code>muda::details::HostDeviceStringCache::HostDeviceStringCache (\n    HostDeviceStringCache &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/#function-operator","title":"function operator=","text":"<pre><code>HostDeviceStringCache &amp; muda::details::HostDeviceStringCache::operator= (\n    const HostDeviceStringCache &amp;\n) = delete\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/#function-operator_1","title":"function operator=","text":"<pre><code>HostDeviceStringCache &amp; muda::details::HostDeviceStringCache::operator= (\n    HostDeviceStringCache &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/#function-operator_2","title":"function operator[]","text":"<pre><code>inline StringPointer muda::details::HostDeviceStringCache::operator[] (\n    std::string_view s\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache/#function-hostdevicestringcache","title":"function ~HostDeviceStringCache","text":"<pre><code>inline muda::details::HostDeviceStringCache::~HostDeviceStringCache () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/host_device_string_cache.h</code></p>"},{"location":"muda/structmuda_1_1details_1_1_launch_callable/","title":"Struct muda::details::LaunchCallable","text":"<p>template &lt;typename F&gt;</p> <p>ClassList &gt; muda &gt; details &gt; LaunchCallable</p>"},{"location":"muda/structmuda_1_1details_1_1_launch_callable/#public-attributes","title":"Public Attributes","text":"Type Name F callable dim3 dim"},{"location":"muda/structmuda_1_1details_1_1_launch_callable/#public-functions","title":"Public Functions","text":"Type Name LaunchCallable (U &amp;&amp; f, const dim3 &amp; d)"},{"location":"muda/structmuda_1_1details_1_1_launch_callable/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/structmuda_1_1details_1_1_launch_callable/#variable-callable","title":"variable callable","text":"<pre><code>F muda::details::LaunchCallable&lt; F &gt;::callable;\n</code></pre>"},{"location":"muda/structmuda_1_1details_1_1_launch_callable/#variable-dim","title":"variable dim","text":"<pre><code>dim3 muda::details::LaunchCallable&lt; F &gt;::dim;\n</code></pre>"},{"location":"muda/structmuda_1_1details_1_1_launch_callable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1details_1_1_launch_callable/#function-launchcallable","title":"function LaunchCallable","text":"<pre><code>template&lt;typename U&gt;\ninline muda::details::LaunchCallable::LaunchCallable (\n    U &amp;&amp; f,\n    const dim3 &amp; d\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/launch.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/","title":"Class muda::details::LaunchInfoCache","text":"<p>ClassList &gt; muda &gt; details &gt; LaunchInfoCache</p>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#public-static-functions","title":"Public Static Functions","text":"Type Name auto current_capture_name (std::string_view name)  auto current_capture_name ()  auto current_kernel_file (std::string_view name)  auto current_kernel_file ()  auto current_kernel_line (int line)  auto current_kernel_line ()  auto current_kernel_name (std::string_view name)  auto current_kernel_name ()  LaunchInfoCache &amp; instance ()  auto view_name (std::string_view name)"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-current_capture_name-12","title":"function current_capture_name [1/2]","text":"<pre><code>static inline auto muda::details::LaunchInfoCache::current_capture_name (\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-current_capture_name-22","title":"function current_capture_name [2/2]","text":"<pre><code>static inline auto muda::details::LaunchInfoCache::current_capture_name () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-current_kernel_file-12","title":"function current_kernel_file [1/2]","text":"<pre><code>static inline auto muda::details::LaunchInfoCache::current_kernel_file (\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-current_kernel_file-22","title":"function current_kernel_file [2/2]","text":"<pre><code>static inline auto muda::details::LaunchInfoCache::current_kernel_file () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-current_kernel_line-12","title":"function current_kernel_line [1/2]","text":"<pre><code>static inline auto muda::details::LaunchInfoCache::current_kernel_line (\n    int line\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-current_kernel_line-22","title":"function current_kernel_line [2/2]","text":"<pre><code>static inline auto muda::details::LaunchInfoCache::current_kernel_line () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-current_kernel_name-12","title":"function current_kernel_name [1/2]","text":"<pre><code>static inline auto muda::details::LaunchInfoCache::current_kernel_name (\n    std::string_view name\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-current_kernel_name-22","title":"function current_kernel_name [2/2]","text":"<pre><code>static inline auto muda::details::LaunchInfoCache::current_kernel_name () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-instance","title":"function instance","text":"<pre><code>static inline LaunchInfoCache &amp; muda::details::LaunchInfoCache::instance () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_launch_info_cache/#function-view_name","title":"function view_name","text":"<pre><code>static inline auto muda::details::LaunchInfoCache::view_name (\n    std::string_view name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/launch_info_cache.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_local_var_id/","title":"Class muda::details::LocalVarId","text":"<p>ClassList &gt; muda &gt; details &gt; LocalVarId</p> <p>Inherits the following classes: muda::IdWithType</p>"},{"location":"muda/classmuda_1_1details_1_1_local_var_id/#public-types-inherited-from-mudaidwithtype","title":"Public Types inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name typedef T value_type"},{"location":"muda/classmuda_1_1details_1_1_local_var_id/#public-static-attributes-inherited-from-mudaidwithtype","title":"Public Static Attributes inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name auto invalid_id   = = std::numeric_limits&lt;value_type&gt;::max()"},{"location":"muda/classmuda_1_1details_1_1_local_var_id/#public-functions-inherited-from-mudaidwithtype","title":"Public Functions inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name MUDA_GENERIC IdWithType (value_type value) noexcept MUDA_GENERIC IdWithType () noexcept MUDA_GENERIC bool is_valid () noexcept const MUDA_GENERIC value_type value () noexcept const"},{"location":"muda/classmuda_1_1details_1_1_local_var_id/#protected-attributes-inherited-from-mudaidwithtype","title":"Protected Attributes inherited from muda::IdWithType","text":"<p>See muda::IdWithType</p> Type Name value_type m_value   = {invalid_id} <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_local_var_info/","title":"Class muda::details::LocalVarInfo","text":"<p>ClassList &gt; muda &gt; details &gt; LocalVarInfo</p>"},{"location":"muda/classmuda_1_1details_1_1_local_var_info/#public-attributes","title":"Public Attributes","text":"Type Name LocalVarId id   = {} ComputeGraphVarBase * var   = = nullptr"},{"location":"muda/classmuda_1_1details_1_1_local_var_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_local_var_info/#variable-id","title":"variable id","text":"<pre><code>LocalVarId muda::details::LocalVarInfo::id;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_local_var_info/#variable-var","title":"variable var","text":"<pre><code>ComputeGraphVarBase* muda::details::LocalVarInfo::var;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_logger_meta_data/","title":"Class muda::details::LoggerMetaData","text":"<p>ClassList &gt; muda &gt; details &gt; LoggerMetaData</p>"},{"location":"muda/classmuda_1_1details_1_1_logger_meta_data/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t exceeded   = = 0 LoggerFmtArg fmt_arg   = = nullptr uint32_t id   = = ~0 uint32_t offset   = = ~0 uint32_t size   = = ~0 LoggerBasicType type   = = LoggerBasicType::None"},{"location":"muda/classmuda_1_1details_1_1_logger_meta_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_logger_meta_data/#variable-exceeded","title":"variable exceeded","text":"<pre><code>uint16_t muda::details::LoggerMetaData::exceeded;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_logger_meta_data/#variable-fmt_arg","title":"variable fmt_arg","text":"<pre><code>LoggerFmtArg muda::details::LoggerMetaData::fmt_arg;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_logger_meta_data/#variable-id","title":"variable id","text":"<pre><code>uint32_t muda::details::LoggerMetaData::id;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_logger_meta_data/#variable-offset","title":"variable offset","text":"<pre><code>uint32_t muda::details::LoggerMetaData::offset;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_logger_meta_data/#variable-size","title":"variable size","text":"<pre><code>uint32_t muda::details::LoggerMetaData::size;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_logger_meta_data/#variable-type","title":"variable type","text":"<pre><code>LoggerBasicType muda::details::LoggerMetaData::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger_basic_data.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_logger_offset/","title":"Class muda::details::LoggerOffset","text":"<p>ClassList &gt; muda &gt; details &gt; LoggerOffset</p>"},{"location":"muda/classmuda_1_1details_1_1_logger_offset/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t buffer_offset   = = 0 uint32_t exceed_buffer   = = 0 uint32_t exceed_meta_data   = = 0 uint32_t log_id   = = 0 uint32_t meta_data_offset   = = 0"},{"location":"muda/classmuda_1_1details_1_1_logger_offset/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_logger_offset/#variable-buffer_offset","title":"variable buffer_offset","text":"<pre><code>uint32_t muda::details::LoggerOffset::buffer_offset;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_logger_offset/#variable-exceed_buffer","title":"variable exceed_buffer","text":"<pre><code>uint32_t muda::details::LoggerOffset::exceed_buffer;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_logger_offset/#variable-exceed_meta_data","title":"variable exceed_meta_data","text":"<pre><code>uint32_t muda::details::LoggerOffset::exceed_meta_data;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_logger_offset/#variable-log_id","title":"variable log_id","text":"<pre><code>uint32_t muda::details::LoggerOffset::log_id;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_logger_offset/#variable-meta_data_offset","title":"variable meta_data_offset","text":"<pre><code>uint32_t muda::details::LoggerOffset::meta_data_offset;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger_basic_data.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/","title":"Class muda::details::MatrixFormatConverter","text":"<p>template &lt;typename T, int N&gt;</p> <p>ClassList &gt; muda &gt; details &gt; MatrixFormatConverter</p> <p>Inherits the following classes: muda::details::MatrixFormatConverterBase</p>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#public-functions","title":"Public Functions","text":"Type Name MatrixFormatConverter (LinearSystemHandles &amp; handles)  void bsr2csr (cusparseHandle_t handle, int mb, int nb, int blockDim, cusparseMatDescr_t descrA, const T * bsrValA, const int * bsrRowPtrA, const int * bsrColIndA, int nnzb, DeviceCSRMatrix&lt; T &gt; &amp; to, muda::DeviceBuffer&lt; int &gt; &amp; row_offsets, muda::DeviceBuffer&lt; int &gt; &amp; col_indices, muda::DeviceBuffer&lt; T &gt; &amp; values)  void calculate_block_offsets (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceBSRMatrix&lt; T, N &gt; &amp; to)  void convert (const DeviceTripletMatrix&lt; T, N &gt; &amp; from, DeviceBCOOMatrix&lt; T, N &gt; &amp; to)  void convert (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceDenseMatrix&lt; T &gt; &amp; to, bool clear_dense_matrix=true)  void convert (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceCOOMatrix&lt; T &gt; &amp; to)  void convert (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceBSRMatrix&lt; T, N &gt; &amp; to)  void convert (DeviceBCOOMatrix&lt; T, N &gt; &amp;&amp; from, DeviceBSRMatrix&lt; T, N &gt; &amp; to)  void convert (const DeviceDoubletVector&lt; T, N &gt; &amp; from, DeviceBCOOVector&lt; T, N &gt; &amp; to)  void convert (const DeviceBCOOVector&lt; T, N &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  void convert (const DeviceDoubletVector&lt; T, N &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector=true)  void convert (const DeviceBSRMatrix&lt; T, N &gt; &amp; from, DeviceCSRMatrix&lt; T &gt; &amp; to)  void expand_blocks (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceCOOMatrix&lt; T &gt; &amp; to)  void make_unique_blocks (const DeviceTripletMatrix&lt; T, N &gt; &amp; from, DeviceBCOOMatrix&lt; T, N &gt; &amp; to)  void make_unique_indices (const DeviceTripletMatrix&lt; T, N &gt; &amp; from, DeviceBCOOMatrix&lt; T, N &gt; &amp; to)  void make_unique_indices (const DeviceDoubletVector&lt; T, N &gt; &amp; from, DeviceBCOOVector&lt; T, N &gt; &amp; to)  void make_unique_indices_and_blocks (const DeviceTripletMatrix&lt; T, N &gt; &amp; from, DeviceBCOOMatrix&lt; T, N &gt; &amp; to)  void make_unique_segments (const DeviceDoubletVector&lt; T, N &gt; &amp; from, DeviceBCOOVector&lt; T, N &gt; &amp; to)  void merge_sort_indices_and_blocks (const DeviceTripletMatrix&lt; T, N &gt; &amp; from, DeviceBCOOMatrix&lt; T, N &gt; &amp; to)  void merge_sort_indices_and_segments (const DeviceDoubletVector&lt; T, N &gt; &amp; from, DeviceBCOOVector&lt; T, N &gt; &amp; to)  void radix_sort_indices_and_blocks (const DeviceTripletMatrix&lt; T, N &gt; &amp; from, DeviceBCOOMatrix&lt; T, N &gt; &amp; to)  void set_unique_values_to_dense_vector (const DeviceBCOOVector&lt; T, N &gt; &amp; from, DeviceDenseVector&lt; T &gt; &amp; to, bool clear_dense_vector)  void sort_indices_and_values (const DeviceBCOOMatrix&lt; T, N &gt; &amp; from, DeviceCOOMatrix&lt; T &gt; &amp; to)  virtual ~MatrixFormatConverter () = default"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#public-functions-inherited-from-mudadetailsmatrixformatconverterbase","title":"Public Functions inherited from muda::details::MatrixFormatConverterBase","text":"<p>See muda::details::MatrixFormatConverterBase</p> Type Name MatrixFormatConverterBase (LinearSystemHandles &amp; context, cudaDataType_t data_type, int N)  auto cublas () const auto cusolver_dn () const auto cusolver_sp () const auto cusparse () const auto data_type () const auto dim () const void loose_resize (DeviceBuffer&lt; T &gt; &amp; buf, size_t new_size)  virtual ~MatrixFormatConverterBase () = default"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#protected-attributes-inherited-from-mudadetailsmatrixformatconverterbase","title":"Protected Attributes inherited from muda::details::MatrixFormatConverterBase","text":"<p>See muda::details::MatrixFormatConverterBase</p> Type Name int m_N cudaDataType_t m_data_type LinearSystemHandles &amp; m_handles"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-matrixformatconverter","title":"function MatrixFormatConverter","text":"<pre><code>inline muda::details::MatrixFormatConverter::MatrixFormatConverter (\n    LinearSystemHandles &amp; handles\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-bsr2csr","title":"function bsr2csr","text":"<pre><code>inline void muda::details::MatrixFormatConverter::bsr2csr (\n    cusparseHandle_t handle,\n    int mb,\n    int nb,\n    int blockDim,\n    cusparseMatDescr_t descrA,\n    const T * bsrValA,\n    const int * bsrRowPtrA,\n    const int * bsrColIndA,\n    int nnzb,\n    DeviceCSRMatrix &lt; T &gt; &amp; to,\n    muda::DeviceBuffer &lt; int &gt; &amp; row_offsets,\n    muda::DeviceBuffer &lt; int &gt; &amp; col_indices,\n    muda::DeviceBuffer &lt; T &gt; &amp; values\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-calculate_block_offsets","title":"function calculate_block_offsets","text":"<pre><code>inline void muda::details::MatrixFormatConverter::calculate_block_offsets (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceBSRMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-convert-19","title":"function convert [1/9]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::convert (\n    const DeviceTripletMatrix &lt; T, N &gt; &amp; from,\n    DeviceBCOOMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-convert-29","title":"function convert [2/9]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::convert (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceDenseMatrix &lt; T &gt; &amp; to,\n    bool clear_dense_matrix=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-convert-39","title":"function convert [3/9]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::convert (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceCOOMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-convert-49","title":"function convert [4/9]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::convert (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceBSRMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-convert-59","title":"function convert [5/9]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::convert (\n    DeviceBCOOMatrix &lt; T, N &gt; &amp;&amp; from,\n    DeviceBSRMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-convert-69","title":"function convert [6/9]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::convert (\n    const DeviceDoubletVector &lt; T, N &gt; &amp; from,\n    DeviceBCOOVector &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-convert-79","title":"function convert [7/9]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::convert (\n    const DeviceBCOOVector &lt; T, N &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-convert-89","title":"function convert [8/9]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::convert (\n    const DeviceDoubletVector &lt; T, N &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector=true\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-convert-99","title":"function convert [9/9]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::convert (\n    const DeviceBSRMatrix &lt; T, N &gt; &amp; from,\n    DeviceCSRMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-expand_blocks","title":"function expand_blocks","text":"<pre><code>inline void muda::details::MatrixFormatConverter::expand_blocks (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceCOOMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-make_unique_blocks","title":"function make_unique_blocks","text":"<pre><code>inline void muda::details::MatrixFormatConverter::make_unique_blocks (\n    const DeviceTripletMatrix &lt; T, N &gt; &amp; from,\n    DeviceBCOOMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-make_unique_indices-12","title":"function make_unique_indices [1/2]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::make_unique_indices (\n    const DeviceTripletMatrix &lt; T, N &gt; &amp; from,\n    DeviceBCOOMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-make_unique_indices-22","title":"function make_unique_indices [2/2]","text":"<pre><code>inline void muda::details::MatrixFormatConverter::make_unique_indices (\n    const DeviceDoubletVector &lt; T, N &gt; &amp; from,\n    DeviceBCOOVector &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-make_unique_indices_and_blocks","title":"function make_unique_indices_and_blocks","text":"<pre><code>inline void muda::details::MatrixFormatConverter::make_unique_indices_and_blocks (\n    const DeviceTripletMatrix &lt; T, N &gt; &amp; from,\n    DeviceBCOOMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-make_unique_segments","title":"function make_unique_segments","text":"<pre><code>inline void muda::details::MatrixFormatConverter::make_unique_segments (\n    const DeviceDoubletVector &lt; T, N &gt; &amp; from,\n    DeviceBCOOVector &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-merge_sort_indices_and_blocks","title":"function merge_sort_indices_and_blocks","text":"<pre><code>inline void muda::details::MatrixFormatConverter::merge_sort_indices_and_blocks (\n    const DeviceTripletMatrix &lt; T, N &gt; &amp; from,\n    DeviceBCOOMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-merge_sort_indices_and_segments","title":"function merge_sort_indices_and_segments","text":"<pre><code>inline void muda::details::MatrixFormatConverter::merge_sort_indices_and_segments (\n    const DeviceDoubletVector &lt; T, N &gt; &amp; from,\n    DeviceBCOOVector &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-radix_sort_indices_and_blocks","title":"function radix_sort_indices_and_blocks","text":"<pre><code>inline void muda::details::MatrixFormatConverter::radix_sort_indices_and_blocks (\n    const DeviceTripletMatrix &lt; T, N &gt; &amp; from,\n    DeviceBCOOMatrix &lt; T, N &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-set_unique_values_to_dense_vector","title":"function set_unique_values_to_dense_vector","text":"<pre><code>inline void muda::details::MatrixFormatConverter::set_unique_values_to_dense_vector (\n    const DeviceBCOOVector &lt; T, N &gt; &amp; from,\n    DeviceDenseVector &lt; T &gt; &amp; to,\n    bool clear_dense_vector\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-sort_indices_and_values","title":"function sort_indices_and_values","text":"<pre><code>inline void muda::details::MatrixFormatConverter::sort_indices_and_values (\n    const DeviceBCOOMatrix &lt; T, N &gt; &amp; from,\n    DeviceCOOMatrix &lt; T &gt; &amp; to\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter/#function-matrixformatconverter_1","title":"function ~MatrixFormatConverter","text":"<pre><code>virtual muda::details::MatrixFormatConverter::~MatrixFormatConverter () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_bcoo_matrix.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/","title":"Class muda::details::MatrixFormatConverterBase","text":"<p>ClassList &gt; muda &gt; details &gt; MatrixFormatConverterBase</p> <p>Inherited by the following classes: muda::details::MatrixFormatConverter</p>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#public-functions","title":"Public Functions","text":"Type Name MatrixFormatConverterBase (LinearSystemHandles &amp; context, cudaDataType_t data_type, int N)  auto cublas () const auto cusolver_dn () const auto cusolver_sp () const auto cusparse () const auto data_type () const auto dim () const void loose_resize (DeviceBuffer&lt; T &gt; &amp; buf, size_t new_size)  virtual ~MatrixFormatConverterBase () = default"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#protected-attributes","title":"Protected Attributes","text":"Type Name int m_N cudaDataType_t m_data_type LinearSystemHandles &amp; m_handles"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#function-matrixformatconverterbase","title":"function MatrixFormatConverterBase","text":"<pre><code>inline muda::details::MatrixFormatConverterBase::MatrixFormatConverterBase (\n    LinearSystemHandles &amp; context,\n    cudaDataType_t data_type,\n    int N\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#function-cublas","title":"function cublas","text":"<pre><code>inline auto muda::details::MatrixFormatConverterBase::cublas () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#function-cusolver_dn","title":"function cusolver_dn","text":"<pre><code>inline auto muda::details::MatrixFormatConverterBase::cusolver_dn () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#function-cusolver_sp","title":"function cusolver_sp","text":"<pre><code>inline auto muda::details::MatrixFormatConverterBase::cusolver_sp () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#function-cusparse","title":"function cusparse","text":"<pre><code>inline auto muda::details::MatrixFormatConverterBase::cusparse () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#function-data_type","title":"function data_type","text":"<pre><code>inline auto muda::details::MatrixFormatConverterBase::data_type () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#function-dim","title":"function dim","text":"<pre><code>inline auto muda::details::MatrixFormatConverterBase::dim () const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#function-loose_resize","title":"function loose_resize","text":"<pre><code>template&lt;typename T&gt;\ninline void muda::details::MatrixFormatConverterBase::loose_resize (\n    DeviceBuffer &lt; T &gt; &amp; buf,\n    size_t new_size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#function-matrixformatconverterbase_1","title":"function ~MatrixFormatConverterBase","text":"<pre><code>virtual muda::details::MatrixFormatConverterBase::~MatrixFormatConverterBase () = default\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#variable-m_n","title":"variable m_N","text":"<pre><code>int muda::details::MatrixFormatConverterBase::m_N;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#variable-m_data_type","title":"variable m_data_type","text":"<pre><code>cudaDataType_t muda::details::MatrixFormatConverterBase::m_data_type;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_base/#variable-m_handles","title":"variable m_handles","text":"<pre><code>LinearSystemHandles&amp; muda::details::MatrixFormatConverterBase::m_handles;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/matrix_format_converter_impl.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_type/","title":"Class muda::details::MatrixFormatConverterType","text":"<p>ClassList &gt; muda &gt; details &gt; MatrixFormatConverterType</p>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_type/#public-attributes","title":"Public Attributes","text":"Type Name int N cudaDataType_t data_type"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_type/#public-functions","title":"Public Functions","text":"Type Name bool friend operator== (const MatrixFormatConverterType &amp; lhs, const MatrixFormatConverterType &amp; rhs)"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_type/#variable-n","title":"variable N","text":"<pre><code>int muda::details::MatrixFormatConverterType::N;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_type/#variable-data_type","title":"variable data_type","text":"<pre><code>cudaDataType_t muda::details::MatrixFormatConverterType::data_type;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_matrix_format_converter_type/#function-operator","title":"function operator==","text":"<pre><code>inline bool friend muda::details::MatrixFormatConverterType::operator== (\n    const MatrixFormatConverterType &amp; lhs,\n    const MatrixFormatConverterType &amp; rhs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/matrix_format_converter.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_parallel_for_callable/","title":"Class muda::details::ParallelForCallable","text":"<p>template &lt;typename F&gt;</p> <p>ClassList &gt; muda &gt; details &gt; ParallelForCallable</p>"},{"location":"muda/classmuda_1_1details_1_1_parallel_for_callable/#public-attributes","title":"Public Attributes","text":"Type Name F callable int count"},{"location":"muda/classmuda_1_1details_1_1_parallel_for_callable/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC ParallelForCallable (U &amp;&amp; callable, int count)"},{"location":"muda/classmuda_1_1details_1_1_parallel_for_callable/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_parallel_for_callable/#variable-callable","title":"variable callable","text":"<pre><code>F muda::details::ParallelForCallable&lt; F &gt;::callable;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_parallel_for_callable/#variable-count","title":"variable count","text":"<pre><code>int muda::details::ParallelForCallable&lt; F &gt;::count;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_parallel_for_callable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_parallel_for_callable/#function-parallelforcallable","title":"function ParallelForCallable","text":"<pre><code>template&lt;typename U&gt;\ninline MUDA_GENERIC muda::details::ParallelForCallable::ParallelForCallable (\n    U &amp;&amp; callable,\n    int count\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/parallel_for.h</code></p>"},{"location":"muda/structmuda_1_1details_1_1_so_a_copy_map/","title":"Struct muda::details::SoACopyMap","text":"<p>ClassList &gt; muda &gt; details &gt; SoACopyMap</p>"},{"location":"muda/structmuda_1_1details_1_1_so_a_copy_map/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t elem_byte_size uint32_t offset_in_base_struct"},{"location":"muda/structmuda_1_1details_1_1_so_a_copy_map/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/structmuda_1_1details_1_1_so_a_copy_map/#variable-elem_byte_size","title":"variable elem_byte_size","text":"<pre><code>uint32_t muda::details::SoACopyMap::elem_byte_size;\n</code></pre>"},{"location":"muda/structmuda_1_1details_1_1_so_a_copy_map/#variable-offset_in_base_struct","title":"variable offset_in_base_struct","text":"<pre><code>uint32_t muda::details::SoACopyMap::offset_in_base_struct;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/sub_field/soa_sub_field.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_string_pointer/","title":"Class muda::details::StringPointer","text":"<p>ClassList &gt; muda &gt; details &gt; StringPointer</p>"},{"location":"muda/classmuda_1_1details_1_1_string_pointer/#public-attributes","title":"Public Attributes","text":"Type Name char * device_string   = = nullptr char * host_string   = = nullptr unsigned int length   = = 0"},{"location":"muda/classmuda_1_1details_1_1_string_pointer/#public-functions","title":"Public Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC const char * auto_select () const"},{"location":"muda/classmuda_1_1details_1_1_string_pointer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_string_pointer/#variable-device_string","title":"variable device_string","text":"<pre><code>char* muda::details::StringPointer::device_string;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_string_pointer/#variable-host_string","title":"variable host_string","text":"<pre><code>char* muda::details::StringPointer::host_string;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_string_pointer/#variable-length","title":"variable length","text":"<pre><code>unsigned int muda::details::StringPointer::length;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_string_pointer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_string_pointer/#function-auto_select","title":"function auto_select","text":"<pre><code>inline MUDA_INLINE MUDA_GENERIC const char * muda::details::StringPointer::auto_select () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/string_pointer.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/","title":"Class muda::details::TempBuffer","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; details &gt; TempBuffer</p>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#public-functions","title":"Public Functions","text":"Type Name TempBuffer ()  TempBuffer (size_t size)  TempBuffer (TempBuffer &amp;&amp; other) noexcept TempBuffer (const TempBuffer &amp;) noexcept TempBuffer (const std::vector&lt; T &gt; &amp; vec)  auto capacity () noexcept const void copy_from (TempBuffer&lt; T &gt; &amp; other, cudaStream_t stream=nullptr)  void copy_from (const std::vector&lt; T &gt; &amp; vec, cudaStream_t stream=nullptr)  void copy_to (std::vector&lt; T &gt; &amp; vec, cudaStream_t stream=nullptr) const auto data () noexcept const void free () noexcept TempBuffer &amp; operator= (TempBuffer &amp;&amp; other) noexcept TempBuffer &amp; operator= (const TempBuffer &amp;) noexcept TempBuffer &amp; operator= (const std::vector&lt; T &gt; &amp; vec)  void reserve (size_t new_cap, cudaStream_t stream=nullptr)  void resize (size_t size, cudaStream_t stream=nullptr)  auto size () noexcept const ~TempBuffer ()"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-tempbuffer-15","title":"function TempBuffer [1/5]","text":"<pre><code>inline muda::details::TempBuffer::TempBuffer () \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-tempbuffer-25","title":"function TempBuffer [2/5]","text":"<pre><code>inline muda::details::TempBuffer::TempBuffer (\n    size_t size\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-tempbuffer-35","title":"function TempBuffer [3/5]","text":"<pre><code>inline muda::details::TempBuffer::TempBuffer (\n    TempBuffer &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-tempbuffer-45","title":"function TempBuffer [4/5]","text":"<pre><code>inline muda::details::TempBuffer::TempBuffer (\n    const TempBuffer &amp;\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-tempbuffer-55","title":"function TempBuffer [5/5]","text":"<pre><code>inline muda::details::TempBuffer::TempBuffer (\n    const std::vector&lt; T &gt; &amp; vec\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-capacity","title":"function capacity","text":"<pre><code>inline auto muda::details::TempBuffer::capacity () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-copy_from-12","title":"function copy_from [1/2]","text":"<pre><code>inline void muda::details::TempBuffer::copy_from (\n    TempBuffer &lt; T &gt; &amp; other,\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-copy_from-22","title":"function copy_from [2/2]","text":"<pre><code>inline void muda::details::TempBuffer::copy_from (\n    const std::vector&lt; T &gt; &amp; vec,\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-copy_to","title":"function copy_to","text":"<pre><code>inline void muda::details::TempBuffer::copy_to (\n    std::vector&lt; T &gt; &amp; vec,\n    cudaStream_t stream=nullptr\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-data","title":"function data","text":"<pre><code>inline auto muda::details::TempBuffer::data () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-free","title":"function free","text":"<pre><code>inline void muda::details::TempBuffer::free () noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-operator","title":"function operator=","text":"<pre><code>inline TempBuffer &amp; muda::details::TempBuffer::operator= (\n    TempBuffer &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-operator_1","title":"function operator=","text":"<pre><code>inline TempBuffer &amp; muda::details::TempBuffer::operator= (\n    const TempBuffer &amp;\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-operator_2","title":"function operator=","text":"<pre><code>inline TempBuffer &amp; muda::details::TempBuffer::operator= (\n    const std::vector&lt; T &gt; &amp; vec\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-reserve","title":"function reserve","text":"<pre><code>inline void muda::details::TempBuffer::reserve (\n    size_t new_cap,\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-resize","title":"function resize","text":"<pre><code>inline void muda::details::TempBuffer::resize (\n    size_t size,\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-size","title":"function size","text":"<pre><code>inline auto muda::details::TempBuffer::size () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_temp_buffer/#function-tempbuffer","title":"function ~TempBuffer","text":"<pre><code>inline muda::details::TempBuffer::~TempBuffer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/temp_buffer.h</code></p>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/","title":"Namespace muda::details::buffer","text":"<p>Namespace List &gt; muda &gt; details &gt; buffer</p>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#classes","title":"Classes","text":"Type Name class BufferInfoAccessor"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#public-functions","title":"Public Functions","text":"Type Name MUDA_HOST void kernel_assign (cudaStream_t stream, VarView&lt; T &gt; dst, CVarView&lt; T &gt; src)  MUDA_HOST void kernel_assign (int grid_dim, int block_dim, cudaStream_t stream, BufferView&lt; T &gt; dst, CBufferView&lt; T &gt; src)  MUDA_HOST void kernel_assign (int grid_dim, int block_dim, cudaStream_t stream, Buffer2DView&lt; T &gt; dst, CBuffer2DView&lt; T &gt; src)  MUDA_HOST void kernel_assign (int grid_dim, int block_dim, cudaStream_t stream, Buffer3DView&lt; T &gt; dst, CBuffer3DView&lt; T &gt; src)  MUDA_HOST void kernel_construct (cudaStream_t stream, VarView&lt; T &gt; view)  MUDA_HOST void kernel_construct (int grid_dim, int block_dim, cudaStream_t stream, BufferView&lt; T &gt; buffer_view)  MUDA_HOST void kernel_construct (int grid_dim, int block_dim, cudaStream_t stream, Buffer2DView&lt; T &gt; buffer_view)  MUDA_HOST void kernel_construct (int grid_dim, int block_dim, cudaStream_t stream, Buffer3DView&lt; T &gt; buffer_view)  MUDA_HOST void kernel_copy_construct (cudaStream_t stream, VarView&lt; T &gt; dst, CVarView&lt; T &gt; src)  MUDA_HOST void kernel_copy_construct (int grid_dim, int block_dim, cudaStream_t stream, BufferView&lt; T &gt; dst, CBufferView&lt; T &gt; src)  MUDA_HOST void kernel_copy_construct (int grid_dim, int block_dim, cudaStream_t stream, Buffer2DView&lt; T &gt; dst, CBuffer2DView&lt; T &gt; src)  MUDA_HOST void kernel_copy_construct (int grid_dim, int block_dim, cudaStream_t stream, Buffer3DView&lt; T &gt; dst, CBuffer3DView&lt; T &gt; src)  MUDA_HOST void kernel_destruct (cudaStream_t stream, VarView&lt; T &gt; view)  MUDA_HOST void kernel_destruct (int grid_dim, int block_dim, cudaStream_t stream, BufferView&lt; T &gt; buffer_view)  MUDA_HOST void kernel_destruct (int grid_dim, int block_dim, cudaStream_t stream, Buffer2DView&lt; T &gt; buffer_view)  MUDA_HOST void kernel_destruct (int grid_dim, int block_dim, cudaStream_t stream, Buffer3DView&lt; T &gt; buffer_view)  MUDA_HOST void kernel_fill (cudaStream_t stream, VarView&lt; T &gt; dst, const T &amp; val)  MUDA_HOST void kernel_fill (int grid_dim, int block_dim, cudaStream_t stream, BufferView&lt; T &gt; dst, const T &amp; val)  MUDA_HOST void kernel_fill (int grid_dim, int block_dim, cudaStream_t stream, Buffer2DView&lt; T &gt; dst, const T &amp; val)  MUDA_HOST void kernel_fill (int grid_dim, int block_dim, cudaStream_t stream, Buffer3DView&lt; T &gt; dst, const T &amp; val)  MUDA_INLINE bool less (bool b, size_t l, size_t r)  MUDA_INLINE bool less (std::bitset&lt; N &gt; mask, const std::array&lt; size_t, N &gt; &amp; lhs, const std::array&lt; size_t, N &gt; &amp; rhs)  MUDA_INLINE MUDA_HOST BufferView&lt; T &gt; reserve_1d (cudaStream_t stream, size_t size)  MUDA_INLINE MUDA_HOST Buffer2DView&lt; T &gt; reserve_2d (cudaStream_t stream, Extent2D extent)  MUDA_INLINE MUDA_HOST Buffer3DView&lt; T &gt; reserve_3d (cudaStream_t stream, Extent3D extent)  MUDA_INLINE void swap (bool b, size_t &amp; l, size_t &amp; r)  MUDA_INLINE void swap (std::bitset&lt; N &gt; mask, std::array&lt; size_t, N &gt; &amp; lhs, std::array&lt; size_t, N &gt; &amp; rhs)"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_assign","title":"function kernel_assign","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_assign (\n    cudaStream_t stream,\n    VarView &lt; T &gt; dst,\n    CVarView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_assign_1","title":"function kernel_assign","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_assign (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    BufferView &lt; T &gt; dst,\n    CBufferView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_assign_2","title":"function kernel_assign","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_assign (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer2DView &lt; T &gt; dst,\n    CBuffer2DView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_assign_3","title":"function kernel_assign","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_assign (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer3DView &lt; T &gt; dst,\n    CBuffer3DView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_construct","title":"function kernel_construct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_construct (\n    cudaStream_t stream,\n    VarView &lt; T &gt; view\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_construct_1","title":"function kernel_construct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_construct (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    BufferView &lt; T &gt; buffer_view\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_construct_2","title":"function kernel_construct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_construct (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer2DView &lt; T &gt; buffer_view\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_construct_3","title":"function kernel_construct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_construct (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer3DView &lt; T &gt; buffer_view\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_copy_construct","title":"function kernel_copy_construct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_copy_construct (\n    cudaStream_t stream,\n    VarView &lt; T &gt; dst,\n    CVarView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_copy_construct_1","title":"function kernel_copy_construct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_copy_construct (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    BufferView &lt; T &gt; dst,\n    CBufferView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_copy_construct_2","title":"function kernel_copy_construct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_copy_construct (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer2DView &lt; T &gt; dst,\n    CBuffer2DView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_copy_construct_3","title":"function kernel_copy_construct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_copy_construct (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer3DView &lt; T &gt; dst,\n    CBuffer3DView &lt; T &gt; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_destruct","title":"function kernel_destruct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_destruct (\n    cudaStream_t stream,\n    VarView &lt; T &gt; view\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_destruct_1","title":"function kernel_destruct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_destruct (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    BufferView &lt; T &gt; buffer_view\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_destruct_2","title":"function kernel_destruct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_destruct (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer2DView &lt; T &gt; buffer_view\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_destruct_3","title":"function kernel_destruct","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_destruct (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer3DView &lt; T &gt; buffer_view\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_fill","title":"function kernel_fill","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_fill (\n    cudaStream_t stream,\n    VarView &lt; T &gt; dst,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_fill_1","title":"function kernel_fill","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_fill (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    BufferView &lt; T &gt; dst,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_fill_2","title":"function kernel_fill","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_fill (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer2DView &lt; T &gt; dst,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-kernel_fill_3","title":"function kernel_fill","text":"<pre><code>template&lt;typename T&gt;\nMUDA_HOST void muda::details::buffer::kernel_fill (\n    int grid_dim,\n    int block_dim,\n    cudaStream_t stream,\n    Buffer3DView &lt; T &gt; dst,\n    const T &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-less","title":"function less","text":"<pre><code>MUDA_INLINE bool muda::details::buffer::less (\n    bool b,\n    size_t l,\n    size_t r\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-less_1","title":"function less","text":"<pre><code>template&lt;size_t N&gt;\nMUDA_INLINE bool muda::details::buffer::less (\n    std::bitset&lt; N &gt; mask,\n    const std::array&lt; size_t, N &gt; &amp; lhs,\n    const std::array&lt; size_t, N &gt; &amp; rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-reserve_1d","title":"function reserve_1d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_HOST BufferView &lt; T &gt; muda::details::buffer::reserve_1d (\n    cudaStream_t stream,\n    size_t size\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-reserve_2d","title":"function reserve_2d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_HOST Buffer2DView &lt; T &gt; muda::details::buffer::reserve_2d (\n    cudaStream_t stream,\n    Extent2D extent\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-reserve_3d","title":"function reserve_3d","text":"<pre><code>template&lt;typename T&gt;\nMUDA_INLINE MUDA_HOST Buffer3DView &lt; T &gt; muda::details::buffer::reserve_3d (\n    cudaStream_t stream,\n    Extent3D extent\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-swap","title":"function swap","text":"<pre><code>MUDA_INLINE void muda::details::buffer::swap (\n    bool b,\n    size_t &amp; l,\n    size_t &amp; r\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1buffer/#function-swap_1","title":"function swap","text":"<pre><code>template&lt;size_t N&gt;\nMUDA_INLINE void muda::details::buffer::swap (\n    std::bitset&lt; N &gt; mask,\n    std::array&lt; size_t, N &gt; &amp; lhs,\n    std::array&lt; size_t, N &gt; &amp; rhs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/agent/kernel_assign.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1buffer_1_1_buffer_info_accessor/","title":"Class muda::details::buffer::BufferInfoAccessor","text":"<p>ClassList &gt; muda &gt; details &gt; buffer &gt; BufferInfoAccessor</p>"},{"location":"muda/classmuda_1_1details_1_1buffer_1_1_buffer_info_accessor/#public-static-functions","title":"Public Static Functions","text":"Type Name auto cuda_pitched_ptr (BufferView &amp;&amp; b)"},{"location":"muda/classmuda_1_1details_1_1buffer_1_1_buffer_info_accessor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1buffer_1_1_buffer_info_accessor/#function-cuda_pitched_ptr","title":"function cuda_pitched_ptr","text":"<pre><code>template&lt;typename BufferView&gt;\nstatic inline auto muda::details::buffer::BufferInfoAccessor::cuda_pitched_ptr (\n    BufferView &amp;&amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_info_accessor.h</code></p>"},{"location":"muda/namespacemuda_1_1details_1_1eigen/","title":"Namespace muda::details::eigen","text":"<p>Namespace List &gt; muda &gt; details &gt; eigen</p>"},{"location":"muda/namespacemuda_1_1details_1_1eigen/#public-types","title":"Public Types","text":"Type Name union un"},{"location":"muda/namespacemuda_1_1details_1_1eigen/#public-functions","title":"Public Functions","text":"Type Name __device__ __forceinline__ void svd3x3 (float a11, float a12, float a13, float a21, float a22, float a23, float a31, float a32, float a33, float &amp; u11, float &amp; u12, float &amp; u13, float &amp; u21, float &amp; u22, float &amp; u23, float &amp; u31, float &amp; u32, float &amp; u33, float &amp; s11, float &amp; s22, float &amp; s33, float &amp; v11, float &amp; v12, float &amp; v13, float &amp; v21, float &amp; v22, float &amp; v23, float &amp; v31, float &amp; v32, float &amp; v33)"},{"location":"muda/namespacemuda_1_1details_1_1eigen/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/namespacemuda_1_1details_1_1eigen/#union-un","title":"union un","text":""},{"location":"muda/namespacemuda_1_1details_1_1eigen/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1details_1_1eigen/#function-svd3x3","title":"function svd3x3","text":"<pre><code>__device__ __forceinline__ void muda::details::eigen::svd3x3 (\n    float a11,\n    float a12,\n    float a13,\n    float a21,\n    float a22,\n    float a23,\n    float a31,\n    float a32,\n    float a33,\n    float &amp; u11,\n    float &amp; u12,\n    float &amp; u13,\n    float &amp; u21,\n    float &amp; u22,\n    float &amp; u23,\n    float &amp; u31,\n    float &amp; u32,\n    float &amp; u33,\n    float &amp; s11,\n    float &amp; s22,\n    float &amp; s33,\n    float &amp; v11,\n    float &amp; v12,\n    float &amp; v13,\n    float &amp; v21,\n    float &amp; v22,\n    float &amp; v23,\n    float &amp; v31,\n    float &amp; v32,\n    float &amp; v33\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/svd/svd_impl.h</code></p>"},{"location":"muda/unionmuda_1_1details_1_1eigen_1_1un/","title":"Union muda::details::eigen::un","text":"<p>ClassList &gt; muda &gt; details &gt; eigen &gt; un</p>"},{"location":"muda/unionmuda_1_1details_1_1eigen_1_1un/#public-attributes","title":"Public Attributes","text":"Type Name float f unsigned int ui"},{"location":"muda/unionmuda_1_1details_1_1eigen_1_1un/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/unionmuda_1_1details_1_1eigen_1_1un/#variable-f","title":"variable f","text":"<pre><code>float muda::details::eigen::un::f;\n</code></pre>"},{"location":"muda/unionmuda_1_1details_1_1eigen_1_1un/#variable-ui","title":"variable ui","text":"<pre><code>unsigned int muda::details::eigen::un::ui;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/svd/svd_impl.h</code></p>"},{"location":"muda/namespacemuda_1_1details_1_1field/","title":"Namespace muda::details::field","text":"<p>Namespace List &gt; muda &gt; details &gt; field</p>"},{"location":"muda/namespacemuda_1_1details_1_1field/#public-types","title":"Public Types","text":"Type Name typedef Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt; MatStride"},{"location":"muda/namespacemuda_1_1details_1_1field/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC MatStride make_stride (const FieldEntryCore &amp; core)"},{"location":"muda/namespacemuda_1_1details_1_1field/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/namespacemuda_1_1details_1_1field/#typedef-matstride","title":"typedef MatStride","text":"<pre><code>using muda::details::field::MatStride =  Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;;\n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1field/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1details_1_1field/#function-make_stride","title":"function make_stride","text":"<pre><code>template&lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nMUDA_GENERIC MatStride muda::details::field::make_stride (\n    const FieldEntryCore &amp; core\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_viewer.h</code></p>"},{"location":"muda/namespacemuda_1_1details_1_1stream/","title":"Namespace muda::details::stream","text":"<p>Namespace List &gt; muda &gt; details &gt; stream</p>"},{"location":"muda/namespacemuda_1_1details_1_1stream/#public-functions","title":"Public Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC cudaStream_t fire_and_forget ()  MUDA_INLINE MUDA_GENERIC cudaStream_t graph_fire_and_forget ()  MUDA_INLINE MUDA_GENERIC cudaStream_t graph_tail_launch ()  MUDA_INLINE MUDA_GENERIC cudaStream_t tail_launch ()"},{"location":"muda/namespacemuda_1_1details_1_1stream/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1details_1_1stream/#function-fire_and_forget","title":"function fire_and_forget","text":"<pre><code>MUDA_INLINE MUDA_GENERIC cudaStream_t muda::details::stream::fire_and_forget () \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1stream/#function-graph_fire_and_forget","title":"function graph_fire_and_forget","text":"<pre><code>MUDA_INLINE MUDA_GENERIC cudaStream_t muda::details::stream::graph_fire_and_forget () \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1stream/#function-graph_tail_launch","title":"function graph_tail_launch","text":"<pre><code>MUDA_INLINE MUDA_GENERIC cudaStream_t muda::details::stream::graph_tail_launch () \n</code></pre>"},{"location":"muda/namespacemuda_1_1details_1_1stream/#function-tail_launch","title":"function tail_launch","text":"<pre><code>MUDA_INLINE MUDA_GENERIC cudaStream_t muda::details::stream::tail_launch () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/launch/stream_define.h</code></p>"},{"location":"muda/namespacemuda_1_1distance/","title":"Namespace muda::distance","text":"<p>Namespace List &gt; muda &gt; distance</p>"},{"location":"muda/namespacemuda_1_1distance/#public-types","title":"Public Types","text":"Type Name enum unsigned char EdgeEdgeDistanceType enum unsigned char PointEdgeDistanceType enum unsigned char PointPointDistanceType enum unsigned char PointTriangleDistanceType"},{"location":"muda/namespacemuda_1_1distance/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC bool edge_edge_ccd (Eigen::Matrix&lt; T, 3, 1 &gt; ea0, Eigen::Matrix&lt; T, 3, 1 &gt; ea1, Eigen::Matrix&lt; T, 3, 1 &gt; eb0, Eigen::Matrix&lt; T, 3, 1 &gt; eb1, Eigen::Matrix&lt; T, 3, 1 &gt; dea0, Eigen::Matrix&lt; T, 3, 1 &gt; dea1, Eigen::Matrix&lt; T, 3, 1 &gt; deb0, Eigen::Matrix&lt; T, 3, 1 &gt; deb1, T eta, T thickness, int max_iter, T &amp; toc)  MUDA_GENERIC bool edge_edge_ccd_broadphase (const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; ea0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; ea1, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; eb0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; eb1, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dea0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dea1, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; deb0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; deb1, T dist)  MUDA_GENERIC bool edge_edge_cd_broadphase (const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; ea0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; ea1, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; eb0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; eb1, T dist)  MUDA_GENERIC void edge_edge_cross_norm2 (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, T &amp; result)  MUDA_GENERIC void edge_edge_cross_norm2_gradient (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, Eigen::Vector&lt; T, 12 &gt; &amp; grad)  MUDA_GENERIC void edge_edge_cross_norm2_hessian (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, Eigen::Matrix&lt; T, 12, 12 &gt; &amp; Hessian)  MUDA_GENERIC void edge_edge_distance (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, T &amp; dist2)  MUDA_GENERIC void edge_edge_distance_gradient (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, Eigen::Vector&lt; T, 12 &gt; &amp; grad)  MUDA_GENERIC void edge_edge_distance_hessian (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, Eigen::Matrix&lt; T, 12, 12 &gt; &amp; Hessian)  MUDA_GENERIC EdgeEdgeDistanceType edge_edge_distance_type (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1)  MUDA_GENERIC void edge_edge_distance_unclassified (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, T &amp; dist2)  MUDA_GENERIC void edge_edge_mollifier (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, T eps_x, T &amp; e)  MUDA_GENERIC void edge_edge_mollifier_gradient (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, T eps_x, Eigen::Vector&lt; T, 12 &gt; &amp; g)  MUDA_GENERIC void edge_edge_mollifier_hessian (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1, T eps_x, Eigen::Matrix&lt; T, 12, 12 &gt; &amp; H)  MUDA_GENERIC void edge_edge_mollifier_threshold (const Eigen::Vector&lt; T, 3 &gt; &amp; ea0_rest, const Eigen::Vector&lt; T, 3 &gt; &amp; ea1_rest, const Eigen::Vector&lt; T, 3 &gt; &amp; eb0_rest, const Eigen::Vector&lt; T, 3 &gt; &amp; eb1_rest, T &amp; eps_x)  MUDA_GENERIC bool point_edge_ccd (const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x0, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x1, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x2, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; d0, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; d1, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; d2, T eta, T &amp; toc)  MUDA_GENERIC bool point_edge_ccd (Eigen::Matrix&lt; T, 3, 1 &gt; p, Eigen::Matrix&lt; T, 3, 1 &gt; e0, Eigen::Matrix&lt; T, 3, 1 &gt; e1, Eigen::Matrix&lt; T, 3, 1 &gt; dp, Eigen::Matrix&lt; T, 3, 1 &gt; de0, Eigen::Matrix&lt; T, 3, 1 &gt; de1, T eta, T thickness, int max_iter, T &amp; toc)  MUDA_GENERIC bool point_edge_ccd_broadphase (const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; p, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; e0, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; e1, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; dp, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; de0, const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; de1, T dist)  MUDA_GENERIC bool point_edge_ccd_broadphase (const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; e0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; e1, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dp, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; de0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; de1, T dist)  MUDA_GENERIC bool point_edge_cd_broadphase (const Eigen::Matrix&lt; T, dim, 1 &gt; &amp; x0, const Eigen::Matrix&lt; T, dim, 1 &gt; &amp; x1, const Eigen::Matrix&lt; T, dim, 1 &gt; &amp; x2, T dist)  MUDA_GENERIC void point_edge_distance (const Eigen::Vector&lt; T, dim &gt; &amp; p, const Eigen::Vector&lt; T, dim &gt; &amp; e0, const Eigen::Vector&lt; T, dim &gt; &amp; e1, T &amp; dist2)  MUDA_GENERIC void point_edge_distance_gradient (const Eigen::Vector&lt; T, dim &gt; &amp; p, const Eigen::Vector&lt; T, dim &gt; &amp; e0, const Eigen::Vector&lt; T, dim &gt; &amp; e1, Eigen::Vector&lt; T, dim *3 &gt; &amp; grad)  MUDA_GENERIC void point_edge_distance_hessian (const Eigen::Vector&lt; T, dim &gt; &amp; p, const Eigen::Vector&lt; T, dim &gt; &amp; e0, const Eigen::Vector&lt; T, dim &gt; &amp; e1, Eigen::Matrix&lt; T, dim *3, dim *3 &gt; &amp; Hessian)  MUDA_GENERIC PointEdgeDistanceType point_edge_distance_type (const Eigen::Vector&lt; T, dim &gt; &amp; p, const Eigen::Vector&lt; T, dim &gt; &amp; e0, const Eigen::Vector&lt; T, dim &gt; &amp; e1)  MUDA_GENERIC PointEdgeDistanceType point_edge_distance_type (const Eigen::Vector&lt; T, dim &gt; &amp; p, const Eigen::Vector&lt; T, dim &gt; &amp; e0, const Eigen::Vector&lt; T, dim &gt; &amp; e1, T &amp; ratio)  MUDA_GENERIC void point_edge_distance_unclassified (const Eigen::Vector&lt; T, 3 &gt; &amp; p, const Eigen::Vector&lt; T, 3 &gt; &amp; e0, const Eigen::Vector&lt; T, 3 &gt; &amp; e1, T &amp; dist2)  MUDA_GENERIC bool point_point_ccd (Eigen::Matrix&lt; T, 3, 1 &gt; p0, Eigen::Matrix&lt; T, 3, 1 &gt; p1, Eigen::Matrix&lt; T, 3, 1 &gt; dp0, Eigen::Matrix&lt; T, 3, 1 &gt; dp1, T eta, T thickness, int max_iter, T &amp; toc)  MUDA_GENERIC bool point_point_ccd_broadphase (const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p1, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dp0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dp1, T dist)  MUDA_GENERIC void point_point_distance (const Eigen::Vector&lt; T, dim &gt; &amp; a, const Eigen::Vector&lt; T, dim &gt; &amp; b, T &amp; dist2)  MUDA_GENERIC void point_point_distance_gradient (const Eigen::Vector&lt; T, dim &gt; &amp; a, const Eigen::Vector&lt; T, dim &gt; &amp; b, Eigen::Vector&lt; T, dim *2 &gt; &amp; grad)  MUDA_GENERIC void point_point_distance_hessian (const Eigen::Vector&lt; T, dim &gt; &amp; a, const Eigen::Vector&lt; T, dim &gt; &amp; b, Eigen::Matrix&lt; T, dim *2, dim *2 &gt; &amp; Hessian)  MUDA_GENERIC PointPointDistanceType point_point_distance_type (const Eigen::Vector&lt; T, dim &gt; &amp; p0, const Eigen::Vector&lt; T, dim &gt; &amp; p1)  MUDA_GENERIC void point_point_distance_unclassified (const Eigen::Vector&lt; T, 3 &gt; &amp; p0, const Eigen::Vector&lt; T, 3 &gt; &amp; p1, T &amp; dist2)  MUDA_GENERIC bool point_triangle_ccd (Eigen::Matrix&lt; T, 3, 1 &gt; p, Eigen::Matrix&lt; T, 3, 1 &gt; t0, Eigen::Matrix&lt; T, 3, 1 &gt; t1, Eigen::Matrix&lt; T, 3, 1 &gt; t2, Eigen::Matrix&lt; T, 3, 1 &gt; dp, Eigen::Matrix&lt; T, 3, 1 &gt; dt0, Eigen::Matrix&lt; T, 3, 1 &gt; dt1, Eigen::Matrix&lt; T, 3, 1 &gt; dt2, T eta, T thickness, int max_iter, T &amp; toc)  MUDA_GENERIC bool point_triangle_ccd_broadphase (const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t1, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t2, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dp, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dt0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dt1, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dt2, T dist)  MUDA_GENERIC bool point_triangle_cd_broadphase (const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t0, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t1, const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t2, T dist)  MUDA_GENERIC void point_triangle_distance (const Eigen::Vector&lt; T, 3 &gt; &amp; p, const Eigen::Vector&lt; T, 3 &gt; &amp; t0, const Eigen::Vector&lt; T, 3 &gt; &amp; t1, const Eigen::Vector&lt; T, 3 &gt; &amp; t2, T &amp; dist2)  MUDA_GENERIC void point_triangle_distance_gradient (const Eigen::Vector&lt; T, 3 &gt; &amp; p, const Eigen::Vector&lt; T, 3 &gt; &amp; t0, const Eigen::Vector&lt; T, 3 &gt; &amp; t1, const Eigen::Vector&lt; T, 3 &gt; &amp; t2, Eigen::Vector&lt; T, 12 &gt; &amp; grad)  MUDA_GENERIC void point_triangle_distance_hessian (const Eigen::Vector&lt; T, 3 &gt; &amp; p, const Eigen::Vector&lt; T, 3 &gt; &amp; t0, const Eigen::Vector&lt; T, 3 &gt; &amp; t1, const Eigen::Vector&lt; T, 3 &gt; &amp; t2, Eigen::Matrix&lt; T, 12, 12 &gt; &amp; Hessian)  MUDA_GENERIC PointTriangleDistanceType point_triangle_distance_type (const Eigen::Vector&lt; T, 3 &gt; &amp; p, const Eigen::Vector&lt; T, 3 &gt; &amp; t0, const Eigen::Vector&lt; T, 3 &gt; &amp; t1, const Eigen::Vector&lt; T, 3 &gt; &amp; t2)  MUDA_GENERIC void point_triangle_distance_unclassified (const Eigen::Vector&lt; T, 3 &gt; &amp; p, const Eigen::Vector&lt; T, 3 &gt; &amp; t0, const Eigen::Vector&lt; T, 3 &gt; &amp; t1, const Eigen::Vector&lt; T, 3 &gt; &amp; t2, T &amp; dist2)"},{"location":"muda/namespacemuda_1_1distance/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/namespacemuda_1_1distance/#enum-edgeedgedistancetype","title":"enum EdgeEdgeDistanceType","text":"<pre><code>enum muda::distance::EdgeEdgeDistanceType {\n    PP_Ea0Eb0 = 0,\n    PP_Ea0Eb1 = 1,\n    PE_Ea0Eb0Eb1 = 2,\n    PP_Ea1Eb0 = 3,\n    PP_Ea1Eb1 = 4,\n    PE_Ea1Eb0Eb1 = 5,\n    PE_Eb0Ea0Ea1 = 6,\n    PE_Eb1Ea0Ea1 = 7,\n    EE = 8\n};\n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#enum-pointedgedistancetype","title":"enum PointEdgeDistanceType","text":"<pre><code>enum muda::distance::PointEdgeDistanceType {\n    PP_PE0 = 0,\n    PP_PE1 = 1,\n    PE = 2\n};\n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#enum-pointpointdistancetype","title":"enum PointPointDistanceType","text":"<pre><code>enum muda::distance::PointPointDistanceType {\n    PP = 0\n};\n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#enum-pointtriangledistancetype","title":"enum PointTriangleDistanceType","text":"<pre><code>enum muda::distance::PointTriangleDistanceType {\n    PP_PT0 = 0,\n    PP_PT1 = 1,\n    PP_PT2 = 2,\n    PE_PT0T1 = 3,\n    PE_PT1T2 = 4,\n    PE_PT2T0 = 5,\n    PT = 6\n};\n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_ccd","title":"function edge_edge_ccd","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::edge_edge_ccd (\n    Eigen::Matrix&lt; T, 3, 1 &gt; ea0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; ea1,\n    Eigen::Matrix&lt; T, 3, 1 &gt; eb0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; eb1,\n    Eigen::Matrix&lt; T, 3, 1 &gt; dea0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; dea1,\n    Eigen::Matrix&lt; T, 3, 1 &gt; deb0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; deb1,\n    T eta,\n    T thickness,\n    int max_iter,\n    T &amp; toc\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_ccd_broadphase","title":"function edge_edge_ccd_broadphase","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::edge_edge_ccd_broadphase (\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; ea0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; ea1,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; eb0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; eb1,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dea0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dea1,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; deb0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; deb1,\n    T dist\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_cd_broadphase","title":"function edge_edge_cd_broadphase","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::edge_edge_cd_broadphase (\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; ea0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; ea1,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; eb0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; eb1,\n    T dist\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_cross_norm2","title":"function edge_edge_cross_norm2","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_cross_norm2 (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    T &amp; result\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_cross_norm2_gradient","title":"function edge_edge_cross_norm2_gradient","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_cross_norm2_gradient (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    Eigen::Vector&lt; T, 12 &gt; &amp; grad\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_cross_norm2_hessian","title":"function edge_edge_cross_norm2_hessian","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_cross_norm2_hessian (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    Eigen::Matrix&lt; T, 12, 12 &gt; &amp; Hessian\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_distance","title":"function edge_edge_distance","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_distance (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    T &amp; dist2\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_distance_gradient","title":"function edge_edge_distance_gradient","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_distance_gradient (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    Eigen::Vector&lt; T, 12 &gt; &amp; grad\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_distance_hessian","title":"function edge_edge_distance_hessian","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_distance_hessian (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    Eigen::Matrix&lt; T, 12, 12 &gt; &amp; Hessian\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_distance_type","title":"function edge_edge_distance_type","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC EdgeEdgeDistanceType muda::distance::edge_edge_distance_type (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_distance_unclassified","title":"function edge_edge_distance_unclassified","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_distance_unclassified (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    T &amp; dist2\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_mollifier","title":"function edge_edge_mollifier","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_mollifier (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    T eps_x,\n    T &amp; e\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_mollifier_gradient","title":"function edge_edge_mollifier_gradient","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_mollifier_gradient (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    T eps_x,\n    Eigen::Vector&lt; T, 12 &gt; &amp; g\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_mollifier_hessian","title":"function edge_edge_mollifier_hessian","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_mollifier_hessian (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1,\n    T eps_x,\n    Eigen::Matrix&lt; T, 12, 12 &gt; &amp; H\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-edge_edge_mollifier_threshold","title":"function edge_edge_mollifier_threshold","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::edge_edge_mollifier_threshold (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea0_rest,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; ea1_rest,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb0_rest,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; eb1_rest,\n    T &amp; eps_x\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_ccd","title":"function point_edge_ccd","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::point_edge_ccd (\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x0,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x1,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x2,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; d0,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; d1,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; d2,\n    T eta,\n    T &amp; toc\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_ccd_1","title":"function point_edge_ccd","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::point_edge_ccd (\n    Eigen::Matrix&lt; T, 3, 1 &gt; p,\n    Eigen::Matrix&lt; T, 3, 1 &gt; e0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; e1,\n    Eigen::Matrix&lt; T, 3, 1 &gt; dp,\n    Eigen::Matrix&lt; T, 3, 1 &gt; de0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; de1,\n    T eta,\n    T thickness,\n    int max_iter,\n    T &amp; toc\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_ccd_broadphase","title":"function point_edge_ccd_broadphase","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::point_edge_ccd_broadphase (\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; p,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; e0,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; e1,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; dp,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; de0,\n    const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; de1,\n    T dist\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_ccd_broadphase_1","title":"function point_edge_ccd_broadphase","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::point_edge_ccd_broadphase (\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; e0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; e1,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dp,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; de0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; de1,\n    T dist\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_cd_broadphase","title":"function point_edge_cd_broadphase","text":"<pre><code>template&lt;typename T, int dim&gt;\nMUDA_GENERIC bool muda::distance::point_edge_cd_broadphase (\n    const Eigen::Matrix&lt; T, dim, 1 &gt; &amp; x0,\n    const Eigen::Matrix&lt; T, dim, 1 &gt; &amp; x1,\n    const Eigen::Matrix&lt; T, dim, 1 &gt; &amp; x2,\n    T dist\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_distance","title":"function point_edge_distance","text":"<pre><code>template&lt;class T, int dim&gt;\nMUDA_GENERIC void muda::distance::point_edge_distance (\n    const Eigen::Vector&lt; T, dim &gt; &amp; p,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e0,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e1,\n    T &amp; dist2\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_distance_gradient","title":"function point_edge_distance_gradient","text":"<pre><code>template&lt;class T, int dim&gt;\nMUDA_GENERIC void muda::distance::point_edge_distance_gradient (\n    const Eigen::Vector&lt; T, dim &gt; &amp; p,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e0,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e1,\n    Eigen::Vector&lt; T, dim *3 &gt; &amp; grad\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_distance_hessian","title":"function point_edge_distance_hessian","text":"<pre><code>template&lt;class T, int dim&gt;\nMUDA_GENERIC void muda::distance::point_edge_distance_hessian (\n    const Eigen::Vector&lt; T, dim &gt; &amp; p,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e0,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e1,\n    Eigen::Matrix&lt; T, dim *3, dim *3 &gt; &amp; Hessian\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_distance_type","title":"function point_edge_distance_type","text":"<pre><code>template&lt;class T, int dim&gt;\nMUDA_GENERIC PointEdgeDistanceType muda::distance::point_edge_distance_type (\n    const Eigen::Vector&lt; T, dim &gt; &amp; p,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e0,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e1\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_distance_type_1","title":"function point_edge_distance_type","text":"<pre><code>template&lt;class T, int dim&gt;\nMUDA_GENERIC PointEdgeDistanceType muda::distance::point_edge_distance_type (\n    const Eigen::Vector&lt; T, dim &gt; &amp; p,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e0,\n    const Eigen::Vector&lt; T, dim &gt; &amp; e1,\n    T &amp; ratio\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_edge_distance_unclassified","title":"function point_edge_distance_unclassified","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::point_edge_distance_unclassified (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; p,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; e0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; e1,\n    T &amp; dist2\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_point_ccd","title":"function point_point_ccd","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::point_point_ccd (\n    Eigen::Matrix&lt; T, 3, 1 &gt; p0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; p1,\n    Eigen::Matrix&lt; T, 3, 1 &gt; dp0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; dp1,\n    T eta,\n    T thickness,\n    int max_iter,\n    T &amp; toc\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_point_ccd_broadphase","title":"function point_point_ccd_broadphase","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::point_point_ccd_broadphase (\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p1,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dp0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dp1,\n    T dist\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_point_distance","title":"function point_point_distance","text":"<pre><code>template&lt;class T, int dim&gt;\nMUDA_GENERIC void muda::distance::point_point_distance (\n    const Eigen::Vector&lt; T, dim &gt; &amp; a,\n    const Eigen::Vector&lt; T, dim &gt; &amp; b,\n    T &amp; dist2\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_point_distance_gradient","title":"function point_point_distance_gradient","text":"<pre><code>template&lt;class T, int dim&gt;\nMUDA_GENERIC void muda::distance::point_point_distance_gradient (\n    const Eigen::Vector&lt; T, dim &gt; &amp; a,\n    const Eigen::Vector&lt; T, dim &gt; &amp; b,\n    Eigen::Vector&lt; T, dim *2 &gt; &amp; grad\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_point_distance_hessian","title":"function point_point_distance_hessian","text":"<pre><code>template&lt;class T, int dim&gt;\nMUDA_GENERIC void muda::distance::point_point_distance_hessian (\n    const Eigen::Vector&lt; T, dim &gt; &amp; a,\n    const Eigen::Vector&lt; T, dim &gt; &amp; b,\n    Eigen::Matrix&lt; T, dim *2, dim *2 &gt; &amp; Hessian\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_point_distance_type","title":"function point_point_distance_type","text":"<pre><code>template&lt;class T, int dim&gt;\nMUDA_GENERIC PointPointDistanceType muda::distance::point_point_distance_type (\n    const Eigen::Vector&lt; T, dim &gt; &amp; p0,\n    const Eigen::Vector&lt; T, dim &gt; &amp; p1\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_point_distance_unclassified","title":"function point_point_distance_unclassified","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::point_point_distance_unclassified (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; p0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; p1,\n    T &amp; dist2\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_triangle_ccd","title":"function point_triangle_ccd","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::point_triangle_ccd (\n    Eigen::Matrix&lt; T, 3, 1 &gt; p,\n    Eigen::Matrix&lt; T, 3, 1 &gt; t0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; t1,\n    Eigen::Matrix&lt; T, 3, 1 &gt; t2,\n    Eigen::Matrix&lt; T, 3, 1 &gt; dp,\n    Eigen::Matrix&lt; T, 3, 1 &gt; dt0,\n    Eigen::Matrix&lt; T, 3, 1 &gt; dt1,\n    Eigen::Matrix&lt; T, 3, 1 &gt; dt2,\n    T eta,\n    T thickness,\n    int max_iter,\n    T &amp; toc\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_triangle_ccd_broadphase","title":"function point_triangle_ccd_broadphase","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::point_triangle_ccd_broadphase (\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t1,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t2,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dp,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dt0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dt1,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; dt2,\n    T dist\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_triangle_cd_broadphase","title":"function point_triangle_cd_broadphase","text":"<pre><code>template&lt;typename T&gt;\nMUDA_GENERIC bool muda::distance::point_triangle_cd_broadphase (\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; p,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t0,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t1,\n    const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; t2,\n    T dist\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_triangle_distance","title":"function point_triangle_distance","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::point_triangle_distance (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; p,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t2,\n    T &amp; dist2\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_triangle_distance_gradient","title":"function point_triangle_distance_gradient","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::point_triangle_distance_gradient (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; p,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t2,\n    Eigen::Vector&lt; T, 12 &gt; &amp; grad\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_triangle_distance_hessian","title":"function point_triangle_distance_hessian","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::point_triangle_distance_hessian (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; p,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t2,\n    Eigen::Matrix&lt; T, 12, 12 &gt; &amp; Hessian\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_triangle_distance_type","title":"function point_triangle_distance_type","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC PointTriangleDistanceType muda::distance::point_triangle_distance_type (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; p,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t2\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1distance/#function-point_triangle_distance_unclassified","title":"function point_triangle_distance_unclassified","text":"<pre><code>template&lt;class T&gt;\nMUDA_GENERIC void muda::distance::point_triangle_distance_unclassified (\n    const Eigen::Vector&lt; T, 3 &gt; &amp; p,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t0,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t1,\n    const Eigen::Vector&lt; T, 3 &gt; &amp; t2,\n    T &amp; dist2\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/ccd.h</code></p>"},{"location":"muda/namespacemuda_1_1eigen/","title":"Namespace muda::eigen","text":"<p>Namespace List &gt; muda &gt; eigen</p>"},{"location":"muda/namespacemuda_1_1eigen/#classes","title":"Classes","text":"Type Name struct AnalyticalInverse struct GaussEliminationInverse"},{"location":"muda/namespacemuda_1_1eigen/#public-functions","title":"Public Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; float, 2, 1 &gt; &gt; as_eigen (float2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; float, 2, 1 &gt; &gt; as_eigen (const float2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; float, 3, 1 &gt; &gt; as_eigen (float3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; float, 3, 1 &gt; &gt; as_eigen (const float3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; float, 4, 1 &gt; &gt; as_eigen (float4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; float, 4, 1 &gt; &gt; as_eigen (const float4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; double, 2, 1 &gt; &gt; as_eigen (double2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; double, 2, 1 &gt; &gt; as_eigen (const double2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; double, 3, 1 &gt; &gt; as_eigen (double3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; double, 3, 1 &gt; &gt; as_eigen (const double3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; double, 4, 1 &gt; &gt; as_eigen (double4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; double, 4, 1 &gt; &gt; as_eigen (const double4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; int, 2, 1 &gt; &gt; as_eigen (int2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; int, 2, 1 &gt; &gt; as_eigen (const int2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; int, 3, 1 &gt; &gt; as_eigen (int3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; int, 3, 1 &gt; &gt; as_eigen (const int3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; int, 4, 1 &gt; &gt; as_eigen (int4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; int, 4, 1 &gt; &gt; as_eigen (const int4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned int, 2, 1 &gt; &gt; as_eigen (uint2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned int, 2, 1 &gt; &gt; as_eigen (const uint2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned int, 3, 1 &gt; &gt; as_eigen (uint3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned int, 3, 1 &gt; &gt; as_eigen (const uint3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned int, 4, 1 &gt; &gt; as_eigen (uint4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned int, 4, 1 &gt; &gt; as_eigen (const uint4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; short, 2, 1 &gt; &gt; as_eigen (short2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; short, 2, 1 &gt; &gt; as_eigen (const short2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; short, 3, 1 &gt; &gt; as_eigen (short3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; short, 3, 1 &gt; &gt; as_eigen (const short3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; short, 4, 1 &gt; &gt; as_eigen (short4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; short, 4, 1 &gt; &gt; as_eigen (const short4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned short, 2, 1 &gt; &gt; as_eigen (ushort2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned short, 2, 1 &gt; &gt; as_eigen (const ushort2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned short, 3, 1 &gt; &gt; as_eigen (ushort3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned short, 3, 1 &gt; &gt; as_eigen (const ushort3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned short, 4, 1 &gt; &gt; as_eigen (ushort4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned short, 4, 1 &gt; &gt; as_eigen (const ushort4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; char, 2, 1 &gt; &gt; as_eigen (char2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; char, 2, 1 &gt; &gt; as_eigen (const char2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; char, 3, 1 &gt; &gt; as_eigen (char3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; char, 3, 1 &gt; &gt; as_eigen (const char3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; char, 4, 1 &gt; &gt; as_eigen (char4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; char, 4, 1 &gt; &gt; as_eigen (const char4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned char, 2, 1 &gt; &gt; as_eigen (uchar2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned char, 2, 1 &gt; &gt; as_eigen (const uchar2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned char, 3, 1 &gt; &gt; as_eigen (uchar3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned char, 3, 1 &gt; &gt; as_eigen (const uchar3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned char, 4, 1 &gt; &gt; as_eigen (uchar4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned char, 4, 1 &gt; &gt; as_eigen (const uchar4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long int, 2, 1 &gt; &gt; as_eigen (long2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long int, 2, 1 &gt; &gt; as_eigen (const long2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long int, 3, 1 &gt; &gt; as_eigen (long3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long int, 3, 1 &gt; &gt; as_eigen (const long3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long int, 4, 1 &gt; &gt; as_eigen (long4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long int, 4, 1 &gt; &gt; as_eigen (const long4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long int, 2, 1 &gt; &gt; as_eigen (ulong2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long int, 2, 1 &gt; &gt; as_eigen (const ulong2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long int, 3, 1 &gt; &gt; as_eigen (ulong3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long int, 3, 1 &gt; &gt; as_eigen (const ulong3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long int, 4, 1 &gt; &gt; as_eigen (ulong4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long int, 4, 1 &gt; &gt; as_eigen (const ulong4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long long int, 2, 1 &gt; &gt; as_eigen (longlong2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long long int, 2, 1 &gt; &gt; as_eigen (const longlong2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long long int, 3, 1 &gt; &gt; as_eigen (longlong3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long long int, 3, 1 &gt; &gt; as_eigen (const longlong3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long long int, 4, 1 &gt; &gt; as_eigen (longlong4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long long int, 4, 1 &gt; &gt; as_eigen (const longlong4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long long int, 2, 1 &gt; &gt; as_eigen (ulonglong2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long long int, 2, 1 &gt; &gt; as_eigen (const ulonglong2 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long long int, 3, 1 &gt; &gt; as_eigen (ulonglong3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long long int, 3, 1 &gt; &gt; as_eigen (const ulonglong3 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long long int, 4, 1 &gt; &gt; as_eigen (ulonglong4 &amp; val)  MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long long int, 4, 1 &gt; &gt; as_eigen (const ulonglong4 &amp; val)  MUDA_GENERIC Eigen::Matrix&lt; T, M, N &gt; atomic_add (Eigen::Matrix&lt; T, M, N &gt; &amp; dst, const Eigen::Matrix&lt; T, M, N &gt; &amp; src)  MUDA_GENERIC Eigen::Matrix&lt; T, M, N &gt; atomic_add (Eigen::Map&lt; Eigen::Matrix&lt; T, M, N &gt; &gt; &amp; dst, const Eigen::Matrix&lt; T, M, N &gt; &amp; src)  MUDA_GENERIC void evd (const Eigen::Matrix&lt; T, N, N &gt; &amp; M, Eigen::Vector&lt; T, N &gt; &amp; eigen_values, Eigen::Matrix&lt; T, N, N &gt; &amp; eigen_vectors)  MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, N, N &gt; inverse (const Eigen::Matrix&lt; T, N, N &gt; &amp; m)  MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 2, 2 &gt; inverse (const Eigen::Matrix&lt; T, 2, 2 &gt; &amp; m)  MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 3, 3 &gt; inverse (const Eigen::Matrix&lt; T, 3, 3 &gt; &amp; m)  MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 4, 4 &gt; inverse (const Eigen::Matrix&lt; T, 4, 4 &gt; &amp; m)  MUDA_GENERIC void pd (const Eigen::Matrix&lt; float, 3, 3 &gt; &amp; F, Eigen::Matrix&lt; float, 3, 3 &gt; &amp; R, Eigen::Matrix&lt; float, 3, 3 &gt; &amp; S)  MUDA_GENERIC void pd (const Eigen::Matrix&lt; double, 3, 3 &gt; &amp; F, Eigen::Matrix&lt; double, 3, 3 &gt; &amp; R, Eigen::Matrix&lt; double, 3, 3 &gt; &amp; S)  MUDA_GENERIC void svd (const Eigen::Matrix&lt; float, 3, 3 &gt; &amp; F, Eigen::Matrix&lt; float, 3, 3 &gt; &amp; U, Eigen::Vector3&lt; float &gt; &amp; Sigma, Eigen::Matrix&lt; float, 3, 3 &gt; &amp; V)  MUDA_GENERIC void svd (const Eigen::Matrix&lt; double, 3, 3 &gt; &amp; F, Eigen::Matrix&lt; double, 3, 3 &gt; &amp; U, Eigen::Vector3&lt; double &gt; &amp; Sigma, Eigen::Matrix&lt; double, 3, 3 &gt; &amp; V)"},{"location":"muda/namespacemuda_1_1eigen/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; float, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    float2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_1","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; float, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const float2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_2","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; float, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    float3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_3","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; float, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const float3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_4","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; float, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    float4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_5","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; float, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const float4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_6","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; double, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    double2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_7","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; double, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const double2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_8","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; double, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    double3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_9","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; double, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const double3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_10","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; double, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    double4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_11","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; double, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const double4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_12","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    int2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_13","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const int2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_14","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    int3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_15","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const int3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_16","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    int4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_17","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const int4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_18","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    uint2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_19","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const uint2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_20","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    uint3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_21","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const uint3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_22","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    uint4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_23","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const uint4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_24","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; short, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    short2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_25","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; short, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const short2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_26","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; short, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    short3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_27","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; short, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const short3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_28","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; short, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    short4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_29","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; short, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const short4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_30","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned short, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    ushort2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_31","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned short, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const ushort2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_32","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned short, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    ushort3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_33","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned short, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const ushort3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_34","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned short, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    ushort4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_35","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned short, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const ushort4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_36","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; char, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    char2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_37","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; char, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const char2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_38","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; char, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    char3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_39","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; char, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const char3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_40","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; char, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    char4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_41","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; char, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const char4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_42","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned char, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    uchar2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_43","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned char, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const uchar2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_44","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned char, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    uchar3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_45","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned char, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const uchar3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_46","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned char, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    uchar4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_47","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned char, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const uchar4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_48","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    long2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_49","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const long2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_50","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    long3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_51","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const long3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_52","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    long4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_53","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const long4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_54","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    ulong2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_55","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const ulong2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_56","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    ulong3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_57","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const ulong3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_58","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    ulong4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_59","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const ulong4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_60","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long long int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    longlong2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_61","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long long int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const longlong2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_62","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long long int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    longlong3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_63","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long long int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const longlong3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_64","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; long long int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    longlong4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_65","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; long long int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const longlong4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_66","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long long int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    ulonglong2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_67","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long long int, 2, 1 &gt; &gt; muda::eigen::as_eigen (\n    const ulonglong2 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_68","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long long int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    ulonglong3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_69","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long long int, 3, 1 &gt; &gt; muda::eigen::as_eigen (\n    const ulonglong3 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_70","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; Eigen::Matrix&lt; unsigned long long int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    ulonglong4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-as_eigen_71","title":"function as_eigen","text":"<pre><code>MUDA_INLINE MUDA_GENERIC Eigen::Map&lt; const Eigen::Matrix&lt; unsigned long long int, 4, 1 &gt; &gt; muda::eigen::as_eigen (\n    const ulonglong4 &amp; val\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-atomic_add","title":"function atomic_add","text":"<pre><code>template&lt;typename T, int M, int N&gt;\nMUDA_GENERIC Eigen::Matrix&lt; T, M, N &gt; muda::eigen::atomic_add (\n    Eigen::Matrix&lt; T, M, N &gt; &amp; dst,\n    const Eigen::Matrix&lt; T, M, N &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-atomic_add_1","title":"function atomic_add","text":"<pre><code>template&lt;typename T, int M, int N&gt;\nMUDA_GENERIC Eigen::Matrix&lt; T, M, N &gt; muda::eigen::atomic_add (\n    Eigen::Map&lt; Eigen::Matrix&lt; T, M, N &gt; &gt; &amp; dst,\n    const Eigen::Matrix&lt; T, M, N &gt; &amp; src\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-evd","title":"function evd","text":"<pre><code>template&lt;typename T, int N&gt;\nMUDA_GENERIC void muda::eigen::evd (\n    const Eigen::Matrix&lt; T, N, N &gt; &amp; M,\n    Eigen::Vector&lt; T, N &gt; &amp; eigen_values,\n    Eigen::Matrix&lt; T, N, N &gt; &amp; eigen_vectors\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-inverse","title":"function inverse","text":"<pre><code>template&lt;typename T, int N, typename InverseAlgorithm&gt;\nMUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, N, N &gt; muda::eigen::inverse (\n    const Eigen::Matrix&lt; T, N, N &gt; &amp; m\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-inverse_1","title":"function inverse","text":"<pre><code>template&lt;typename T, typename InverseAlgorithm&gt;\nMUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 2, 2 &gt; muda::eigen::inverse (\n    const Eigen::Matrix&lt; T, 2, 2 &gt; &amp; m\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-inverse_2","title":"function inverse","text":"<pre><code>template&lt;typename T, typename InverseAlgorithm&gt;\nMUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 3, 3 &gt; muda::eigen::inverse (\n    const Eigen::Matrix&lt; T, 3, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-inverse_3","title":"function inverse","text":"<pre><code>template&lt;typename T, typename InverseAlgorithm&gt;\nMUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 4, 4 &gt; muda::eigen::inverse (\n    const Eigen::Matrix&lt; T, 4, 4 &gt; &amp; m\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-pd","title":"function pd","text":"<pre><code>MUDA_GENERIC void muda::eigen::pd (\n    const Eigen::Matrix&lt; float, 3, 3 &gt; &amp; F,\n    Eigen::Matrix&lt; float, 3, 3 &gt; &amp; R,\n    Eigen::Matrix&lt; float, 3, 3 &gt; &amp; S\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-pd_1","title":"function pd","text":"<pre><code>MUDA_GENERIC void muda::eigen::pd (\n    const Eigen::Matrix&lt; double, 3, 3 &gt; &amp; F,\n    Eigen::Matrix&lt; double, 3, 3 &gt; &amp; R,\n    Eigen::Matrix&lt; double, 3, 3 &gt; &amp; S\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-svd","title":"function svd","text":"<pre><code>MUDA_GENERIC void muda::eigen::svd (\n    const Eigen::Matrix&lt; float, 3, 3 &gt; &amp; F,\n    Eigen::Matrix&lt; float, 3, 3 &gt; &amp; U,\n    Eigen::Vector3&lt; float &gt; &amp; Sigma,\n    Eigen::Matrix&lt; float, 3, 3 &gt; &amp; V\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1eigen/#function-svd_1","title":"function svd","text":"<pre><code>MUDA_GENERIC void muda::eigen::svd (\n    const Eigen::Matrix&lt; double, 3, 3 &gt; &amp; F,\n    Eigen::Matrix&lt; double, 3, 3 &gt; &amp; U,\n    Eigen::Vector3&lt; double &gt; &amp; Sigma,\n    Eigen::Matrix&lt; double, 3, 3 &gt; &amp; V\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/as_eigen.h</code></p>"},{"location":"muda/structmuda_1_1eigen_1_1_analytical_inverse/","title":"Struct muda::eigen::AnalyticalInverse","text":"<p>ClassList &gt; muda &gt; eigen &gt; AnalyticalInverse</p>"},{"location":"muda/structmuda_1_1eigen_1_1_analytical_inverse/#public-functions","title":"Public Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 2, 2 &gt; operator() (const Eigen::Matrix&lt; T, 2, 2 &gt; &amp; m)  MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 3, 3 &gt; operator() (const Eigen::Matrix&lt; T, 3, 3 &gt; &amp; m)  MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 4, 4 &gt; operator() (const Eigen::Matrix&lt; T, 4, 4 &gt; &amp; m)"},{"location":"muda/structmuda_1_1eigen_1_1_analytical_inverse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1eigen_1_1_analytical_inverse/#function-operator-13","title":"function operator() [1/3]","text":"<pre><code>template&lt;typename T&gt;\ninline MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 2, 2 &gt; muda::eigen::AnalyticalInverse::operator() (\n    const Eigen::Matrix&lt; T, 2, 2 &gt; &amp; m\n) \n</code></pre>"},{"location":"muda/structmuda_1_1eigen_1_1_analytical_inverse/#function-operator-23","title":"function operator() [2/3]","text":"<pre><code>template&lt;typename T&gt;\ninline MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 3, 3 &gt; muda::eigen::AnalyticalInverse::operator() (\n    const Eigen::Matrix&lt; T, 3, 3 &gt; &amp; m\n) \n</code></pre>"},{"location":"muda/structmuda_1_1eigen_1_1_analytical_inverse/#function-operator-33","title":"function operator() [3/3]","text":"<pre><code>template&lt;typename T&gt;\ninline MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, 4, 4 &gt; muda::eigen::AnalyticalInverse::operator() (\n    const Eigen::Matrix&lt; T, 4, 4 &gt; &amp; m\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/inverse/analytic_inverse.h</code></p>"},{"location":"muda/structmuda_1_1eigen_1_1_gauss_elimination_inverse/","title":"Struct muda::eigen::GaussEliminationInverse","text":"<p>ClassList &gt; muda &gt; eigen &gt; GaussEliminationInverse</p>"},{"location":"muda/structmuda_1_1eigen_1_1_gauss_elimination_inverse/#public-functions","title":"Public Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, N, N &gt; operator() (const Eigen::Matrix&lt; T, N, N &gt; &amp; input)"},{"location":"muda/structmuda_1_1eigen_1_1_gauss_elimination_inverse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1eigen_1_1_gauss_elimination_inverse/#function-operator","title":"function operator()","text":"<pre><code>template&lt;typename T, int N&gt;\ninline MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt; T, N, N &gt; muda::eigen::GaussEliminationInverse::operator() (\n    const Eigen::Matrix&lt; T, N, N &gt; &amp; input\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/inverse/gauss_elimination.h</code></p>"},{"location":"muda/classmuda_1_1exception/","title":"Class muda::exception","text":"<p>ClassList &gt; muda &gt; exception</p> <p>Inherits the following classes: std::exception</p> <p>Inherited by the following classes: muda::cuda_error,  muda::invalid_argument,  muda::logic_error,  muda::not_implemented,  muda::out_of_range,  muda::runtime_error</p>"},{"location":"muda/classmuda_1_1exception/#public-functions","title":"Public Functions","text":"Type Name exception (const std::string &amp; msg)  virtual char const * what () const"},{"location":"muda/classmuda_1_1exception/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1exception/#function-exception","title":"function exception","text":"<pre><code>inline muda::exception::exception (\n    const std::string &amp; msg\n) \n</code></pre>"},{"location":"muda/classmuda_1_1exception/#function-what","title":"function what","text":"<pre><code>inline virtual char const * muda::exception::what () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/exception.h</code></p>"},{"location":"muda/structmuda_1_1force__trivial/","title":"Struct muda::force_trivial","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; force_trivial</p>"},{"location":"muda/structmuda_1_1force__trivial/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool value   = = false"},{"location":"muda/structmuda_1_1force__trivial/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/structmuda_1_1force__trivial/#variable-value","title":"variable value","text":"<pre><code>bool muda::force_trivial&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/type_label.h</code></p>"},{"location":"muda/structmuda_1_1force__trivially__constructible/","title":"Struct muda::force_trivially_constructible","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; force_trivially_constructible</p>"},{"location":"muda/structmuda_1_1force__trivially__constructible/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool value   = = false"},{"location":"muda/structmuda_1_1force__trivially__constructible/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/structmuda_1_1force__trivially__constructible/#variable-value","title":"variable value","text":"<pre><code>bool muda::force_trivially_constructible&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/type_label.h</code></p>"},{"location":"muda/structmuda_1_1force__trivially__copy__assignable/","title":"Struct muda::force_trivially_copy_assignable","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; force_trivially_copy_assignable</p>"},{"location":"muda/structmuda_1_1force__trivially__copy__assignable/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool value   = = false"},{"location":"muda/structmuda_1_1force__trivially__copy__assignable/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/structmuda_1_1force__trivially__copy__assignable/#variable-value","title":"variable value","text":"<pre><code>bool muda::force_trivially_copy_assignable&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/type_label.h</code></p>"},{"location":"muda/structmuda_1_1force__trivially__copy__constructible/","title":"Struct muda::force_trivially_copy_constructible","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; force_trivially_copy_constructible</p>"},{"location":"muda/structmuda_1_1force__trivially__copy__constructible/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool value   = = false"},{"location":"muda/structmuda_1_1force__trivially__copy__constructible/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/structmuda_1_1force__trivially__copy__constructible/#variable-value","title":"variable value","text":"<pre><code>bool muda::force_trivially_copy_constructible&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/type_label.h</code></p>"},{"location":"muda/structmuda_1_1force__trivially__destructible/","title":"Struct muda::force_trivially_destructible","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; force_trivially_destructible</p>"},{"location":"muda/structmuda_1_1force__trivially__destructible/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool value   = = false"},{"location":"muda/structmuda_1_1force__trivially__destructible/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/structmuda_1_1force__trivially__destructible/#variable-value","title":"variable value","text":"<pre><code>bool muda::force_trivially_destructible&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/type_label.h</code></p>"},{"location":"muda/classmuda_1_1invalid__argument/","title":"Class muda::invalid_argument","text":"<p>ClassList &gt; muda &gt; invalid_argument</p> <p>Inherits the following classes: muda::exception</p>"},{"location":"muda/classmuda_1_1invalid__argument/#public-functions","title":"Public Functions","text":"Type Name invalid_argument (const std::string &amp; msg)"},{"location":"muda/classmuda_1_1invalid__argument/#public-functions-inherited-from-mudaexception","title":"Public Functions inherited from muda::exception","text":"<p>See muda::exception</p> Type Name exception (const std::string &amp; msg)  virtual char const * what () const"},{"location":"muda/classmuda_1_1invalid__argument/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1invalid__argument/#function-invalid_argument","title":"function invalid_argument","text":"<pre><code>inline muda::invalid_argument::invalid_argument (\n    const std::string &amp; msg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/exception.h</code></p>"},{"location":"muda/structmuda_1_1is__cuda__arch/","title":"Struct muda::is_cuda_arch","text":"<p>ClassList &gt; muda &gt; is_cuda_arch</p>"},{"location":"muda/structmuda_1_1is__cuda__arch/#public-static-attributes","title":"Public Static Attributes","text":"Type Name bool value   = = false"},{"location":"muda/structmuda_1_1is__cuda__arch/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"muda/structmuda_1_1is__cuda__arch/#variable-value","title":"variable value","text":"<pre><code>bool muda::is_cuda_arch::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/cuda_arch.h</code></p>"},{"location":"muda/namespacemuda_1_1lbvh/","title":"Namespace muda::lbvh","text":"<p>Namespace List &gt; muda &gt; lbvh</p>"},{"location":"muda/namespacemuda_1_1lbvh/#namespaces","title":"Namespaces","text":"Type Name namespace details"},{"location":"muda/namespacemuda_1_1lbvh/#classes","title":"Classes","text":"Type Name struct AABB &lt;typename T&gt; class BVH &lt;typename Real, typename Object, typename AABBGetter, typename MortonCodeCalculator&gt; struct DefaultMortonCodeCalculator &lt;typename Real, typename Object&gt; struct query_nearest &lt;typename Real&gt; struct query_overlap &lt;typename Real&gt; struct vector_of &lt;typename T&gt; struct vector_of &lt;typename T&gt; struct vector_of &lt;typename T&gt;"},{"location":"muda/namespacemuda_1_1lbvh/#public-types","title":"Public Types","text":"Type Name typedef details::BVHViewerBase&lt; false, Real, Object &gt; BVHViewer typedef details::BVHViewerBase&lt; true, Real, Object &gt; CBVHViewer typedef typename vector_of&lt; T &gt;::type vector_of_t"},{"location":"muda/namespacemuda_1_1lbvh/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC vector_of&lt; T &gt;::type centroid (const AABB&lt; T &gt; &amp; box) noexcept __device__ MUDA_INLINE int common_upper_bits (const unsigned int lhs, const unsigned int rhs) noexcept __device__ MUDA_INLINE int common_upper_bits (const unsigned long long int lhs, const unsigned long long int rhs) noexcept MUDA_GENERIC MUDA_INLINE std::uint32_t expand_bits (std::uint32_t v) noexcept __device__ T infinity () noexcept __device__ double infinity&lt; double &gt; () noexcept __device__ float infinity&lt; float &gt; () noexcept MUDA_GENERIC bool intersects (const AABB&lt; T &gt; &amp; lhs, const AABB&lt; T &gt; &amp; rhs) noexcept MUDA_GENERIC AABB&lt; double &gt; merge (const AABB&lt; double &gt; &amp; lhs, const AABB&lt; double &gt; &amp; rhs) noexcept MUDA_GENERIC AABB&lt; float &gt; merge (const AABB&lt; float &gt; &amp; lhs, const AABB&lt; float &gt; &amp; rhs) noexcept MUDA_GENERIC float mindist (const AABB&lt; float &gt; &amp; lhs, const float4 &amp; rhs) noexcept MUDA_GENERIC double mindist (const AABB&lt; double &gt; &amp; lhs, const double4 &amp; rhs) noexcept MUDA_GENERIC float minmaxdist (const AABB&lt; float &gt; &amp; lhs, const float4 &amp; rhs) noexcept MUDA_GENERIC double minmaxdist (const AABB&lt; double &gt; &amp; lhs, const double4 &amp; rhs) noexcept MUDA_GENERIC MUDA_INLINE std::uint32_t morton_code (float4 xyz, float resolution=1024.0f) noexcept MUDA_GENERIC MUDA_INLINE std::uint32_t morton_code (double4 xyz, double resolution=1024.0) noexcept MUDA_GENERIC query_nearest&lt; float &gt; nearest (const float4 &amp; point) noexcept MUDA_GENERIC query_nearest&lt; float &gt; nearest (const float3 &amp; point) noexcept MUDA_GENERIC query_nearest&lt; double &gt; nearest (const double4 &amp; point) noexcept MUDA_GENERIC query_nearest&lt; double &gt; nearest (const double3 &amp; point) noexcept MUDA_GENERIC query_overlap&lt; Real &gt; overlaps (const AABB&lt; Real &gt; &amp; region) noexcept MUDA_HOST uint32_t query (const BVH&lt; Real, Objects, AABBGetter, MortonCodeCalculator &gt; &amp; tree, const query_overlap&lt; Real &gt; q, OutputBackInserter outiter) noexcept MUDA_HOST std::pair&lt; uint32_t, Real &gt; query (const BVH&lt; Real, Objects, AABBGetter, MortonCodeCalculator &gt; &amp; tree, const query_nearest&lt; Real &gt; &amp; q, DistanceCalculator calc_dist) noexcept"},{"location":"muda/namespacemuda_1_1lbvh/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/namespacemuda_1_1lbvh/#typedef-bvhviewer","title":"typedef BVHViewer","text":"<pre><code>using muda::lbvh::BVHViewer =  details::BVHViewerBase&lt;false, Real, Object&gt;;\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#typedef-cbvhviewer","title":"typedef CBVHViewer","text":"<pre><code>using muda::lbvh::CBVHViewer =  details::BVHViewerBase&lt;true, Real, Object&gt;;\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#typedef-vector_of_t","title":"typedef vector_of_t","text":"<pre><code>using muda::lbvh::vector_of_t =  typename vector_of&lt;T&gt;::type;\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1lbvh/#function-centroid","title":"function centroid","text":"<pre><code>template&lt;typename T&gt;\ninline MUDA_GENERIC vector_of &lt; T &gt;::type muda::lbvh::centroid (\n    const AABB &lt; T &gt; &amp; box\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-common_upper_bits","title":"function common_upper_bits","text":"<pre><code>__device__ MUDA_INLINE int muda::lbvh::common_upper_bits (\n    const unsigned int lhs,\n    const unsigned int rhs\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-common_upper_bits_1","title":"function common_upper_bits","text":"<pre><code>__device__ MUDA_INLINE int muda::lbvh::common_upper_bits (\n    const unsigned long long int lhs,\n    const unsigned long long int rhs\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-expand_bits","title":"function expand_bits","text":"<pre><code>MUDA_GENERIC MUDA_INLINE std::uint32_t muda::lbvh::expand_bits (\n    std::uint32_t v\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-infinity","title":"function infinity","text":"<pre><code>template&lt;typename T&gt;\ninline __device__ T muda::lbvh::infinity () noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-infinity-double","title":"function infinity&lt; double &gt;","text":"<pre><code>template&lt;&gt;\ninline __device__ double muda::lbvh::infinity&lt; double &gt; () noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-infinity-float","title":"function infinity&lt; float &gt;","text":"<pre><code>template&lt;&gt;\ninline __device__ float muda::lbvh::infinity&lt; float &gt; () noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-intersects","title":"function intersects","text":"<pre><code>template&lt;typename T&gt;\ninline MUDA_GENERIC bool muda::lbvh::intersects (\n    const AABB &lt; T &gt; &amp; lhs,\n    const AABB &lt; T &gt; &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-merge","title":"function merge","text":"<pre><code>inline MUDA_GENERIC AABB &lt; double &gt; muda::lbvh::merge (\n    const AABB &lt; double &gt; &amp; lhs,\n    const AABB &lt; double &gt; &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-merge_1","title":"function merge","text":"<pre><code>inline MUDA_GENERIC AABB &lt; float &gt; muda::lbvh::merge (\n    const AABB &lt; float &gt; &amp; lhs,\n    const AABB &lt; float &gt; &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-mindist","title":"function mindist","text":"<pre><code>inline MUDA_GENERIC float muda::lbvh::mindist (\n    const AABB &lt; float &gt; &amp; lhs,\n    const float4 &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-mindist_1","title":"function mindist","text":"<pre><code>inline MUDA_GENERIC double muda::lbvh::mindist (\n    const AABB &lt; double &gt; &amp; lhs,\n    const double4 &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-minmaxdist","title":"function minmaxdist","text":"<pre><code>inline MUDA_GENERIC float muda::lbvh::minmaxdist (\n    const AABB &lt; float &gt; &amp; lhs,\n    const float4 &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-minmaxdist_1","title":"function minmaxdist","text":"<pre><code>inline MUDA_GENERIC double muda::lbvh::minmaxdist (\n    const AABB &lt; double &gt; &amp; lhs,\n    const double4 &amp; rhs\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-morton_code","title":"function morton_code","text":"<pre><code>MUDA_GENERIC MUDA_INLINE std::uint32_t muda::lbvh::morton_code (\n    float4 xyz,\n    float resolution=1024.0f\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-morton_code_1","title":"function morton_code","text":"<pre><code>MUDA_GENERIC MUDA_INLINE std::uint32_t muda::lbvh::morton_code (\n    double4 xyz,\n    double resolution=1024.0\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-nearest","title":"function nearest","text":"<pre><code>inline MUDA_GENERIC query_nearest &lt; float &gt; muda::lbvh::nearest (\n    const float4 &amp; point\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-nearest_1","title":"function nearest","text":"<pre><code>inline MUDA_GENERIC query_nearest &lt; float &gt; muda::lbvh::nearest (\n    const float3 &amp; point\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-nearest_2","title":"function nearest","text":"<pre><code>inline MUDA_GENERIC query_nearest &lt; double &gt; muda::lbvh::nearest (\n    const double4 &amp; point\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-nearest_3","title":"function nearest","text":"<pre><code>inline MUDA_GENERIC query_nearest &lt; double &gt; muda::lbvh::nearest (\n    const double3 &amp; point\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-overlaps","title":"function overlaps","text":"<pre><code>template&lt;typename Real&gt;\nMUDA_GENERIC query_overlap &lt; Real &gt; muda::lbvh::overlaps (\n    const AABB &lt; Real &gt; &amp; region\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-query","title":"function query","text":"<pre><code>template&lt;typename Real, typename Objects, typename AABBGetter, typename MortonCodeCalculator, typename OutputBackInserter&gt;\nMUDA_HOST uint32_t muda::lbvh::query (\n    const BVH &lt; Real, Objects, AABBGetter, MortonCodeCalculator &gt; &amp; tree,\n    const query_overlap &lt; Real &gt; q,\n    OutputBackInserter outiter\n) noexcept\n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh/#function-query_1","title":"function query","text":"<pre><code>template&lt;typename Real, typename Objects, typename AABBGetter, typename MortonCodeCalculator, typename DistanceCalculator&gt;\nMUDA_HOST std::pair&lt; uint32_t, Real &gt; muda::lbvh::query (\n    const BVH &lt; Real, Objects, AABBGetter, MortonCodeCalculator &gt; &amp; tree,\n    const query_nearest &lt; Real &gt; &amp; q,\n    DistanceCalculator calc_dist\n) noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/aabb.h</code></p>"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/","title":"Struct muda::lbvh::AABB","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; lbvh &gt; AABB</p>"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#public-attributes","title":"Public Attributes","text":"Type Name vector_of&lt; T &gt;::type lower vector_of&lt; T &gt;::type upper"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC AABB () noexcept MUDA_GENERIC AABB (const AABB&lt; T &gt; &amp;) noexcept MUDA_GENERIC AABB (AABB&lt; T &gt; &amp;&amp;) noexcept MUDA_GENERIC AABB &amp; operator= (const AABB&lt; T &gt; &amp;) noexcept MUDA_GENERIC AABB &amp; operator= (AABB&lt; T &gt; &amp;&amp;) noexcept"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#variable-lower","title":"variable lower","text":"<pre><code>vector_of&lt;T&gt;::type muda::lbvh::AABB&lt; T &gt;::lower;\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#variable-upper","title":"variable upper","text":"<pre><code>vector_of&lt;T&gt;::type muda::lbvh::AABB&lt; T &gt;::upper;\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#function-aabb-13","title":"function AABB [1/3]","text":"<pre><code>MUDA_GENERIC muda::lbvh::AABB::AABB () noexcept\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#function-aabb-23","title":"function AABB [2/3]","text":"<pre><code>MUDA_GENERIC muda::lbvh::AABB::AABB (\n    const AABB &lt; T &gt; &amp;\n) noexcept\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#function-aabb-33","title":"function AABB [3/3]","text":"<pre><code>MUDA_GENERIC muda::lbvh::AABB::AABB (\n    AABB &lt; T &gt; &amp;&amp;\n) noexcept\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#function-operator","title":"function operator=","text":"<pre><code>MUDA_GENERIC AABB &amp; muda::lbvh::AABB::operator= (\n    const AABB &lt; T &gt; &amp;\n) noexcept\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_a_a_b_b/#function-operator_1","title":"function operator=","text":"<pre><code>MUDA_GENERIC AABB &amp; muda::lbvh::AABB::operator= (\n    AABB &lt; T &gt; &amp;&amp;\n) noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/aabb.h</code></p>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/","title":"Class muda::lbvh::BVH","text":"<p>template &lt;typename Real, typename Object, typename AABBGetter, typename MortonCodeCalculator&gt;</p> <p>ClassList &gt; muda &gt; lbvh &gt; BVH</p>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#public-types","title":"Public Types","text":"Type Name typedef AABBGetter aabb_getter_type typedef AABB&lt; real_type &gt; aabb_type typedef std::uint32_t index_type typedef MortonCodeCalculator morton_code_calculator_type typedef details::Node node_type typedef Object object_type typedef Real real_type"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#public-functions","title":"Public Functions","text":"Type Name BVH () = default BVH (const BVH &amp;) = default BVH (BVH &amp;&amp;) = default const auto &amp; aabbs () noexcept const void build (cudaStream_t stream=nullptr)  void clear ()  CBVHViewer&lt; real_type, object_type &gt; cviewer () noexcept const const auto &amp; host_aabbs () noexcept const const auto &amp; host_nodes () noexcept const const auto &amp; host_objects () noexcept const const auto &amp; nodes () noexcept const const auto &amp; objects () noexcept const auto &amp; objects () noexcept BVH &amp; operator= (const BVH &amp;) = default BVH &amp; operator= (BVH &amp;&amp;) = default BVHViewer&lt; real_type, object_type &gt; viewer () noexcept ~BVH () = default"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#typedef-aabb_getter_type","title":"typedef aabb_getter_type","text":"<pre><code>using muda::lbvh::BVH&lt; Real, Object, AABBGetter, MortonCodeCalculator &gt;::aabb_getter_type =  AABBGetter;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#typedef-aabb_type","title":"typedef aabb_type","text":"<pre><code>using muda::lbvh::BVH&lt; Real, Object, AABBGetter, MortonCodeCalculator &gt;::aabb_type =  AABB&lt;real_type&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#typedef-index_type","title":"typedef index_type","text":"<pre><code>using muda::lbvh::BVH&lt; Real, Object, AABBGetter, MortonCodeCalculator &gt;::index_type =  std::uint32_t;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#typedef-morton_code_calculator_type","title":"typedef morton_code_calculator_type","text":"<pre><code>using muda::lbvh::BVH&lt; Real, Object, AABBGetter, MortonCodeCalculator &gt;::morton_code_calculator_type =  MortonCodeCalculator;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#typedef-node_type","title":"typedef node_type","text":"<pre><code>using muda::lbvh::BVH&lt; Real, Object, AABBGetter, MortonCodeCalculator &gt;::node_type =  details::Node;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#typedef-object_type","title":"typedef object_type","text":"<pre><code>using muda::lbvh::BVH&lt; Real, Object, AABBGetter, MortonCodeCalculator &gt;::object_type =  Object;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#typedef-real_type","title":"typedef real_type","text":"<pre><code>using muda::lbvh::BVH&lt; Real, Object, AABBGetter, MortonCodeCalculator &gt;::real_type =  Real;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-bvh-13","title":"function BVH [1/3]","text":"<pre><code>muda::lbvh::BVH::BVH () = default\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-bvh-23","title":"function BVH [2/3]","text":"<pre><code>muda::lbvh::BVH::BVH (\n    const BVH &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-bvh-33","title":"function BVH [3/3]","text":"<pre><code>muda::lbvh::BVH::BVH (\n    BVH &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-aabbs","title":"function aabbs","text":"<pre><code>inline const auto &amp; muda::lbvh::BVH::aabbs () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-build","title":"function build","text":"<pre><code>inline void muda::lbvh::BVH::build (\n    cudaStream_t stream=nullptr\n) \n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-clear","title":"function clear","text":"<pre><code>inline void muda::lbvh::BVH::clear () \n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-cviewer","title":"function cviewer","text":"<pre><code>inline CBVHViewer &lt; real_type, object_type &gt; muda::lbvh::BVH::cviewer () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-host_aabbs","title":"function host_aabbs","text":"<pre><code>inline const auto &amp; muda::lbvh::BVH::host_aabbs () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-host_nodes","title":"function host_nodes","text":"<pre><code>inline const auto &amp; muda::lbvh::BVH::host_nodes () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-host_objects","title":"function host_objects","text":"<pre><code>inline const auto &amp; muda::lbvh::BVH::host_objects () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-nodes","title":"function nodes","text":"<pre><code>inline const auto &amp; muda::lbvh::BVH::nodes () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-objects-12","title":"function objects [1/2]","text":"<pre><code>inline const auto &amp; muda::lbvh::BVH::objects () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-objects-22","title":"function objects [2/2]","text":"<pre><code>inline auto &amp; muda::lbvh::BVH::objects () noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-operator","title":"function operator=","text":"<pre><code>BVH &amp; muda::lbvh::BVH::operator= (\n    const BVH &amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-operator_1","title":"function operator=","text":"<pre><code>BVH &amp; muda::lbvh::BVH::operator= (\n    BVH &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-viewer","title":"function viewer","text":"<pre><code>inline BVHViewer &lt; real_type, object_type &gt; muda::lbvh::BVH::viewer () noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1_b_v_h/#function-bvh","title":"function ~BVH","text":"<pre><code>muda::lbvh::BVH::~BVH () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/bvh.h</code></p>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/","title":"Struct muda::lbvh::DefaultMortonCodeCalculator","text":"<p>template &lt;typename Real, typename Object&gt;</p> <p>ClassList &gt; muda &gt; lbvh &gt; DefaultMortonCodeCalculator</p>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#public-attributes","title":"Public Attributes","text":"Type Name AABB&lt; Real &gt; whole"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#public-functions","title":"Public Functions","text":"Type Name DefaultMortonCodeCalculator (AABB&lt; Real &gt; w)  DefaultMortonCodeCalculator () = default DefaultMortonCodeCalculator (DefaultMortonCodeCalculator const &amp;) = default DefaultMortonCodeCalculator (DefaultMortonCodeCalculator &amp;&amp;) = default __device__ __host__ uint32_t operator() (const Object &amp;, const AABB&lt; Real &gt; &amp; box) noexcept DefaultMortonCodeCalculator &amp; operator= (DefaultMortonCodeCalculator const &amp;) = default DefaultMortonCodeCalculator &amp; operator= (DefaultMortonCodeCalculator &amp;&amp;) = default ~DefaultMortonCodeCalculator () = default"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#variable-whole","title":"variable whole","text":"<pre><code>AABB&lt;Real&gt; muda::lbvh::DefaultMortonCodeCalculator&lt; Real, Object &gt;::whole;\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#function-defaultmortoncodecalculator-14","title":"function DefaultMortonCodeCalculator [1/4]","text":"<pre><code>inline muda::lbvh::DefaultMortonCodeCalculator::DefaultMortonCodeCalculator (\n    AABB &lt; Real &gt; w\n) \n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#function-defaultmortoncodecalculator-24","title":"function DefaultMortonCodeCalculator [2/4]","text":"<pre><code>muda::lbvh::DefaultMortonCodeCalculator::DefaultMortonCodeCalculator () = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#function-defaultmortoncodecalculator-34","title":"function DefaultMortonCodeCalculator [3/4]","text":"<pre><code>muda::lbvh::DefaultMortonCodeCalculator::DefaultMortonCodeCalculator (\n    DefaultMortonCodeCalculator const &amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#function-defaultmortoncodecalculator-44","title":"function DefaultMortonCodeCalculator [4/4]","text":"<pre><code>muda::lbvh::DefaultMortonCodeCalculator::DefaultMortonCodeCalculator (\n    DefaultMortonCodeCalculator &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#function-operator","title":"function operator()","text":"<pre><code>inline __device__ __host__ uint32_t muda::lbvh::DefaultMortonCodeCalculator::operator() (\n    const Object &amp;,\n    const AABB &lt; Real &gt; &amp; box\n) noexcept\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#function-operator_1","title":"function operator=","text":"<pre><code>DefaultMortonCodeCalculator &amp; muda::lbvh::DefaultMortonCodeCalculator::operator= (\n    DefaultMortonCodeCalculator const &amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#function-operator_2","title":"function operator=","text":"<pre><code>DefaultMortonCodeCalculator &amp; muda::lbvh::DefaultMortonCodeCalculator::operator= (\n    DefaultMortonCodeCalculator &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1_default_morton_code_calculator/#function-defaultmortoncodecalculator","title":"function ~DefaultMortonCodeCalculator","text":"<pre><code>muda::lbvh::DefaultMortonCodeCalculator::~DefaultMortonCodeCalculator () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/bvh.h</code></p>"},{"location":"muda/namespacemuda_1_1lbvh_1_1details/","title":"Namespace muda::lbvh::details","text":"<p>Namespace List &gt; muda &gt; lbvh &gt; details</p>"},{"location":"muda/namespacemuda_1_1lbvh_1_1details/#classes","title":"Classes","text":"Type Name class BVHViewerBase &lt;IsConst, typename Real, typename Object&gt; struct Node"},{"location":"muda/namespacemuda_1_1lbvh_1_1details/#public-functions","title":"Public Functions","text":"Type Name void construct_internal_nodes (const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; policy, Node * nodes, UInt const * node_code, const uint32_t num_objects)  MUDA_GENERIC uint2 determine_range (UInt const * node_code, const uint32_t num_leaves, uint32_t idx)  MUDA_GENERIC uint32_t find_split (UInt const * node_code, const uint32_t num_leaves, const uint32_t first, const uint32_t last) noexcept"},{"location":"muda/namespacemuda_1_1lbvh_1_1details/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1lbvh_1_1details/#function-construct_internal_nodes","title":"function construct_internal_nodes","text":"<pre><code>template&lt;typename DerivedPolicy, typename UInt&gt;\nvoid muda::lbvh::details::construct_internal_nodes (\n    const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; policy,\n    Node * nodes,\n    UInt const * node_code,\n    const uint32_t num_objects\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh_1_1details/#function-determine_range","title":"function determine_range","text":"<pre><code>template&lt;typename UInt&gt;\nMUDA_GENERIC uint2 muda::lbvh::details::determine_range (\n    UInt const * node_code,\n    const uint32_t num_leaves,\n    uint32_t idx\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1lbvh_1_1details/#function-find_split","title":"function find_split","text":"<pre><code>template&lt;typename UInt&gt;\nMUDA_GENERIC uint32_t muda::lbvh::details::find_split (\n    UInt const * node_code,\n    const uint32_t num_leaves,\n    const uint32_t first,\n    const uint32_t last\n) noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/bvh.h</code></p>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/","title":"Class muda::lbvh::details::BVHViewerBase","text":"<p>template &lt;bool IsConst, typename Real, typename Object&gt;</p> <p>ClassList &gt; muda &gt; lbvh &gt; details &gt; BVHViewerBase</p> <p>Inherits the following classes: muda::ViewerBase</p>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#classes","title":"Classes","text":"Type Name struct DefaultQueryCallback"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#public-types","title":"Public Types","text":"Type Name typedef BVHViewerBase&lt; true, real_type, object_type &gt; ConstViewer typedef BVHViewerBase&lt; false, real_type, object_type &gt; NonConstViewer typedef BVHViewerBase&lt; IsConst, real_type, object_type &gt; ThisViewer typedef AABB&lt; real_type &gt; aabb_type typedef std::uint32_t index_type typedef details::Node node_type typedef Object object_type typedef Real real_type"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#public-static-attributes-inherited-from-mudaviewerbase","title":"Public Static Attributes inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name bool IsConst   = = IsConst_ bool IsNonConst   = = !IsConst_"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC BVHViewerBase (const uint32_t num_nodes, const uint32_t num_objects, auto_const_t&lt; node_type &gt; * nodes, auto_const_t&lt; aabb_type &gt; * aabbs, auto_const_t&lt; object_type &gt; * objects)  MUDA_GENERIC auto as_const () noexcept const MUDA_GENERIC auto num_nodes () noexcept const MUDA_GENERIC auto num_objects () noexcept const MUDA_GENERIC auto_const_t&lt; object_type &gt; &amp; object (const uint32_t idx) noexcept MUDA_GENERIC const object_type &amp; object (const uint32_t idx) noexcept const MUDA_GENERIC operator ConstViewer () noexcept const MUDA_GENERIC uint32_t query (const query_overlap&lt; real_type &gt; &amp; q, F callback=DefaultQueryCallback{}) noexcept const MUDA_GENERIC thrust::pair&lt; uint32_t, real_type &gt; query (const query_nearest&lt; real_type &gt; &amp; q, FDistanceCalculator calc_dist) noexcept const"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#public-functions-inherited-from-mudaviewerbase","title":"Public Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_GENERIC ViewerBase ()  ViewerBase (const ViewerBase &amp;) = default ViewerBase (ViewerBase &amp;&amp;) = default MUDA_INLINE MUDA_GENERIC void copy_label (const ViewerBase &amp; other)  MUDA_GENERIC const char * kernel_file () const MUDA_GENERIC int kernel_line () const MUDA_GENERIC const char * kernel_name () const MUDA_GENERIC const char * name () const ViewerBase &amp; operator= (const ViewerBase &amp;) = default ViewerBase &amp; operator= (ViewerBase &amp;&amp;) = default"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#protected-types-inherited-from-mudaviewerbase","title":"Protected Types inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name typedef std::conditional_t&lt; IsConst, const T, T &gt; auto_const_t typedef std::enable_if_t&lt; IsNonConst, T &gt; non_const_enable_t"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#protected-functions-inherited-from-mudaviewerbase","title":"Protected Functions inherited from muda::ViewerBase","text":"<p>See muda::ViewerBase</p> Type Name MUDA_INLINE MUDA_HOST void name (const char * n)  MUDA_INLINE MUDA_GENERIC void name (details::StringPointer pointer)"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#typedef-constviewer","title":"typedef ConstViewer","text":"<pre><code>using muda::lbvh::details::BVHViewerBase&lt; IsConst, Real, Object &gt;::ConstViewer =  BVHViewerBase&lt;true, real_type, object_type&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#typedef-nonconstviewer","title":"typedef NonConstViewer","text":"<pre><code>using muda::lbvh::details::BVHViewerBase&lt; IsConst, Real, Object &gt;::NonConstViewer =  BVHViewerBase&lt;false, real_type, object_type&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#typedef-thisviewer","title":"typedef ThisViewer","text":"<pre><code>using muda::lbvh::details::BVHViewerBase&lt; IsConst, Real, Object &gt;::ThisViewer =  BVHViewerBase&lt;IsConst, real_type, object_type&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#typedef-aabb_type","title":"typedef aabb_type","text":"<pre><code>using muda::lbvh::details::BVHViewerBase&lt; IsConst, Real, Object &gt;::aabb_type =  AABB&lt;real_type&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#typedef-index_type","title":"typedef index_type","text":"<pre><code>using muda::lbvh::details::BVHViewerBase&lt; IsConst, Real, Object &gt;::index_type =  std::uint32_t;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#typedef-node_type","title":"typedef node_type","text":"<pre><code>using muda::lbvh::details::BVHViewerBase&lt; IsConst, Real, Object &gt;::node_type =  details::Node;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#typedef-object_type","title":"typedef object_type","text":"<pre><code>using muda::lbvh::details::BVHViewerBase&lt; IsConst, Real, Object &gt;::object_type =  Object;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#typedef-real_type","title":"typedef real_type","text":"<pre><code>using muda::lbvh::details::BVHViewerBase&lt; IsConst, Real, Object &gt;::real_type =  Real;\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#function-bvhviewerbase","title":"function BVHViewerBase","text":"<pre><code>inline MUDA_GENERIC muda::lbvh::details::BVHViewerBase::BVHViewerBase (\n    const uint32_t num_nodes,\n    const uint32_t num_objects,\n    auto_const_t&lt; node_type &gt; * nodes,\n    auto_const_t&lt; aabb_type &gt; * aabbs,\n    auto_const_t&lt; object_type &gt; * objects\n) \n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#function-as_const","title":"function as_const","text":"<pre><code>inline MUDA_GENERIC auto muda::lbvh::details::BVHViewerBase::as_const () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#function-num_nodes","title":"function num_nodes","text":"<pre><code>inline MUDA_GENERIC auto muda::lbvh::details::BVHViewerBase::num_nodes () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#function-num_objects","title":"function num_objects","text":"<pre><code>inline MUDA_GENERIC auto muda::lbvh::details::BVHViewerBase::num_objects () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#function-object-12","title":"function object [1/2]","text":"<pre><code>inline MUDA_GENERIC auto_const_t&lt; object_type &gt; &amp; muda::lbvh::details::BVHViewerBase::object (\n    const uint32_t idx\n) noexcept\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#function-object-22","title":"function object [2/2]","text":"<pre><code>inline MUDA_GENERIC const object_type &amp; muda::lbvh::details::BVHViewerBase::object (\n    const uint32_t idx\n) noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#function-operator-constviewer","title":"function operator ConstViewer","text":"<pre><code>inline MUDA_GENERIC muda::lbvh::details::BVHViewerBase::operator ConstViewer () noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#function-query-12","title":"function query [1/2]","text":"<pre><code>template&lt;typename F, uint32_t StackNum&gt;\ninline MUDA_GENERIC uint32_t muda::lbvh::details::BVHViewerBase::query (\n    const query_overlap &lt; real_type &gt; &amp; q,\n    F callback=DefaultQueryCallback {}\n) noexcept const\n</code></pre>"},{"location":"muda/classmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base/#function-query-22","title":"function query [2/2]","text":"<pre><code>template&lt;typename FDistanceCalculator, uint32_t StackNum&gt;\ninline MUDA_GENERIC thrust::pair&lt; uint32_t, real_type &gt; muda::lbvh::details::BVHViewerBase::query (\n    const query_nearest &lt; real_type &gt; &amp; q,\n    FDistanceCalculator calc_dist\n) noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/bvh_viewer.h</code></p>"},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base_1_1_default_query_callback/","title":"Struct muda::lbvh::details::BVHViewerBase::DefaultQueryCallback","text":"<p>ClassList &gt; muda &gt; lbvh &gt; details &gt; BVHViewerBase &gt; DefaultQueryCallback</p>"},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base_1_1_default_query_callback/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC void operator() (uint32_t obj_idx) noexcept const"},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base_1_1_default_query_callback/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_b_v_h_viewer_base_1_1_default_query_callback/#function-operator","title":"function operator()","text":"<pre><code>inline MUDA_GENERIC void muda::lbvh::details::BVHViewerBase::DefaultQueryCallback::operator() (\n    uint32_t obj_idx\n) noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/bvh_viewer.h</code></p>"},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_node/","title":"Struct muda::lbvh::details::Node","text":"<p>ClassList &gt; muda &gt; lbvh &gt; details &gt; Node</p>"},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_node/#public-attributes","title":"Public Attributes","text":"Type Name std::uint32_t left_idx std::uint32_t object_idx std::uint32_t parent_idx std::uint32_t right_idx"},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_node/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_node/#variable-left_idx","title":"variable left_idx","text":"<pre><code>std::uint32_t muda::lbvh::details::Node::left_idx;\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_node/#variable-object_idx","title":"variable object_idx","text":"<pre><code>std::uint32_t muda::lbvh::details::Node::object_idx;\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_node/#variable-parent_idx","title":"variable parent_idx","text":"<pre><code>std::uint32_t muda::lbvh::details::Node::parent_idx;\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1details_1_1_node/#variable-right_idx","title":"variable right_idx","text":"<pre><code>std::uint32_t muda::lbvh::details::Node::right_idx;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/bvh_viewer.h</code></p>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/","title":"Struct muda::lbvh::query_nearest","text":"<p>template &lt;typename Real&gt;</p> <p>ClassList &gt; muda &gt; lbvh &gt; query_nearest</p>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#public-types","title":"Public Types","text":"Type Name typedef typename vector_of&lt; Real &gt;::type vector_type"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#public-attributes","title":"Public Attributes","text":"Type Name vector_type target"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#public-functions","title":"Public Functions","text":"Type Name query_nearest &amp; operator= (const query_nearest &amp;) = default query_nearest &amp; operator= (query_nearest &amp;&amp;) = default MUDA_GENERIC query_nearest (const vector_type &amp; tgt)  query_nearest () = default query_nearest (const query_nearest &amp;) = default query_nearest (query_nearest &amp;&amp;) = default ~query_nearest () = default"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#typedef-vector_type","title":"typedef vector_type","text":"<pre><code>using muda::lbvh::query_nearest&lt; Real &gt;::vector_type =  typename vector_of&lt;Real&gt;::type;\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#variable-target","title":"variable target","text":"<pre><code>vector_type muda::lbvh::query_nearest&lt; Real &gt;::target;\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#function-operator","title":"function operator=","text":"<pre><code>query_nearest &amp; muda::lbvh::query_nearest::operator= (\n    const query_nearest &amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#function-operator_1","title":"function operator=","text":"<pre><code>query_nearest &amp; muda::lbvh::query_nearest::operator= (\n    query_nearest &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#function-query_nearest-14","title":"function query_nearest [1/4]","text":"<pre><code>inline MUDA_GENERIC muda::lbvh::query_nearest::query_nearest (\n    const vector_type &amp; tgt\n) \n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#function-query_nearest-24","title":"function query_nearest [2/4]","text":"<pre><code>muda::lbvh::query_nearest::query_nearest () = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#function-query_nearest-34","title":"function query_nearest [3/4]","text":"<pre><code>muda::lbvh::query_nearest::query_nearest (\n    const query_nearest &amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#function-query_nearest-44","title":"function query_nearest [4/4]","text":"<pre><code>muda::lbvh::query_nearest::query_nearest (\n    query_nearest &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__nearest/#function-query_nearest","title":"function ~query_nearest","text":"<pre><code>muda::lbvh::query_nearest::~query_nearest () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/predicator.h</code></p>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/","title":"Struct muda::lbvh::query_overlap","text":"<p>template &lt;typename Real&gt;</p> <p>ClassList &gt; muda &gt; lbvh &gt; query_overlap</p>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#public-attributes","title":"Public Attributes","text":"Type Name AABB&lt; Real &gt; target"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC bool operator() (const AABB&lt; Real &gt; &amp; box) noexcept query_overlap &amp; operator= (const query_overlap &amp;) = default query_overlap &amp; operator= (query_overlap &amp;&amp;) = default MUDA_GENERIC query_overlap (const AABB&lt; Real &gt; &amp; tgt)  query_overlap () = default query_overlap (const query_overlap &amp;) = default query_overlap (query_overlap &amp;&amp;) = default ~query_overlap () = default"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#variable-target","title":"variable target","text":"<pre><code>AABB&lt;Real&gt; muda::lbvh::query_overlap&lt; Real &gt;::target;\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#function-operator","title":"function operator()","text":"<pre><code>inline MUDA_GENERIC bool muda::lbvh::query_overlap::operator() (\n    const AABB &lt; Real &gt; &amp; box\n) noexcept\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#function-operator_1","title":"function operator=","text":"<pre><code>query_overlap &amp; muda::lbvh::query_overlap::operator= (\n    const query_overlap &amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#function-operator_2","title":"function operator=","text":"<pre><code>query_overlap &amp; muda::lbvh::query_overlap::operator= (\n    query_overlap &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#function-query_overlap-14","title":"function query_overlap [1/4]","text":"<pre><code>inline MUDA_GENERIC muda::lbvh::query_overlap::query_overlap (\n    const AABB &lt; Real &gt; &amp; tgt\n) \n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#function-query_overlap-24","title":"function query_overlap [2/4]","text":"<pre><code>muda::lbvh::query_overlap::query_overlap () = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#function-query_overlap-34","title":"function query_overlap [3/4]","text":"<pre><code>muda::lbvh::query_overlap::query_overlap (\n    const query_overlap &amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#function-query_overlap-44","title":"function query_overlap [4/4]","text":"<pre><code>muda::lbvh::query_overlap::query_overlap (\n    query_overlap &amp;&amp;\n) = default\n</code></pre>"},{"location":"muda/structmuda_1_1lbvh_1_1query__overlap/#function-query_overlap","title":"function ~query_overlap","text":"<pre><code>muda::lbvh::query_overlap::~query_overlap () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/predicator.h</code></p>"},{"location":"muda/structmuda_1_1lbvh_1_1vector__of/","title":"Struct muda::lbvh::vector_of","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; lbvh &gt; vector_of</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/utility.h</code></p>"},{"location":"muda/classmuda_1_1logic__error/","title":"Class muda::logic_error","text":"<p>ClassList &gt; muda &gt; logic_error</p> <p>Inherits the following classes: muda::exception</p>"},{"location":"muda/classmuda_1_1logic__error/#public-functions","title":"Public Functions","text":"Type Name logic_error (const std::string &amp; msg)"},{"location":"muda/classmuda_1_1logic__error/#public-functions-inherited-from-mudaexception","title":"Public Functions inherited from muda::exception","text":"<p>See muda::exception</p> Type Name exception (const std::string &amp; msg)  virtual char const * what () const"},{"location":"muda/classmuda_1_1logic__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1logic__error/#function-logic_error","title":"function logic_error","text":"<pre><code>inline muda::logic_error::logic_error (\n    const std::string &amp; msg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/exception.h</code></p>"},{"location":"muda/classmuda_1_1not__implemented/","title":"Class muda::not_implemented","text":"<p>ClassList &gt; muda &gt; not_implemented</p> <p>Inherits the following classes: muda::exception</p>"},{"location":"muda/classmuda_1_1not__implemented/#public-functions","title":"Public Functions","text":"Type Name not_implemented (const std::string &amp; msg)"},{"location":"muda/classmuda_1_1not__implemented/#public-functions-inherited-from-mudaexception","title":"Public Functions inherited from muda::exception","text":"<p>See muda::exception</p> Type Name exception (const std::string &amp; msg)  virtual char const * what () const"},{"location":"muda/classmuda_1_1not__implemented/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1not__implemented/#function-not_implemented","title":"function not_implemented","text":"<pre><code>inline muda::not_implemented::not_implemented (\n    const std::string &amp; msg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/exception.h</code></p>"},{"location":"muda/classmuda_1_1out__of__range/","title":"Class muda::out_of_range","text":"<p>ClassList &gt; muda &gt; out_of_range</p> <p>Inherits the following classes: muda::exception</p>"},{"location":"muda/classmuda_1_1out__of__range/#public-functions","title":"Public Functions","text":"Type Name out_of_range (const std::string &amp; msg)"},{"location":"muda/classmuda_1_1out__of__range/#public-functions-inherited-from-mudaexception","title":"Public Functions inherited from muda::exception","text":"<p>See muda::exception</p> Type Name exception (const std::string &amp; msg)  virtual char const * what () const"},{"location":"muda/classmuda_1_1out__of__range/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1out__of__range/#function-out_of_range","title":"function out_of_range","text":"<pre><code>inline muda::out_of_range::out_of_range (\n    const std::string &amp; msg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/exception.h</code></p>"},{"location":"muda/structmuda_1_1read__only__view/","title":"Struct muda::read_only_view","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; read_only_view</p>"},{"location":"muda/structmuda_1_1read__only__view/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"muda/structmuda_1_1read__only__view/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/structmuda_1_1read__only__view/#typedef-type","title":"typedef type","text":"<pre><code>using muda::read_only_view&lt; T &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/type_modifier.h</code></p>"},{"location":"muda/structmuda_1_1read__write__view/","title":"Struct muda::read_write_view","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; read_write_view</p>"},{"location":"muda/structmuda_1_1read__write__view/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"muda/structmuda_1_1read__write__view/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/structmuda_1_1read__write__view/#typedef-type","title":"typedef type","text":"<pre><code>using muda::read_write_view&lt; T &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/type_modifier.h</code></p>"},{"location":"muda/classmuda_1_1runtime__error/","title":"Class muda::runtime_error","text":"<p>ClassList &gt; muda &gt; runtime_error</p> <p>Inherits the following classes: muda::exception</p>"},{"location":"muda/classmuda_1_1runtime__error/#public-functions","title":"Public Functions","text":"Type Name runtime_error (const std::string &amp; msg)"},{"location":"muda/classmuda_1_1runtime__error/#public-functions-inherited-from-mudaexception","title":"Public Functions inherited from muda::exception","text":"<p>See muda::exception</p> Type Name exception (const std::string &amp; msg)  virtual char const * what () const"},{"location":"muda/classmuda_1_1runtime__error/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1runtime__error/#function-runtime_error","title":"function runtime_error","text":"<pre><code>inline muda::runtime_error::runtime_error (\n    const std::string &amp; msg\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/exception.h</code></p>"},{"location":"muda/namespacemuda_1_1spatial__hash/","title":"Namespace muda::spatial_hash","text":"<p>Namespace List &gt; muda &gt; spatial_hash</p>"},{"location":"muda/namespacemuda_1_1spatial__hash/#namespaces","title":"Namespaces","text":"Type Name namespace details"},{"location":"muda/namespacemuda_1_1spatial__hash/#classes","title":"Classes","text":"Type Name class AABB class BoundingSphere class CollisionPair class DefaultPredication class Morton &lt;typename T&gt; class Morton &lt;typename T&gt; class Morton &lt;typename T&gt; class SparseSpatialHash &lt;typename Hash&gt; class SpatialHashTableInfo &lt;typename Hash&gt; class SpatialPartitionCell To represent a cell-object pair in the spatial hash 3D grid e.g. (cell_id,object_id) = (1024, 32) for the meaning: the 32th object overlap with the 1024th cell."},{"location":"muda/namespacemuda_1_1spatial__hash/#public-functions","title":"Public Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC float distance (const Eigen::Vector3f &amp; p, AABB b)  MUDA_INLINE MUDA_GENERIC bool intersect (const BoundingSphere &amp; s, const AABB &amp; b)  MUDA_INLINE MUDA_GENERIC bool intersect (const BoundingSphere &amp; lhs, const BoundingSphere &amp; rhs)  MUDA_INLINE MUDA_GENERIC bool intersect (const AABB &amp; l, const AABB &amp; r)  MUDA_INLINE MUDA_GENERIC float squared_distance (const Eigen::Vector3f &amp; p, AABB b)"},{"location":"muda/namespacemuda_1_1spatial__hash/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/namespacemuda_1_1spatial__hash/#function-distance","title":"function distance","text":"<pre><code>MUDA_INLINE MUDA_GENERIC float muda::spatial_hash::distance (\n    const Eigen::Vector3f &amp; p,\n    AABB b\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1spatial__hash/#function-intersect","title":"function intersect","text":"<pre><code>MUDA_INLINE MUDA_GENERIC bool muda::spatial_hash::intersect (\n    const BoundingSphere &amp; s,\n    const AABB &amp; b\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1spatial__hash/#function-intersect_1","title":"function intersect","text":"<pre><code>MUDA_INLINE MUDA_GENERIC bool muda::spatial_hash::intersect (\n    const BoundingSphere &amp; lhs,\n    const BoundingSphere &amp; rhs\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1spatial__hash/#function-intersect_2","title":"function intersect","text":"<pre><code>MUDA_INLINE MUDA_GENERIC bool muda::spatial_hash::intersect (\n    const AABB &amp; l,\n    const AABB &amp; r\n) \n</code></pre>"},{"location":"muda/namespacemuda_1_1spatial__hash/#function-squared_distance","title":"function squared_distance","text":"<pre><code>MUDA_INLINE MUDA_GENERIC float muda::spatial_hash::squared_distance (\n    const Eigen::Vector3f &amp; p,\n    AABB b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/bounding_volume.h</code></p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/","title":"Class muda::spatial_hash::AABB","text":"<p>ClassList &gt; muda &gt; spatial_hash &gt; AABB</p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#public-attributes","title":"Public Attributes","text":"Type Name Vector3 max Vector3 min"},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC AABB (const Vector3 &amp; min, const Vector3 &amp; max)  MUDA_GENERIC AABB (const AABB &amp; l, const AABB &amp; r)  MUDA_GENERIC Vector3 center () const MUDA_GENERIC float radius () const"},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#variable-max","title":"variable max","text":"<pre><code>Vector3 muda::spatial_hash::AABB::max;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#variable-min","title":"variable min","text":"<pre><code>Vector3 muda::spatial_hash::AABB::min;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#function-aabb-12","title":"function AABB [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::spatial_hash::AABB::AABB (\n    const Vector3 &amp; min,\n    const Vector3 &amp; max\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#function-aabb-22","title":"function AABB [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::spatial_hash::AABB::AABB (\n    const AABB &amp; l,\n    const AABB &amp; r\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#function-center","title":"function center","text":"<pre><code>inline MUDA_GENERIC Vector3 muda::spatial_hash::AABB::center () const\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_a_a_b_b/#function-radius","title":"function radius","text":"<pre><code>inline MUDA_GENERIC float muda::spatial_hash::AABB::radius () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/bounding_volume.h</code></p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/","title":"Class muda::spatial_hash::BoundingSphere","text":"<p>ClassList &gt; muda &gt; spatial_hash &gt; BoundingSphere</p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/#public-attributes","title":"Public Attributes","text":"Type Name int level   = = 0 Vector3 o   = = Vector3::Zero() float r   = = 0.0f"},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC BoundingSphere (const Vector3 &amp; o, float r)  MUDA_GENERIC BoundingSphere () = default"},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/#variable-level","title":"variable level","text":"<pre><code>int muda::spatial_hash::BoundingSphere::level;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/#variable-o","title":"variable o","text":"<pre><code>Vector3 muda::spatial_hash::BoundingSphere::o;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/#variable-r","title":"variable r","text":"<pre><code>float muda::spatial_hash::BoundingSphere::r;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/#function-boundingsphere-12","title":"function BoundingSphere [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::spatial_hash::BoundingSphere::BoundingSphere (\n    const Vector3 &amp; o,\n    float r\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_bounding_sphere/#function-boundingsphere-22","title":"function BoundingSphere [2/2]","text":"<pre><code>MUDA_GENERIC muda::spatial_hash::BoundingSphere::BoundingSphere () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/bounding_volume.h</code></p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/","title":"Class muda::spatial_hash::CollisionPair","text":"<p>ClassList &gt; muda &gt; spatial_hash &gt; CollisionPair</p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC CollisionPair (int i, int j)  MUDA_GENERIC CollisionPair ()  Eigen::Vector2i IDs () const MUDA_GENERIC bool is_valid () const"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#public-static-functions","title":"Public Static Functions","text":"Type Name MUDA_GENERIC CollisionPair invalid ()"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#function-collisionpair-12","title":"function CollisionPair [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::spatial_hash::CollisionPair::CollisionPair (\n    int i,\n    int j\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#function-collisionpair-22","title":"function CollisionPair [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::spatial_hash::CollisionPair::CollisionPair () \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#function-ids","title":"function IDs","text":"<pre><code>inline Eigen::Vector2i muda::spatial_hash::CollisionPair::IDs () const\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#function-is_valid","title":"function is_valid","text":"<pre><code>inline MUDA_GENERIC bool muda::spatial_hash::CollisionPair::is_valid () const\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#function-invalid","title":"function invalid","text":"<pre><code>static inline MUDA_GENERIC CollisionPair muda::spatial_hash::CollisionPair::invalid () \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#friends-documentation","title":"Friends Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#friend-operator","title":"friend operator&lt;","text":"<pre><code>inline MUDA_GENERIC friend bool muda::spatial_hash::CollisionPair::operator&lt; (\n    const CollisionPair &amp; l,\n    const CollisionPair &amp; r\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#friend-operator_1","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; muda::spatial_hash::CollisionPair::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const CollisionPair &amp; c\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_collision_pair/#friend-operator_2","title":"friend operator==","text":"<pre><code>inline MUDA_GENERIC friend bool muda::spatial_hash::CollisionPair::operator== (\n    const CollisionPair &amp; l,\n    const CollisionPair &amp; r\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/collision_pair.h</code></p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_default_predication/","title":"Class muda::spatial_hash::DefaultPredication","text":"<p>ClassList &gt; muda &gt; spatial_hash &gt; DefaultPredication</p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_default_predication/#public-functions","title":"Public Functions","text":"Type Name __device__ bool operator() (int i, int j)"},{"location":"muda/classmuda_1_1spatial__hash_1_1_default_predication/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_default_predication/#function-operator","title":"function operator()","text":"<pre><code>inline __device__ bool muda::spatial_hash::DefaultPredication::operator() (\n    int i,\n    int j\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/sparse_spatial_hash.h</code></p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_morton/","title":"Class muda::spatial_hash::Morton","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; muda &gt; spatial_hash &gt; Morton</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/morton_hash.h</code></p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_sparse_spatial_hash/","title":"Class muda::spatial_hash::SparseSpatialHash","text":"<p>template &lt;typename Hash&gt;</p> <p>ClassList &gt; muda &gt; spatial_hash &gt; SparseSpatialHash</p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_sparse_spatial_hash/#public-functions","title":"Public Functions","text":"Type Name SparseSpatialHash (muda::Stream &amp; stream=muda::Stream::Default())  void detect (CBufferView&lt; BoundingSphere &gt; spheres, DeviceBuffer&lt; CollisionPair &gt; &amp; collisionPairs, Pred &amp;&amp; pred={}) Detect collision pairs from bounding spheres. Note that: void detect (int level, CBufferView&lt; BoundingSphere &gt; spheres, DeviceBuffer&lt; CollisionPair &gt; &amp; collisionPairs, Pred &amp;&amp; pred={}) Detect collision pairs from bounding spheres at a specific level (level &gt;= 0). This is used for hierarchical spatial hashing collision detection. Its user's responsibility to set <code>level</code> value to a bounding sphere. Normally, higher level means larger bounding sphere. Users should decide a proper range of radius for each level, like:"},{"location":"muda/classmuda_1_1spatial__hash_1_1_sparse_spatial_hash/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_sparse_spatial_hash/#function-sparsespatialhash","title":"function SparseSpatialHash","text":"<pre><code>inline muda::spatial_hash::SparseSpatialHash::SparseSpatialHash (\n    muda::Stream &amp; stream=muda::Stream::Default()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_sparse_spatial_hash/#function-detect-12","title":"function detect [1/2]","text":"<p>Detect collision pairs from bounding spheres. Note that: <pre><code>template&lt;typename Pred&gt;\ninline void muda::spatial_hash::SparseSpatialHash::detect (\n    CBufferView &lt; BoundingSphere &gt; spheres,\n    DeviceBuffer &lt; CollisionPair &gt; &amp; collisionPairs,\n    Pred &amp;&amp; pred={}\n) \n</code></pre></p> <ul> <li>The collision pairs are unique but not sorted.</li> <li>All <code>(i,j)</code> pairs in collisionPairs satisfy <code>i &lt; j</code>.</li> </ul> <p>Parameters:</p> <ul> <li><code>spheres</code> bounding spheres </li> <li><code>collisionPairs</code> output collision pairs </li> <li><code>pred</code> predication function. f: <code>__device__ (int i, int j) -&gt; bool</code>. If <code>pred(i,j)</code> is true, then the collision pair <code>(i,j)</code> is recorded, else the collision pair is discarded. </li> </ul> <p>See also: DefaultPredication </p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_sparse_spatial_hash/#function-detect-22","title":"function detect [2/2]","text":"<p>Detect collision pairs from bounding spheres at a specific level (level &gt;= 0). This is used for hierarchical spatial hashing collision detection. Its user's responsibility to set <code>level</code> value to a bounding sphere. Normally, higher level means larger bounding sphere. Users should decide a proper range of radius for each level, like: <pre><code>template&lt;typename Pred&gt;\ninline void muda::spatial_hash::SparseSpatialHash::detect (\n    int level,\n    CBufferView &lt; BoundingSphere &gt; spheres,\n    DeviceBuffer &lt; CollisionPair &gt; &amp; collisionPairs,\n    Pred &amp;&amp; pred={}\n) \n</code></pre></p> <p><pre><code>BoundingSphere s{o,r};\nif (r &lt; r0) s.level = 0;\nelse if (r &lt; r1) s.level = 1;\nelse s.level = 2;\n...\n</code></pre>  Note that: * For a level <code>L</code>, any bounding spheres has a <code>level &lt;= L</code> will be taken into account. * The collision pairs are unique but not sorted. * All <code>(i,j)</code> pairs in collisionPairs satisfy <code>i &lt; j</code>. * The <code>collisionPairs</code> will be appended with new collision pairs (not cleared).</p> <p>Typical usage:  <pre><code>DeviceBuffer&lt;BoundingSphere&gt; spheres;\n\n// Your code to fill spheres with proper level\n// ...\n\nDeviceBuffer&lt;CollisionPair&gt; collisionPairs;\n\nfor (int level = 0; level &lt; level_count; ++level)\n{\n    detect(level, spheres, collisionPairs);\n}\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>level</code> the hierarchy level we want to detect </li> <li><code>spheres</code> bounding spheres </li> <li><code>collisionPairs</code> appended output collision pairs </li> <li><code>pred</code> predication function. f: <code>__device__ (int i, int j) -&gt; bool</code>. If <code>pred(i,j)</code> is true, then the collision pair <code>(i,j)</code> is recorded, else the collision pair is discarded.</li> </ul> <p>See also: DefaultPredication </p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/sparse_spatial_hash.h</code></p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/","title":"Class muda::spatial_hash::SpatialHashTableInfo","text":"<p>template &lt;typename Hash&gt;</p> <p>ClassList &gt; muda &gt; spatial_hash &gt; SpatialHashTableInfo</p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#public-attributes","title":"Public Attributes","text":"Type Name Float cell_size   = = 0.0f Vector3 coord_min   = = Vector3::Zero()"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC SpatialHashTableInfo () = default MUDA_GENERIC SpatialHashTableInfo (Float cell_size, const Vector3 &amp; coord_min)  MUDA_GENERIC Vector3u cell (const Vector3 &amp; xyz) const MUDA_GENERIC Vector3 cell_center_coord (const Vector3u &amp; ijk) const MUDA_GENERIC Vector3 coord (const Vector3u &amp; ijk) const MUDA_GENERIC U32 hash_cell (const Vector3 &amp; xyz) const MUDA_GENERIC U32 hash_cell (const Vector3u &amp; ijk) const"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#variable-cell_size","title":"variable cell_size","text":"<pre><code>Float muda::spatial_hash::SpatialHashTableInfo&lt; Hash &gt;::cell_size;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#variable-coord_min","title":"variable coord_min","text":"<pre><code>Vector3 muda::spatial_hash::SpatialHashTableInfo&lt; Hash &gt;::coord_min;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#function-spatialhashtableinfo-12","title":"function SpatialHashTableInfo [1/2]","text":"<pre><code>MUDA_GENERIC muda::spatial_hash::SpatialHashTableInfo::SpatialHashTableInfo () = default\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#function-spatialhashtableinfo-22","title":"function SpatialHashTableInfo [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::spatial_hash::SpatialHashTableInfo::SpatialHashTableInfo (\n    Float cell_size,\n    const Vector3 &amp; coord_min\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#function-cell","title":"function cell","text":"<pre><code>inline MUDA_GENERIC Vector3u muda::spatial_hash::SpatialHashTableInfo::cell (\n    const Vector3 &amp; xyz\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#function-cell_center_coord","title":"function cell_center_coord","text":"<pre><code>inline MUDA_GENERIC Vector3 muda::spatial_hash::SpatialHashTableInfo::cell_center_coord (\n    const Vector3u &amp; ijk\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#function-coord","title":"function coord","text":"<pre><code>inline MUDA_GENERIC Vector3 muda::spatial_hash::SpatialHashTableInfo::coord (\n    const Vector3u &amp; ijk\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#function-hash_cell-12","title":"function hash_cell [1/2]","text":"<pre><code>inline MUDA_GENERIC U32 muda::spatial_hash::SpatialHashTableInfo::hash_cell (\n    const Vector3 &amp; xyz\n) const\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_hash_table_info/#function-hash_cell-22","title":"function hash_cell [2/2]","text":"<pre><code>inline MUDA_GENERIC U32 muda::spatial_hash::SpatialHashTableInfo::hash_cell (\n    const Vector3u &amp; ijk\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/sparse_spatial_hash_impl.h</code></p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/","title":"Class muda::spatial_hash::SpatialPartitionCell","text":"<p>ClassList &gt; muda &gt; spatial_hash &gt; SpatialPartitionCell</p> <p>To represent a cell-object pair in the spatial hash 3D grid e.g. (cell_id,object_id) = (1024, 32) for the meaning: the 32th object overlap with the 1024th cell. </p> <ul> <li><code>#include &lt;sparse_spatial_hash_impl.h&gt;</code></li> </ul>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#public-types","title":"Public Types","text":"Type Name typedef uint32_t U32 typedef Eigen::Vector3&lt; uint32_t &gt; Vector3u"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#public-attributes","title":"Public Attributes","text":"Type Name U32 cid struct muda::spatial_hash::SpatialPartitionCell ctlbit U32 home U32 oid U32 overlap U32 pass"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC SpatialPartitionCell ()  MUDA_GENERIC SpatialPartitionCell (U32 cid, U32 oid)  MUDA_GENERIC bool is_home () const MUDA_GENERIC bool is_phantom () const MUDA_GENERIC void set_as_home (const Vector3u &amp; ijk)  MUDA_GENERIC void set_as_phantom (const Vector3u &amp; home_ijk, const Vector3u &amp; cell_ijk)  MUDA_GENERIC void set_overlap (const Vector3u &amp; ijk)"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#public-static-functions","title":"Public Static Functions","text":"Type Name MUDA_GENERIC bool allow_ignore (const SpatialPartitionCell &amp; l, const SpatialPartitionCell &amp; r)  MUDA_GENERIC U32 pass_type (const Vector3u &amp; ijk)"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#typedef-u32","title":"typedef U32","text":"<pre><code>using muda::spatial_hash::SpatialPartitionCell::U32 =  uint32_t;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#typedef-vector3u","title":"typedef Vector3u","text":"<pre><code>using muda::spatial_hash::SpatialPartitionCell::Vector3u =  Eigen::Vector3&lt;uint32_t&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#variable-cid","title":"variable cid","text":"<pre><code>U32 muda::spatial_hash::SpatialPartitionCell::cid;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#variable-ctlbit","title":"variable ctlbit","text":"<pre><code>struct muda::spatial_hash::SpatialPartitionCell muda::spatial_hash::SpatialPartitionCell::ctlbit;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#variable-home","title":"variable home","text":"<pre><code>U32 muda::spatial_hash::SpatialPartitionCell::home;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#variable-oid","title":"variable oid","text":"<pre><code>U32 muda::spatial_hash::SpatialPartitionCell::oid;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#variable-overlap","title":"variable overlap","text":"<pre><code>U32 muda::spatial_hash::SpatialPartitionCell::overlap;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#variable-pass","title":"variable pass","text":"<pre><code>U32 muda::spatial_hash::SpatialPartitionCell::pass;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#function-spatialpartitioncell-12","title":"function SpatialPartitionCell [1/2]","text":"<pre><code>inline MUDA_GENERIC muda::spatial_hash::SpatialPartitionCell::SpatialPartitionCell () \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#function-spatialpartitioncell-22","title":"function SpatialPartitionCell [2/2]","text":"<pre><code>inline MUDA_GENERIC muda::spatial_hash::SpatialPartitionCell::SpatialPartitionCell (\n    U32 cid,\n    U32 oid\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#function-is_home","title":"function is_home","text":"<pre><code>inline MUDA_GENERIC bool muda::spatial_hash::SpatialPartitionCell::is_home () const\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#function-is_phantom","title":"function is_phantom","text":"<pre><code>inline MUDA_GENERIC bool muda::spatial_hash::SpatialPartitionCell::is_phantom () const\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#function-set_as_home","title":"function set_as_home","text":"<pre><code>inline MUDA_GENERIC void muda::spatial_hash::SpatialPartitionCell::set_as_home (\n    const Vector3u &amp; ijk\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#function-set_as_phantom","title":"function set_as_phantom","text":"<pre><code>inline MUDA_GENERIC void muda::spatial_hash::SpatialPartitionCell::set_as_phantom (\n    const Vector3u &amp; home_ijk,\n    const Vector3u &amp; cell_ijk\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#function-set_overlap","title":"function set_overlap","text":"<pre><code>inline MUDA_GENERIC void muda::spatial_hash::SpatialPartitionCell::set_overlap (\n    const Vector3u &amp; ijk\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#function-allow_ignore","title":"function allow_ignore","text":"<pre><code>static inline MUDA_GENERIC bool muda::spatial_hash::SpatialPartitionCell::allow_ignore (\n    const SpatialPartitionCell &amp; l,\n    const SpatialPartitionCell &amp; r\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1_spatial_partition_cell/#function-pass_type","title":"function pass_type","text":"<pre><code>static inline MUDA_GENERIC U32 muda::spatial_hash::SpatialPartitionCell::pass_type (\n    const Vector3u &amp; ijk\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/sparse_spatial_hash_impl.h</code></p>"},{"location":"muda/namespacemuda_1_1spatial__hash_1_1details/","title":"Namespace muda::spatial_hash::details","text":"<p>Namespace List &gt; muda &gt; spatial_hash &gt; details</p>"},{"location":"muda/namespacemuda_1_1spatial__hash_1_1details/#classes","title":"Classes","text":"Type Name class SparseSpatialHashImpl &lt;typename Hash&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/sparse_spatial_hash_impl.h</code></p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/","title":"Class muda::spatial_hash::details::SparseSpatialHashImpl","text":"<p>template &lt;typename Hash&gt;</p> <p>ClassList &gt; muda &gt; spatial_hash &gt; details &gt; SparseSpatialHashImpl</p>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#public-types","title":"Public Types","text":"Type Name typedef SpatialPartitionCell Cell typedef int32_t I32 typedef uint32_t U32 typedef Eigen::Vector3f Vector3 typedef Eigen::Vector3&lt; I32 &gt; Vector3i typedef Eigen::Vector3&lt; U32 &gt; Vector3u"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#public-attributes","title":"Public Attributes","text":"Type Name DeviceBuffer&lt; Vector3 &gt; allCoords DeviceBuffer&lt; float &gt; allRadius DeviceBuffer&lt; int &gt; cellArrayKey DeviceBuffer&lt; int &gt; cellArrayKeySorted DeviceBuffer&lt; SpatialPartitionCell &gt; cellArrayValue DeviceBuffer&lt; SpatialPartitionCell &gt; cellArrayValueSorted DeviceVar&lt; int &gt; cellCount DeviceBuffer&lt; int &gt; cellToCollisionPairUpperBound DeviceBuffer&lt; int &gt; cellToCollisionPairUpperBoundPrefixSum DeviceBuffer&lt; CollisionPair &gt; collisionPairBuffer DeviceBuffer&lt; int &gt; collisionPairCount DeviceBuffer&lt; int &gt; collisionPairPrefixSum bool empty_level   = = false SpatialHashTableInfo&lt; Hash &gt; h_spatialHashConfig int level   = = 0 muda::Stream &amp; m_stream DeviceVar&lt; float &gt; maxRadius DeviceVar&lt; Vector3 &gt; minCoord DeviceBuffer&lt; int &gt; objCountInCell DeviceBuffer&lt; int &gt; objCountInCellPrefixSum DeviceVar&lt; int &gt; pairCount size_t pairListOffset   = = 0 DeviceBuffer&lt; int &gt; potentialCollisionPairIdToCellIndex DeviceBuffer&lt; int &gt; potentialCollisionPairIdToCellIndexBuffer DeviceVar&lt; SpatialHashTableInfo&lt; Hash &gt; &gt; spatialHashConfig CBufferView&lt; BoundingSphere &gt; spheres int sum DeviceBuffer&lt; int &gt; uniqueKey DeviceVar&lt; int &gt; uniqueKeyCount int validCellCount DeviceVar&lt; int &gt; validCollisionPairCount"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#public-functions","title":"Public Functions","text":"Type Name SparseSpatialHashImpl (muda::Stream &amp; stream=muda::Stream::Default())  void alloc_collision_pair_list (DeviceBuffer&lt; CollisionPair &gt; &amp; collisionPairs, int totalCollisionPairCount)  void balanced_setup_collision_pairs (bool append, DeviceBuffer&lt; CollisionPair &gt; &amp; collisionPairs, Pred &amp;&amp; pred)  void calculate_hash_table_basic_info ()  void count_object_per_cell ()  void detect (CBufferView&lt; BoundingSphere &gt; boundingSphereList, bool append, DeviceBuffer&lt; CollisionPair &gt; &amp; collisionPairs, Pred &amp;&amp; pred)  void fill_hash_cells ()  void setup_hash_table ()  void simple_count_collision_pairs (Pred &amp;&amp; pred)  void simple_fill_collision_pair_list (DeviceBuffer&lt; CollisionPair &gt; &amp; collisionPairs, Pred &amp;&amp; pred)  void simple_setup_collision_pairs (Pred &amp;&amp; pred, DeviceBuffer&lt; CollisionPair &gt; &amp; collisionPairs)"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#typedef-cell","title":"typedef Cell","text":"<pre><code>using muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::Cell =  SpatialPartitionCell;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#typedef-i32","title":"typedef I32","text":"<pre><code>using muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::I32 =  int32_t;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#typedef-u32","title":"typedef U32","text":"<pre><code>using muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::U32 =  uint32_t;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#typedef-vector3","title":"typedef Vector3","text":"<pre><code>using muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::Vector3 =  Eigen::Vector3f;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#typedef-vector3i","title":"typedef Vector3i","text":"<pre><code>using muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::Vector3i =  Eigen::Vector3&lt;I32&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#typedef-vector3u","title":"typedef Vector3u","text":"<pre><code>using muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::Vector3u =  Eigen::Vector3&lt;U32&gt;;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-allcoords","title":"variable allCoords","text":"<pre><code>DeviceBuffer&lt;Vector3&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::allCoords;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-allradius","title":"variable allRadius","text":"<pre><code>DeviceBuffer&lt;float&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::allRadius;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-cellarraykey","title":"variable cellArrayKey","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::cellArrayKey;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-cellarraykeysorted","title":"variable cellArrayKeySorted","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::cellArrayKeySorted;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-cellarrayvalue","title":"variable cellArrayValue","text":"<pre><code>DeviceBuffer&lt;SpatialPartitionCell&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::cellArrayValue;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-cellarrayvaluesorted","title":"variable cellArrayValueSorted","text":"<pre><code>DeviceBuffer&lt;SpatialPartitionCell&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::cellArrayValueSorted;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-cellcount","title":"variable cellCount","text":"<pre><code>DeviceVar&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::cellCount;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-celltocollisionpairupperbound","title":"variable cellToCollisionPairUpperBound","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::cellToCollisionPairUpperBound;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-celltocollisionpairupperboundprefixsum","title":"variable cellToCollisionPairUpperBoundPrefixSum","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::cellToCollisionPairUpperBoundPrefixSum;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-collisionpairbuffer","title":"variable collisionPairBuffer","text":"<pre><code>DeviceBuffer&lt;CollisionPair&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::collisionPairBuffer;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-collisionpaircount","title":"variable collisionPairCount","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::collisionPairCount;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-collisionpairprefixsum","title":"variable collisionPairPrefixSum","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::collisionPairPrefixSum;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-empty_level","title":"variable empty_level","text":"<pre><code>bool muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::empty_level;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-h_spatialhashconfig","title":"variable h_spatialHashConfig","text":"<pre><code>SpatialHashTableInfo&lt;Hash&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::h_spatialHashConfig;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-level","title":"variable level","text":"<pre><code>int muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::level;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-m_stream","title":"variable m_stream","text":"<pre><code>muda::Stream&amp; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::m_stream;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-maxradius","title":"variable maxRadius","text":"<pre><code>DeviceVar&lt;float&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::maxRadius;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-mincoord","title":"variable minCoord","text":"<pre><code>DeviceVar&lt;Vector3&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::minCoord;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-objcountincell","title":"variable objCountInCell","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::objCountInCell;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-objcountincellprefixsum","title":"variable objCountInCellPrefixSum","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::objCountInCellPrefixSum;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-paircount","title":"variable pairCount","text":"<pre><code>DeviceVar&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::pairCount;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-pairlistoffset","title":"variable pairListOffset","text":"<pre><code>size_t muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::pairListOffset;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-potentialcollisionpairidtocellindex","title":"variable potentialCollisionPairIdToCellIndex","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::potentialCollisionPairIdToCellIndex;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-potentialcollisionpairidtocellindexbuffer","title":"variable potentialCollisionPairIdToCellIndexBuffer","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::potentialCollisionPairIdToCellIndexBuffer;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-spatialhashconfig","title":"variable spatialHashConfig","text":"<pre><code>DeviceVar&lt;SpatialHashTableInfo&lt;Hash&gt; &gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::spatialHashConfig;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-spheres","title":"variable spheres","text":"<pre><code>CBufferView&lt;BoundingSphere&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::spheres;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-sum","title":"variable sum","text":"<pre><code>int muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::sum;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-uniquekey","title":"variable uniqueKey","text":"<pre><code>DeviceBuffer&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::uniqueKey;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-uniquekeycount","title":"variable uniqueKeyCount","text":"<pre><code>DeviceVar&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::uniqueKeyCount;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-validcellcount","title":"variable validCellCount","text":"<pre><code>int muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::validCellCount;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#variable-validcollisionpaircount","title":"variable validCollisionPairCount","text":"<pre><code>DeviceVar&lt;int&gt; muda::spatial_hash::details::SparseSpatialHashImpl&lt; Hash &gt;::validCollisionPairCount;\n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-sparsespatialhashimpl","title":"function SparseSpatialHashImpl","text":"<pre><code>inline muda::spatial_hash::details::SparseSpatialHashImpl::SparseSpatialHashImpl (\n    muda::Stream &amp; stream=muda::Stream::Default()\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-alloc_collision_pair_list","title":"function alloc_collision_pair_list","text":"<pre><code>void muda::spatial_hash::details::SparseSpatialHashImpl::alloc_collision_pair_list (\n    DeviceBuffer &lt; CollisionPair &gt; &amp; collisionPairs,\n    int totalCollisionPairCount\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-balanced_setup_collision_pairs","title":"function balanced_setup_collision_pairs","text":"<pre><code>template&lt;typename Pred&gt;\nvoid muda::spatial_hash::details::SparseSpatialHashImpl::balanced_setup_collision_pairs (\n    bool append,\n    DeviceBuffer &lt; CollisionPair &gt; &amp; collisionPairs,\n    Pred &amp;&amp; pred\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-calculate_hash_table_basic_info","title":"function calculate_hash_table_basic_info","text":"<pre><code>void muda::spatial_hash::details::SparseSpatialHashImpl::calculate_hash_table_basic_info () \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-count_object_per_cell","title":"function count_object_per_cell","text":"<pre><code>void muda::spatial_hash::details::SparseSpatialHashImpl::count_object_per_cell () \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-detect","title":"function detect","text":"<pre><code>template&lt;typename Pred&gt;\nvoid muda::spatial_hash::details::SparseSpatialHashImpl::detect (\n    CBufferView &lt; BoundingSphere &gt; boundingSphereList,\n    bool append,\n    DeviceBuffer &lt; CollisionPair &gt; &amp; collisionPairs,\n    Pred &amp;&amp; pred\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-fill_hash_cells","title":"function fill_hash_cells","text":"<pre><code>void muda::spatial_hash::details::SparseSpatialHashImpl::fill_hash_cells () \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-setup_hash_table","title":"function setup_hash_table","text":"<pre><code>void muda::spatial_hash::details::SparseSpatialHashImpl::setup_hash_table () \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-simple_count_collision_pairs","title":"function simple_count_collision_pairs","text":"<pre><code>template&lt;typename Pred&gt;\nvoid muda::spatial_hash::details::SparseSpatialHashImpl::simple_count_collision_pairs (\n    Pred &amp;&amp; pred\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-simple_fill_collision_pair_list","title":"function simple_fill_collision_pair_list","text":"<pre><code>template&lt;typename Pred&gt;\nvoid muda::spatial_hash::details::SparseSpatialHashImpl::simple_fill_collision_pair_list (\n    DeviceBuffer &lt; CollisionPair &gt; &amp; collisionPairs,\n    Pred &amp;&amp; pred\n) \n</code></pre>"},{"location":"muda/classmuda_1_1spatial__hash_1_1details_1_1_sparse_spatial_hash_impl/#function-simple_setup_collision_pairs","title":"function simple_setup_collision_pairs","text":"<pre><code>template&lt;typename Pred&gt;\nvoid muda::spatial_hash::details::SparseSpatialHashImpl::simple_setup_collision_pairs (\n    Pred &amp;&amp; pred,\n    DeviceBuffer &lt; CollisionPair &gt; &amp; collisionPairs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/sparse_spatial_hash_impl.h</code></p>"},{"location":"muda/classmuda_1_1_compute_graph_var_base_1_1_related_closure_info/","title":"Class muda::ComputeGraphVarBase::RelatedClosureInfo","text":"<p>ClassList &gt; RelatedClosureInfo</p>"},{"location":"muda/classmuda_1_1_compute_graph_var_base_1_1_related_closure_info/#public-attributes","title":"Public Attributes","text":"Type Name std::set&lt; ClosureId &gt; closure_ids ComputeGraph * graph"},{"location":"muda/classmuda_1_1_compute_graph_var_base_1_1_related_closure_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1_compute_graph_var_base_1_1_related_closure_info/#variable-closure_ids","title":"variable closure_ids","text":"<pre><code>std::set&lt;ClosureId&gt; muda::ComputeGraphVarBase::RelatedClosureInfo::closure_ids;\n</code></pre>"},{"location":"muda/classmuda_1_1_compute_graph_var_base_1_1_related_closure_info/#variable-graph","title":"variable graph","text":"<pre><code>ComputeGraph* muda::ComputeGraphVarBase::RelatedClosureInfo::graph;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_var.h</code></p>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache_1_1_string_location/","title":"Class muda::details::HostDeviceStringCache::StringLocation","text":"<p>ClassList &gt; StringLocation</p>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache_1_1_string_location/#public-attributes","title":"Public Attributes","text":"Type Name size_t buffer_index   = = ~0 size_t offset   = = ~0 size_t size   = = ~0"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache_1_1_string_location/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache_1_1_string_location/#variable-buffer_index","title":"variable buffer_index","text":"<pre><code>size_t muda::details::HostDeviceStringCache::StringLocation::buffer_index;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache_1_1_string_location/#variable-offset","title":"variable offset","text":"<pre><code>size_t muda::details::HostDeviceStringCache::StringLocation::offset;\n</code></pre>"},{"location":"muda/classmuda_1_1details_1_1_host_device_string_cache_1_1_string_location/#variable-size","title":"variable size","text":"<pre><code>size_t muda::details::HostDeviceStringCache::StringLocation::size;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/host_device_string_cache.h</code></p>"},{"location":"muda/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p>"},{"location":"muda/namespacestd/#classes","title":"Classes","text":"Type Name struct hash&lt; muda::ClosureId &gt; &lt;&gt; struct hash&lt; muda::IdWithType&lt; T &gt; &gt; &lt;typename T&gt; struct hash&lt; muda::details::MatrixFormatConverterType &gt; &lt;&gt; class tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; &lt;I, typename ElementType, Extent&gt; class tuple_size&lt; TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; &lt;typename ElementType, Extent&gt; <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_closure_id.h</code></p>"},{"location":"muda/structstd_1_1hash_3_01muda_1_1_closure_id_01_4/","title":"Struct std::hash&lt; muda::ClosureId &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; std &gt; hash&lt; muda::ClosureId &gt;</p>"},{"location":"muda/structstd_1_1hash_3_01muda_1_1_closure_id_01_4/#public-functions","title":"Public Functions","text":"Type Name size_t operator() (const muda::ClosureId &amp; s) noexcept const"},{"location":"muda/structstd_1_1hash_3_01muda_1_1_closure_id_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structstd_1_1hash_3_01muda_1_1_closure_id_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline size_t std::hash&lt; muda::ClosureId &gt;::operator() (\n    const muda::ClosureId &amp; s\n) noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_closure_id.h</code></p>"},{"location":"muda/structstd_1_1hash_3_01muda_1_1_id_with_type_3_01_t_01_4_01_4/","title":"Struct std::hash&lt; muda::IdWithType&lt; T &gt; &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; std &gt; hash&lt; muda::IdWithType&lt; T &gt; &gt;</p>"},{"location":"muda/structstd_1_1hash_3_01muda_1_1_id_with_type_3_01_t_01_4_01_4/#public-functions","title":"Public Functions","text":"Type Name size_t operator() (const muda::IdWithType&lt; T &gt; &amp; s) noexcept const"},{"location":"muda/structstd_1_1hash_3_01muda_1_1_id_with_type_3_01_t_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structstd_1_1hash_3_01muda_1_1_id_with_type_3_01_t_01_4_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline size_t std::hash&lt; muda::IdWithType&lt; T &gt; &gt;::operator() (\n    const muda::IdWithType &lt; T &gt; &amp; s\n) noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/id_with_type.h</code></p>"},{"location":"muda/structstd_1_1hash_3_01muda_1_1details_1_1_matrix_format_converter_type_01_4/","title":"Struct std::hash&lt; muda::details::MatrixFormatConverterType &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; std &gt; hash&lt; muda::details::MatrixFormatConverterType &gt;</p>"},{"location":"muda/structstd_1_1hash_3_01muda_1_1details_1_1_matrix_format_converter_type_01_4/#public-functions","title":"Public Functions","text":"Type Name size_t operator() (const muda::details::MatrixFormatConverterType &amp; x) const"},{"location":"muda/structstd_1_1hash_3_01muda_1_1details_1_1_matrix_format_converter_type_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/structstd_1_1hash_3_01muda_1_1details_1_1_matrix_format_converter_type_01_4/#function-operator","title":"function operator()","text":"<pre><code>inline size_t std::hash&lt; muda::details::MatrixFormatConverterType &gt;::operator() (\n    const muda::details::MatrixFormatConverterType &amp; x\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/matrix_format_converter.h</code></p>"},{"location":"muda/classstd_1_1tuple__element_3_01_i_00_01_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span_3_93b789f899ee7baa4f7d754ce2758ef3/","title":"Class std::tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt;","text":"<p>template &lt;size_t I, typename ElementType, size_t Extent&gt;</p> <p>ClassList &gt; std &gt; tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt;</p>"},{"location":"muda/classstd_1_1tuple__element_3_01_i_00_01_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span_3_93b789f899ee7baa4f7d754ce2758ef3/#public-types","title":"Public Types","text":"Type Name typedef ElementType type"},{"location":"muda/classstd_1_1tuple__element_3_01_i_00_01_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span_3_93b789f899ee7baa4f7d754ce2758ef3/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/classstd_1_1tuple__element_3_01_i_00_01_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span_3_93b789f899ee7baa4f7d754ce2758ef3/#typedef-type","title":"typedef type","text":"<pre><code>using std::tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt;::type =  ElementType;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/classstd_1_1tuple__size_3_01_t_c_b___s_p_a_n___n_a_m_e_s_p_a_c_e___n_a_m_e_1_1span_3_01_element_type_00_01_extent_01_4_01_4/","title":"Class std::tuple_size&lt; TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt;","text":"<p>template &lt;typename ElementType, size_t Extent&gt;</p> <p>ClassList &gt; std &gt; tuple_size&lt; TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt;</p> <p>Inherits the following classes: integral_constant&lt; size_t, Extent &gt;</p> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/namespacethrust/","title":"Namespace thrust","text":"<p>Namespace List &gt; thrust</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"muda/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"muda/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","title":"Directories","text":"Type Name dir muda <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"muda/dir_be047e8c00f93e2e88c2a417393a7f42/","title":"Dir src/muda","text":"<p>FileList &gt; muda</p>"},{"location":"muda/dir_be047e8c00f93e2e88c2a417393a7f42/#files","title":"Files","text":"Type Name file assert.h file atomic.h file buffer.h file compute_graph.h file container.h file debug.h file exception.h file graph.h file launch.h file logger.h file muda.h file muda_config.h file muda_def.h file print.h file profiler.h file syntax_sugar.h file type_define.h file viewer.h"},{"location":"muda/dir_be047e8c00f93e2e88c2a417393a7f42/#directories","title":"Directories","text":"Type Name dir buffer dir check dir compute_graph dir container dir cub dir cuda dir ext dir graph dir launch dir literal dir logger dir mstl dir tools dir type_traits dir view dir viewer <p>The documentation for this class was generated from the following file <code>src/muda/</code></p>"},{"location":"muda/assert_8h/","title":"File assert.h","text":"<p>FileList &gt; muda &gt; assert.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/tools/debug_break.h&gt;</code></li> </ul>"},{"location":"muda/assert_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/assert.h</code></p>"},{"location":"muda/assert_8h_source/","title":"File assert.h","text":"<p>File List &gt; muda &gt; assert.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/tools/debug_break.h&gt;\n\nnamespace muda\n{\nMUDA_INLINE MUDA_GENERIC void trap() MUDA_NOEXCEPT\n{\n#ifdef __CUDA_ARCH__\n    __trap();\n#else\n    std::abort();\n#endif\n}\n\nMUDA_INLINE MUDA_GENERIC void brkpt() MUDA_NOEXCEPT\n{\n#ifdef __CUDA_ARCH__\n    __brkpt();\n#else\n    debug_break();\n#endif\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/atomic_8h/","title":"File atomic.h","text":"<p>FileList &gt; muda &gt; atomic.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;device_atomic_functions.h&gt;</code></li> </ul>"},{"location":"muda/atomic_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/atomic.h</code></p>"},{"location":"muda/atomic_8h_source/","title":"File atomic.h","text":"<p>File List &gt; muda &gt; atomic.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;device_atomic_functions.h&gt;\nnamespace muda\n{\ntemplate &lt;typename T&gt;\n__forceinline__ __device__ T atomic_cas(T* address, T compare, T val)\n{\n    return atomicCAS(address, compare, val);\n}\n\ntemplate &lt;typename T&gt;\n__forceinline__ __device__ T atomic_add(T* address, T val)\n{\n    return atomicAdd(address, val);\n}\n\ntemplate &lt;typename T&gt;\n__forceinline__ __device__ T atomic_sub(T* address, T val)\n{\n    return atomicSub(address, val);\n}\n\ntemplate &lt;typename T&gt;\n__forceinline__ __device__ T atomic_exch(T* address, T val)\n{\n    return atomicExch(address, val);\n}\n\ntemplate &lt;typename T&gt;\n__forceinline__ __device__ T atomic_max(T* address, T val)\n{\n    return atomicMax(address, val);\n}\n\ntemplate &lt;typename T&gt;\n__forceinline__ __device__ T atomic_min(T* address, T val)\n{\n    return atomicMin(address, val);\n}\n\ntemplate &lt;typename T&gt;\n__forceinline__ __device__ T atomic_and(T* address, T val)\n{\n    return atomicAnd(address, val);\n}\n\ntemplate &lt;typename T&gt;\n__forceinline__ __device__ T atomic_or(T* address, T val)\n{\n    return atomicOr(address, val);\n}\n\ntemplate &lt;typename T&gt;\n__forceinline__ __device__ T atomic_xor(T* address, T val)\n{\n    return atomicXor(address, val);\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/buffer_8h/","title":"File buffer.h","text":"<p>FileList &gt; muda &gt; buffer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_var.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_launch.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_view.h&gt;</code></li> <li><code>#include &lt;muda/buffer/graph_buffer_view.h&gt;</code></li> <li><code>#include &lt;muda/buffer/var_view.h&gt;</code></li> <li><code>#include &lt;muda/buffer/graph_var_view.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/buffer.h</code></p>"},{"location":"muda/buffer_8h_source/","title":"File buffer.h","text":"<p>File List &gt; muda &gt; buffer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/buffer/device_var.h&gt;\n#include &lt;muda/buffer/buffer_launch.h&gt;\n#include &lt;muda/buffer/buffer_view.h&gt;\n#include &lt;muda/buffer/graph_buffer_view.h&gt;\n#include &lt;muda/buffer/var_view.h&gt;\n#include &lt;muda/buffer/graph_var_view.h&gt;\n</code></pre>"},{"location":"muda/compute__graph_8h/","title":"File compute_graph.h","text":"<p>FileList &gt; muda &gt; compute_graph.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/compute_graph/compute_graph.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_builder.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_manager.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph.h</code></p>"},{"location":"muda/compute__graph_8h_source/","title":"File compute_graph.h","text":"<p>File List &gt; muda &gt; compute_graph.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/compute_graph/compute_graph.h&gt;\n#include &lt;muda/compute_graph/compute_graph_builder.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var.h&gt;\n#include &lt;muda/compute_graph/compute_graph_node.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_manager.h&gt;\n</code></pre>"},{"location":"muda/container_8h/","title":"File container.h","text":"<p>FileList &gt; muda &gt; container.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/container/var.h&gt;</code></li> <li><code>#include &lt;muda/container/vector.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/container.h</code></p>"},{"location":"muda/container_8h_source/","title":"File container.h","text":"<p>File List &gt; muda &gt; container.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/container/var.h&gt;\n#include &lt;muda/container/vector.h&gt;\n</code></pre>"},{"location":"muda/debug_8h/","title":"File debug.h","text":"<p>FileList &gt; muda &gt; debug.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;muda/muda_config.h&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"muda/debug_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/debug_8h/#classes","title":"Classes","text":"Type Name class Debug <p>The documentation for this class was generated from the following file <code>src/muda/debug.h</code></p>"},{"location":"muda/debug_8h_source/","title":"File debug.h","text":"<p>File List &gt; muda &gt; debug.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;atomic&gt;\n#include &lt;muda/muda_config.h&gt;\n#include &lt;mutex&gt;\nnamespace muda\n{\nclass Debug\n{\n  private:\n    static auto&amp; _is_debug_sync_all()\n    {\n        static std::atomic&lt;bool&gt; m_is_debug_sync_all(false);\n        return m_is_debug_sync_all;\n    }\n\n    static auto&amp; _mutex()\n    {\n        static std::mutex m_mutex;\n        return m_mutex;\n    }\n\n    static auto&amp; _sync_callback()\n    {\n        static std::function&lt;void()&gt; m_sync_callback = nullptr;\n        return m_sync_callback;\n    }\n\n  public:\n    static bool debug_sync_all(bool value)\n    {\n        _is_debug_sync_all() = value;\n        return value;\n    }\n\n    static bool is_debug_sync_all() { return _is_debug_sync_all(); }\n\n    static void set_sync_callback(std::function&lt;void()&gt; callback)\n    {\n        std::lock_guard&lt;std::mutex&gt; lock(_mutex());\n        _sync_callback() = callback;\n    }\n\n    static void call_sync_callback()\n    {\n        if(_sync_callback())\n        {\n            _sync_callback()();\n        }\n    }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/exception_8h/","title":"File exception.h","text":"<p>FileList &gt; muda &gt; exception.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"muda/exception_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/exception_8h/#classes","title":"Classes","text":"Type Name class exception class invalid_argument class logic_error class not_implemented class out_of_range class runtime_error <p>The documentation for this class was generated from the following file <code>src/muda/exception.h</code></p>"},{"location":"muda/exception_8h_source/","title":"File exception.h","text":"<p>File List &gt; muda &gt; exception.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;exception&gt;\n#include &lt;string&gt;\n\nnamespace muda\n{\nclass exception : public std::exception\n{\n    std::string m_what;\n\n  public:\n    exception(const std::string&amp; msg)\n        : m_what(msg)\n    {\n    }\n    virtual char const* what() const\n#ifdef MUDA_PLATFORM_LINUX\n        MUDA_NOEXCEPT\n#endif\n    {\n        return m_what.c_str();\n    }\n};\n\nclass not_implemented : public exception\n{\n  public:\n    not_implemented(const std::string&amp; msg)\n        : exception(msg)\n    {\n    }\n};\n\nclass invalid_argument : public exception\n{\n  public:\n    invalid_argument(const std::string&amp; msg)\n        : exception(msg)\n    {\n    }\n};\n\nclass out_of_range : public exception\n{\n  public:\n    out_of_range(const std::string&amp; msg)\n        : exception(msg)\n    {\n    }\n};\n\nclass runtime_error : public exception\n{\n  public:\n    runtime_error(const std::string&amp; msg)\n        : exception(msg)\n    {\n    }\n};\n\nclass logic_error : public exception\n{\n  public:\n    logic_error(const std::string&amp; msg)\n        : exception(msg)\n    {\n    }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/graph_8h/","title":"File graph.h","text":"<p>FileList &gt; muda &gt; graph.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/graph/graph.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph_launch.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph_graph_viewer.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/graph.h</code></p>"},{"location":"muda/graph_8h_source/","title":"File graph.h","text":"<p>File List &gt; muda &gt; graph.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/graph/graph.h&gt;\n#include &lt;muda/graph/graph_launch.h&gt;\n#include &lt;muda/graph/graph_graph_viewer.h&gt;\n</code></pre>"},{"location":"muda/launch_8h/","title":"File launch.h","text":"<p>FileList &gt; muda &gt; launch.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/launch/stream.h&gt;</code></li> <li><code>#include &lt;muda/launch/event.h&gt;</code></li> <li><code>#include &lt;muda/launch/launch.h&gt;</code></li> <li><code>#include &lt;muda/launch/parallel_for.h&gt;</code></li> <li><code>#include &lt;muda/launch/memory.h&gt;</code></li> <li><code>#include &lt;muda/launch/host_call.h&gt;</code></li> <li><code>#include &lt;muda/launch/kernel.h&gt;</code></li> <li><code>#include &lt;muda/launch/kernel_label.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/launch.h</code></p>"},{"location":"muda/launch_8h_source/","title":"File launch.h","text":"<p>File List &gt; muda &gt; launch.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/launch/stream.h&gt;\n#include &lt;muda/launch/event.h&gt;\n#include &lt;muda/launch/launch.h&gt;\n#include &lt;muda/launch/parallel_for.h&gt;\n#include &lt;muda/launch/memory.h&gt;\n#include &lt;muda/launch/host_call.h&gt;\n#include &lt;muda/launch/kernel.h&gt;\n#include &lt;muda/launch/kernel_label.h&gt;\n</code></pre>"},{"location":"muda/logger_8h/","title":"File logger.h","text":"<p>FileList &gt; muda &gt; logger.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/logger/logger.h&gt;</code></li> <li><code>#include &lt;muda/logger/logger_function.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/logger.h</code></p>"},{"location":"muda/logger_8h_source/","title":"File logger.h","text":"<p>File List &gt; muda &gt; logger.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/logger/logger.h&gt;\n#include &lt;muda/logger/logger_function.h&gt;\n</code></pre>"},{"location":"muda/muda_8h/","title":"File muda.h","text":"<p>FileList &gt; muda &gt; muda.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_config.h&gt;</code></li> <li><code>#include &lt;muda/launch.h&gt;</code></li> <li><code>#include &lt;muda/viewer.h&gt;</code></li> <li><code>#include &lt;muda/print.h&gt;</code></li> <li><code>#include &lt;muda/profiler.h&gt;</code></li> <li><code>#include &lt;muda/assert.h&gt;</code></li> <li><code>#include &lt;muda/graph.h&gt;</code></li> <li><code>#include &lt;muda/container.h&gt;</code></li> <li><code>#include &lt;muda/buffer.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph.h&gt;</code></li> <li><code>#include &lt;muda/logger.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/muda.h</code></p>"},{"location":"muda/muda_8h_source/","title":"File muda.h","text":"<p>File List &gt; muda &gt; muda.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_config.h&gt;\n#include &lt;muda/launch.h&gt;\n#include &lt;muda/viewer.h&gt;\n#include &lt;muda/print.h&gt;\n#include &lt;muda/profiler.h&gt;\n#include &lt;muda/assert.h&gt;\n#include &lt;muda/graph.h&gt;\n#include &lt;muda/container.h&gt;\n#include &lt;muda/buffer.h&gt;\n#include &lt;muda/compute_graph.h&gt;\n#include &lt;muda/logger.h&gt;\n</code></pre>"},{"location":"muda/muda__config_8h/","title":"File muda_config.h","text":"<p>FileList &gt; muda &gt; muda_config.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/muda__config_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace config"},{"location":"muda/muda__config_8h/#macros","title":"Macros","text":"Type Name define MUDA_CHECK_ON  0 define MUDA_COMPUTE_GRAPH_ON  0"},{"location":"muda/muda__config_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/muda__config_8h/#define-muda_check_on","title":"define MUDA_CHECK_ON","text":"<pre><code>#define MUDA_CHECK_ON 0\n</code></pre>"},{"location":"muda/muda__config_8h/#define-muda_compute_graph_on","title":"define MUDA_COMPUTE_GRAPH_ON","text":"<pre><code>#define MUDA_COMPUTE_GRAPH_ON 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/muda_config.h</code></p>"},{"location":"muda/muda__config_8h_source/","title":"File muda_config.h","text":"<p>File List &gt; muda &gt; muda_config.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#ifndef MUDA_CHECK_ON\n#define MUDA_CHECK_ON 0\n#endif\n#ifndef MUDA_COMPUTE_GRAPH_ON\n#define MUDA_COMPUTE_GRAPH_ON 0\n#endif\n\nnamespace muda\n{\nconstexpr bool RUNTIME_CHECK_ON = MUDA_CHECK_ON;\nconstexpr bool COMPUTE_GRAPH_ON = MUDA_COMPUTE_GRAPH_ON;\nnamespace config\n{\n    constexpr bool on(bool cond = false)\n    {\n        return cond &amp;&amp; RUNTIME_CHECK_ON;\n    }\n}  // namespace config\n// debug viewer\nconstexpr bool DEBUG_VIEWER = config::on(true);\n// trap on error happens\nconstexpr bool TRAP_ON_ERROR = config::on(true);\n// light workload block size\nconstexpr int LIGHT_WORKLOAD_BLOCK_SIZE = 256;\n// middle workload block size\nconstexpr int MIDDLE_WORKLOAD_BLOCK_SIZE = 128;\n// heavy workload block size\nconstexpr int HEAVY_WORKLOAD_BLOCK_SIZE = 64;\n}  // namespace muda\n</code></pre>"},{"location":"muda/muda__def_8h/","title":"File muda_def.h","text":"<p>FileList &gt; muda &gt; muda_def.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_config.h&gt;</code></li> <li><code>#include &lt;muda/tools/platform.h&gt;</code></li> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> </ul>"},{"location":"muda/muda__def_8h/#macros","title":"Macros","text":"Type Name define MUDA_CONSTANT  __constant__ define MUDA_CONSTEXPR  constexpr define MUDA_DEPRECATED  [[deprecated]] define MUDA_DEVICE  __device__ define MUDA_FALLTHROUGH  [[fallthrough]] define MUDA_GENERIC define MUDA_GLOBAL  __global__ define MUDA_HOST  __host__ define MUDA_INLINE  inline define MUDA_MANAGED  __managed__ define MUDA_MAYBE_UNUSED  [[maybe_unused]] define MUDA_NODISCARD  [[nodiscard]] define MUDA_NOEXCEPT  noexcept define MUDA_NORETURN  [[noreturn]] define MUDA_REQUIRES (...)  define MUDA_SHARED  __shared__"},{"location":"muda/muda__def_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/muda__def_8h/#define-muda_constant","title":"define MUDA_CONSTANT","text":"<pre><code>#define MUDA_CONSTANT __constant__\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_constexpr","title":"define MUDA_CONSTEXPR","text":"<pre><code>#define MUDA_CONSTEXPR constexpr\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_deprecated","title":"define MUDA_DEPRECATED","text":"<pre><code>#define MUDA_DEPRECATED [[deprecated]]\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_device","title":"define MUDA_DEVICE","text":"<pre><code>#define MUDA_DEVICE __device__\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_fallthrough","title":"define MUDA_FALLTHROUGH","text":"<pre><code>#define MUDA_FALLTHROUGH [[fallthrough]]\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_generic","title":"define MUDA_GENERIC","text":"<pre><code>#define MUDA_GENERIC \n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_global","title":"define MUDA_GLOBAL","text":"<pre><code>#define MUDA_GLOBAL __global__\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_host","title":"define MUDA_HOST","text":"<pre><code>#define MUDA_HOST __host__\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_inline","title":"define MUDA_INLINE","text":"<pre><code>#define MUDA_INLINE inline\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_managed","title":"define MUDA_MANAGED","text":"<pre><code>#define MUDA_MANAGED __managed__\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_maybe_unused","title":"define MUDA_MAYBE_UNUSED","text":"<pre><code>#define MUDA_MAYBE_UNUSED [[maybe_unused]]\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_nodiscard","title":"define MUDA_NODISCARD","text":"<pre><code>#define MUDA_NODISCARD [[nodiscard]]\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_noexcept","title":"define MUDA_NOEXCEPT","text":"<pre><code>#define MUDA_NOEXCEPT noexcept\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_noreturn","title":"define MUDA_NORETURN","text":"<pre><code>#define MUDA_NORETURN [[noreturn]]\n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_requires","title":"define MUDA_REQUIRES","text":"<pre><code>#define MUDA_REQUIRES (\n    ...\n) \n</code></pre>"},{"location":"muda/muda__def_8h/#define-muda_shared","title":"define MUDA_SHARED","text":"<pre><code>#define MUDA_SHARED __shared__\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/muda_def.h</code></p>"},{"location":"muda/muda__def_8h_source/","title":"File muda_def.h","text":"<p>File List &gt; muda &gt; muda_def.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_config.h&gt;\n#include &lt;muda/tools/platform.h&gt;\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n\n#define MUDA_HOST __host__\n#define MUDA_DEVICE __device__\n#define MUDA_GLOBAL __global__\n#define MUDA_CONSTANT __constant__\n#define MUDA_SHARED __shared__\n#define MUDA_MANAGED __managed__\n\n#ifdef __CUDA_ARCH__\n#define MUDA_GENERIC MUDA_HOST MUDA_DEVICE\n#else\n#define MUDA_GENERIC\n#endif\n\n// Attributes\n#define MUDA_NODISCARD [[nodiscard]]\n#define MUDA_DEPRECATED [[deprecated]]\n#define MUDA_FALLTHROUGH [[fallthrough]]\n#define MUDA_MAYBE_UNUSED [[maybe_unused]]\n#define MUDA_NORETURN [[noreturn]]\n\n// Keywords\n#define MUDA_NOEXCEPT noexcept\n#define MUDA_INLINE inline\n#define MUDA_CONSTEXPR constexpr\n\n// Concepts\n#if MUDA_HAS_CXX20\n#define MUDA_REQUIRES(...) requires (__VA_ARGS__)\n#else\n#define MUDA_REQUIRES(...)\n#endif\n</code></pre>"},{"location":"muda/print_8h/","title":"File print.h","text":"<p>FileList &gt; muda &gt; print.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdio&gt;</code></li> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> </ul>"},{"location":"muda/print_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/print.h</code></p>"},{"location":"muda/print_8h_source/","title":"File print.h","text":"<p>File List &gt; muda &gt; print.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdio&gt;\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename InType, typename OutType = InType&gt;\nMUDA_INLINE MUDA_GENERIC OutType print_convert(const InType&amp; v)\n{\n    return v;\n}\n\nMUDA_INLINE MUDA_GENERIC auto print_convert(const char* v)\n{\n    return v;\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC const T&amp; print_check(const T&amp; t)\n{\n    static_assert(std::is_arithmetic_v&lt;T&gt; || std::is_pointer_v&lt;T&gt;\n                      || std::is_same_v&lt;T, std::nullptr_t&gt;,\n                  \"not supported type T in printf!\");\n    return t;\n}\n\nMUDA_INLINE MUDA_GENERIC auto print_check(const char* t)\n{\n    return t;\n}\n\ntemplate &lt;typename... Args&gt;\nMUDA_INLINE MUDA_GENERIC void print(const char* const fmt, Args&amp;&amp;... arg)\n{\n    ::printf(fmt, print_check(print_convert(std::forward&lt;Args&gt;(arg)))...);\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/profiler_8h/","title":"File profiler.h","text":"<p>FileList &gt; muda &gt; profiler.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;device_launch_parameters.h&gt;</code></li> <li><code>#include &lt;cuda_profiler_api.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cuda_errors.h&gt;</code></li> </ul>"},{"location":"muda/profiler_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/profiler_8h/#classes","title":"Classes","text":"Type Name class Profile class RangeName <p>The documentation for this class was generated from the following file <code>src/muda/profiler.h</code></p>"},{"location":"muda/profiler_8h_source/","title":"File profiler.h","text":"<p>File List &gt; muda &gt; profiler.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;chrono&gt;\n\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;device_launch_parameters.h&gt;\n\n#include &lt;cuda_profiler_api.h&gt;\n\n#if MUDA_WITH_NVTX3\n#include &lt;nvtx3/nvToolsExt.h&gt;\n#include &lt;nvtx3/nvToolsExtCuda.h&gt;\n#endif\n\n#include &lt;muda/check/check_cuda_errors.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename F&gt;\nMUDA_HOST double profile_host(F&amp;&amp; f)\n{\n    using namespace std::chrono;\n    wait_device();\n    auto start = high_resolution_clock::now();\n    f();\n    wait_device();\n    auto end = high_resolution_clock::now();\n    return duration_cast&lt;microseconds&gt;(end - start).count() / 1000.0;\n}\n\nclass Profile\n{\n    bool need_pop;\n\n  public:\n    Profile() MUDA_NOEXCEPT : need_pop(false)\n    {\n        checkCudaErrors(cudaProfilerStart());\n    }\n    Profile(const std::string&amp; name) MUDA_NOEXCEPT : need_pop(true)\n    {\n#if MUDA_WITH_NVTX3\n        nvtxEventAttributes_t eventAttrib = {0};\n        eventAttrib.version               = NVTX_VERSION;\n        eventAttrib.size                  = NVTX_EVENT_ATTRIB_STRUCT_SIZE;\n        eventAttrib.colorType             = NVTX_COLOR_ARGB;\n        eventAttrib.color                 = 255;\n        eventAttrib.messageType           = NVTX_MESSAGE_TYPE_ASCII;\n        eventAttrib.message.ascii         = name.c_str();\n        nvtxRangePushEx(&amp;eventAttrib);\n#endif\n        checkCudaErrors(cudaProfilerStart());\n    }\n    ~Profile()\n    {\n        checkCudaErrors(cudaProfilerStop());\n#if MUDA_WITH_NVTX3\n        if(need_pop)\n            nvtxRangePop();\n#endif\n    }\n};\n\nclass RangeName\n{\n  public:\n    RangeName(const std::string&amp; name) MUDA_NOEXCEPT\n    {\n#if MUDA_WITH_NVTX3\n        nvtxEventAttributes_t eventAttrib = {0};\n        eventAttrib.version               = NVTX_VERSION;\n        eventAttrib.size                  = NVTX_EVENT_ATTRIB_STRUCT_SIZE;\n        eventAttrib.colorType             = NVTX_COLOR_ARGB;\n        eventAttrib.color                 = 255;\n        eventAttrib.messageType           = NVTX_MESSAGE_TYPE_ASCII;\n        eventAttrib.message.ascii         = name.c_str();\n        nvtxRangePushEx(&amp;eventAttrib);\n#endif\n    }\n\n    ~RangeName() { \n#if MUDA_WITH_NVTX3\n        nvtxRangePop();\n#endif\n    }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_9b44f68c181db0b11e9502e462454d05/","title":"Dir src/muda/buffer","text":"<p>FileList &gt; buffer</p>"},{"location":"muda/dir_9b44f68c181db0b11e9502e462454d05/#files","title":"Files","text":"Type Name file agent.h file buffer_2d_view.h file buffer_3d_view.h file buffer_fwd.h file buffer_info_accessor.h file buffer_launch.h file buffer_view.h A view interface for any array-like liner memory, which can be constructed from DeviceBuffer/DeviceVector or any thing that is a array-like liner memory, e.g. raw cuda pointer. file device_buffer.h A light-weight wrapper of cuda device memory. Like <code>std::vector</code> , allow user to resize, reserve, shrink_to_fit, fill, also provide muda viewer for in-kernel access. file device_buffer_2d.h file device_buffer_3d.h A light-weight wrapper of cuda device memory3D, allows user to resize, reserve, shrink_to_fit, fill, also provide muda viewer for in-kernel access. file device_var.h file graph_buffer_2d_view.h file graph_buffer_3d_view.h file graph_buffer_view.h file graph_var_view.h file var_view.h"},{"location":"muda/dir_9b44f68c181db0b11e9502e462454d05/#directories","title":"Directories","text":"Type Name dir agent dir reshape_nd <p>The documentation for this class was generated from the following file <code>src/muda/buffer/</code></p>"},{"location":"muda/agent_8h/","title":"File agent.h","text":"<p>FileList &gt; buffer &gt; agent.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/agent/kernel_assign.h&gt;</code></li> <li><code>#include &lt;muda/buffer/agent/kernel_construct.h&gt;</code></li> <li><code>#include &lt;muda/buffer/agent/kernel_copy_construct.h&gt;</code></li> <li><code>#include &lt;muda/buffer/agent/kernel_destruct.h&gt;</code></li> <li><code>#include &lt;muda/buffer/agent/kernel_fill.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/agent.h</code></p>"},{"location":"muda/agent_8h_source/","title":"File agent.h","text":"<p>File List &gt; buffer &gt; agent.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/agent/kernel_assign.h&gt;\n#include &lt;muda/buffer/agent/kernel_construct.h&gt;\n#include &lt;muda/buffer/agent/kernel_copy_construct.h&gt;\n#include &lt;muda/buffer/agent/kernel_destruct.h&gt;\n#include &lt;muda/buffer/agent/kernel_fill.h&gt;\n</code></pre>"},{"location":"muda/buffer__2d__view_8h/","title":"File buffer_2d_view.h","text":"<p>FileList &gt; buffer &gt; buffer_2d_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;muda/type_traits/type_modifier.h&gt;</code></li> <li><code>#include &lt;muda/viewer/dense/dense_2d.h&gt;</code></li> <li><code>#include &lt;muda/tools/extent.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_info_accessor.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include \"details/buffer_2d_view.inl\"</code></li> </ul>"},{"location":"muda/buffer__2d__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/buffer__2d__view_8h/#classes","title":"Classes","text":"Type Name class Buffer2DViewT &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_2d_view.h</code></p>"},{"location":"muda/buffer__2d__view_8h_source/","title":"File buffer_2d_view.h","text":"<p>File List &gt; buffer &gt; buffer_2d_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;cinttypes&gt;\n#include &lt;muda/type_traits/type_modifier.h&gt;\n#include &lt;muda/viewer/dense/dense_2d.h&gt;\n#include &lt;muda/tools/extent.h&gt;\n#include &lt;muda/buffer/buffer_info_accessor.h&gt;\n#include &lt;muda/view/view_base.h&gt;\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass Buffer2DViewT : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;T&gt;;\n\n    friend class BufferLaunch;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class Buffer2DViewT;\n\n\n  public:\n    static_assert(!std::is_const_v&lt;T&gt;, \"Ty must be non-const\");\n    using ConstView = Buffer2DViewT&lt;true, T&gt;;\n    using ThisView  = Buffer2DViewT&lt;IsConst, T&gt;;\n\n    using CViewer    = CDense2D&lt;T&gt;;\n    using Viewer     = Dense2D&lt;T&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n\n  private:\n    friend class details::buffer::BufferInfoAccessor;\n\n  protected:\n    auto_const_t&lt;T&gt;* m_data          = nullptr;\n    size_t           m_pitch_bytes   = ~0;\n    size_t           m_origin_width  = 0;\n    size_t           m_origin_height = 0;\n    Offset2D         m_offset;\n    Extent2D         m_extent;\n\n  public:\n    MUDA_GENERIC Buffer2DViewT() MUDA_NOEXCEPT = default;\n\n    MUDA_GENERIC Buffer2DViewT(const Buffer2DViewT&amp;) MUDA_NOEXCEPT = default;\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC Buffer2DViewT(const Buffer2DViewT&lt;OtherIsConst, T&gt;&amp; other) MUDA_NOEXCEPT\n        MUDA_REQUIRES(!OtherIsConst);\n\n    MUDA_GENERIC Buffer2DViewT(auto_const_t&lt;T&gt;* data,\n                               size_t           pitch_bytes,\n                               size_t           origin_width,\n                               size_t           origin_height,\n                               const Offset2D&amp;  offset,\n                               const Extent2D&amp;  extent) MUDA_NOEXCEPT;\n\n    MUDA_GENERIC Buffer2DViewT(auto_const_t&lt;T&gt;* data,\n                               size_t           pitch_bytes,\n                               const Offset2D&amp;  offset,\n                               const Extent2D&amp;  extent) MUDA_NOEXCEPT;\n\n    MUDA_GENERIC ConstView as_const() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data(size_t x, size_t y) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data(size_t flatten_i) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* origin_data() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC ThisView subview(Offset2D offset, Extent2D extent = {}) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC Extent2D extent() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC size_t pitch_bytes() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC Offset2D offset() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC size_t total_size() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC CViewer cviewer() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC ThisViewer viewer() const MUDA_NOEXCEPT;\n\n    MUDA_HOST void copy_to(T* host) const;\n\n    MUDA_HOST void fill(const T&amp; v) MUDA_REQUIRES(!IsConst);\n\n    MUDA_HOST void copy_from(const Buffer2DViewT&lt;true, T&gt;&amp; other) MUDA_REQUIRES(!IsConst);\n\n    MUDA_HOST void copy_from(const T* host) MUDA_REQUIRES(!IsConst);\n\n  private:\n    MUDA_HOST cudaPitchedPtr cuda_pitched_ptr() const MUDA_NOEXCEPT;\n};\n\ntemplate &lt;typename T&gt;\nusing Buffer2DView = Buffer2DViewT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CBuffer2DView = Buffer2DViewT&lt;true, T&gt;;\n\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;Buffer2DView&lt;T&gt;&gt;\n{\n    using type = CBuffer2DView&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CBuffer2DView&lt;T&gt;&gt;\n{\n    using type = Buffer2DView&lt;T&gt;;\n};\n}  // namespace muda\n\n#include \"details/buffer_2d_view.inl\"\n</code></pre>"},{"location":"muda/buffer__3d__view_8h/","title":"File buffer_3d_view.h","text":"<p>FileList &gt; buffer &gt; buffer_3d_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;muda/type_traits/type_modifier.h&gt;</code></li> <li><code>#include &lt;muda/viewer/dense/dense_3d.h&gt;</code></li> <li><code>#include &lt;muda/tools/extent.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_info_accessor.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include \"details/buffer_3d_view.inl\"</code></li> </ul>"},{"location":"muda/buffer__3d__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/buffer__3d__view_8h/#classes","title":"Classes","text":"Type Name class Buffer3DViewT &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_3d_view.h</code></p>"},{"location":"muda/buffer__3d__view_8h_source/","title":"File buffer_3d_view.h","text":"<p>File List &gt; buffer &gt; buffer_3d_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;cinttypes&gt;\n#include &lt;muda/type_traits/type_modifier.h&gt;\n#include &lt;muda/viewer/dense/dense_3d.h&gt;\n#include &lt;muda/tools/extent.h&gt;\n#include &lt;muda/buffer/buffer_info_accessor.h&gt;\n#include &lt;muda/view/view_base.h&gt;\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass Buffer3DViewT : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class Buffer3DViewT;\n\n  public:\n    static_assert(!std::is_const_v&lt;T&gt;, \"Ty must be non-const\");\n    using ConstView    = Buffer3DViewT&lt;true, T&gt;;\n    using NonConstView = Buffer3DViewT&lt;false, T&gt;;\n    using ThisView     = Buffer3DViewT&lt;IsConst, T&gt;;\n    using OtherView    = Buffer3DViewT&lt;!IsConst, T&gt;;\n\n    using CViewer    = CDense3D&lt;T&gt;;\n    using Viewer     = Dense3D&lt;T&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n\n  private:\n    friend class BufferLaunch;\n    friend class details::buffer::BufferInfoAccessor;\n\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n  protected:\n    auto_const_t&lt;T&gt;* m_data             = nullptr;\n    size_t           m_pitch_bytes      = ~0;\n    size_t           m_pitch_bytes_area = ~0;\n    size_t           m_origin_width     = ~0;\n    size_t           m_origin_height    = ~0;\n\n    Offset3D m_offset;\n    Extent3D m_extent;\n\n  public:\n    MUDA_GENERIC Buffer3DViewT() MUDA_NOEXCEPT = default;\n\n    MUDA_GENERIC Buffer3DViewT(const Buffer3DViewT&amp;) MUDA_NOEXCEPT = default;\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC Buffer3DViewT(const Buffer3DViewT&lt;OtherIsConst, T&gt;&amp; other) MUDA_NOEXCEPT;\n\n    MUDA_GENERIC\n    Buffer3DViewT(auto_const_t&lt;T&gt;* data,\n                  size_t           pitch_bytes,\n                  size_t           pitch_bytes_area,\n                  size_t           origin_width,\n                  size_t           origin_height,\n                  const Offset3D&amp;  offset,\n                  const Extent3D&amp;  extent) MUDA_NOEXCEPT;\n\n    MUDA_GENERIC Buffer3DViewT(T*              data,\n                               size_t          pitch_bytes,\n                               size_t          pitch_bytes_area,\n                               const Offset3D&amp; offset,\n                               const Extent3D&amp; extent) MUDA_NOEXCEPT;\n\n\n    MUDA_GENERIC ConstView as_const() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data(size_t x, size_t y, size_t z) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data(size_t flatten_i) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* origin_data() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC ThisView subview(Offset3D offset, Extent3D extent = {}) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC ThisViewer viewer() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC Extent3D extent() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC Offset3D offset() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC size_t pitch_bytes() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC size_t pitch_bytes_area() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC size_t total_size() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC CViewer cviewer() const MUDA_NOEXCEPT;\n\n    MUDA_HOST void fill(const T&amp; v) const MUDA_REQUIRES(!IsConst);\n\n    MUDA_HOST void copy_from(const Buffer3DViewT&lt;true, T&gt;&amp; other) const\n        MUDA_REQUIRES(!IsConst);\n\n    MUDA_HOST void copy_from(const T* host) const MUDA_REQUIRES(!IsConst);\n\n    MUDA_HOST void copy_to(T* host) const;\n\n  private:\n    MUDA_GENERIC cudaPitchedPtr cuda_pitched_ptr() const MUDA_NOEXCEPT;\n};\n\ntemplate &lt;typename T&gt;\nusing Buffer3DView = Buffer3DViewT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CBuffer3DView = Buffer3DViewT&lt;true, T&gt;;\n\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;Buffer3DView&lt;T&gt;&gt;\n{\n    using type = CBuffer3DView&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CBuffer3DView&lt;T&gt;&gt;\n{\n    using type = Buffer3DView&lt;T&gt;;\n};\n}  // namespace muda\n\n#include \"details/buffer_3d_view.inl\"\n</code></pre>"},{"location":"muda/buffer__fwd_8h/","title":"File buffer_fwd.h","text":"<p>FileList &gt; buffer &gt; buffer_fwd.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/buffer__fwd_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_fwd.h</code></p>"},{"location":"muda/buffer__fwd_8h_source/","title":"File buffer_fwd.h","text":"<p>File List &gt; buffer &gt; buffer_fwd.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass VarViewT;\n\ntemplate &lt;typename T&gt;\nusing VarView = VarViewT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CVarView = VarViewT&lt;true, T&gt;;\n\n\ntemplate &lt;bool IsConst, typename T&gt;\nclass BufferViewT;\n\ntemplate &lt;typename T&gt;\nusing BufferView = BufferViewT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CBufferView = BufferViewT&lt;true, T&gt;;\n\n\ntemplate &lt;bool IsConst, typename T&gt;\nclass Buffer2DViewT;\n\ntemplate &lt;typename T&gt;\nusing Buffer2DView = Buffer2DViewT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CBuffer2DView = Buffer2DViewT&lt;true, T&gt;;\n\n\ntemplate &lt;bool IsConst, typename T&gt;\nclass Buffer3DViewT;\n\ntemplate &lt;typename T&gt;\nusing Buffer3DView = Buffer3DViewT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CBuffer3DView = Buffer3DViewT&lt;true, T&gt;;\n\n\ntemplate &lt;typename T&gt;\nclass DeviceVar;\n\ntemplate &lt;typename T&gt;\nclass DeviceBuffer;\n\ntemplate &lt;typename T&gt;\nclass DeviceBuffer2D;\n\ntemplate &lt;typename T&gt;\nclass DeviceBuffer3D;\n}  // namespace muda\n</code></pre>"},{"location":"muda/buffer__info__accessor_8h/","title":"File buffer_info_accessor.h","text":"<p>FileList &gt; buffer &gt; buffer_info_accessor.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"muda/buffer__info__accessor_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace buffer"},{"location":"muda/buffer__info__accessor_8h/#classes","title":"Classes","text":"Type Name class BufferInfoAccessor <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_info_accessor.h</code></p>"},{"location":"muda/buffer__info__accessor_8h_source/","title":"File buffer_info_accessor.h","text":"<p>File List &gt; buffer &gt; buffer_info_accessor.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;utility&gt;\nnamespace muda::details::buffer\n{\nclass BufferInfoAccessor\n{\n  public:\n    template &lt;typename BufferView&gt;\n    static auto cuda_pitched_ptr(BufferView&amp;&amp; b)\n    {\n        return std::forward&lt;BufferView&gt;(b).cuda_pitched_ptr();\n    }\n};\n}  // namespace muda::details::buffer\n</code></pre>"},{"location":"muda/buffer__launch_8h/","title":"File buffer_launch.h","text":"<p>FileList &gt; buffer &gt; buffer_launch.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/launch/launch_base.h&gt;</code></li> <li><code>#include &lt;muda/muda_config.h&gt;</code></li> <li><code>#include &lt;muda/tools/extent.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_fwd.h&gt;</code></li> <li><code>#include \"details/buffer_launch.inl\"</code></li> </ul>"},{"location":"muda/buffer__launch_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/buffer__launch_8h/#classes","title":"Classes","text":"Type Name class BufferLaunch <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_launch.h</code></p>"},{"location":"muda/buffer__launch_8h_source/","title":"File buffer_launch.h","text":"<p>File List &gt; buffer &gt; buffer_launch.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/launch/launch_base.h&gt;\n#include &lt;muda/muda_config.h&gt;\n#include &lt;muda/tools/extent.h&gt;\n#include &lt;muda/buffer/buffer_fwd.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass ComputeGraphVar;\n\nclass BufferLaunch : public LaunchBase&lt;BufferLaunch&gt;\n{\n    int m_grid_dim  = 0;\n    int m_block_dim = -1;  // we use automatic block dim choose as default.\n\n  public:\n    // default config\n    MUDA_HOST BufferLaunch(cudaStream_t s = nullptr) MUDA_NOEXCEPT : LaunchBase(s)\n    {\n    }\n\n    MUDA_HOST BufferLaunch(int block_dim, cudaStream_t s = nullptr) MUDA_NOEXCEPT\n        : LaunchBase(s),\n          m_block_dim(block_dim)\n    {\n    }\n\n    MUDA_HOST BufferLaunch(int grid_dim, int block_dim, cudaStream_t s = nullptr) MUDA_NOEXCEPT\n        : LaunchBase(s),\n          m_grid_dim(grid_dim),\n          m_block_dim(block_dim)\n    {\n    }\n\n    /**********************************************************************************************\n    * \n    * Buffer API\n    * 0D DeviceVar\n    * 1D DeviceBuffer\n    * 2D DeviceBuffer2D\n    * 3D DeviceBuffer3D\n    * \n    ***********************************************************************************************/\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; resize(DeviceBuffer&lt;T&gt;&amp; buffer, size_t size);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; resize(DeviceBuffer2D&lt;T&gt;&amp; buffer, Extent2D extent);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; resize(DeviceBuffer3D&lt;T&gt;&amp; buffer, Extent3D extent);\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; reserve(DeviceBuffer&lt;T&gt;&amp; buffer, size_t capacity);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; reserve(DeviceBuffer2D&lt;T&gt;&amp; buffer, Extent2D capacity);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; reserve(DeviceBuffer3D&lt;T&gt;&amp; buffer, Extent3D capacity);\n\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; resize(DeviceBuffer&lt;T&gt;&amp; buffer, size_t size, const T&amp; val);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; resize(DeviceBuffer2D&lt;T&gt;&amp; buffer, Extent2D extent, const T&amp; val);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; resize(DeviceBuffer3D&lt;T&gt;&amp; buffer, Extent3D extent, const T&amp; val);\n\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; clear(DeviceBuffer&lt;T&gt;&amp; buffer);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; clear(DeviceBuffer2D&lt;T&gt;&amp; buffer);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; clear(DeviceBuffer3D&lt;T&gt;&amp; buffer);\n\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; alloc(DeviceBuffer&lt;T&gt;&amp; buffer, size_t n);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; alloc(DeviceBuffer2D&lt;T&gt;&amp; buffer, Extent2D extent);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; alloc(DeviceBuffer3D&lt;T&gt;&amp; buffer, Extent3D extent);\n\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; free(DeviceBuffer&lt;T&gt;&amp; buffer);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; free(DeviceBuffer2D&lt;T&gt;&amp; buffer);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; free(DeviceBuffer3D&lt;T&gt;&amp; buffer);\n\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; shrink_to_fit(DeviceBuffer&lt;T&gt;&amp; buffer);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; shrink_to_fit(DeviceBuffer2D&lt;T&gt;&amp; buffer);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; shrink_to_fit(DeviceBuffer3D&lt;T&gt;&amp; buffer);\n\n    /**********************************************************************************************\n    * \n    * BufferView Copy: Device &lt;- Device\n    * \n    **********************************************************************************************/\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(VarView&lt;T&gt; dst, CVarView&lt;T&gt; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(BufferView&lt;T&gt; dst, CBufferView&lt;T&gt; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(Buffer2DView&lt;T&gt; dst, CBuffer2DView&lt;T&gt; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(Buffer3DView&lt;T&gt; dst, CBuffer3DView&lt;T&gt; src);\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;VarView&lt;T&gt;&gt;&amp;       dst,\n                                 const ComputeGraphVar&lt;VarView&lt;T&gt;&gt;&amp; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;BufferView&lt;T&gt;&gt;&amp;       dst,\n                                 const ComputeGraphVar&lt;BufferView&lt;T&gt;&gt;&amp; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;Buffer2DView&lt;T&gt;&gt;&amp;       dst,\n                                 const ComputeGraphVar&lt;Buffer2DView&lt;T&gt;&gt;&amp; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;Buffer3DView&lt;T&gt;&gt;&amp;       dst,\n                                 const ComputeGraphVar&lt;Buffer3DView&lt;T&gt;&gt;&amp; src);\n\n    /**********************************************************************************************\n    * \n    * BufferView Copy: Host &lt;- Device\n    * \n    **********************************************************************************************/\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(T* dst, CVarView&lt;T&gt; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(T* dst, CBufferView&lt;T&gt; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(T* dst, CBuffer2DView&lt;T&gt; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(T* dst, CBuffer3DView&lt;T&gt; src);\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;T*&gt;&amp;                  dst,\n                                 const ComputeGraphVar&lt;BufferView&lt;T&gt;&gt;&amp; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;T*&gt;&amp;                    dst,\n                                 const ComputeGraphVar&lt;Buffer2DView&lt;T&gt;&gt;&amp; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;T*&gt;&amp;               dst,\n                                 const ComputeGraphVar&lt;VarView&lt;T&gt;&gt;&amp; src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;T*&gt;&amp;                    dst,\n                                 const ComputeGraphVar&lt;Buffer3DView&lt;T&gt;&gt;&amp; src);\n\n    /**********************************************************************************************\n    * \n    * BufferView Copy: Device &lt;- Host\n    * \n    **********************************************************************************************/\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(VarView&lt;T&gt; dst, const T* src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(BufferView&lt;T&gt; dst, const T* src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(Buffer2DView&lt;T&gt; dst, const T* src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(Buffer3DView&lt;T&gt; dst, const T* src);\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;BufferView&lt;T&gt;&gt;&amp; dst,\n                                 const ComputeGraphVar&lt;T*&gt;&amp;      src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;Buffer2DView&lt;T&gt;&gt;&amp; dst,\n                                 const ComputeGraphVar&lt;T*&gt;&amp;        src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;VarView&lt;T&gt;&gt;&amp; dst,\n                                 const ComputeGraphVar&lt;T*&gt;&amp;   src);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; copy(ComputeGraphVar&lt;Buffer3DView&lt;T&gt;&gt;&amp; dst,\n                                 const ComputeGraphVar&lt;T*&gt;&amp;        src);\n\n    /**********************************************************************************************\n    * \n    * BufferView Scatter: Device &lt;- Host\n    * \n    **********************************************************************************************/\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; fill(VarView&lt;T&gt; buffer, const T&amp; val);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; fill(BufferView&lt;T&gt; buffer, const T&amp; val);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; fill(Buffer2DView&lt;T&gt; buffer, const T&amp; val);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; fill(Buffer3DView&lt;T&gt; buffer, const T&amp; val);\n\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; fill(ComputeGraphVar&lt;VarView&lt;T&gt;&gt;&amp; buffer,\n                                 const ComputeGraphVar&lt;T&gt;&amp;    val);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; fill(ComputeGraphVar&lt;BufferView&lt;T&gt;&gt;&amp; buffer,\n                                 const ComputeGraphVar&lt;T&gt;&amp;       val);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; fill(ComputeGraphVar&lt;Buffer2DView&lt;T&gt;&gt;&amp; buffer,\n                                 const ComputeGraphVar&lt;T&gt;&amp;         val);\n    template &lt;typename T&gt;\n    MUDA_HOST BufferLaunch&amp; fill(ComputeGraphVar&lt;Buffer3DView&lt;T&gt;&gt;&amp; buffer,\n                                 const ComputeGraphVar&lt;T&gt;&amp;         val);\n\n  private:\n    template &lt;typename T, typename FConstruct&gt;\n    MUDA_HOST BufferLaunch&amp; resize(DeviceBuffer&lt;T&gt;&amp; buffer, size_t new_size, FConstruct&amp;&amp; fct);\n\n    template &lt;typename T, typename FConstruct&gt;\n    MUDA_HOST BufferLaunch&amp; resize(DeviceBuffer2D&lt;T&gt;&amp; buffer, Extent2D new_extent, FConstruct&amp;&amp; fct);\n\n    template &lt;typename T, typename FConstruct&gt;\n    MUDA_HOST BufferLaunch&amp; resize(DeviceBuffer3D&lt;T&gt;&amp; buffer, Extent3D new_extent, FConstruct&amp;&amp; fct);\n};\n}  // namespace muda\n\n#include \"details/buffer_launch.inl\"\n</code></pre>"},{"location":"muda/buffer__view_8h/","title":"File buffer_view.h","text":"<p>FileList &gt; buffer &gt; buffer_view.h</p> <p>Go to the source code of this file</p> <p>A view interface for any array-like liner memory, which can be constructed from DeviceBuffer/DeviceVector or any thing that is a array-like liner memory, e.g. raw cuda pointer. More...</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;muda/type_traits/type_modifier.h&gt;</code></li> <li><code>#include &lt;muda/viewer/dense/dense_1d.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_fwd.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include \"details/buffer_view.inl\"</code></li> </ul>"},{"location":"muda/buffer__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/buffer__view_8h/#classes","title":"Classes","text":"Type Name class BufferViewT &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt;"},{"location":"muda/buffer__view_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>MuGdxy </p> <p>Date:</p> <p>January 2024 </p> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/buffer_view.h</code></p>"},{"location":"muda/buffer__view_8h_source/","title":"File buffer_view.h","text":"<p>File List &gt; buffer &gt; buffer_view.h</p> <p>Go to the documentation of this file</p> <pre><code>/*****************************************************************/ \n#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;cinttypes&gt;\n#include &lt;muda/type_traits/type_modifier.h&gt;\n#include &lt;muda/viewer/dense/dense_1d.h&gt;\n#include &lt;muda/buffer/buffer_fwd.h&gt;\n#include &lt;muda/view/view_base.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass BufferViewT : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class BufferViewT;\n\n  public:\n    static_assert(!std::is_const_v&lt;T&gt;, \"Ty must be non-const\");\n    using ConstView = BufferViewT&lt;true, T&gt;;\n    using ThisView  = BufferViewT&lt;IsConst, T&gt;;\n\n    using CViewer    = CDense1D&lt;T&gt;;\n    using Viewer     = Dense1D&lt;T&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n  protected:\n    auto_const_t&lt;T&gt;* m_data   = nullptr;\n    size_t           m_offset = ~0;\n    size_t           m_size   = ~0;\n\n  public:\n    MUDA_GENERIC BufferViewT() MUDA_NOEXCEPT = default;\n\n    MUDA_GENERIC BufferViewT(const BufferViewT&amp; other) MUDA_NOEXCEPT = default;\n\n    MUDA_GENERIC BufferViewT(auto_const_t&lt;T&gt;* data, size_t offset, size_t size) MUDA_NOEXCEPT;\n\n    MUDA_GENERIC BufferViewT(auto_const_t&lt;T&gt;* data, size_t size) MUDA_NOEXCEPT;\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC BufferViewT(const BufferViewT&lt;OtherIsConst, T&gt;&amp; other) MUDA_NOEXCEPT\n        MUDA_REQUIRES(!OtherIsConst);\n\n    MUDA_GENERIC ConstView as_const() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data(size_t i) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* origin_data() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC ThisView subview(size_t offset, size_t size = ~0) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC ThisViewer viewer() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC CViewer cviewer() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC size_t size() const MUDA_NOEXCEPT { return m_size; }\n\n    MUDA_GENERIC size_t offset() const MUDA_NOEXCEPT { return m_offset; }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator[](size_t i) const MUDA_NOEXCEPT;\n\n    MUDA_HOST void copy_from(const BufferViewT&lt;true, T&gt;&amp; other) const\n        MUDA_REQUIRES(!IsConst);\n\n    MUDA_HOST void fill(const T&amp; value) const MUDA_REQUIRES(!IsConst);\n\n    MUDA_HOST void copy_from(const T* host) const MUDA_REQUIRES(!IsConst);\n\n    MUDA_HOST void copy_to(T* host) const;\n\n    /**********************************************************************************\n    * BufferView As Iterator\n    ***********************************************************************************/\n\n    // Random Access Iterator Interface\n    using value_type        = T;\n    using reference         = T&amp;;\n    using pointer           = T*;\n    using iterator_category = std::random_access_iterator_tag;\n    using difference_type   = size_t;\n\n    MUDA_GENERIC ThisView  operator+(int i) const MUDA_NOEXCEPT;\n    MUDA_GENERIC reference operator*() const MUDA_NOEXCEPT;\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator[](int i) const MUDA_NOEXCEPT;\n};\n\ntemplate &lt;typename T&gt;\nusing BufferView = BufferViewT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CBufferView = BufferViewT&lt;true, T&gt;;\n\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;BufferView&lt;T&gt;&gt;\n{\n    using type = CBufferView&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CBufferView&lt;T&gt;&gt;\n{\n    using type = BufferView&lt;T&gt;;\n};\n}  // namespace muda\n\n#include \"details/buffer_view.inl\"\n</code></pre>"},{"location":"muda/device__buffer_8h/","title":"File device_buffer.h","text":"<p>FileList &gt; buffer &gt; device_buffer.h</p> <p>Go to the source code of this file</p> <p>A light-weight wrapper of cuda device memory. Like <code>std::vector</code> , allow user to resize, reserve, shrink_to_fit, fill, also provide muda viewer for in-kernel access.More...</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;muda/viewer/dense.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_view.h&gt;</code></li> <li><code>#include \"details/device_buffer.inl\"</code></li> </ul>"},{"location":"muda/device__buffer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__buffer_8h/#classes","title":"Classes","text":"Type Name class DeviceBuffer &lt;typename T&gt;A <code>std::vector</code> like wrapper of cuda device memory, allows user to:"},{"location":"muda/device__buffer_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>MuGdxy </p> <p>Date:</p> <p>January 2024 </p> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/device_buffer.h</code></p>"},{"location":"muda/device__buffer_8h_source/","title":"File device_buffer.h","text":"<p>File List &gt; buffer &gt; device_buffer.h</p> <p>Go to the documentation of this file</p> <pre><code>/*****************************************************************/\n\n#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;vector&gt;\n#include &lt;muda/viewer/dense.h&gt;\n#include &lt;muda/buffer/buffer_view.h&gt;\n\nnamespace muda\n{\nclass NDReshaper;\n\ntemplate &lt;typename T&gt;\nclass DeviceVector;\n\ntemplate &lt;typename T&gt;\nclass HostVector;\n\n\ntemplate &lt;typename T&gt;\nclass DeviceBuffer\n{\n  private:\n    friend class BufferLaunch;\n    friend class NDReshaper;\n\n    size_t m_size     = 0;\n    size_t m_capacity = 0;\n    T*     m_data     = nullptr;\n\n  public:\n    using value_type = T;\n\n    DeviceBuffer(size_t n);\n    DeviceBuffer();\n\n    DeviceBuffer(const DeviceBuffer&lt;T&gt;&amp; other);\n    DeviceBuffer(DeviceBuffer&amp;&amp; other) MUDA_NOEXCEPT;\n    DeviceBuffer&amp; operator=(const DeviceBuffer&lt;T&gt;&amp; other);\n    DeviceBuffer&amp; operator=(DeviceBuffer&lt;T&gt;&amp;&amp; other);\n\n    DeviceBuffer(CBufferView&lt;T&gt; other);\n    DeviceBuffer(const std::vector&lt;T&gt;&amp; host);\n    DeviceBuffer&amp; operator=(CBufferView&lt;T&gt; other);\n    DeviceBuffer&amp; operator=(const std::vector&lt;T&gt;&amp; other);\n\n    void copy_to(std::vector&lt;T&gt;&amp; host) const;\n    void copy_from(const std::vector&lt;T&gt;&amp; host);\n\n    void resize(size_t new_size);\n    void resize(size_t new_size, const T&amp; value);\n    void reserve(size_t new_capacity);\n    void clear();\n    void shrink_to_fit();\n    void fill(const T&amp; v);\n\n    Dense1D&lt;T&gt;  viewer() MUDA_NOEXCEPT;\n    CDense1D&lt;T&gt; cviewer() const MUDA_NOEXCEPT;\n\n    BufferView&lt;T&gt;  view(size_t offset, size_t size = ~0) MUDA_NOEXCEPT;\n    BufferView&lt;T&gt;  view() MUDA_NOEXCEPT;\n    CBufferView&lt;T&gt; view(size_t offset, size_t size = ~0) const MUDA_NOEXCEPT;\n    CBufferView&lt;T&gt; view() const MUDA_NOEXCEPT;\n    operator BufferView&lt;T&gt;() MUDA_NOEXCEPT { return view(); }\n    operator CBufferView&lt;T&gt;() const MUDA_NOEXCEPT { return view(); }\n\n    ~DeviceBuffer();\n\n    auto     size() const MUDA_NOEXCEPT { return m_size; }\n    auto     capacity() const MUDA_NOEXCEPT { return m_capacity; }\n    T*       data() MUDA_NOEXCEPT { return m_data; }\n    const T* data() const MUDA_NOEXCEPT { return m_data; }\n};\n}  // namespace muda\n\n#include \"details/device_buffer.inl\"\n</code></pre>"},{"location":"muda/device__buffer__2d_8h/","title":"File device_buffer_2d.h","text":"<p>FileList &gt; buffer &gt; device_buffer_2d.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;muda/viewer/dense.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_2d_view.h&gt;</code></li> <li><code>#include \"details/device_buffer_2d.inl\"</code></li> </ul>"},{"location":"muda/device__buffer__2d_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__buffer__2d_8h/#classes","title":"Classes","text":"Type Name class DeviceBuffer2D &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/buffer/device_buffer_2d.h</code></p>"},{"location":"muda/device__buffer__2d_8h_source/","title":"File device_buffer_2d.h","text":"<p>File List &gt; buffer &gt; device_buffer_2d.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;vector&gt;\n#include &lt;muda/viewer/dense.h&gt;\n#include &lt;muda/buffer/buffer_2d_view.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass DeviceBuffer2D\n{\n  private:\n    friend class BufferLaunch;\n    friend class NDReshaper;\n    T*       m_data        = nullptr;\n    size_t   m_pitch_bytes = 0;\n    Extent2D m_extent      = Extent2D::Zero();\n    Extent2D m_capacity    = Extent2D::Zero();\n\n  public:\n    using value_type = T;\n\n    DeviceBuffer2D(const Extent2D&amp; n);\n    DeviceBuffer2D();\n\n    DeviceBuffer2D(const DeviceBuffer2D&lt;T&gt;&amp; other);\n    DeviceBuffer2D(DeviceBuffer2D&amp;&amp; other) MUDA_NOEXCEPT;\n    DeviceBuffer2D&amp; operator=(const DeviceBuffer2D&lt;T&gt;&amp; other);\n    DeviceBuffer2D&amp; operator=(DeviceBuffer2D&lt;T&gt;&amp;&amp; other);\n\n    DeviceBuffer2D(CBuffer2DView&lt;T&gt; other);\n    DeviceBuffer2D&amp; operator=(CBuffer2DView&lt;T&gt; other);\n\n    void copy_to(std::vector&lt;T&gt;&amp; host) const;\n    void copy_from(const std::vector&lt;T&gt;&amp; host);\n\n    void resize(Extent2D new_extent);\n    void resize(Extent2D new_extent, const T&amp; value);\n    void reserve(Extent2D new_capacity);\n    void clear();\n    void shrink_to_fit();\n    void fill(const T&amp; v);\n\n    Dense2D&lt;T&gt;  viewer() MUDA_NOEXCEPT { return view().viewer(); }\n    CDense2D&lt;T&gt; cviewer() const MUDA_NOEXCEPT { return view().viewer(); }\n\n    Buffer2DView&lt;T&gt; view(Offset2D offset, Extent2D extent = {}) MUDA_NOEXCEPT\n    {\n        return view().subview(offset, extent);\n    }\n    Buffer2DView&lt;T&gt; view() MUDA_NOEXCEPT\n    {\n        return Buffer2DView&lt;T&gt;{m_data, m_pitch_bytes, Offset2D::Zero(), m_extent};\n    }\n    operator Buffer2DView&lt;T&gt;() MUDA_NOEXCEPT { return view(); }\n\n    CBuffer2DView&lt;T&gt; view(Offset2D offset, Extent2D extent = {}) const MUDA_NOEXCEPT\n    {\n        return view().subview(offset, extent);\n    }\n\n    CBuffer2DView&lt;T&gt; view() const MUDA_NOEXCEPT\n    {\n        return CBuffer2DView&lt;T&gt;{m_data, m_pitch_bytes, Offset2D::Zero(), m_extent};\n    }\n    operator CBuffer2DView&lt;T&gt;() const MUDA_NOEXCEPT { return view(); }\n\n    ~DeviceBuffer2D();\n\n    auto extent() const MUDA_NOEXCEPT { return m_extent; }\n    auto capacity() const MUDA_NOEXCEPT { return m_capacity; }\n    auto pitch_bytes() const MUDA_NOEXCEPT { return m_pitch_bytes; }\n    auto total_size() const MUDA_NOEXCEPT\n    {\n        return m_extent.width() * m_extent.height();\n    }\n    T*       data() MUDA_NOEXCEPT { return m_data; }\n    const T* data() const MUDA_NOEXCEPT { return m_data; }\n};\n}  // namespace muda\n\n#include \"details/device_buffer_2d.inl\"\n</code></pre>"},{"location":"muda/device__buffer__3d_8h/","title":"File device_buffer_3d.h","text":"<p>FileList &gt; buffer &gt; device_buffer_3d.h</p> <p>Go to the source code of this file</p> <p>A light-weight wrapper of cuda device memory3D, allows user to resize, reserve, shrink_to_fit, fill, also provide muda viewer for in-kernel access. More...</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;muda/viewer/dense.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_3d_view.h&gt;</code></li> <li><code>#include \"details/device_buffer_3d.inl\"</code></li> </ul>"},{"location":"muda/device__buffer__3d_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__buffer__3d_8h/#classes","title":"Classes","text":"Type Name class DeviceBuffer3D &lt;typename T&gt;"},{"location":"muda/device__buffer__3d_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>MuGdxy </p> <p>Date:</p> <p>January 2024 </p> <p>The documentation for this class was generated from the following file <code>src/muda/buffer/device_buffer_3d.h</code></p>"},{"location":"muda/device__buffer__3d_8h_source/","title":"File device_buffer_3d.h","text":"<p>File List &gt; buffer &gt; device_buffer_3d.h</p> <p>Go to the documentation of this file</p> <pre><code>/*****************************************************************/\n\n#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;vector&gt;\n#include &lt;muda/viewer/dense.h&gt;\n#include &lt;muda/buffer/buffer_3d_view.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass DeviceBuffer3D\n{\n  private:\n    friend class BufferLaunch;\n    friend class NDReshaper;\n\n    T*       m_data             = nullptr;\n    size_t   m_pitch_bytes      = 0;\n    size_t   m_pitch_bytes_area = 0;\n    Extent3D m_extent           = Extent3D::Zero();\n    Extent3D m_capacity         = Extent3D::Zero();\n\n  public:\n    using value_type = T;\n\n    DeviceBuffer3D(const Extent3D&amp; n);\n    DeviceBuffer3D();\n\n    DeviceBuffer3D(const DeviceBuffer3D&lt;T&gt;&amp; other);\n    DeviceBuffer3D(DeviceBuffer3D&amp;&amp; other) MUDA_NOEXCEPT;\n    DeviceBuffer3D&amp; operator=(const DeviceBuffer3D&lt;T&gt;&amp; other);\n    DeviceBuffer3D&amp; operator=(DeviceBuffer3D&lt;T&gt;&amp;&amp; other);\n\n    DeviceBuffer3D(CBuffer3DView&lt;T&gt; other);\n    DeviceBuffer3D&amp; operator=(CBuffer3DView&lt;T&gt; other);\n\n    void copy_to(std::vector&lt;T&gt;&amp; host) const;\n    void copy_from(const std::vector&lt;T&gt;&amp; host);\n\n    void resize(Extent3D new_size);\n    void resize(Extent3D new_size, const T&amp; value);\n    void reserve(Extent3D new_capacity);\n    void clear();\n    void shrink_to_fit();\n    void fill(const T&amp; v);\n\n    Dense3D&lt;T&gt;  viewer() MUDA_NOEXCEPT { return view().viewer(); }\n    CDense3D&lt;T&gt; cviewer() const MUDA_NOEXCEPT { return view().viewer(); }\n\n    Buffer3DView&lt;T&gt; view(Offset3D offset, Extent3D extent = {}) MUDA_NOEXCEPT\n    {\n        return view().subview(offset, extent);\n    }\n    Buffer3DView&lt;T&gt; view() MUDA_NOEXCEPT\n    {\n        return Buffer3DView&lt;T&gt;{\n            m_data, m_pitch_bytes, m_pitch_bytes_area, Offset3D::Zero(), m_extent};\n    }\n    operator Buffer3DView&lt;T&gt;() MUDA_NOEXCEPT { return view(); }\n\n    CBuffer3DView&lt;T&gt; view(Offset3D offset, Extent3D extent = {}) const MUDA_NOEXCEPT\n    {\n        return view().subview(offset, extent);\n    }\n\n    CBuffer3DView&lt;T&gt; view() const MUDA_NOEXCEPT\n    {\n        return CBuffer3DView&lt;T&gt;{\n            m_data, m_pitch_bytes, m_pitch_bytes_area, Offset3D::Zero(), m_extent};\n    }\n    operator CBuffer3DView&lt;T&gt;() const MUDA_NOEXCEPT { return view(); }\n\n    ~DeviceBuffer3D();\n\n    auto extent() const MUDA_NOEXCEPT { return m_extent; }\n    auto capacity() const MUDA_NOEXCEPT { return m_capacity; }\n    auto pitch_bytes() const MUDA_NOEXCEPT { return m_pitch_bytes; }\n    auto pitch_bytes_area() const MUDA_NOEXCEPT { return m_pitch_bytes_area; }\n    auto total_size() const MUDA_NOEXCEPT\n    {\n        return m_extent.width() * m_extent.height() * m_extent.depth();\n    }\n    T*       data() MUDA_NOEXCEPT { return m_data; }\n    const T* data() const MUDA_NOEXCEPT { return m_data; }\n};\n}  // namespace muda\n\n#include \"details/device_buffer_3d.inl\"\n</code></pre>"},{"location":"muda/device__var_8h/","title":"File device_var.h","text":"<p>FileList &gt; buffer &gt; device_var.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;muda/buffer/var_view.h&gt;</code></li> <li><code>#include \"details/device_var.inl\"</code></li> </ul>"},{"location":"muda/device__var_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__var_8h/#classes","title":"Classes","text":"Type Name class DeviceVar &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/buffer/device_var.h</code></p>"},{"location":"muda/device__var_8h_source/","title":"File device_var.h","text":"<p>File List &gt; buffer &gt; device_var.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;muda/buffer/var_view.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass DeviceVar\n{\n  private:\n    friend class BufferLaunch;\n    T* m_data;\n\n  public:\n    using value_type = T;\n\n    DeviceVar();\n    DeviceVar(const T&amp; value);\n\n    DeviceVar(const DeviceVar&amp; other);\n    DeviceVar(DeviceVar&amp;&amp; other) MUDA_NOEXCEPT;\n    DeviceVar&amp; operator=(const DeviceVar&lt;T&gt;&amp; other);\n    DeviceVar&amp; operator=(DeviceVar&lt;T&gt;&amp;&amp; other);\n\n    // device transfer\n\n    DeviceVar&amp; operator=(CVarView&lt;T&gt; other);\n    void       copy_from(CVarView&lt;T&gt; other);\n\n    DeviceVar&amp; operator=(const T&amp; val);  // copy from host\n    operator T() const;                  // copy to host\n\n    T*       data() MUDA_NOEXCEPT { return m_data; }\n    const T* data() const MUDA_NOEXCEPT { return m_data; }\n\n    VarView&lt;T&gt;  view() MUDA_NOEXCEPT { return VarView&lt;T&gt;{m_data}; };\n    CVarView&lt;T&gt; view() const MUDA_NOEXCEPT { return CVarView&lt;T&gt;{m_data}; };\n\n    operator VarView&lt;T&gt;() MUDA_NOEXCEPT { return view(); }\n    operator CVarView&lt;T&gt;() const MUDA_NOEXCEPT { return view(); }\n\n    Dense&lt;T&gt;  viewer() MUDA_NOEXCEPT;\n    CDense&lt;T&gt; cviewer() const MUDA_NOEXCEPT;\n\n    ~DeviceVar();\n};\n}  // namespace muda\n\n#include \"details/device_var.inl\"\n</code></pre>"},{"location":"muda/graph__buffer__2d__view_8h/","title":"File graph_buffer_2d_view.h","text":"<p>FileList &gt; buffer &gt; graph_buffer_2d_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/buffer_2d_view.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var.h&gt;</code></li> <li><code>#include \"details/graph_buffer_2d_view.inl\"</code></li> </ul>"},{"location":"muda/graph__buffer__2d__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph__buffer__2d__view_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphVar &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/buffer/graph_buffer_2d_view.h</code></p>"},{"location":"muda/graph__buffer__2d__view_8h_source/","title":"File graph_buffer_2d_view.h","text":"<p>File List &gt; buffer &gt; graph_buffer_2d_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/buffer_2d_view.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass ComputeGraphVar&lt;Buffer2DView&lt;T&gt;&gt; : public ComputeGraphVarBase\n{\n  public:\n    static_assert(!std::is_const_v&lt;T&gt;, \"T must not be const\");\n    using VarType = Buffer2DView&lt;T&gt;;\n    using ROView  = CBuffer2DView&lt;T&gt;;\n    using RWView  = Buffer2DView&lt;T&gt;;\n\n  protected:\n    friend class ComputeGraph;\n    friend class ComputeGraphVarManager;\n\n    using ComputeGraphVarBase::ComputeGraphVarBase;\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager, std::string_view name, VarId var_id) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id)\n    {\n    }\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager,\n                    std::string_view        name,\n                    VarId                   var_id,\n                    const RWView&amp;           init_value) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id, true),\n          m_value(init_value)\n    {\n    }\n\n    virtual ~ComputeGraphVar() = default;\n\n  public:\n    ROView ceval() const { return _ceval(m_value); }\n    RWView eval() { return _eval(m_value); }\n\n    operator ROView() const { return ceval(); }\n    operator RWView() { return eval(); }\n    auto cviewer() const\n    {\n        return ceval().cviewer().name(this-&gt;name().data());\n    };\n    auto viewer() { return eval().viewer().name(this-&gt;name().data()); };\n\n    void                      update(const RWView&amp; view);\n    ComputeGraphVar&lt;VarType&gt;&amp; operator=(const RWView&amp; view);\n\n  private:\n    RWView m_value;\n};\n\n}  // namespace muda\n\n#include \"details/graph_buffer_2d_view.inl\"\n</code></pre>"},{"location":"muda/graph__buffer__3d__view_8h/","title":"File graph_buffer_3d_view.h","text":"<p>FileList &gt; buffer &gt; graph_buffer_3d_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/buffer_3d_view.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var.h&gt;</code></li> <li><code>#include \"details/graph_buffer_3d_view.inl\"</code></li> </ul>"},{"location":"muda/graph__buffer__3d__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph__buffer__3d__view_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphVar &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/buffer/graph_buffer_3d_view.h</code></p>"},{"location":"muda/graph__buffer__3d__view_8h_source/","title":"File graph_buffer_3d_view.h","text":"<p>File List &gt; buffer &gt; graph_buffer_3d_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/buffer_3d_view.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass ComputeGraphVar&lt;Buffer3DView&lt;T&gt;&gt; : public ComputeGraphVarBase\n{\n  public:\n    static_assert(!std::is_const_v&lt;T&gt;, \"T must not be const\");\n    using VarType = Buffer3DView&lt;T&gt;;\n    using ROView  = CBuffer3DView&lt;T&gt;;\n    using RWView  = Buffer3DView&lt;T&gt;;\n\n  protected:\n    friend class ComputeGraph;\n    friend class ComputeGraphVarManager;\n\n    using ComputeGraphVarBase::ComputeGraphVarBase;\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager, std::string_view name, VarId var_id) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id)\n    {\n    }\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager,\n                    std::string_view        name,\n                    VarId                   var_id,\n                    const RWView&amp;           init_value) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id, true),\n          m_value(init_value)\n    {\n    }\n\n    virtual ~ComputeGraphVar() = default;\n\n  public:\n    ROView ceval() const { return _ceval(m_value); }\n    RWView eval() { return _eval(m_value); }\n\n    operator ROView() const { return ceval(); }\n    operator RWView() { return eval(); }\n    auto cviewer() const\n    {\n        return ceval().cviewer().name(this-&gt;name().data());\n    };\n    auto viewer() { return eval().viewer().name(this-&gt;name().data()); };\n\n    void                      update(const RWView&amp; view);\n    ComputeGraphVar&lt;VarType&gt;&amp; operator=(const RWView&amp; view);\n\n  private:\n    RWView m_value;\n};\n\n}  // namespace muda\n\n#include \"details/graph_buffer_3d_view.inl\"\n</code></pre>"},{"location":"muda/graph__buffer__view_8h/","title":"File graph_buffer_view.h","text":"<p>FileList &gt; buffer &gt; graph_buffer_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/buffer_view.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var.h&gt;</code></li> <li><code>#include \"details/graph_buffer_view.inl\"</code></li> </ul>"},{"location":"muda/graph__buffer__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph__buffer__view_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphVar &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/buffer/graph_buffer_view.h</code></p>"},{"location":"muda/graph__buffer__view_8h_source/","title":"File graph_buffer_view.h","text":"<p>File List &gt; buffer &gt; graph_buffer_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/buffer_view.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass ComputeGraphVar&lt;BufferView&lt;T&gt;&gt; : public ComputeGraphVarBase\n{\n  public:\n    static_assert(!std::is_const_v&lt;T&gt;, \"T must not be const\");\n    using VarType = BufferView&lt;T&gt;;\n    using ROView  = CBufferView&lt;T&gt;;\n    using RWView  = BufferView&lt;T&gt;;\n\n  protected:\n    friend class ComputeGraph;\n    friend class ComputeGraphVarManager;\n\n    using ComputeGraphVarBase::ComputeGraphVarBase;\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager, std::string_view name, VarId var_id) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id)\n    {\n    }\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager,\n                    std::string_view        name,\n                    VarId                   var_id,\n                    const RWView&amp;           init_value) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id, true),\n          m_value(init_value)\n    {\n    }\n\n    virtual ~ComputeGraphVar() = default;\n\n  public:\n    ROView ceval() const { return _ceval(m_value); }\n    RWView eval() { return _eval(m_value); }\n\n    operator ROView() const { return ceval(); }\n    operator RWView() { return eval(); }\n    auto cviewer() const\n    {\n        return ceval().cviewer().name(this-&gt;name().data());\n    };\n    auto viewer() { return eval().viewer().name(this-&gt;name().data()); };\n\n    void                      update(const RWView&amp; view);\n    ComputeGraphVar&lt;VarType&gt;&amp; operator=(const RWView&amp; view);\n\n  private:\n    RWView m_value;\n};\n\n}  // namespace muda\n\n#include \"details/graph_buffer_view.inl\"\n</code></pre>"},{"location":"muda/graph__var__view_8h/","title":"File graph_var_view.h","text":"<p>FileList &gt; buffer &gt; graph_var_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/var_view.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var.h&gt;</code></li> <li><code>#include \"details/graph_var_view.inl\"</code></li> </ul>"},{"location":"muda/graph__var__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph__var__view_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphVar &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/buffer/graph_var_view.h</code></p>"},{"location":"muda/graph__var__view_8h_source/","title":"File graph_var_view.h","text":"<p>File List &gt; buffer &gt; graph_var_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/var_view.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass ComputeGraphVar&lt;VarView&lt;T&gt;&gt; : public ComputeGraphVarBase\n{\n  public:\n    static_assert(!std::is_const_v&lt;T&gt;, \"T must not be const\");\n\n    using VarType = VarView&lt;T&gt;;\n    using ROView  = CVarView&lt;T&gt;;\n    using RWView  = VarView&lt;T&gt;;\n\n  protected:\n    friend class ComputeGraph;\n    friend class ComputeGraphVarManager;\n\n    using ComputeGraphVarBase::ComputeGraphVarBase;\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager, std::string_view name, VarId var_id) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id)\n    {\n    }\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager,\n                    std::string_view        name,\n                    VarId                   var_id,\n                    const RWView&amp;           init_value) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id, true),\n          m_value(init_value)\n    {\n    }\n\n    virtual ~ComputeGraphVar() = default;\n\n  public:\n    ROView ceval() const { return _ceval(m_value); }\n    RWView eval() { return _eval(m_value); }\n    auto   cviewer() const { return ceval().cviewer(); };\n    auto   viewer() { return eval().viewer(); };\n    operator ROView() const { return ceval(); }\n    operator RWView() { return eval(); }\n\n    void                      update(const RWView&amp; view);\n    ComputeGraphVar&lt;VarType&gt;&amp; operator=(const RWView&amp; view);\n\n  private:\n    RWView m_value;\n};\n\n}  // namespace muda\n\n#include \"details/graph_var_view.inl\"\n</code></pre>"},{"location":"muda/dir_b105d52dbe330929a6f21338e69b1ba4/","title":"Dir src/muda/buffer/agent","text":"<p>FileList &gt; agent</p>"},{"location":"muda/dir_b105d52dbe330929a6f21338e69b1ba4/#files","title":"Files","text":"Type Name file kernel_assign.h file kernel_construct.h file kernel_copy_construct.h file kernel_destruct.h file kernel_fill.h <p>The documentation for this class was generated from the following file <code>src/muda/buffer/agent/</code></p>"},{"location":"muda/kernel__assign_8h/","title":"File kernel_assign.h","text":"<p>FileList &gt; agent &gt; kernel_assign.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_fwd.h&gt;</code></li> <li><code>#include \"details/kernel_assign.inl\"</code></li> </ul>"},{"location":"muda/kernel__assign_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace buffer <p>The documentation for this class was generated from the following file <code>src/muda/buffer/agent/kernel_assign.h</code></p>"},{"location":"muda/kernel__assign_8h_source/","title":"File kernel_assign.h","text":"<p>File List &gt; agent &gt; kernel_assign.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;muda/buffer/buffer_fwd.h&gt;\n\nnamespace muda::details::buffer\n{\n// assign 0D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_assign(cudaStream_t stream, VarView&lt;T&gt; dst, CVarView&lt;T&gt; src);\n\n// assign 1D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_assign(int            grid_dim,\n                             int            block_dim,\n                             cudaStream_t   stream,\n                             BufferView&lt;T&gt;  dst,\n                             CBufferView&lt;T&gt; src);\n\n// assign 2D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_assign(int              grid_dim,\n                             int              block_dim,\n                             cudaStream_t     stream,\n                             Buffer2DView&lt;T&gt;  dst,\n                             CBuffer2DView&lt;T&gt; src);\n\n// assign 3D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_assign(int              grid_dim,\n                             int              block_dim,\n                             cudaStream_t     stream,\n                             Buffer3DView&lt;T&gt;  dst,\n                             CBuffer3DView&lt;T&gt; src);\n}  // namespace muda::details::buffer\n\n#include \"details/kernel_assign.inl\"\n</code></pre>"},{"location":"muda/kernel__construct_8h/","title":"File kernel_construct.h","text":"<p>FileList &gt; agent &gt; kernel_construct.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_fwd.h&gt;</code></li> <li><code>#include \"details/kernel_construct.inl\"</code></li> </ul>"},{"location":"muda/kernel__construct_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace buffer <p>The documentation for this class was generated from the following file <code>src/muda/buffer/agent/kernel_construct.h</code></p>"},{"location":"muda/kernel__construct_8h_source/","title":"File kernel_construct.h","text":"<p>File List &gt; agent &gt; kernel_construct.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;muda/buffer/buffer_fwd.h&gt;\n\n\nnamespace muda::details::buffer\n{\n// construct 0D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_construct(cudaStream_t stream, VarView&lt;T&gt; view);\n\n// construct 1D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_construct(int           grid_dim,\n                                int           block_dim,\n                                cudaStream_t  stream,\n                                BufferView&lt;T&gt; buffer_view);\n\n// construct 2D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_construct(int             grid_dim,\n                                int             block_dim,\n                                cudaStream_t    stream,\n                                Buffer2DView&lt;T&gt; buffer_view);\n\n// construct 3D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_construct(int             grid_dim,\n                                int             block_dim,\n                                cudaStream_t    stream,\n                                Buffer3DView&lt;T&gt; buffer_view);\n}  // namespace muda::details::buffer\n\n#include \"details/kernel_construct.inl\"\n</code></pre>"},{"location":"muda/kernel__copy__construct_8h/","title":"File kernel_copy_construct.h","text":"<p>FileList &gt; agent &gt; kernel_copy_construct.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_fwd.h&gt;</code></li> <li><code>#include \"details/kernel_copy_construct.inl\"</code></li> </ul>"},{"location":"muda/kernel__copy__construct_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace buffer <p>The documentation for this class was generated from the following file <code>src/muda/buffer/agent/kernel_copy_construct.h</code></p>"},{"location":"muda/kernel__copy__construct_8h_source/","title":"File kernel_copy_construct.h","text":"<p>File List &gt; agent &gt; kernel_copy_construct.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;muda/buffer/buffer_fwd.h&gt;\n\nnamespace muda::details::buffer\n{\n// copy construct 0D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_copy_construct(cudaStream_t stream,\n                                                 VarView&lt;T&gt;   dst,\n                                                 CVarView&lt;T&gt;  src);\n\n// copy construct 1D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_copy_construct(int            grid_dim,\n                                                 int            block_dim,\n                                                 cudaStream_t   stream,\n                                                 BufferView&lt;T&gt;  dst,\n                                                 CBufferView&lt;T&gt; src);\n\n// copy construct 2D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_copy_construct(int              grid_dim,\n                                                 int              block_dim,\n                                                 cudaStream_t     stream,\n                                                 Buffer2DView&lt;T&gt;  dst,\n                                                 CBuffer2DView&lt;T&gt; src);\n\n// copy construct 3D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_copy_construct(int              grid_dim,\n                                                 int              block_dim,\n                                                 cudaStream_t     stream,\n                                                 Buffer3DView&lt;T&gt;  dst,\n                                                 CBuffer3DView&lt;T&gt; src);\n}  // namespace muda::details::buffer\n\n#include \"details/kernel_copy_construct.inl\"\n</code></pre>"},{"location":"muda/kernel__destruct_8h/","title":"File kernel_destruct.h","text":"<p>FileList &gt; agent &gt; kernel_destruct.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_fwd.h&gt;</code></li> <li><code>#include \"details/kernel_destruct.inl\"</code></li> </ul>"},{"location":"muda/kernel__destruct_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace buffer <p>The documentation for this class was generated from the following file <code>src/muda/buffer/agent/kernel_destruct.h</code></p>"},{"location":"muda/kernel__destruct_8h_source/","title":"File kernel_destruct.h","text":"<p>File List &gt; agent &gt; kernel_destruct.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;muda/buffer/buffer_fwd.h&gt;\n\n\nnamespace muda::details::buffer\n{\n// destruct 0D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_destruct(cudaStream_t stream, VarView&lt;T&gt; view);\n\n// destruct 1D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_destruct(int grid_dim, int block_dim, cudaStream_t stream, BufferView&lt;T&gt; buffer_view);\n\n// destruct 2D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_destruct(int             grid_dim,\n                               int             block_dim,\n                               cudaStream_t    stream,\n                               Buffer2DView&lt;T&gt; buffer_view);\n\n// destruct 3D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_destruct(int             grid_dim,\n                               int             block_dim,\n                               cudaStream_t    stream,\n                               Buffer3DView&lt;T&gt; buffer_view);\n}  // namespace muda::details::buffer\n\n#include \"details/kernel_destruct.inl\"\n</code></pre>"},{"location":"muda/kernel__fill_8h/","title":"File kernel_fill.h","text":"<p>FileList &gt; agent &gt; kernel_fill.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_fwd.h&gt;</code></li> <li><code>#include \"details/kernel_fill.inl\"</code></li> </ul>"},{"location":"muda/kernel__fill_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace buffer <p>The documentation for this class was generated from the following file <code>src/muda/buffer/agent/kernel_fill.h</code></p>"},{"location":"muda/kernel__fill_8h_source/","title":"File kernel_fill.h","text":"<p>File List &gt; agent &gt; kernel_fill.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;muda/buffer/buffer_fwd.h&gt;\n\nnamespace muda::details::buffer\n{\n// fill 0D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_fill(cudaStream_t stream, VarView&lt;T&gt; dst, const T&amp; val);\n\n// fill 1D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_fill(\n    int grid_dim, int block_dim, cudaStream_t stream, BufferView&lt;T&gt; dst, const T&amp; val);\n\n// fill 2D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_fill(int             grid_dim,\n                           int             block_dim,\n                           cudaStream_t    stream,\n                           Buffer2DView&lt;T&gt; dst,\n                           const T&amp;        val);\n\n// fill 3D\ntemplate &lt;typename T&gt;\nMUDA_HOST void kernel_fill(int             grid_dim,\n                           int             block_dim,\n                           cudaStream_t    stream,\n                           Buffer3DView&lt;T&gt; dst,\n                           const T&amp;        val);\n}  // namespace muda::details::buffer\n\n#include \"details/kernel_fill.inl\"\n</code></pre>"},{"location":"muda/dir_a8e1d5e93e8295fded484e7c98517cd5/","title":"Dir src/muda/buffer/reshape_nd","text":"<p>FileList &gt; buffer &gt; reshape_nd</p>"},{"location":"muda/dir_a8e1d5e93e8295fded484e7c98517cd5/#files","title":"Files","text":"Type Name file masked_compare.h file masked_swap.h file nd_reshaper.h file reserve.h <p>The documentation for this class was generated from the following file <code>src/muda/buffer/reshape_nd/</code></p>"},{"location":"muda/masked__compare_8h/","title":"File masked_compare.h","text":"<p>FileList &gt; buffer &gt; reshape_nd &gt; masked_compare.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;bitset&gt;</code></li> </ul>"},{"location":"muda/masked__compare_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace buffer <p>The documentation for this class was generated from the following file <code>src/muda/buffer/reshape_nd/masked_compare.h</code></p>"},{"location":"muda/masked__compare_8h_source/","title":"File masked_compare.h","text":"<p>File List &gt; buffer &gt; reshape_nd &gt; masked_compare.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\nnamespace muda::details::buffer\n{\nMUDA_INLINE bool less(bool b, size_t l, size_t r) MUDA_NOEXCEPT\n{\n    return b ? l &lt; r : true;\n}\n\ntemplate &lt;size_t N&gt;\nMUDA_INLINE bool less(std::bitset&lt;N&gt;               mask,\n                      const std::array&lt;size_t, N&gt;&amp; lhs,\n                      const std::array&lt;size_t, N&gt;&amp; rhs) MUDA_NOEXCEPT\n{\n#pragma unroll\n    for(size_t i = 0; i &lt; N; ++i)\n        if(!less(mask[i], lhs[i], rhs[i]))\n            return false;\n    return true;\n}\n}  // namespace muda::details::buffer\n</code></pre>"},{"location":"muda/masked__swap_8h/","title":"File masked_swap.h","text":"<p>FileList &gt; buffer &gt; reshape_nd &gt; masked_swap.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;bitset&gt;</code></li> </ul>"},{"location":"muda/masked__swap_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace buffer <p>The documentation for this class was generated from the following file <code>src/muda/buffer/reshape_nd/masked_swap.h</code></p>"},{"location":"muda/masked__swap_8h_source/","title":"File masked_swap.h","text":"<p>File List &gt; buffer &gt; reshape_nd &gt; masked_swap.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\nnamespace muda::details::buffer\n{\nMUDA_INLINE void swap(bool b, size_t&amp; l, size_t&amp; r) MUDA_NOEXCEPT\n{\n    if(b)\n    {\n        size_t tmp = l;\n        l          = r;\n        r          = tmp;\n    }\n}\n\ntemplate &lt;size_t N&gt;\nMUDA_INLINE void swap(std::bitset&lt;N&gt;         mask,\n                      std::array&lt;size_t, N&gt;&amp; lhs,\n                      std::array&lt;size_t, N&gt;&amp; rhs) MUDA_NOEXCEPT\n{\n#pragma unroll\n    for(size_t i = 0; i &lt; N; ++i)\n        swap(mask[i], lhs[i], rhs[i]);\n}\n}  // namespace muda::details::buffer\n</code></pre>"},{"location":"muda/nd__reshaper_8h/","title":"File nd_reshaper.h","text":"<p>FileList &gt; buffer &gt; reshape_nd &gt; nd_reshaper.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include \"details/nd_reshaper.inl\"</code></li> </ul>"},{"location":"muda/nd__reshaper_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/nd__reshaper_8h/#classes","title":"Classes","text":"Type Name class NDReshaper <p>The documentation for this class was generated from the following file <code>src/muda/buffer/reshape_nd/nd_reshaper.h</code></p>"},{"location":"muda/nd__reshaper_8h_source/","title":"File nd_reshaper.h","text":"<p>File List &gt; buffer &gt; reshape_nd &gt; nd_reshaper.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass DeviceBuffer;\n\ntemplate &lt;typename T&gt;\nclass DeviceBuffer2D;\n\ntemplate &lt;typename T&gt;\nclass DeviceBuffer3D;\n\nclass NDReshaper\n{\n  public:\n    template &lt;typename T, typename FConstruct&gt;\n    static MUDA_HOST void resize(int              grid_dim,\n                                 int              block_dim,\n                                 cudaStream_t     stream,\n                                 DeviceBuffer&lt;T&gt;&amp; buffer,\n                                 size_t           new_size,\n                                 FConstruct&amp;&amp;     fct);\n\n    template &lt;typename T&gt;\n    static MUDA_HOST void shrink_to_fit(int              grid_dim,\n                                        int              block_dim,\n                                        cudaStream_t     stream,\n                                        DeviceBuffer&lt;T&gt;&amp; buffer);\n\n    template &lt;typename T&gt;\n    static MUDA_HOST void reserve(int              grid_dim,\n                                  int              block_dim,\n                                  cudaStream_t     stream,\n                                  DeviceBuffer&lt;T&gt;&amp; buffer,\n                                  size_t           new_capacity);\n\n\n    //using T          = float;\n    //using FConstruct = std::function&lt;void(Buffer2DView&lt;T&gt;)&gt;;\n    template &lt;typename T, typename FConstruct&gt;\n    static MUDA_HOST void resize(int                grid_dim,\n                                 int                block_dim,\n                                 cudaStream_t       stream,\n                                 DeviceBuffer2D&lt;T&gt;&amp; buffer,\n                                 Extent2D           new_extent,\n                                 FConstruct&amp;&amp;       fct);\n\n    template &lt;typename T&gt;\n    static MUDA_HOST void shrink_to_fit(int                grid_dim,\n                                        int                block_dim,\n                                        cudaStream_t       stream,\n                                        DeviceBuffer2D&lt;T&gt;&amp; buffer);\n\n    template &lt;typename T&gt;\n    static MUDA_HOST void reserve(int                grid_dim,\n                                  int                block_dim,\n                                  cudaStream_t       stream,\n                                  DeviceBuffer2D&lt;T&gt;&amp; buffer,\n                                  Extent2D           new_capacity);\n\n    template &lt;typename T, typename FConstruct&gt;\n    static MUDA_HOST void resize(int                grid_dim,\n                                 int                block_dim,\n                                 cudaStream_t       stream,\n                                 DeviceBuffer3D&lt;T&gt;&amp; buffer,\n                                 Extent3D           new_extent,\n                                 FConstruct&amp;&amp;       fct);\n\n    template &lt;typename T&gt;\n    static MUDA_HOST void shrink_to_fit(int                grid_dim,\n                                        int                block_dim,\n                                        cudaStream_t       stream,\n                                        DeviceBuffer3D&lt;T&gt;&amp; buffer);\n\n    template &lt;typename T&gt;\n    static MUDA_HOST void reserve(int                grid_dim,\n                                  int                block_dim,\n                                  cudaStream_t       stream,\n                                  DeviceBuffer3D&lt;T&gt;&amp; buffer,\n                                  Extent3D           new_capacity);\n};\n}  // namespace muda\n\n#include \"details/nd_reshaper.inl\"\n</code></pre>"},{"location":"muda/reserve_8h/","title":"File reserve.h","text":"<p>FileList &gt; buffer &gt; reshape_nd &gt; reserve.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/launch/memory.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_view.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_2d_view.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_3d_view.h&gt;</code></li> </ul>"},{"location":"muda/reserve_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace buffer <p>The documentation for this class was generated from the following file <code>src/muda/buffer/reshape_nd/reserve.h</code></p>"},{"location":"muda/reserve_8h_source/","title":"File reserve.h","text":"<p>File List &gt; buffer &gt; reshape_nd &gt; reserve.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/launch/memory.h&gt;\n#include &lt;muda/buffer/buffer_view.h&gt;\n#include &lt;muda/buffer/buffer_2d_view.h&gt;\n#include &lt;muda/buffer/buffer_3d_view.h&gt;\n\nnamespace muda::details::buffer\n{\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_HOST BufferView&lt;T&gt; reserve_1d(cudaStream_t stream, size_t size)\n{\n    T* ptr = nullptr;\n    Memory(stream).alloc_1d(&amp;ptr, size * sizeof(T));\n    return BufferView&lt;T&gt;{ptr, 0, size};\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_HOST Buffer2DView&lt;T&gt; reserve_2d(cudaStream_t stream, Extent2D extent)\n{\n    T*     ptr         = nullptr;\n    size_t pitch_bytes = 0;\n    Memory(stream).alloc_2d(\n        &amp;ptr, &amp;pitch_bytes, extent.width() * sizeof(T), extent.height());\n    return Buffer2DView&lt;T&gt;{ptr, pitch_bytes, Offset2D::Zero(), extent};\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_HOST Buffer3DView&lt;T&gt; reserve_3d(cudaStream_t stream, Extent3D extent)\n{\n    cudaPitchedPtr pitched_ptr;\n    Memory(stream).alloc_3d(&amp;pitched_ptr, extent.template cuda_extent&lt;T&gt;());\n    T*     ptr              = reinterpret_cast&lt;T*&gt;(pitched_ptr.ptr);\n    size_t pitch_bytes      = pitched_ptr.pitch;\n    size_t pitch_bytes_area = pitched_ptr.pitch * extent.height();\n    return Buffer3DView&lt;T&gt;{ptr, pitch_bytes, pitch_bytes_area, Offset3D::Zero(), extent};\n}\n}  // namespace muda::details::buffer\n</code></pre>"},{"location":"muda/var__view_8h/","title":"File var_view.h","text":"<p>FileList &gt; buffer &gt; var_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include &lt;muda/viewer/dense.h&gt;</code></li> <li><code>#include \"details/var_view.inl\"</code></li> </ul>"},{"location":"muda/var__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/var__view_8h/#classes","title":"Classes","text":"Type Name class VarViewT &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/buffer/var_view.h</code></p>"},{"location":"muda/var__view_8h_source/","title":"File var_view.h","text":"<p>File List &gt; buffer &gt; var_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cinttypes&gt;\n#include &lt;muda/view/view_base.h&gt;\n#include &lt;muda/viewer/dense.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass VarViewT : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class VarViewT;\n\n  protected:\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    auto_const_t&lt;T&gt;* m_data = nullptr;\n\n  public:\n    using ConstView = VarViewT&lt;true, T&gt;;\n    using ThisView  = VarViewT&lt;IsConst, T&gt;;\n\n    using ConstViewer    = CDense&lt;T&gt;;\n    using NonConstViewer = Dense&lt;T&gt;;\n    using ThisViewer = typename std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n\n    MUDA_GENERIC VarViewT() MUDA_NOEXCEPT = default;\n    MUDA_GENERIC VarViewT(auto_const_t&lt;T&gt;* data) MUDA_NOEXCEPT;\n\n    MUDA_GENERIC VarViewT(const VarViewT&amp; other) MUDA_NOEXCEPT = default;\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC VarViewT(const VarViewT&lt;OtherIsConst, T&gt;&amp; other) MUDA_NOEXCEPT;\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC ConstView as_const() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC ConstViewer cviewer() const MUDA_NOEXCEPT;\n    MUDA_GENERIC ThisViewer  viewer() const MUDA_NOEXCEPT;\n\n    MUDA_HOST void fill(const T&amp; value) const MUDA_REQUIRES(!IsConst);\n    MUDA_HOST void copy_to(T* data) const;\n    MUDA_HOST void copy_from(const T* data) const MUDA_REQUIRES(!IsConst);\n    MUDA_HOST void copy_from(const ConstView&amp; val) const MUDA_REQUIRES(!IsConst);\n\n    /**********************************************************************************\n    * VarView As Iterator\n    ***********************************************************************************/\n\n    // Random Access Iterator Interface\n    using value_type        = T;\n    using reference         = T&amp;;\n    using pointer           = T*;\n    using iterator_category = std::random_access_iterator_tag;\n    using difference_type   = size_t;\n\n    MUDA_GENERIC reference operator*() { return *data(); }\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator[](int i) const { return *data(); }\n};\n\ntemplate &lt;typename T&gt;\nusing VarView = VarViewT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CVarView = VarViewT&lt;true, T&gt;;\n\n// viewer traits\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;VarView&lt;T&gt;&gt;\n{\n    using type = CVarView&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CVarView&lt;T&gt;&gt;\n{\n    using type = VarView&lt;T&gt;;\n};\n}  // namespace muda\n\n\n#include \"details/var_view.inl\"\n</code></pre>"},{"location":"muda/dir_3ada5fb1291f7068cec99adbe813154e/","title":"Dir src/muda/check","text":"<p>FileList &gt; check</p>"},{"location":"muda/dir_3ada5fb1291f7068cec99adbe813154e/#files","title":"Files","text":"Type Name file check.h file check_cublas.h file check_cuda_errors.h file check_cusolver.h file check_cusparse.h <p>The documentation for this class was generated from the following file <code>src/muda/check/</code></p>"},{"location":"muda/check_8h/","title":"File check.h","text":"<p>FileList &gt; check &gt; check.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;cstdio&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/tools/debug_log.h&gt;</code></li> <li><code>#include &lt;muda/exception.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;muda/check/check_cusparse.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cublas.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cusolver.h&gt;</code></li> </ul>"},{"location":"muda/check_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/check_8h/#classes","title":"Classes","text":"Type Name class cuda_error &lt;typename T&gt;"},{"location":"muda/check_8h/#public-functions","title":"Public Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC const char * mudaCudaGetErrorEnum (cudaError_t error)"},{"location":"muda/check_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/check_8h/#function-mudacudageterrorenum","title":"function mudaCudaGetErrorEnum","text":"<pre><code>MUDA_INLINE MUDA_GENERIC const char * mudaCudaGetErrorEnum (\n    cudaError_t error\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/check/check.h</code></p>"},{"location":"muda/check_8h_source/","title":"File check.h","text":"<p>File List &gt; check &gt; check.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;cstdio&gt;\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/tools/debug_log.h&gt;\n#include &lt;muda/exception.h&gt;\n#include &lt;string&gt;\n#include &lt;muda/check/check_cusparse.h&gt;\n#include &lt;muda/check/check_cublas.h&gt;\n#include &lt;muda/check/check_cusolver.h&gt;\n\nMUDA_INLINE MUDA_GENERIC const char* mudaCudaGetErrorEnum(cudaError_t error)\n{\n//#ifdef __CUDA_ARCH__\n//    return \"&lt;muda: not impl yet&gt;\";\n//#else\n    return cudaGetErrorName(error);\n//#endif\n}\n\nnamespace muda\n{\ntemplate &lt;typename T = cudaError_t&gt;\nclass cuda_error : public exception\n{\n    T           m_error;\n    std::string m_error_string;\n    std::string m_file;\n\n    size_t      m_line;\n    std::string m_func;\n\n  public:\n    cuda_error(T error, std::string error_string, const std::string&amp; file, size_t line, const std::string&amp; func)\n        : exception(\"CUDA error at \" + file + \":\" + std::to_string(line) + \" code=\"\n                    + std::to_string((int)error) + \"(\" + error_string + \")\" + func)\n        , m_error(error)\n        , m_error_string(error_string)\n        , m_file(file)\n        , m_line(line)\n        , m_func(func)\n    {\n    }\n\n    T                  error() const { return m_error; }\n    const std::string&amp; error_string() const { return m_error_string; }\n    const std::string&amp; file() const { return m_file; }\n    size_t             line() const { return m_line; }\n    const std::string&amp; func() const { return m_func; }\n};\n\ntemplate &lt;typename T&gt;\n__host__ __device__ inline void check(T                 result,\n                                      char const* const func,\n                                      const char* const file,\n                                      int const         line)\n{\n#ifdef __CUDA_ARCH__\n    if(result)\n    {\n        printf(\"CUDA error at %s:%d code=%d(%s) \\\"%s\\\" \\n\",\n               file,\n               line,\n               static_cast&lt;unsigned int&gt;(result),\n               mudaCudaGetErrorEnum(result),\n               func);\n        if constexpr(TRAP_ON_ERROR)\n            trap();\n    }\n#else\n    if(result)\n    {\n        std::fprintf(stderr,\n                     \"CUDA error at %s:%d code=%d(%s) \\\"%s\\\" \\n\",\n                     file,\n                     line,\n                     static_cast&lt;unsigned int&gt;(result),\n                     mudaCudaGetErrorEnum(result),\n                     func);\n        throw cuda_error&lt;T&gt;(result, mudaCudaGetErrorEnum(result), file, line, func);\n    }\n#endif\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/check__cublas_8h/","title":"File check_cublas.h","text":"<p>FileList &gt; check &gt; check_cublas.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;cublas_v2.h&gt;</code></li> </ul>"},{"location":"muda/check__cublas_8h/#public-functions","title":"Public Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC const char * mudaCudaGetErrorEnum (cublasStatus_t error)"},{"location":"muda/check__cublas_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/check__cublas_8h/#function-mudacudageterrorenum","title":"function mudaCudaGetErrorEnum","text":"<pre><code>MUDA_INLINE MUDA_GENERIC const char * mudaCudaGetErrorEnum (\n    cublasStatus_t error\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/check/check_cublas.h</code></p>"},{"location":"muda/check__cublas_8h_source/","title":"File check_cublas.h","text":"<p>File List &gt; check &gt; check_cublas.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;cublas_v2.h&gt;\n\nMUDA_INLINE MUDA_GENERIC const char* mudaCudaGetErrorEnum(cublasStatus_t error)\n{\n    switch(error)\n    {\n        case CUBLAS_STATUS_SUCCESS:\n            return \"CUBLAS_STATUS_SUCCESS\";\n\n        case CUBLAS_STATUS_NOT_INITIALIZED:\n            return \"CUBLAS_STATUS_NOT_INITIALIZED\";\n\n        case CUBLAS_STATUS_ALLOC_FAILED:\n            return \"CUBLAS_STATUS_ALLOC_FAILED\";\n\n        case CUBLAS_STATUS_INVALID_VALUE:\n            return \"CUBLAS_STATUS_INVALID_VALUE\";\n\n        case CUBLAS_STATUS_ARCH_MISMATCH:\n            return \"CUBLAS_STATUS_ARCH_MISMATCH\";\n\n        case CUBLAS_STATUS_MAPPING_ERROR:\n            return \"CUBLAS_STATUS_MAPPING_ERROR\";\n\n        case CUBLAS_STATUS_EXECUTION_FAILED:\n            return \"CUBLAS_STATUS_EXECUTION_FAILED\";\n\n        case CUBLAS_STATUS_INTERNAL_ERROR:\n            return \"CUBLAS_STATUS_INTERNAL_ERROR\";\n\n        case CUBLAS_STATUS_NOT_SUPPORTED:\n            return \"CUBLAS_STATUS_NOT_SUPPORTED\";\n\n        case CUBLAS_STATUS_LICENSE_ERROR:\n            return \"CUBLAS_STATUS_LICENSE_ERROR\";\n    }\n    return \"&lt;unknown&gt;\";\n}\n</code></pre>"},{"location":"muda/check__cuda__errors_8h/","title":"File check_cuda_errors.h","text":"<p>FileList &gt; check &gt; check_cuda_errors.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/check/check.h&gt;</code></li> </ul>"},{"location":"muda/check__cuda__errors_8h/#macros","title":"Macros","text":"Type Name define checkCudaErrors (val) ::muda::check((val), #val, __FILE__, __LINE__)"},{"location":"muda/check__cuda__errors_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/check__cuda__errors_8h/#define-checkcudaerrors","title":"define checkCudaErrors","text":"<pre><code>#define checkCudaErrors (\n    val\n) ::muda::check((val), #val, __FILE__, __LINE__)\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/check/check_cuda_errors.h</code></p>"},{"location":"muda/check__cuda__errors_8h_source/","title":"File check_cuda_errors.h","text":"<p>File List &gt; check &gt; check_cuda_errors.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/check/check.h&gt;\n#define checkCudaErrors(val) ::muda::check((val), #val, __FILE__, __LINE__)\n</code></pre>"},{"location":"muda/check__cusolver_8h/","title":"File check_cusolver.h","text":"<p>FileList &gt; check &gt; check_cusolver.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;cusolver_common.h&gt;</code></li> </ul>"},{"location":"muda/check__cusolver_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/check/check_cusolver.h</code></p>"},{"location":"muda/check__cusolver_8h_source/","title":"File check_cusolver.h","text":"<p>File List &gt; check &gt; check_cusolver.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;cusolver_common.h&gt;\n\nnamespace muda\n{\nMUDA_INLINE MUDA_GENERIC const char* mudaCudaGetErrorEnum(cusolverStatus_t error)\n{\n    switch(error)\n    {\n        case CUSOLVER_STATUS_SUCCESS:\n            return \"CUSOLVER_STATUS_SUCCESS\";\n        case CUSOLVER_STATUS_NOT_INITIALIZED:\n            return \"CUSOLVER_STATUS_NOT_INITIALIZED\";\n        case CUSOLVER_STATUS_ALLOC_FAILED:\n            return \"CUSOLVER_STATUS_ALLOC_FAILED\";\n        case CUSOLVER_STATUS_INVALID_VALUE:\n            return \"CUSOLVER_STATUS_INVALID_VALUE\";\n        case CUSOLVER_STATUS_ARCH_MISMATCH:\n            return \"CUSOLVER_STATUS_ARCH_MISMATCH\";\n        case CUSOLVER_STATUS_MAPPING_ERROR:\n            return \"CUSOLVER_STATUS_MAPPING_ERROR\";\n        case CUSOLVER_STATUS_EXECUTION_FAILED:\n            return \"CUSOLVER_STATUS_EXECUTION_FAILED\";\n        case CUSOLVER_STATUS_INTERNAL_ERROR:\n            return \"CUSOLVER_STATUS_INTERNAL_ERROR\";\n        case CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED:\n            return \"CUSOLVER_STATUS_MATRIX_TYPE_NOT_SUPPORTED\";\n        case CUSOLVER_STATUS_NOT_SUPPORTED:\n            return \"CUSOLVER_STATUS_NOT_SUPPORTED \";\n        case CUSOLVER_STATUS_ZERO_PIVOT:\n            return \"CUSOLVER_STATUS_ZERO_PIVOT\";\n        case CUSOLVER_STATUS_INVALID_LICENSE:\n            return \"CUSOLVER_STATUS_INVALID_LICENSE\";\n    }\n\n    return \"&lt;unknown&gt;\";\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/check__cusparse_8h/","title":"File check_cusparse.h","text":"<p>FileList &gt; check &gt; check_cusparse.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;cusparse.h&gt;</code></li> </ul>"},{"location":"muda/check__cusparse_8h/#public-functions","title":"Public Functions","text":"Type Name MUDA_INLINE MUDA_GENERIC const char * mudaCudaGetErrorEnum (cusparseStatus_t error)"},{"location":"muda/check__cusparse_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/check__cusparse_8h/#function-mudacudageterrorenum","title":"function mudaCudaGetErrorEnum","text":"<pre><code>MUDA_INLINE MUDA_GENERIC const char * mudaCudaGetErrorEnum (\n    cusparseStatus_t error\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/check/check_cusparse.h</code></p>"},{"location":"muda/check__cusparse_8h_source/","title":"File check_cusparse.h","text":"<p>File List &gt; check &gt; check_cusparse.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;cusparse.h&gt;\n\n\nMUDA_INLINE MUDA_GENERIC const char* mudaCudaGetErrorEnum(cusparseStatus_t error)\n{\n    switch(error)\n    {\n        case CUSPARSE_STATUS_SUCCESS:\n            return \"CUSPARSE_STATUS_SUCCESS\";\n\n        case CUSPARSE_STATUS_NOT_INITIALIZED:\n            return \"CUSPARSE_STATUS_NOT_INITIALIZED\";\n\n        case CUSPARSE_STATUS_ALLOC_FAILED:\n            return \"CUSPARSE_STATUS_ALLOC_FAILED\";\n\n        case CUSPARSE_STATUS_INVALID_VALUE:\n            return \"CUSPARSE_STATUS_INVALID_VALUE\";\n\n        case CUSPARSE_STATUS_ARCH_MISMATCH:\n            return \"CUSPARSE_STATUS_ARCH_MISMATCH\";\n\n        case CUSPARSE_STATUS_MAPPING_ERROR:\n            return \"CUSPARSE_STATUS_MAPPING_ERROR\";\n\n        case CUSPARSE_STATUS_EXECUTION_FAILED:\n            return \"CUSPARSE_STATUS_EXECUTION_FAILED\";\n\n        case CUSPARSE_STATUS_INTERNAL_ERROR:\n            return \"CUSPARSE_STATUS_INTERNAL_ERROR\";\n\n        case CUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED:\n            return \"CUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED\";\n    }\n\n    return \"&lt;unknown&gt;\";\n}\n</code></pre>"},{"location":"muda/dir_b4aad8ec408afb185bc8426846668e86/","title":"Dir src/muda/compute_graph","text":"<p>FileList &gt; compute_graph</p>"},{"location":"muda/dir_b4aad8ec408afb185bc8426846668e86/#files","title":"Files","text":"Type Name file compute_graph.h file compute_graph_accessor.h file compute_graph_builder.h file compute_graph_closure.h file compute_graph_closure_id.h file compute_graph_dependency.h file compute_graph_flag.h file compute_graph_fwd.h file compute_graph_node.h file compute_graph_node_id.h file compute_graph_node_type.h file compute_graph_phase.h file compute_graph_var.h file compute_graph_var_id.h file compute_graph_var_manager.h file compute_graph_var_usage.h file graphviz_options.h"},{"location":"muda/dir_b4aad8ec408afb185bc8426846668e86/#directories","title":"Directories","text":"Type Name dir nodes <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/</code></p>"},{"location":"muda/compute__graph_2compute__graph_8h/","title":"File compute_graph.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;muda/launch/stream.h&gt;</code></li> <li><code>#include &lt;muda/launch/event.h&gt;</code></li> <li><code>#include &lt;muda/mstl/span.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph_viewer.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_flag.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_phase.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node_type.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_closure_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_dependency.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/graphviz_options.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;</code></li> <li><code>#include \"details/compute_graph.inl\"</code></li> </ul>"},{"location":"muda/compute__graph_2compute__graph_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/compute__graph_2compute__graph_8h/#classes","title":"Classes","text":"Type Name class ComputeGraph class AddNodeProxy class GraphPhaseGuard class LocalVarId class LocalVarInfo <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph.h</code></p>"},{"location":"muda/compute__graph_2compute__graph_8h_source/","title":"File compute_graph.h","text":"<p>File List &gt; compute_graph &gt; compute_graph.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;map&gt;\n#include &lt;functional&gt;\n#include &lt;set&gt;\n#include &lt;muda/launch/stream.h&gt;\n#include &lt;muda/launch/event.h&gt;\n#include &lt;muda/mstl/span.h&gt;\n#include &lt;muda/graph/graph.h&gt;\n#include &lt;muda/graph/graph_viewer.h&gt;\n#include &lt;muda/compute_graph/compute_graph_flag.h&gt;\n#include &lt;muda/compute_graph/compute_graph_phase.h&gt;\n#include &lt;muda/compute_graph/compute_graph_node_type.h&gt;\n#include &lt;muda/compute_graph/compute_graph_node_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_closure_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;\n#include &lt;muda/compute_graph/compute_graph_dependency.h&gt;\n#include &lt;muda/compute_graph/graphviz_options.h&gt;\n#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;\n\nnamespace muda\n{\nnamespace details\n{\n    class LocalVarId : public U64IdWithType\n    {\n        using U64IdWithType::U64IdWithType;\n    };\n    class LocalVarInfo\n    {\n      public:\n        LocalVarId           id{};\n        ComputeGraphVarBase* var = nullptr;\n    };\n}  // namespace details\n\nclass ComputeGraph\n{\n  public:\n    class AddNodeProxy\n    {\n        ComputeGraph&amp; m_cg;\n        std::string   m_node_name;\n\n      public:\n        AddNodeProxy(ComputeGraph&amp; cg, std::string_view node_name);\n        ComputeGraph&amp; operator&lt;&lt;(std::function&lt;void()&gt;&amp;&amp; f) &amp;&amp;;\n    };\n    // A depends on B : from B to A\n    using Dependency = ComputeGraphDependency;\n\n    class GraphPhaseGuard\n    {\n        ComputeGraph&amp; m_cg;\n\n      public:\n        GraphPhaseGuard(ComputeGraph&amp; cg, ComputeGraphPhase phase);\n        ~GraphPhaseGuard();\n    };\n\n    // delete copy\n    ComputeGraph(const ComputeGraph&amp;)            = delete;\n    ComputeGraph&amp; operator=(const ComputeGraph&amp;) = delete;\n\n    // delete move\n    ComputeGraph(ComputeGraph&amp;&amp;)            = delete;\n    ComputeGraph&amp; operator=(ComputeGraph&amp;&amp;) = delete;\n\n  private:\n    //class TempNodeInfo\n    //{\n    //  public:\n    //    std::map&lt;VarId, ComputeGraphVarUsage&gt; var_usage;\n    //};\n    template &lt;typename T&gt;\n    using U = std::unique_ptr&lt;T&gt;;\n    template &lt;typename T&gt;\n    using S = std::shared_ptr&lt;T&gt;;\n\n    friend class ComputeGraphVarBase;\n\n    Graph        m_graph;\n    S&lt;GraphExec&gt; m_graph_exec{nullptr};\n\n    std::unordered_map&lt;NodeId::value_type, cudaGraph_t&gt; m_sub_graphs;\n\n    std::vector&lt;std::pair&lt;std::string, ComputeGraphClosure*&gt;&gt; m_closures;\n\n    std::map&lt;VarId, details::LocalVarId&gt; m_global_to_local_var_id;\n    std::vector&lt;details::LocalVarInfo&gt;   m_related_vars;\n    void emplace_related_var(ComputeGraphVarBase* var);\n\n\n    std::vector&lt;ComputeGraphNodeBase*&gt;              m_nodes;\n    std::vector&lt;std::vector&lt;ComputeGraphNodeBase*&gt;&gt; m_graph_nodes;\n    std::vector&lt;Dependency&gt;                         m_deps;\n\n    std::vector&lt;int&gt;        m_closure_need_update;\n    ComputeGraphVarManager* m_var_manager = nullptr;\n\n    friend class ComputeGraphVarManager;\n\n    Event                      m_event;\n    mutable Event::QueryResult m_event_result = Event::QueryResult::eFinished;\n    Flags&lt;GraphInstantiateFlagBit&gt; m_flags;\n\n  public:\n    ComputeGraph(ComputeGraphVarManager&amp; manager,\n                 std::string_view        name = \"graph\",\n                 ComputeGraphFlag        flag = ComputeGraphFlag::HostLaunch);\n\n    ~ComputeGraph();\n\n    /**************************************************************\n    * \n    * Info API\n    * \n    ***************************************************************/\n\n    std::string_view name() const { return m_name; }\n\n    /**************************************************************\n    * \n    * GraphNode API\n    * \n    ***************************************************************/\n\n    AddNodeProxy create_node(std::string_view node_name);\n\n\n    /**************************************************************\n    * \n    * Graph Launch API\n    * \n    ***************************************************************/\n\n    void update();\n\n    void build();\n\n    void launch(bool single_stream, cudaStream_t s = nullptr);\n\n    void launch(cudaStream_t s = nullptr) { return launch(false, s); }\n\n    /**************************************************************\n    * \n    * Graph Event Query API\n    * \n    ***************************************************************/\n\n    Event::QueryResult query() const;\n\n    /**************************************************************\n    * \n    * Graph Closure Capture Node API\n    * \n    ***************************************************************/\n\n    void capture(std::function&lt;void(cudaStream_t)&gt;&amp;&amp; f);\n    void capture(std::string_view name, std::function&lt;void(cudaStream_t)&gt;&amp;&amp; f);\n\n    /**************************************************************\n    * \n    * Graph Visualization API\n    * \n    ***************************************************************/\n\n    void graphviz(std::ostream&amp; o, const ComputeGraphGraphvizOptions&amp; options = {});\n\n    /**************************************************************\n    * \n    * Graph Viewer API\n    * \n    ***************************************************************/\n\n    GraphViewer viewer();\n\n    operator GraphViewer() { return viewer(); }\n\n  private:  // internal method\n    void topo_build();\n\n    void cuda_graph_add_deps();\n\n    void build_deps();\n\n    void serial_launch();\n\n    void _update();\n\n    void check_vars_valid();\n\n    friend class AddNodeProxy;\n    ComputeGraph&amp; add_node(std::string&amp;&amp; name, const std::function&lt;void()&gt;&amp; f);\n\n    friend class ComputeGraphNodeBase;\n    friend class ComputeGraphClosure;\n    span&lt;const Dependency&gt; dep_span(size_t begin, size_t count) const;\n\n    void set_current_graph_as_this();\n\n    static void clear_current_graph();\n\n    static Stream&amp; shared_capture_stream();\n\n    friend class ComputeGraphBuilder;\n    ClosureId current_closure_id() const { return m_current_closure_id; };\n\n    NodeId current_node_id() const { return m_current_node_id; };\n\n    size_t current_access_index() const { return m_access_graph_index; }\n\n    ComputeGraphPhase current_graph_phase() const;\n\n  private:  // internal data\n    friend class muda::details::ComputeGraphAccessor;\n    std::string       m_name;\n    bool              m_need_update = false;\n    ClosureId         m_current_closure_id;\n    NodeId            m_current_node_id;\n    ComputeGraphPhase m_current_graph_phase = ComputeGraphPhase::None;\n    bool              m_allow_access_graph  = false;\n    size_t            m_access_graph_index  = 0;\n    bool              m_allow_node_adding   = true;\n    // TempNodeInfo      m_temp_node_info;\n    cudaStream_t m_current_single_stream = nullptr;\n    bool         m_is_capturing          = false;\n    // in capture func, we don't allow any var eval()\n    bool m_is_in_capture_func = false;\n    // if we have already built the topo, we don't do that again\n    bool m_is_topo_built = false;\n};\n}  // namespace muda\n\n#include \"details/compute_graph.inl\"\n</code></pre>"},{"location":"muda/compute__graph__accessor_8h/","title":"File compute_graph_accessor.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_accessor.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;</code></li> <li><code>#include &lt;muda/graph/kernel_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/memory_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/event_node.h&gt;</code></li> <li><code>#include \"details/compute_graph_accessor.inl\"</code></li> </ul>"},{"location":"muda/compute__graph__accessor_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/compute__graph__accessor_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphAccessor <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_accessor.h</code></p>"},{"location":"muda/compute__graph__accessor_8h_source/","title":"File compute_graph_accessor.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_accessor.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda_runtime.h&gt;\n#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;\n#include &lt;muda/graph/kernel_node.h&gt;\n#include &lt;muda/graph/memory_node.h&gt;\n#include &lt;muda/graph/event_node.h&gt;\nnamespace muda\n{\nnamespace details\n{\n    // allow devlopers to access some internal function\n    class ComputeGraphAccessor\n    {\n        friend class ComputeGraph;\n        ComputeGraph&amp; m_cg;\n        template &lt;typename T&gt;\n        using S = std::shared_ptr&lt;T&gt;;\n\n      public:\n        ComputeGraphAccessor();\n\n        ComputeGraphAccessor(ComputeGraph&amp; graph);\n        ComputeGraphAccessor(ComputeGraph* graph);\n\n        /************************************************************************************\n        * \n        *                              Graph Add/Update node API\n        * \n        * Automatically add or update graph node by parms (distincted by ComputeGraphPhase)\n        * \n        *************************************************************************************/\n        template &lt;typename T&gt;\n        void set_kernel_node(const S&lt;KernelNodeParms&lt;T&gt;&gt;&amp; kernelParms);\n        void set_memcpy_node(void* dst, const void* src, size_t size_bytes, cudaMemcpyKind kind);\n        void set_memcpy_node(const cudaMemcpy3DParms&amp; parms);\n        void set_memset_node(const cudaMemsetParams&amp; parms);\n        void set_event_record_node(cudaEvent_t event);\n        void set_event_wait_node(cudaEvent_t event);\n        void set_capture_node(cudaGraph_t sub_graph);\n\n        /************************************************************************************\n        * \n        *                             Current State Query API\n        * \n        *************************************************************************************/\n        auto current_closure() const\n            -&gt; const std::pair&lt;std::string, ComputeGraphClosure*&gt;&amp;;\n        auto current_closure() -&gt; std::pair&lt;std::string, ComputeGraphClosure*&gt;&amp;;\n        template &lt;typename T&gt;\n        T*                          current_node();\n        const ComputeGraphNodeBase* current_node() const;\n        ComputeGraphNodeBase*       current_node();\n        cudaStream_t                current_stream() const;\n        cudaStream_t                capture_stream() const;\n\n        bool is_topo_built() const;\n\n        /************************************************************************************\n        * \n        *                             Current State Check API\n        * \n        *************************************************************************************/\n        void check_allow_var_eval() const;\n        void check_allow_node_adding() const;\n\n      private:\n        friend class muda::ComputeGraphVarBase;\n        void set_var_usage(VarId id, ComputeGraphVarUsage usage);\n\n        template &lt;typename T&gt;\n        void add_kernel_node(const S&lt;KernelNodeParms&lt;T&gt;&gt;&amp; kernelParms);\n        template &lt;typename T&gt;\n        void update_kernel_node(const S&lt;KernelNodeParms&lt;T&gt;&gt;&amp; kernelParms);\n\n        void add_memcpy_node(void* dst, const void* src, size_t size_bytes, cudaMemcpyKind kind);\n        void update_memcpy_node(void* dst, const void* src, size_t size_bytes, cudaMemcpyKind kind);\n        void add_memcpy_node(const cudaMemcpy3DParms&amp; parms);\n        void update_memcpy_node(const cudaMemcpy3DParms&amp; parms);\n\n        void add_memset_node(const cudaMemsetParams&amp; parms);\n        void update_memset_node(const cudaMemsetParams&amp; parms);\n\n        void add_event_record_node(cudaEvent_t event);\n        void update_event_record_node(cudaEvent_t event);\n\n        void add_event_wait_node(cudaEvent_t event);\n        void update_event_wait_node(cudaEvent_t event);\n\n        void add_capture_node(cudaGraph_t sub_graph);\n        void update_capture_node(cudaGraph_t sub_graph);\n\n        template &lt;typename F&gt;\n        void access_graph(F&amp;&amp; f);\n\n        template &lt;typename F&gt;\n        void access_graph_exec(F&amp;&amp; f);\n\n        //auto&amp;&amp; temp_var_usage()\n        //{\n        //    return std::move(m_cg.m_temp_node_info.var_usage);\n        //}\n\n        template &lt;typename NodeType, typename F&gt;\n        NodeType* get_or_create_node(F&amp;&amp; f);\n    };\n}  // namespace details\n}  // namespace muda\n\n#include \"details/compute_graph_accessor.inl\"\n</code></pre>"},{"location":"muda/compute__graph__builder_8h/","title":"File compute_graph_builder.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_builder.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_phase.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;</code></li> <li><code>#include \"details/compute_graph_builder.inl\"</code></li> </ul>"},{"location":"muda/compute__graph__builder_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/compute__graph__builder_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphBuilder <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_builder.h</code></p>"},{"location":"muda/compute__graph__builder_8h_source/","title":"File compute_graph_builder.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_builder.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;functional&gt;\n#include &lt;muda/compute_graph/compute_graph_phase.h&gt;\n#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;\n#include &lt;functional&gt;\n\nnamespace muda\n{\nclass ComputeGraphBuilder\n{\n    static ComputeGraphBuilder&amp; instance();\n    using Phase         = ComputeGraphPhase;\n    using PhaseAction   = std::function&lt;void()&gt;;\n    using CaptureAction = std::function&lt;void(cudaStream_t)&gt;;\n\n  public:\n    static Phase current_phase();\n    static void  capture(CaptureAction&amp;&amp; cap);\n    static void  capture(std::string_view name, CaptureAction&amp;&amp; cap);\n    static bool  is_phase_none();\n    static bool  is_phase_serial_launching();\n    static bool  is_topo_building();\n    static bool  is_building();\n    // return true when no graph is building or the graph is in serial launching mode\n    static bool is_direct_launching();\n    static bool is_caturing();\n\n\n    // do_when_direct_launch\n    // do_when_set_node =&gt; do_when_add_node &amp; do_when_update_node\n    // if do_when_topo_building_set_node == nullptr, do_when_set_node will be called\n    // if do_when_topo_building_set_node != nullptr, do_when_topo_building_set_node will be called\n    // copy this code to use:\n    /*\n            ComputeGraphBuilder::invoke_phase_actions(\n            [&amp;] // do_when_direct_launch\n            {\n\n            },\n            [&amp;] // do_when_set_node\n            {\n\n            },\n            [&amp;] // do_when_topo_building_set_node\n            {\n\n            });\n    */\n    static void invoke_phase_actions(PhaseAction&amp;&amp; do_when_direct_launch,\n                                     PhaseAction&amp;&amp; do_when_set_node,\n                                     PhaseAction&amp;&amp; do_when_topo_building_set_node);\n\n    // copy this code to use:\n    /*\n            ComputeGraphBuilder::invoke_phase_actions(\n            [&amp;] // do_when_direct_launch\n            {\n\n            },\n            [&amp;] // do_when_set_node and do_when_topo_building_set_node\n            {\n\n            });\n    */\n    static void invoke_phase_actions(PhaseAction&amp;&amp; do_when_direct_launch,\n                                     PhaseAction&amp;&amp; do_when_set_node);\n\n    // copy this code to use:\n    /*\n            ComputeGraphBuilder::invoke_phase_actions(\n            [&amp;] // do_in_every_phase\n            {\n\n            });\n    */\n    static void invoke_phase_actions(PhaseAction&amp;&amp; do_in_every_phase);\n\n  private:\n    friend class ComputeGraph;\n    friend class ComputeGraphVarBase;\n\n    static void current_graph(ComputeGraph* graph);\n    friend class details::ComputeGraphAccessor;\n    static auto current_graph() { return instance().m_current_graph; }\n\n    ComputeGraphBuilder()  = default;\n    ~ComputeGraphBuilder() = default;\n\n    ComputeGraph* m_current_graph = nullptr;\n};\n}  // namespace muda\n\n#include \"details/compute_graph_builder.inl\"\n</code></pre>"},{"location":"muda/compute__graph__closure_8h/","title":"File compute_graph_closure.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_closure.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node_type.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/graphviz_options.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_dependency.h&gt;</code></li> <li><code>#include \"details/compute_graph_closure.inl\"</code></li> </ul>"},{"location":"muda/compute__graph__closure_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/compute__graph__closure_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphClosure <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_closure.h</code></p>"},{"location":"muda/compute__graph__closure_8h_source/","title":"File compute_graph_closure.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_closure.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;muda/compute_graph/compute_graph_node_type.h&gt;\n#include &lt;muda/compute_graph/compute_graph_node.h&gt;\n#include &lt;muda/compute_graph/compute_graph_node_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;\n#include &lt;muda/compute_graph/graphviz_options.h&gt;\n#include &lt;muda/compute_graph/compute_graph_dependency.h&gt;\n\nnamespace muda\n{\nclass ComputeGraphClosure\n{\n    friend class details::ComputeGraphAccessor;\n\n  public:\n    auto        clousure_id() const { return m_clousure_id; }\n    auto        type() const { return m_type; }\n    auto        name() const { return std::string_view{m_name}; }\n    const auto&amp; var_usages() const { return m_var_usages; }\n    span&lt;const ComputeGraphDependency&gt; deps() const;\n\n    virtual void graphviz_id(std::ostream&amp; o, const ComputeGraphGraphvizOptions&amp; options) const;\n    virtual void graphviz_def(std::ostream&amp; o, const ComputeGraphGraphvizOptions&amp; options) const;\n    virtual void graphviz_var_usages(std::ostream&amp; o,\n                                     const ComputeGraphGraphvizOptions&amp; options) const;\n    virtual ~ComputeGraphClosure() = default;\n\n  protected:\n    template &lt;typename T&gt;\n    using S = std::shared_ptr&lt;T&gt;;\n\n    friend class ComputeGraph;\n    friend class ComputeGraphVarBase;\n    ComputeGraphClosure(ComputeGraph*               graph,\n                        ClosureId                   clousure_id,\n                        std::string_view            name,\n                        const std::function&lt;void()&gt; f)\n        : m_graph(graph)\n        , m_clousure_id(clousure_id)\n        , m_name(name)\n        , m_closure(f)\n    {\n    }\n\n    std::function&lt;void()&gt;                 m_closure;\n    std::map&lt;VarId, ComputeGraphVarUsage&gt; m_var_usages;\n    ClosureId                             m_clousure_id;\n    uint64_t                              m_access_graph_index;\n    ComputeGraph*                         m_graph;\n    std::string                           m_name;\n    ComputeGraphNodeType                  m_type;\n    size_t                                m_deps_begin = 0;\n    size_t                                m_deps_count = 0;\n\n    void operator()() { m_closure(); }\n\n    std::vector&lt;ComputeGraphNodeBase*&gt; m_graph_nodes;\n    void set_deps_range(size_t begin, size_t count);\n};\n}  // namespace muda\n\n#include \"details/compute_graph_closure.inl\"\n</code></pre>"},{"location":"muda/compute__graph__closure__id_8h/","title":"File compute_graph_closure_id.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_closure_id.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/id_with_type.h&gt;</code></li> </ul>"},{"location":"muda/compute__graph__closure__id_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace std"},{"location":"muda/compute__graph__closure__id_8h/#classes","title":"Classes","text":"Type Name class ClosureId struct hash&lt; muda::ClosureId &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_closure_id.h</code></p>"},{"location":"muda/compute__graph__closure__id_8h_source/","title":"File compute_graph_closure_id.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_closure_id.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/id_with_type.h&gt;\nnamespace muda\n{\nclass ClosureId : public U64IdWithType\n{\n    using U64IdWithType::U64IdWithType;\n};\n}  // namespace muda\n\nnamespace std\n{\ntemplate &lt;&gt;\nstruct hash&lt;muda::ClosureId&gt;\n{\n    size_t operator()(const muda::ClosureId&amp; s) const noexcept\n    {\n        return std::hash&lt;uint64_t&gt;{}(s.value());\n    }\n};\n}  // namespace std\n</code></pre>"},{"location":"muda/compute__graph__dependency_8h/","title":"File compute_graph_dependency.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_dependency.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/compute_graph/compute_graph_closure_id.h&gt;</code></li> </ul>"},{"location":"muda/compute__graph__dependency_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/compute__graph__dependency_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphDependency <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_dependency.h</code></p>"},{"location":"muda/compute__graph__dependency_8h_source/","title":"File compute_graph_dependency.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_dependency.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/compute_graph/compute_graph_closure_id.h&gt;\nnamespace muda\n{\nclass ComputeGraphDependency\n{\n  public:\n    ClosureId from;\n    ClosureId to;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/compute__graph__flag_8h/","title":"File compute_graph_flag.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_flag.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/compute__graph__flag_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_flag.h</code></p>"},{"location":"muda/compute__graph__flag_8h_source/","title":"File compute_graph_flag.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_flag.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\nnamespace muda\n{\nenum class ComputeGraphFlag\n{\n    HostLaunch   = 1,\n    DeviceLaunch = 2 | HostLaunch,\n};\n}\n</code></pre>"},{"location":"muda/compute__graph__fwd_8h/","title":"File compute_graph_fwd.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_fwd.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_closure_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;</code></li> </ul>"},{"location":"muda/compute__graph__fwd_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_fwd.h</code></p>"},{"location":"muda/compute__graph__fwd_8h_source/","title":"File compute_graph_fwd.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_fwd.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_closure_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_node_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;\nnamespace muda\n{\nclass ComputeGraphVarBase;\nclass ComputeGraphNodeBase;\nclass ComputeGraphVarManager;\nclass ComputeGraphClosure;\ntemplate &lt;typename T&gt;\nclass ComputeGraphVar;\nclass ComputeGraph;\nclass ComputeGraphGraphvizOptions;\nnamespace details\n{\n    class ComputeGraphAccessor;\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/compute__graph__node_8h/","title":"File compute_graph_node.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node_type.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;</code></li> <li><code>#include \"details/compute_graph_node.inl\"</code></li> </ul>"},{"location":"muda/compute__graph__node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/compute__graph__node_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphNode &lt;typename NodeT, Type&gt; class ComputeGraphNodeBase <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_node.h</code></p>"},{"location":"muda/compute__graph__node_8h_source/","title":"File compute_graph_node.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;muda/compute_graph/compute_graph_node_type.h&gt;\n#include &lt;muda/compute_graph/compute_graph_node_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;\n\nnamespace muda\n{\nclass ComputeGraphNodeBase\n{\n  public:\n    auto node_id() const { return m_node_id; }\n    auto access_index() const { return m_access_index; }\n    auto type() const { return m_type; }\n    auto name() const { return std::string_view{m_name}; }\n\n    virtual ~ComputeGraphNodeBase() = default;\n\n  protected:\n    template &lt;typename T&gt;\n    using S = std::shared_ptr&lt;T&gt;;\n\n    friend class ComputeGraph;\n    friend class ComputeGraphVarBase;\n    ComputeGraphNodeBase(std::string_view name, NodeId node_id, uint64_t access_index, ComputeGraphNodeType type)\n        : m_name(name)\n        , m_node_id(node_id)\n        , m_access_index(access_index)\n        , m_type(type)\n    {\n    }\n\n    std::string m_name;\n    NodeId      m_node_id;\n    uint64_t    m_access_index;\n\n    ComputeGraphNodeType m_type;\n    cudaGraphNode_t      m_cuda_node = nullptr;\n\n\n    auto handle() const { return m_cuda_node; }\n    void set_handle(cudaGraphNode_t handle) { m_cuda_node = handle; }\n    auto is_valid() const { return m_cuda_node; }\n};\n\ntemplate &lt;typename NodeT, ComputeGraphNodeType Type&gt;\nclass ComputeGraphNode : public ComputeGraphNodeBase\n{\n  protected:\n    friend class ComputeGraph;\n    friend class details::ComputeGraphAccessor;\n    ComputeGraphNode(NodeId node_id, uint64_t access_graph_index);\n\n    S&lt;NodeT&gt; m_node;\n    void     set_node(S&lt;NodeT&gt; node);\n    virtual ~ComputeGraphNode() = default;\n};\n}  // namespace muda\n\n#include \"details/compute_graph_node.inl\"\n</code></pre>"},{"location":"muda/compute__graph__node__id_8h/","title":"File compute_graph_node_id.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_node_id.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/id_with_type.h&gt;</code></li> </ul>"},{"location":"muda/compute__graph__node__id_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/compute__graph__node__id_8h/#classes","title":"Classes","text":"Type Name class NodeId <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_node_id.h</code></p>"},{"location":"muda/compute__graph__node__id_8h_source/","title":"File compute_graph_node_id.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_node_id.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/id_with_type.h&gt;\nnamespace muda\n{\nclass NodeId : public U64IdWithType\n{\n    using U64IdWithType::U64IdWithType;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/compute__graph__node__type_8h/","title":"File compute_graph_node_type.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_node_type.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> </ul>"},{"location":"muda/compute__graph__node__type_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_node_type.h</code></p>"},{"location":"muda/compute__graph__node__type_8h_source/","title":"File compute_graph_node_type.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_node_type.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cinttypes&gt;\n#include &lt;string_view&gt;\nnamespace muda\n{\nenum class ComputeGraphNodeType : uint8_t\n{\n    None,\n    KernelNode,\n    MemcpyNode,\n    MemsetNode,\n    CaptureNode,\n    EventRecordNode,\n    EventWaitNode,\n    Max\n};\n\ninline std::string_view enum_name(ComputeGraphNodeType t)\n{\n    switch(t)\n    {\n        case ComputeGraphNodeType::None:\n            return \"None\";\n        case ComputeGraphNodeType::KernelNode:\n            return \"KernelNode\";\n        case ComputeGraphNodeType::MemcpyNode:\n            return \"MemcpyNode\";\n        case ComputeGraphNodeType::MemsetNode:\n            return \"MemsetNode\";\n        case ComputeGraphNodeType::CaptureNode:\n            return \"CaptureNode\";\n        case ComputeGraphNodeType::EventRecordNode:\n            return \"EventRecordNode\";\n        case ComputeGraphNodeType::EventWaitNode:\n            return \"EventWaitNode\";\n        default:\n            return \"Unknown\";\n    }\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/compute__graph__phase_8h/","title":"File compute_graph_phase.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_phase.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/compute__graph__phase_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_phase.h</code></p>"},{"location":"muda/compute__graph__phase_8h_source/","title":"File compute_graph_phase.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_phase.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\nnamespace muda\n{\nenum class ComputeGraphPhase\n{\n    None,\n    TopoBuilding, // we don't create cuda graph at this point, just build the topo\n    Building, // we create cuda graph at this point\n    Updating, // we update the graph at this point\n    SerialLaunching, // we just launch invoke all the graph closure in serial\n    Max\n};\n}\n</code></pre>"},{"location":"muda/compute__graph__var_8h/","title":"File compute_graph_var.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_var.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;muda/launch/event.h&gt;</code></li> <li><code>#include &lt;muda/mstl/span.h&gt;</code></li> <li><code>#include &lt;muda/type_traits/type_modifier.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_closure_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/graphviz_options.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;</code></li> <li><code>#include \"details/compute_graph_var.inl\"</code></li> </ul>"},{"location":"muda/compute__graph__var_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/compute__graph__var_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphVar &lt;typename T&gt; class ComputeGraphVarBase struct read_only_view &lt;typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_var.h</code></p>"},{"location":"muda/compute__graph__var_8h_source/","title":"File compute_graph_var.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_var.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;muda/launch/event.h&gt;\n#include &lt;muda/mstl/span.h&gt;\n#include &lt;muda/type_traits/type_modifier.h&gt;\n#include &lt;muda/compute_graph/compute_graph_closure_id.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_usage.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var_id.h&gt;\n#include &lt;muda/compute_graph/graphviz_options.h&gt;\n#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;\n\nnamespace muda\n{\nclass ComputeGraphVarBase\n{\n    std::string_view        m_name;\n    ComputeGraphVarManager* m_var_manager = nullptr;\n    VarId                   m_var_id;\n    bool                    m_is_valid;\n\n  public:\n    std::string_view   name() const MUDA_NOEXCEPT { return m_name; }\n    VarId              var_id() const MUDA_NOEXCEPT { return m_var_id; }\n    bool               is_valid() const MUDA_NOEXCEPT { return m_is_valid; }\n    void               update();\n    Event::QueryResult query();\n    bool               is_using();\n    void               sync();\n    virtual void       graphviz_def(std::ostream&amp;                      os,\n                                    const ComputeGraphGraphvizOptions&amp; options) const;\n    virtual void graphviz_id(std::ostream&amp; os, const ComputeGraphGraphvizOptions&amp; options) const;\n\n  protected:\n    template &lt;typename RWView&gt;\n    RWView _eval(const RWView&amp; view);\n    template &lt;typename ROView&gt;\n    ROView _ceval(ROView&amp; view) const;\n\n    friend class ComputeGraph;\n    friend class ComputeGraphVarManager;\n\n    ComputeGraphVarBase(ComputeGraphVarManager* var_manager,\n                        std::string_view        name,\n                        VarId var_id) MUDA_NOEXCEPT : m_var_manager(var_manager),\n                                                      m_name(name),\n                                                      m_var_id(var_id),\n                                                      m_is_valid(false)\n    {\n    }\n\n    ComputeGraphVarBase(ComputeGraphVarManager* var_manager,\n                        std::string_view        name,\n                        VarId                   var_id,\n                        bool is_valid) MUDA_NOEXCEPT : m_var_manager(var_manager),\n                                                       m_name(name),\n                                                       m_var_id(var_id),\n                                                       m_is_valid(is_valid)\n    {\n    }\n\n    virtual ~ComputeGraphVarBase() = default;\n\n\n    void base_update();\n\n    friend class LaunchCore;\n\n    mutable std::set&lt;ClosureId&gt; m_closure_ids;\n\n  private:\n    void _building_eval(ComputeGraphVarUsage usage) const;\n    void base_building_eval();\n    void base_building_ceval() const;\n    void remove_related_closure_infos(ComputeGraph* graph);\n\n    class RelatedClosureInfo\n    {\n      public:\n        ComputeGraph*       graph;\n        std::set&lt;ClosureId&gt; closure_ids;\n    };\n\n    mutable std::map&lt;ComputeGraph*, RelatedClosureInfo&gt; m_related_closure_infos;\n};\n\ntemplate &lt;typename T&gt;\nclass ComputeGraphVar : public ComputeGraphVarBase\n{\n  public:\n    static_assert(!std::is_const_v&lt;T&gt;, \"T must not be const\");\n    using ROViewer = read_only_view_t&lt;T&gt;;\n    using RWViewer = T;\n    static_assert(std::is_convertible_v&lt;RWViewer, ROViewer&gt;,\n                  \"RWViewer must be convertible to ROView\");\n\n  protected:\n    friend class ComputeGraph;\n    friend class ComputeGraphVarManager;\n\n    using ComputeGraphVarBase::ComputeGraphVarBase;\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager, std::string_view name, VarId var_id) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id)\n    {\n    }\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager,\n                    std::string_view        name,\n                    VarId                   var_id,\n                    const T&amp;                init_value) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id, true),\n          m_value(init_value)\n    {\n    }\n\n    virtual ~ComputeGraphVar() = default;\n\n  public:\n    RWViewer eval() { return _eval(m_value); }\n    ROViewer ceval() const { return _ceval(m_value); }\n\n    operator ROViewer() const { return ceval(); }\n    operator RWViewer() { return eval(); }\n\n    void                update(const RWViewer&amp; view);\n    ComputeGraphVar&lt;T&gt;&amp; operator=(const RWViewer&amp; view);\n    virtual void        graphviz_def(std::ostream&amp; os,\n                                     const ComputeGraphGraphvizOptions&amp; options) const override;\n\n  private:\n    RWViewer m_value;\n};\n\n// for host memory\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;T*&gt;\n{\n    using type = const T*;\n};\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;const T*&gt;\n{\n    using type = T*;\n};\n\n// for cuda event\ntemplate &lt;&gt;\nstruct read_only_view&lt;cudaEvent_t&gt;\n{\n    using type = cudaEvent_t;\n};\ntemplate &lt;&gt;\nstruct read_write_view&lt;cudaEvent_t&gt;\n{\n    using type = cudaEvent_t;\n};\n\n}  // namespace muda\n\n\n#include \"details/compute_graph_var.inl\"\n</code></pre>"},{"location":"muda/compute__graph__var__id_8h/","title":"File compute_graph_var_id.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_var_id.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/id_with_type.h&gt;</code></li> </ul>"},{"location":"muda/compute__graph__var__id_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/compute__graph__var__id_8h/#classes","title":"Classes","text":"Type Name class VarId <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_var_id.h</code></p>"},{"location":"muda/compute__graph__var__id_8h_source/","title":"File compute_graph_var_id.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_var_id.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/id_with_type.h&gt;\nnamespace muda\n{\nclass VarId : public U64IdWithType\n{\n    using U64IdWithType::U64IdWithType;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/compute__graph__var__manager_8h/","title":"File compute_graph_var_manager.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_var_manager.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;driver_types.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;muda/mstl/span.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_flag.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/graphviz_options.h&gt;</code></li> <li><code>#include \"details/compute_graph_var_manager.inl\"</code></li> </ul>"},{"location":"muda/compute__graph__var__manager_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/compute__graph__var__manager_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphVarManager <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_var_manager.h</code></p>"},{"location":"muda/compute__graph__var__manager_8h_source/","title":"File compute_graph_var_manager.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_var_manager.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;driver_types.h&gt;\n#include &lt;memory&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;muda/mstl/span.h&gt;\n#include &lt;muda/compute_graph/compute_graph_flag.h&gt;\n#include &lt;muda/compute_graph/compute_graph_fwd.h&gt;\n#include &lt;muda/compute_graph/graphviz_options.h&gt;\nnamespace muda\n{\nclass ComputeGraphVarManager\n{\n    template &lt;typename T&gt;\n    using S = std::shared_ptr&lt;T&gt;;\n\n  public:\n    ComputeGraphVarManager() = default;\n    ~ComputeGraphVarManager();\n\n    S&lt;ComputeGraph&gt; create_graph(std::string_view name  = \"graph\",\n                                 ComputeGraphFlag flags = {});\n\n\n    /**************************************************************\n    * \n    * GraphVar API\n    * \n    ***************************************************************/\n    template &lt;typename T&gt;\n    ComputeGraphVar&lt;T&gt;&amp; create_var(std::string_view name);\n    template &lt;typename T&gt;\n    ComputeGraphVar&lt;T&gt;&amp; create_var(std::string_view name, const T&amp; init_value);\n    template &lt;typename T&gt;\n    ComputeGraphVar&lt;T&gt;* find_var(std::string_view name);\n\n    bool is_using() const;\n    void sync() const;\n    void sync_on(cudaStream_t stream) const;\n\n    template &lt;typename... T&gt;\n    bool is_using(const ComputeGraphVar&lt;T&gt;&amp;... vars) const;\n    template &lt;typename... T&gt;\n    void sync(const ComputeGraphVar&lt;T&gt;&amp;... vars) const;\n    template &lt;typename... T&gt;\n    void sync_on(cudaStream_t stream, const ComputeGraphVar&lt;T&gt;&amp;... vars) const;\n\n    bool is_using(const span&lt;const ComputeGraphVarBase*&gt; vars) const;\n    void sync(const span&lt;const ComputeGraphVarBase*&gt; vars) const;\n    void sync_on(cudaStream_t stream, const span&lt;const ComputeGraphVarBase*&gt; vars) const;\n\n    const auto&amp; graphs() const { return m_graphs; }\n    void graphviz(std::ostream&amp; os, const ComputeGraphGraphvizOptions&amp; options = {}) const;\n\n  private:\n    friend class ComputeGraph;\n    friend class ComputeGraphNodeBase;\n    friend class ComputeGraphClosure;\n    std::vector&lt;ComputeGraph*&gt; unique_graphs(span&lt;const ComputeGraphVarBase*&gt; vars) const;\n    std::unordered_map&lt;std::string, ComputeGraphVarBase*&gt; m_vars_map;\n    std::vector&lt;ComputeGraphVarBase*&gt;                     m_vars;\n    std::unordered_set&lt;ComputeGraph*&gt;                     m_graphs;\n    span&lt;const ComputeGraphVarBase*&gt;                      var_span() const;\n};\n}  // namespace muda\n\n#include \"details/compute_graph_var_manager.inl\"\n</code></pre>"},{"location":"muda/compute__graph__var__usage_8h/","title":"File compute_graph_var_usage.h","text":"<p>FileList &gt; compute_graph &gt; compute_graph_var_usage.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/compute__graph__var__usage_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/compute_graph_var_usage.h</code></p>"},{"location":"muda/compute__graph__var__usage_8h_source/","title":"File compute_graph_var_usage.h","text":"<p>File List &gt; compute_graph &gt; compute_graph_var_usage.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\nnamespace muda\n{\nenum class ComputeGraphVarUsage : char\n{\n    None,\n    Read,\n    ReadWrite,\n    Max\n};\n\ninline bool operator&lt;(ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)\n{\n    return static_cast&lt;char&gt;(lhs) &lt; static_cast&lt;char&gt;(rhs);\n}\n\ninline bool operator&lt;=(ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)\n{\n    return static_cast&lt;char&gt;(lhs) &lt;= static_cast&lt;char&gt;(rhs);\n}\n\ninline bool operator&gt;(ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)\n{\n    return static_cast&lt;char&gt;(lhs) &gt; static_cast&lt;char&gt;(rhs);\n}\n\ninline bool operator&gt;=(ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)\n{\n    return static_cast&lt;char&gt;(lhs) &gt;= static_cast&lt;char&gt;(rhs);\n}\n\ninline bool operator==(ComputeGraphVarUsage lhs, ComputeGraphVarUsage rhs)\n{\n    return static_cast&lt;char&gt;(lhs) == static_cast&lt;char&gt;(rhs);\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/graphviz__options_8h/","title":"File graphviz_options.h","text":"<p>FileList &gt; compute_graph &gt; graphviz_options.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"muda/graphviz__options_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graphviz__options_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphGraphvizOptions <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/graphviz_options.h</code></p>"},{"location":"muda/graphviz__options_8h_source/","title":"File graphviz_options.h","text":"<p>File List &gt; compute_graph &gt; graphviz_options.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\nnamespace muda\n{\nclass ComputeGraphGraphvizOptions\n{\n  public:\n    bool show_vars                         = true;\n    bool show_nodes                        = true;\n    bool as_subgraph                       = false;\n    bool show_all_graph_nodes_in_a_closure = false;\n    int  graph_id                          = 0;\n\n    // styles\n    std::string node_style =\n        R\"(shape=\"egg\", color=\"#82B366\", style=\"filled\", fillcolor=\"#D5E8D4\",)\";\n\n    std::string all_nodes_closure_style =\n        R\"(shape=\"Mrecord\", color=\"#82B366\", style=\"filled\", fillcolor=\"#D5E8D4\",)\";\n\n    std::string var_style =\n        R\"(shape=\"rectangle\", color=\"#F08705\", style=\"filled,rounded\", fillcolor=\"#F5AF58\",)\";\n\n    std::string read_write_style = R\"(color=\"#F08E81\", arrowhead = diamond,)\";\n\n    std::string read_style = R\"(color=\"#64BBE2\", arrowhead = dot, )\";\n\n    std::string arc_style = R\"(color=\"#82B366\", )\";\n\n    std::string event_style =\n        R\"(shape=\"rectangle\", color=\"#8E44AD\", style=\"filled,rounded\", fillcolor=\"#BB8FCE\",)\";\n\n    std::string graph_viewer_style =\n        R\"(shape=\"rectangle\", color=\"#82B366\", style=\"filled,rounded\", fillcolor=\"#D5E8D4\",)\";\n\n    std::string cluster_style =\n        R\"(fontcolor=\"#82B366\" fontsize=18; color = \"#82B366\"; style = \"dashed\";)\";\n\n    std::string cluster_var_style = R\"(color=\"#F08705\"; style=\"dashed\";)\";\n\n    std::string graph_font = R\"(graph [fontname = \"helvetica\"];\nnode [fontname = \"helvetica\"];\nedge [fontname = \"helvetica\"];)\";\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_7ff8159720d09b9da5f49b4c95af33a4/","title":"Dir src/muda/compute_graph/nodes","text":"<p>FileList &gt; compute_graph &gt; nodes</p>"},{"location":"muda/dir_7ff8159720d09b9da5f49b4c95af33a4/#files","title":"Files","text":"Type Name file compute_graph_catpure_node.h file compute_graph_event_node.h file compute_graph_kernel_node.h file compute_graph_memory_node.h <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/nodes/</code></p>"},{"location":"muda/compute__graph__catpure__node_8h/","title":"File compute_graph_catpure_node.h","text":"<p>FileList &gt; compute_graph &gt; nodes &gt; compute_graph_catpure_node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/compute_graph/compute_graph_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph.h&gt;</code></li> </ul>"},{"location":"muda/compute__graph__catpure__node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/compute__graph__catpure__node_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphCaptureNode <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/nodes/compute_graph_catpure_node.h</code></p>"},{"location":"muda/compute__graph__catpure__node_8h_source/","title":"File compute_graph_catpure_node.h","text":"<p>File List &gt; compute_graph &gt; nodes &gt; compute_graph_catpure_node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/compute_graph/compute_graph_node.h&gt;\n#include &lt;muda/graph/graph.h&gt;\n\nnamespace muda\n{\nclass ComputeGraphCaptureNode : public ComputeGraphNodeBase\n{\n  protected:\n    friend class ComputeGraph;\n    friend class details::ComputeGraphAccessor;\n    ComputeGraphCaptureNode(NodeId node_id, uint64_t access_index)\n        : ComputeGraphNodeBase(enum_name(ComputeGraphNodeType::CaptureNode),\n                               node_id,\n                               access_index,\n                               ComputeGraphNodeType::CaptureNode)\n    {\n        auto n = std::string_view{\n            details::LaunchInfoCache::current_capture_name().auto_select()};\n        if(n.empty() || n == \"\")\n            m_name += std::string(\":~\");\n        else\n            m_name += std::string(\":\") + std::string(n.data());\n    }\n\n    virtual ~ComputeGraphCaptureNode() override { update_sub_graph(nullptr); }\n\n    void set_node(cudaGraphNode_t node) { set_handle(node); }\n\n    void update_sub_graph(cudaGraph_t sub_graph)\n    {\n        if(m_sub_graph)\n            checkCudaErrors(cudaGraphDestroy(m_sub_graph));\n        m_sub_graph = sub_graph;\n    }\n\n    cudaGraph_t m_sub_graph = nullptr;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/compute__graph__event__node_8h/","title":"File compute_graph_event_node.h","text":"<p>FileList &gt; compute_graph &gt; nodes &gt; compute_graph_event_node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/compute_graph/compute_graph.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph.h&gt;</code></li> <li><code>#include &lt;muda/graph/event_node.h&gt;</code></li> </ul>"},{"location":"muda/compute__graph__event__node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/nodes/compute_graph_event_node.h</code></p>"},{"location":"muda/compute__graph__event__node_8h_source/","title":"File compute_graph_event_node.h","text":"<p>File List &gt; compute_graph &gt; nodes &gt; compute_graph_event_node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/compute_graph/compute_graph.h&gt;\n#include &lt;muda/compute_graph/compute_graph_node.h&gt;\n#include &lt;muda/graph/graph.h&gt;\n#include &lt;muda/graph/event_node.h&gt;\n\nnamespace muda\n{\nusing ComputeGraphEventRecordNode =\n    ComputeGraphNode&lt;EventRecordNode, ComputeGraphNodeType::EventRecordNode&gt;;\nusing ComputeGraphEventWaitNode =\n    ComputeGraphNode&lt;EventWaitNode, ComputeGraphNodeType::EventWaitNode&gt;;\n}  // namespace muda\n</code></pre>"},{"location":"muda/compute__graph__kernel__node_8h/","title":"File compute_graph_kernel_node.h","text":"<p>FileList &gt; compute_graph &gt; nodes &gt; compute_graph_kernel_node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/compute_graph/compute_graph_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph.h&gt;</code></li> <li><code>#include &lt;muda/graph/kernel_node.h&gt;</code></li> </ul>"},{"location":"muda/compute__graph__kernel__node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/nodes/compute_graph_kernel_node.h</code></p>"},{"location":"muda/compute__graph__kernel__node_8h_source/","title":"File compute_graph_kernel_node.h","text":"<p>File List &gt; compute_graph &gt; nodes &gt; compute_graph_kernel_node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/compute_graph/compute_graph_node.h&gt;\n#include &lt;muda/graph/graph.h&gt;\n#include &lt;muda/graph/kernel_node.h&gt;\n\nnamespace muda\n{\nusing ComputeGraphKernelNode =\n    ComputeGraphNode&lt;KernelNode, ComputeGraphNodeType::KernelNode&gt;;\n}  // namespace muda\n</code></pre>"},{"location":"muda/compute__graph__memory__node_8h/","title":"File compute_graph_memory_node.h","text":"<p>FileList &gt; compute_graph &gt; nodes &gt; compute_graph_memory_node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/compute_graph/compute_graph.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph.h&gt;</code></li> <li><code>#include &lt;muda/graph/memory_node.h&gt;</code></li> </ul>"},{"location":"muda/compute__graph__memory__node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/compute_graph/nodes/compute_graph_memory_node.h</code></p>"},{"location":"muda/compute__graph__memory__node_8h_source/","title":"File compute_graph_memory_node.h","text":"<p>File List &gt; compute_graph &gt; nodes &gt; compute_graph_memory_node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/compute_graph/compute_graph.h&gt;\n#include &lt;muda/compute_graph/compute_graph_node.h&gt;\n#include &lt;muda/graph/graph.h&gt;\n#include &lt;muda/graph/memory_node.h&gt;\n\nnamespace muda\n{\nusing ComputeGraphMemcpyNode =\n    ComputeGraphNode&lt;MemcpyNode, ComputeGraphNodeType::MemcpyNode&gt;;\n\nusing ComputeGraphMemsetNode =\n    ComputeGraphNode&lt;MemsetNode, ComputeGraphNodeType::MemsetNode&gt;;\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_abdf540317f100377c0fed488fb71651/","title":"Dir src/muda/container","text":"<p>FileList &gt; container</p>"},{"location":"muda/dir_abdf540317f100377c0fed488fb71651/#files","title":"Files","text":"Type Name file var.h file vector.h <p>The documentation for this class was generated from the following file <code>src/muda/container/</code></p>"},{"location":"muda/var_8h/","title":"File var.h","text":"<p>FileList &gt; container &gt; var.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/device_var.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/container/var.h</code></p>"},{"location":"muda/var_8h_source/","title":"File var.h","text":"<p>File List &gt; container &gt; var.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n//#include &lt;muda/tools/version.h&gt;\n//#include &lt;vector&gt;\n//#include &lt;thrust/device_allocator.h&gt;\n//\n//#include &lt;thrust/detail/raw_pointer_cast.h&gt;\n//#include &lt;thrust/fill.h&gt;\n//#include &lt;thrust/copy.h&gt;\n//#include &lt;muda/muda_def.h&gt;\n//#include &lt;muda/buffer/var_view.h&gt;\n//#include &lt;muda/viewer/dense.h&gt;\n//\n//namespace muda\n//{\n//namespace details\n//{\n//    template &lt;typename T, typename Allocator&gt;\n//    class VarBase\n//    {\n//      public:\n//        //using T = int;\n//        //using Allocator = thrust::device_allocator&lt;int&gt;;\n//        using pointer       = typename Allocator::pointer;\n//        using const_pointer = typename Allocator::const_pointer;\n//\n//        VarBase() MUDA_NOEXCEPT : m_data(Allocator().allocate(1)) {}\n//\n//        VarBase(const T&amp; value) MUDA_NOEXCEPT : m_data(Allocator().allocate(1))\n//        {\n//            this-&gt;operator=(value);\n//        }\n//\n//        ~VarBase() MUDA_NOEXCEPT { Allocator().deallocate(m_data, 1); }\n//\n//        pointer       data() { return m_data; }\n//        const_pointer data() const { return m_data; }\n//\n//        // copy value from host to device\n//        VarBase&amp; operator=(const T&amp; rhs)\n//        {\n//            thrust::fill_n(data(), 1, rhs);\n//            return *this;\n//        }\n//\n//        // copy value from device to host\n//        operator T()\n//        {\n//            T t;\n//            thrust::copy_n(data(), 1, &amp;t);\n//            return t;\n//        }\n//\n//      private:\n//        pointer m_data;\n//    };\n//}  // namespace details\n//\n//template &lt;typename T&gt;\n//class DeviceVar : public details::VarBase&lt;T, thrust::device_allocator&lt;T&gt;&gt;\n//{\n//  public:\n//    using Base = details::VarBase&lt;T, thrust::device_allocator&lt;T&gt;&gt;;\n//    using Base::Base;\n//    using Base::operator=;\n//\n//    const T* data() const { return thrust::raw_pointer_cast(Base::data()); }\n//    T*       data() { return thrust::raw_pointer_cast(Base::data()); }\n//\n//    DeviceVar&amp; operator=(DeviceVar&lt;T&gt; other)\n//    {\n//        view().copy_from(other.view());\n//        return *this;\n//    }\n//\n//    DeviceVar&amp; operator=(VarView other)\n//    {\n//        view().copy_from(other);\n//        return *this;\n//    }\n//\n//    auto viewer() { return Dense&lt;T&gt;(this-&gt;data()); }\n//    auto cviewer() const { return CDense&lt;T&gt;(this-&gt;data()); }\n//    auto view() const { return VarView&lt;T&gt;{m_data}; }\n//    operator VarView&lt;T&gt;() { return view(); }\n//};\n//}  // namespace muda\n\n#include &lt;muda/buffer/device_var.h&gt;\n</code></pre>"},{"location":"muda/vector_8h/","title":"File vector.h","text":"<p>FileList &gt; container &gt; vector.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/version.h&gt;</code></li> <li><code>#include &lt;thrust/device_allocator.h&gt;</code></li> <li><code>#include &lt;thrust/device_vector.h&gt;</code></li> <li><code>#include &lt;thrust/host_vector.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_view.h&gt;</code></li> <li><code>#include &lt;muda/viewer/dense.h&gt;</code></li> </ul>"},{"location":"muda/vector_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/vector_8h/#classes","title":"Classes","text":"Type Name class DeviceVector &lt;typename T&gt; class HostVector &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/container/vector.h</code></p>"},{"location":"muda/vector_8h_source/","title":"File vector.h","text":"<p>File List &gt; container &gt; vector.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/version.h&gt;\n#include &lt;thrust/device_allocator.h&gt;\n\n#include &lt;thrust/device_vector.h&gt;\n#include &lt;thrust/host_vector.h&gt;\n#include &lt;vector&gt;\n\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/buffer/buffer_view.h&gt;\n#include &lt;muda/viewer/dense.h&gt;\n\nnamespace muda\n{\nnamespace details\n{\n    template &lt;typename T, typename Alloc&gt;\n    using vector_base = thrust::detail::vector_base&lt;T, Alloc&gt;;\n}\n\ntemplate &lt;typename T&gt;\nclass DeviceVector : public thrust::device_vector&lt;T, thrust::device_allocator&lt;T&gt;&gt;\n{\n  public:\n    using Base = thrust::device_vector&lt;T, thrust::device_allocator&lt;T&gt;&gt;;\n    using Base::Base;\n    using Base::operator=;\n\n    auto view() MUDA_NOEXCEPT { return BufferView&lt;T&gt;{raw_ptr(), Base::size()}; }\n\n    auto view() const MUDA_NOEXCEPT\n    {\n        return CBufferView&lt;T&gt;{raw_ptr(), Base::size()};\n    }\n\n    operator BufferView&lt;T&gt;() const MUDA_NOEXCEPT { return view(); }\n    operator CBufferView&lt;T&gt;() const MUDA_NOEXCEPT { return view(); }\n\n    DeviceVector&amp; operator=(CBufferView&lt;T&gt; v)\n    {\n        this-&gt;resize(v.size());\n        view().copy_from(v);\n        return *this;\n    }\n\n    void copy_to(std::vector&lt;T&gt;&amp; v) const\n    {\n        v.resize(this-&gt;size());\n        view().copy_to(v.data());\n    }\n\n    auto viewer() MUDA_NOEXCEPT\n    {\n        return Dense1D&lt;T&gt;(raw_ptr(), static_cast&lt;int&gt;(this-&gt;size()));\n    }\n\n    auto cviewer() const MUDA_NOEXCEPT\n    {\n        return CDense1D&lt;T&gt;(raw_ptr(), static_cast&lt;int&gt;(this-&gt;size()));\n    }\n\n  private:\n    T*       raw_ptr() { return thrust::raw_pointer_cast(Base::data()); }\n    const T* raw_ptr() const { return thrust::raw_pointer_cast(Base::data()); }\n};\n\ntemplate &lt;typename T&gt;\nclass HostVector : public thrust::host_vector&lt;T, std::allocator&lt;T&gt;&gt;\n{\n  public:\n    using thrust::host_vector&lt;T, std::allocator&lt;T&gt;&gt;::host_vector;\n    using thrust::host_vector&lt;T, std::allocator&lt;T&gt;&gt;::operator=;\n};\n}  // namespace muda\n\n\n//namespace muda\n//{\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_dense(DeviceVector&lt;T&gt;&amp; v) MUDA_NOEXCEPT\n//{\n//    return make_dense(v.view());\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_cdense(const DeviceVector&lt;T&gt;&amp; v) MUDA_NOEXCEPT\n//{\n//    return make_cdense(v.view());\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_viewer(DeviceVector&lt;T&gt;&amp; v) MUDA_NOEXCEPT\n//{\n//    return make_viewer(v.view());\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_cviewer(const DeviceVector&lt;T&gt;&amp; v) MUDA_NOEXCEPT\n//{\n//    return make_cviewer(v.view());\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_dense2D(DeviceVector&lt;T&gt;&amp; v, int dimy) MUDA_NOEXCEPT\n//{\n//    return make_dense2D(v.view(), dimy);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_cdense2D(const DeviceVector&lt;T&gt;&amp; v, int dimy) MUDA_NOEXCEPT\n//{\n//    return make_cdense2D(v.view(), dimy);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_dense2D(DeviceVector&lt;T&gt;&amp; v, int dimx, int dimy) MUDA_NOEXCEPT\n//{\n//    return make_dense2D(v.view(), dimx, dimy);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_cdense2D(const DeviceVector&lt;T&gt;&amp; v, int dimx, int dimy) MUDA_NOEXCEPT\n//{\n//    return make_cdense2D(v.view(), dimx, dimy);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_dense2D(DeviceVector&lt;T&gt;&amp; v, const int2&amp; dim) MUDA_NOEXCEPT\n//{\n//    return make_dense2D(v.view(), dim.x, dim.y);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_cdense2D(const DeviceVector&lt;T&gt;&amp; v, const int2&amp; dim) MUDA_NOEXCEPT\n//{\n//    return make_cdense2D(v.view(), dim.x, dim.y);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_dense3D(DeviceVector&lt;T&gt;&amp; v, int dimy, int dimz) MUDA_NOEXCEPT\n//{\n//    return make_dense3D(v.view(), dimy, dimz);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_cdense3D(const DeviceVector&lt;T&gt;&amp; v, int dimy, int dimz) MUDA_NOEXCEPT\n//{\n//    return make_cdense3D(v.view(), dimy, dimz);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_dense3D(DeviceVector&lt;T&gt;&amp; v, const int2&amp; dimyz) MUDA_NOEXCEPT\n//{\n//    return make_dense3D(v.view(), dimyz.x, dimyz.y);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_cdense3D(const DeviceVector&lt;T&gt;&amp; v, const int2&amp; dimyz) MUDA_NOEXCEPT\n//{\n//    return make_cdense3D(v.view(), dimyz.x, dimyz.y);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_dense3D(DeviceVector&lt;T&gt;&amp; v, int dimx, int dimy, int dimz) MUDA_NOEXCEPT\n//{\n//    return make_dense3D(v.view(), dimx, dimy, dimz);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_cdense3D(const DeviceVector&lt;T&gt;&amp; v, int dimx, int dimy, int dimz) MUDA_NOEXCEPT\n//{\n//    return make_cdense3D(v.view(), dimx, dimy, dimz);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_dense3D(DeviceVector&lt;T&gt;&amp; v, const int3&amp; dim) MUDA_NOEXCEPT\n//{\n//    return make_dense3D(v.view(), dim.x, dim.y, dim.z);\n//}\n//template &lt;typename T&gt;\n//MUDA_INLINE MUDA_HOST auto make_cdense3D(const DeviceVector&lt;T&gt;&amp; v, const int3&amp; dim) MUDA_NOEXCEPT\n//{\n//    return make_cdense3D(v.view(), dim.x, dim.y, dim.z);\n//}\n//}  // namespace muda\n</code></pre>"},{"location":"muda/dir_98c5d599fe44dff86fbf620b2a1f3e8e/","title":"Dir src/muda/cub","text":"<p>FileList &gt; cub</p>"},{"location":"muda/dir_98c5d599fe44dff86fbf620b2a1f3e8e/#files","title":"Files","text":"Type Name file cub.h file cub_device.h file util_type.h"},{"location":"muda/dir_98c5d599fe44dff86fbf620b2a1f3e8e/#directories","title":"Directories","text":"Type Name dir device <p>The documentation for this class was generated from the following file <code>src/muda/cub/</code></p>"},{"location":"muda/cub_8h/","title":"File cub.h","text":"<p>FileList &gt; cub &gt; cub.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/util_type.h&gt;</code></li> <li><code>#include &lt;muda/cub/cub_device.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cub/cub.h</code></p>"},{"location":"muda/cub_8h_source/","title":"File cub.h","text":"<p>File List &gt; cub &gt; cub.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/util_type.h&gt;\n#include &lt;muda/cub/cub_device.h&gt;\n</code></pre>"},{"location":"muda/cub__device_8h/","title":"File cub_device.h","text":"<p>FileList &gt; cub &gt; cub_device.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/device_reduce.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_scan.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_run_length_encode.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_radix_sort.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_merge_sort.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_adjacent_difference.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_histogram.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_partition.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_select.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_spmv.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_segmented_sort.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_segmented_radix_sort.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_segmented_reduce.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cub/cub_device.h</code></p>"},{"location":"muda/cub__device_8h_source/","title":"File cub_device.h","text":"<p>File List &gt; cub &gt; cub_device.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/device_reduce.h&gt;\n#include &lt;muda/cub/device/device_scan.h&gt;\n#include &lt;muda/cub/device/device_run_length_encode.h&gt;\n#include &lt;muda/cub/device/device_radix_sort.h&gt;\n#include &lt;muda/cub/device/device_merge_sort.h&gt;\n#include &lt;muda/cub/device/device_adjacent_difference.h&gt;\n#include &lt;muda/cub/device/device_histogram.h&gt;\n#include &lt;muda/cub/device/device_partition.h&gt;\n#include &lt;muda/cub/device/device_select.h&gt;\n#include &lt;muda/cub/device/device_spmv.h&gt;\n#include &lt;muda/cub/device/device_segmented_sort.h&gt;\n#include &lt;muda/cub/device/device_segmented_radix_sort.h&gt;\n#include &lt;muda/cub/device/device_segmented_reduce.h&gt;\n</code></pre>"},{"location":"muda/dir_e7785ab0b6a4810de2e8c4f6e4ccf5c0/","title":"Dir src/muda/cub/device","text":"<p>FileList &gt; cub &gt; device</p>"},{"location":"muda/dir_e7785ab0b6a4810de2e8c4f6e4ccf5c0/#files","title":"Files","text":"Type Name file cub_wrapper.h file device_adjacent_difference.h file device_histogram.h file device_merge_sort.h file device_partition.h file device_radix_sort.h file device_reduce.h file device_run_length_encode.h file device_scan.h file device_segmented_radix_sort.h file device_segmented_reduce.h file device_segmented_sort.h file device_select.h file device_spmv.h <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/</code></p>"},{"location":"muda/cub__wrapper_8h/","title":"File cub_wrapper.h","text":"<p>FileList &gt; cub &gt; device &gt; cub_wrapper.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cub/version.cuh&gt;</code></li> <li><code>#include &lt;muda/launch/launch_base.h&gt;</code></li> <li><code>#include &lt;muda/buffer.h&gt;</code></li> <li><code>#include &lt;muda/container.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_launch.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph.h&gt;</code></li> <li><code>#include &lt;muda/launch/stream.h&gt;</code></li> </ul>"},{"location":"muda/cub__wrapper_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/cub__wrapper_8h/#classes","title":"Classes","text":"Type Name class CubWrapper &lt;typename Derive&gt; <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/cub_wrapper.h</code></p>"},{"location":"muda/cub__wrapper_8h_source/","title":"File cub_wrapper.h","text":"<p>File List &gt; cub &gt; device &gt; cub_wrapper.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cub/version.cuh&gt;\n#include &lt;muda/launch/launch_base.h&gt;\n#include &lt;muda/buffer.h&gt;\n#include &lt;muda/container.h&gt;\n#include &lt;muda/buffer/buffer_launch.h&gt;\n#include &lt;muda/compute_graph/compute_graph.h&gt;\n#include &lt;muda/launch/stream.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename Derive&gt;\nclass CubWrapper : public LaunchBase&lt;Derive&gt;\n{\n  protected:\n    std::byte* prepare_buffer(size_t reqSize)\n    {\n        return m_muda_stream-&gt;workspace(reqSize);\n    }\n\n  public:\n    CubWrapper(Stream&amp; stream = Stream::Default())\n        : LaunchBase&lt;Derive&gt;(stream)\n        , m_muda_stream(&amp;stream)\n    {\n    }\n\n    // meaningless for cub, so we just delete it\n    void kernel_name(std::string_view) = delete;\n\n    Stream* m_muda_stream = nullptr;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/device__adjacent__difference_8h/","title":"File device_adjacent_difference.h","text":"<p>FileList &gt; cub &gt; device &gt; device_adjacent_difference.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_adjacent_difference.h</code></p>"},{"location":"muda/device__adjacent__difference_8h_source/","title":"File device_adjacent_difference.h","text":"<p>File List &gt; cub &gt; device &gt; device_adjacent_difference.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#if CUB_VERSION &gt;= 200200\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_adjacent_difference.cuh&gt;\n#else\nnamespace cub\n{\nclass Difference;\n}\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_adjacent_difference.html\nclass DeviceAdjacentDifference : public CubWrapper&lt;DeviceAdjacentDifference&gt;\n{\n    using Base = CubWrapper&lt;DeviceAdjacentDifference&gt;;\n\n  public:\n    using Base::Base;\n    // DeviceVector:\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename DifferenceOpT = cub::Difference&gt;\n    DeviceAdjacentDifference&amp; SubtractLeftCopy(InputIteratorT  d_in,\n                                               OutputIteratorT d_out,\n                                               int             num_items,\n                                               DifferenceOpT difference_op = {},\n                                               bool debug_synchronous = false)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceAdjacentDifference::SubtractLeftCopy(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, difference_op, _stream, debug_synchronous));\n    }\n\n    template &lt;typename RandomAccessIteratorT, typename DifferenceOpT = cub::Difference&gt;\n    DeviceAdjacentDifference&amp; SubtractLeft(RandomAccessIteratorT d_in,\n                                           int                   num_items,\n                                           DifferenceOpT difference_op = {},\n                                           bool debug_synchronous      = false)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceAdjacentDifference::SubtractLeft(\n            d_temp_storage, temp_storage_bytes, d_in, num_items, difference_op, _stream, debug_synchronous));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename DifferenceOpT = cub::Difference&gt;\n    DeviceAdjacentDifference&amp; SubtractRightCopy(InputIteratorT  d_in,\n                                                OutputIteratorT d_out,\n                                                int             num_items,\n                                                DifferenceOpT difference_op = {},\n                                                bool debug_synchronous = false)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceAdjacentDifference::SubtractRightCopy(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, difference_op, _stream, debug_synchronous));\n    }\n\n    template &lt;typename RandomAccessIteratorT, typename DifferenceOpT = cub::Difference&gt;\n    DeviceAdjacentDifference&amp; SubtractRight(RandomAccessIteratorT d_in,\n                                            int                   num_items,\n                                            DifferenceOpT difference_op = {},\n                                            bool debug_synchronous      = false)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceAdjacentDifference::SubtractRight(\n            d_temp_storage, temp_storage_bytes, d_in, num_items, difference_op, _stream, debug_synchronous));\n    }\n\n    // Origin:\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename DifferenceOpT = cub::Difference&gt;\n    DeviceAdjacentDifference&amp; SubtractLeftCopy(void*   d_temp_storage,\n                                               size_t&amp; temp_storage_bytes,\n                                               InputIteratorT  d_in,\n                                               OutputIteratorT d_out,\n                                               int             num_items,\n                                               DifferenceOpT difference_op = {},\n                                               bool debug_synchronous = false)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceAdjacentDifference::SubtractLeftCopy(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, difference_op, _stream, debug_synchronous));\n    }\n\n    template &lt;typename RandomAccessIteratorT, typename DifferenceOpT = cub::Difference&gt;\n    DeviceAdjacentDifference&amp; SubtractLeft(void*   d_temp_storage,\n                                           size_t&amp; temp_storage_bytes,\n                                           RandomAccessIteratorT d_in,\n                                           int                   num_items,\n                                           DifferenceOpT difference_op = {},\n                                           bool debug_synchronous      = false)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceAdjacentDifference::SubtractLeft(\n            d_temp_storage, temp_storage_bytes, d_in, num_items, difference_op, _stream, debug_synchronous));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename DifferenceOpT = cub::Difference&gt;\n    DeviceAdjacentDifference&amp; SubtractRightCopy(void*   d_temp_storage,\n                                                size_t&amp; temp_storage_bytes,\n                                                InputIteratorT  d_in,\n                                                OutputIteratorT d_out,\n                                                int             num_items,\n                                                DifferenceOpT difference_op = {},\n                                                bool debug_synchronous = false)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceAdjacentDifference::SubtractRightCopy(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, difference_op, _stream, debug_synchronous));\n    }\n\n    template &lt;typename RandomAccessIteratorT, typename DifferenceOpT = cub::Difference&gt;\n    DeviceAdjacentDifference&amp; SubtractRight(void*   d_temp_storage,\n                                            size_t&amp; temp_storage_bytes,\n                                            RandomAccessIteratorT d_in,\n                                            int                   num_items,\n                                            DifferenceOpT difference_op = {},\n                                            bool debug_synchronous      = false)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceAdjacentDifference::SubtractRight(\n            d_temp_storage, temp_storage_bytes, d_in, num_items, difference_op, _stream, debug_synchronous));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n#endif\n</code></pre>"},{"location":"muda/device__histogram_8h/","title":"File device_histogram.h","text":"<p>FileList &gt; cub &gt; device &gt; device_histogram.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_histogram.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__histogram_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__histogram_8h/#classes","title":"Classes","text":"Type Name class DeviceHistogram <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_histogram.h</code></p>"},{"location":"muda/device__histogram_8h_source/","title":"File device_histogram.h","text":"<p>File List &gt; cub &gt; device &gt; device_histogram.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_histogram.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_histogram.html\n\nclass DeviceHistogram : public CubWrapper&lt;DeviceHistogram&gt;\n{\n    using Base = CubWrapper&lt;DeviceHistogram&gt;;\n\n  public:\n    using Base::Base;\n\n    // DeviceVector:\n\n    // HistogramEven (single channel, 1D input)\n    template &lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; HistogramEven(SampleIteratorT d_samples,\n                                   CounterT*       d_histogram,\n                                   int             num_levels,\n                                   LevelT          lower_level,\n                                   LevelT          upper_level,\n                                   OffsetT         num_samples)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceHistogram::HistogramEven(d_temp_storage,\n                                                                  temp_storage_bytes,\n                                                                  d_samples,\n                                                                  d_histogram,\n                                                                  num_levels,\n                                                                  lower_level,\n                                                                  upper_level,\n                                                                  num_samples,\n                                                                  _stream,\n                                                                  false));\n    }\n\n    // HistogramEven (single channel, 2D input)\n    template &lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; HistogramEven(SampleIteratorT d_samples,\n                                   CounterT*       d_histogram,\n                                   int             num_levels,\n                                   LevelT          lower_level,\n                                   LevelT          upper_level,\n                                   OffsetT         num_row_samples,\n                                   OffsetT         num_rows,\n                                   size_t          row_stride_bytes)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceHistogram::HistogramEven(d_temp_storage,\n                                                                  temp_storage_bytes,\n                                                                  d_samples,\n                                                                  d_histogram,\n                                                                  num_levels,\n                                                                  lower_level,\n                                                                  upper_level,\n                                                                  num_row_samples,\n                                                                  num_rows,\n                                                                  row_stride_bytes,\n                                                                  _stream,\n                                                                  false));\n    }\n\n    // MultiHistogramEven (multiple channels, 1D input)\n    template &lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; MultiHistogramEven(SampleIteratorT d_samples,\n                                        CounterT* d_histogram[NUM_ACTIVE_CHANNELS],\n                                        int    num_levels[NUM_ACTIVE_CHANNELS],\n                                        LevelT lower_level[NUM_ACTIVE_CHANNELS],\n                                        LevelT upper_level[NUM_ACTIVE_CHANNELS],\n                                        OffsetT num_pixels)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceHistogram::MultiHistogramEven(d_temp_storage,\n                                                                       temp_storage_bytes,\n                                                                       d_samples,\n                                                                       d_histogram,\n                                                                       num_levels,\n                                                                       lower_level,\n                                                                       upper_level,\n                                                                       num_pixels,\n                                                                       _stream,\n                                                                       false));\n    }\n\n    // MultiHistogramEven (multiple channels, 2D input)\n    template &lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; MultiHistogramEven(SampleIteratorT d_samples,\n                                        CounterT* d_histogram[NUM_ACTIVE_CHANNELS],\n                                        int    num_levels[NUM_ACTIVE_CHANNELS],\n                                        LevelT lower_level[NUM_ACTIVE_CHANNELS],\n                                        LevelT upper_level[NUM_ACTIVE_CHANNELS],\n                                        OffsetT num_row_pixels,\n                                        OffsetT num_rows,\n                                        size_t  row_stride_bytes)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceHistogram::MultiHistogramEven(d_temp_storage,\n                                                     temp_storage_bytes,\n                                                     d_samples,\n                                                     d_histogram,\n                                                     num_levels,\n                                                     lower_level,\n                                                     upper_level,\n                                                     num_row_pixels,\n                                                     num_rows,\n                                                     row_stride_bytes,\n                                                     _stream,\n                                                     false));\n    }\n\n    // HistogramRange (single channel, 1D input)\n    template &lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; HistogramRange(SampleIteratorT d_samples,\n                                    CounterT*       d_histogram,\n                                    int             num_levels,\n                                    LevelT*         d_levels,\n                                    OffsetT         num_samples)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceHistogram::HistogramRange(\n            d_temp_storage, temp_storage_bytes, d_samples, d_histogram, num_levels, d_levels, num_samples, _stream, false));\n    }\n\n    // HistogramRange (single channel, 2D input)\n    template &lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; HistogramRange(SampleIteratorT d_samples,\n                                    CounterT*       d_histogram,\n                                    int             num_levels,\n                                    LevelT*         d_levels,\n                                    OffsetT         num_row_samples,\n                                    OffsetT         num_rows,\n                                    size_t          row_stride_bytes)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceHistogram::HistogramRange(d_temp_storage,\n                                                                   temp_storage_bytes,\n                                                                   d_samples,\n                                                                   d_histogram,\n                                                                   num_levels,\n                                                                   d_levels,\n                                                                   num_row_samples,\n                                                                   num_rows,\n                                                                   row_stride_bytes,\n                                                                   _stream,\n                                                                   false));\n    }\n\n    // MultiHistogramRange (multiple channels, 1D input)\n    template &lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; MultiHistogramRange(SampleIteratorT d_samples,\n                                         CounterT* d_histogram[NUM_ACTIVE_CHANNELS],\n                                         int num_levels[NUM_ACTIVE_CHANNELS],\n                                         LevelT* d_levels[NUM_ACTIVE_CHANNELS],\n                                         OffsetT num_pixels)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceHistogram::MultiHistogramRange(\n            d_temp_storage, temp_storage_bytes, d_samples, d_histogram, num_levels, d_levels, num_pixels, _stream, false));\n    }\n\n    // MultiHistogramRange (multiple channels, 2D input)\n    template &lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; MultiHistogramRange(SampleIteratorT d_samples,\n                                         CounterT* d_histogram[NUM_ACTIVE_CHANNELS],\n                                         int num_levels[NUM_ACTIVE_CHANNELS],\n                                         LevelT* d_levels[NUM_ACTIVE_CHANNELS],\n                                         OffsetT num_row_pixels,\n                                         OffsetT num_rows,\n                                         size_t  row_stride_bytes)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceHistogram::MultiHistogramRange(d_temp_storage,\n                                                      temp_storage_bytes,\n                                                      d_samples,\n                                                      d_histogram,\n                                                      num_levels,\n                                                      d_levels,\n                                                      num_row_pixels,\n                                                      num_rows,\n                                                      row_stride_bytes,\n                                                      _stream,\n                                                      false));\n    }\n\n    // Origin:\n\n    // HistogramEven (single channel, 1D input)\n    template &lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; HistogramEven(void*           d_temp_storage,\n                                   size_t&amp;         temp_storage_bytes,\n                                   SampleIteratorT d_samples,\n                                   CounterT*       d_histogram,\n                                   int             num_levels,\n                                   LevelT          lower_level,\n                                   LevelT          upper_level,\n                                   OffsetT         num_samples)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceHistogram::HistogramEven(\n            d_temp_storage, temp_storage_bytes, d_samples, d_histogram, num_levels, lower_level, upper_level, num_samples, _stream, false));\n    }\n\n    // HistogramEven (single channel, 2D input)\n    template &lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; HistogramEven(void*           d_temp_storage,\n                                   size_t&amp;         temp_storage_bytes,\n                                   SampleIteratorT d_samples,\n                                   CounterT*       d_histogram,\n                                   int             num_levels,\n                                   LevelT          lower_level,\n                                   LevelT          upper_level,\n                                   OffsetT         num_row_samples,\n                                   OffsetT         num_rows,\n                                   size_t          row_stride_bytes)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceHistogram::HistogramEven(d_temp_storage,\n                                                temp_storage_bytes,\n                                                d_samples,\n                                                d_histogram,\n                                                num_levels,\n                                                lower_level,\n                                                upper_level,\n                                                num_row_samples,\n                                                num_rows,\n                                                row_stride_bytes,\n                                                _stream,\n                                                false));\n    }\n\n    // MultiHistogramEven (multiple channels, 1D input)\n    template &lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; MultiHistogramEven(void*           d_temp_storage,\n                                        size_t&amp;         temp_storage_bytes,\n                                        SampleIteratorT d_samples,\n                                        CounterT* d_histogram[NUM_ACTIVE_CHANNELS],\n                                        int    num_levels[NUM_ACTIVE_CHANNELS],\n                                        LevelT lower_level[NUM_ACTIVE_CHANNELS],\n                                        LevelT upper_level[NUM_ACTIVE_CHANNELS],\n                                        OffsetT num_pixels)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceHistogram::MultiHistogramEven(\n            d_temp_storage, temp_storage_bytes, d_samples, d_histogram, num_levels, lower_level, upper_level, num_pixels, _stream, false));\n    }\n\n    // MultiHistogramEven (multiple channels, 2D input)\n    template &lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; MultiHistogramEven(void*           d_temp_storage,\n                                        size_t&amp;         temp_storage_bytes,\n                                        SampleIteratorT d_samples,\n                                        CounterT* d_histogram[NUM_ACTIVE_CHANNELS],\n                                        int    num_levels[NUM_ACTIVE_CHANNELS],\n                                        LevelT lower_level[NUM_ACTIVE_CHANNELS],\n                                        LevelT upper_level[NUM_ACTIVE_CHANNELS],\n                                        OffsetT num_row_pixels,\n                                        OffsetT num_rows,\n                                        size_t  row_stride_bytes)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceHistogram::MultiHistogramEven(d_temp_storage,\n                                                     temp_storage_bytes,\n                                                     d_samples,\n                                                     d_histogram,\n                                                     num_levels,\n                                                     lower_level,\n                                                     upper_level,\n                                                     num_row_pixels,\n                                                     num_rows,\n                                                     row_stride_bytes,\n                                                     _stream,\n                                                     false));\n    }\n\n    // HistogramRange (single channel, 1D input)\n    template &lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; HistogramRange(void*           d_temp_storage,\n                                    size_t&amp;         temp_storage_bytes,\n                                    SampleIteratorT d_samples,\n                                    CounterT*       d_histogram,\n                                    int             num_levels,\n                                    LevelT*         d_levels,\n                                    OffsetT         num_samples)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceHistogram::HistogramRange(\n            d_temp_storage, temp_storage_bytes, d_samples, d_histogram, num_levels, d_levels, num_samples, _stream, false));\n    }\n\n    // HistogramRange (single channel, 2D input)\n    template &lt;typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; HistogramRange(void*           d_temp_storage,\n                                    size_t&amp;         temp_storage_bytes,\n                                    SampleIteratorT d_samples,\n                                    CounterT*       d_histogram,\n                                    int             num_levels,\n                                    LevelT*         d_levels,\n                                    OffsetT         num_row_samples,\n                                    OffsetT         num_rows,\n                                    size_t          row_stride_bytes)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceHistogram::HistogramRange(d_temp_storage,\n                                                 temp_storage_bytes,\n                                                 d_samples,\n                                                 d_histogram,\n                                                 num_levels,\n                                                 d_levels,\n                                                 num_row_samples,\n                                                 num_rows,\n                                                 row_stride_bytes,\n                                                 _stream,\n                                                 false));\n    }\n\n    // MultiHistogramRange (multiple channels, 1D input)\n    template &lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; MultiHistogramRange(void*           d_temp_storage,\n                                         size_t&amp;         temp_storage_bytes,\n                                         SampleIteratorT d_samples,\n                                         CounterT* d_histogram[NUM_ACTIVE_CHANNELS],\n                                         int num_levels[NUM_ACTIVE_CHANNELS],\n                                         LevelT* d_levels[NUM_ACTIVE_CHANNELS],\n                                         OffsetT num_pixels)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceHistogram::MultiHistogramRange(\n            d_temp_storage, temp_storage_bytes, d_samples, d_histogram, num_levels, d_levels, num_pixels, _stream, false));\n    }\n\n    // MultiHistogramRange (multiple channels, 2D input)\n    template &lt;int NUM_CHANNELS, int NUM_ACTIVE_CHANNELS, typename SampleIteratorT, typename CounterT, typename LevelT, typename OffsetT&gt;\n    DeviceHistogram&amp; MultiHistogramRange(void*           d_temp_storage,\n                                         size_t&amp;         temp_storage_bytes,\n                                         SampleIteratorT d_samples,\n                                         CounterT* d_histogram[NUM_ACTIVE_CHANNELS],\n                                         int num_levels[NUM_ACTIVE_CHANNELS],\n                                         LevelT* d_levels[NUM_ACTIVE_CHANNELS],\n                                         OffsetT num_row_pixels,\n                                         OffsetT num_rows,\n                                         size_t  row_stride_bytes)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceHistogram::MultiHistogramRange(d_temp_storage,\n                                                      temp_storage_bytes,\n                                                      d_samples,\n                                                      d_histogram,\n                                                      num_levels,\n                                                      d_levels,\n                                                      num_row_pixels,\n                                                      num_rows,\n                                                      row_stride_bytes,\n                                                      _stream,\n                                                      false));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__merge__sort_8h/","title":"File device_merge_sort.h","text":"<p>FileList &gt; cub &gt; device &gt; device_merge_sort.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_merge_sort.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__merge__sort_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__merge__sort_8h/#classes","title":"Classes","text":"Type Name class DeviceMergeSort <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_merge_sort.h</code></p>"},{"location":"muda/device__merge__sort_8h_source/","title":"File device_merge_sort.h","text":"<p>File List &gt; cub &gt; device &gt; device_merge_sort.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_merge_sort.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_merge_sort.html\nclass DeviceMergeSort : public CubWrapper&lt;DeviceMergeSort&gt;\n{\n    using Base = CubWrapper&lt;DeviceMergeSort&gt;;\n\n  public:\n    using Base::Base;\n\n    template &lt;typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; SortPairs(KeyIteratorT d_keys, ValueIteratorT d_items, OffsetT num_items, CompareOpT compare_op)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceMergeSort::SortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys, d_items, num_items, compare_op, _stream, false));\n    }\n\n    template &lt;typename KeyInputIteratorT, typename ValueInputIteratorT, typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; SortPairsCopy(KeyInputIteratorT   d_input_keys,\n                                   ValueInputIteratorT d_input_items,\n                                   KeyIteratorT        d_output_keys,\n                                   ValueIteratorT      d_output_items,\n                                   OffsetT             num_items,\n                                   CompareOpT          compare_op)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceMergeSort::SortPairsCopy(d_temp_storage,\n                                                                  temp_storage_bytes,\n                                                                  d_input_keys,\n                                                                  d_input_items,\n                                                                  d_output_keys,\n                                                                  d_output_items,\n                                                                  num_items,\n                                                                  compare_op,\n                                                                  _stream,\n                                                                  false));\n    }\n\n    template &lt;typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; SortKeys(KeyIteratorT d_keys, OffsetT num_items, CompareOpT compare_op)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceMergeSort::SortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, compare_op, _stream, false));\n    }\n\n    template &lt;typename KeyInputIteratorT, typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; SortKeysCopy(KeyInputIteratorT d_input_keys,\n                                  KeyIteratorT      d_output_keys,\n                                  OffsetT           num_items,\n                                  CompareOpT        compare_op)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceMergeSort::SortKeysCopy(\n            d_temp_storage, temp_storage_bytes, d_input_keys, d_output_keys, num_items, compare_op, _stream, false));\n    }\n\n    template &lt;typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; StableSortPairs(KeyIteratorT   d_keys,\n                                     ValueIteratorT d_items,\n                                     OffsetT        num_items,\n                                     CompareOpT     compare_op)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceMergeSort::StableSortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys, d_items, num_items, compare_op, _stream, false));\n    }\n\n    template &lt;typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; StableSortKeys(KeyIteratorT d_keys, OffsetT num_items, CompareOpT compare_op)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceMergeSort::StableSortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, compare_op, _stream, false));\n    }\n\n    // Origin:\n\n    template &lt;typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; SortPairs(void*          d_temp_storage,\n                               size_t&amp;        temp_storage_bytes,\n                               KeyIteratorT   d_keys,\n                               ValueIteratorT d_items,\n                               OffsetT        num_items,\n                               CompareOpT     compare_op)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceMergeSort::SortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys, d_items, num_items, compare_op, _stream, false));\n    }\n\n    template &lt;typename KeyInputIteratorT, typename ValueInputIteratorT, typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; SortPairsCopy(void*               d_temp_storage,\n                                   size_t&amp;             temp_storage_bytes,\n                                   KeyInputIteratorT   d_input_keys,\n                                   ValueInputIteratorT d_input_items,\n                                   KeyIteratorT        d_output_keys,\n                                   ValueIteratorT      d_output_items,\n                                   OffsetT             num_items,\n                                   CompareOpT          compare_op)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceMergeSort::SortPairsCopy(d_temp_storage,\n                                                temp_storage_bytes,\n                                                d_input_keys,\n                                                d_input_items,\n                                                d_output_keys,\n                                                d_output_items,\n                                                num_items,\n                                                compare_op,\n                                                _stream,\n                                                false));\n    }\n\n    template &lt;typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; SortKeys(void*        d_temp_storage,\n                              size_t&amp;      temp_storage_bytes,\n                              KeyIteratorT d_keys,\n                              OffsetT      num_items,\n                              CompareOpT   compare_op)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceMergeSort::SortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, compare_op, _stream, false));\n    }\n\n    template &lt;typename KeyInputIteratorT, typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; SortKeysCopy(void*             d_temp_storage,\n                                  size_t&amp;           temp_storage_bytes,\n                                  KeyInputIteratorT d_input_keys,\n                                  KeyIteratorT      d_output_keys,\n                                  OffsetT           num_items,\n                                  CompareOpT        compare_op)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceMergeSort::SortKeysCopy(\n            d_temp_storage, temp_storage_bytes, d_input_keys, d_output_keys, num_items, compare_op, _stream, false));\n    }\n\n    template &lt;typename KeyIteratorT, typename ValueIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; StableSortPairs(void*          d_temp_storage,\n                                     size_t&amp;        temp_storage_bytes,\n                                     KeyIteratorT   d_keys,\n                                     ValueIteratorT d_items,\n                                     OffsetT        num_items,\n                                     CompareOpT     compare_op)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceMergeSort::StableSortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys, d_items, num_items, compare_op, _stream, false));\n    }\n\n    template &lt;typename KeyIteratorT, typename OffsetT, typename CompareOpT&gt;\n    DeviceMergeSort&amp; StableSortKeys(void*        d_temp_storage,\n                                    size_t&amp;      temp_storage_bytes,\n                                    KeyIteratorT d_keys,\n                                    OffsetT      num_items,\n                                    CompareOpT   compare_op)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceMergeSort::StableSortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, compare_op, _stream, false));\n    }\n};\n}  // namespace muda\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__partition_8h/","title":"File device_partition.h","text":"<p>FileList &gt; cub &gt; device &gt; device_partition.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_partition.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__partition_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__partition_8h/#classes","title":"Classes","text":"Type Name class DevicePartition <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_partition.h</code></p>"},{"location":"muda/device__partition_8h_source/","title":"File device_partition.h","text":"<p>File List &gt; cub &gt; device &gt; device_partition.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_partition.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_partition.html\nclass DevicePartition : public CubWrapper&lt;DevicePartition&gt;\n{\n    using Base = CubWrapper&lt;DevicePartition&gt;;\n\n  public:\n    using Base::Base;\n\n    // DeviceVector:\n\n    template &lt;typename InputIteratorT, typename FlagIterator, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\n    DevicePartition&amp; Flagged(InputIteratorT       d_in,\n                             FlagIterator         d_flags,\n                             OutputIteratorT      d_out,\n                             NumSelectedIteratorT d_num_selected_out,\n                             int                  num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DevicePartition::Flagged(\n            d_temp_storage, temp_storage_bytes, d_in, d_flags, d_out, d_num_selected_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT, typename SelectOp&gt;\n    DevicePartition&amp; If(InputIteratorT       d_in,\n                        OutputIteratorT      d_out,\n                        NumSelectedIteratorT d_num_selected_out,\n                        int                  num_items,\n                        SelectOp             select_op)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DevicePartition::If(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, d_num_selected_out, num_items, select_op, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename FirstOutputIteratorT, typename SecondOutputIteratorT, typename UnselectedOutputIteratorT, typename NumSelectedIteratorT, typename SelectFirstPartOp, typename SelectSecondPartOp&gt;\n    DevicePartition&amp; If(InputIteratorT            d_in,\n                        FirstOutputIteratorT      d_first_part_out,\n                        SecondOutputIteratorT     d_second_part_out,\n                        UnselectedOutputIteratorT d_unselected_out,\n                        NumSelectedIteratorT      d_num_selected_out,\n                        int                       num_items,\n                        SelectFirstPartOp         select_first_part_op,\n                        SelectSecondPartOp        select_second_part_op)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DevicePartition::If(d_temp_storage,\n                                                       temp_storage_bytes,\n                                                       d_in,\n                                                       d_first_part_out,\n                                                       d_second_part_out,\n                                                       d_unselected_out,\n                                                       d_num_selected_out,\n                                                       num_items,\n                                                       select_first_part_op,\n                                                       select_second_part_op,\n                                                       _stream,\n                                                       false));\n    }\n\n    // Origin:\n\n    template &lt;typename InputIteratorT, typename FlagIterator, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\n    DevicePartition&amp; Flagged(void*                d_temp_storage,\n                             size_t&amp;              temp_storage_bytes,\n                             InputIteratorT       d_in,\n                             FlagIterator         d_flags,\n                             OutputIteratorT      d_out,\n                             NumSelectedIteratorT d_num_selected_out,\n                             int                  num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DevicePartition::Flagged(\n            d_temp_storage, temp_storage_bytes, d_in, d_flags, d_out, d_num_selected_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT, typename SelectOp&gt;\n    DevicePartition&amp; If(void*                d_temp_storage,\n                        size_t&amp;              temp_storage_bytes,\n                        InputIteratorT       d_in,\n                        OutputIteratorT      d_out,\n                        NumSelectedIteratorT d_num_selected_out,\n                        int                  num_items,\n                        SelectOp             select_op)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DevicePartition::If(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, d_num_selected_out, num_items, select_op, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename FirstOutputIteratorT, typename SecondOutputIteratorT, typename UnselectedOutputIteratorT, typename NumSelectedIteratorT, typename SelectFirstPartOp, typename SelectSecondPartOp&gt;\n    DevicePartition&amp; If(void*                     d_temp_storage,\n                        size_t&amp;                   temp_storage_bytes,\n                        InputIteratorT            d_in,\n                        FirstOutputIteratorT      d_first_part_out,\n                        SecondOutputIteratorT     d_second_part_out,\n                        UnselectedOutputIteratorT d_unselected_out,\n                        NumSelectedIteratorT      d_num_selected_out,\n                        int                       num_items,\n                        SelectFirstPartOp         select_first_part_op,\n                        SelectSecondPartOp        select_second_part_op)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DevicePartition::If(d_temp_storage,\n                                     temp_storage_bytes,\n                                     d_in,\n                                     d_first_part_out,\n                                     d_second_part_out,\n                                     d_unselected_out,\n                                     d_num_selected_out,\n                                     num_items,\n                                     select_first_part_op,\n                                     select_second_part_op,\n                                     _stream,\n                                     false));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__radix__sort_8h/","title":"File device_radix_sort.h","text":"<p>FileList &gt; cub &gt; device &gt; device_radix_sort.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_radix_sort.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__radix__sort_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__radix__sort_8h/#classes","title":"Classes","text":"Type Name class DeviceRadixSort <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_radix_sort.h</code></p>"},{"location":"muda/device__radix__sort_8h_source/","title":"File device_radix_sort.h","text":"<p>File List &gt; cub &gt; device &gt; device_radix_sort.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_radix_sort.cuh&gt;\n#else\n//namespace cub\n//{\n//template &lt;typename KeyT&gt;\n//struct DoubleBuffer;\n//}\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_radix_sort.html\nclass DeviceRadixSort : public CubWrapper&lt;DeviceRadixSort&gt;\n{\n    using Base = CubWrapper&lt;DeviceRadixSort&gt;;\n\n  public:\n    using Base::Base;\n\n    template &lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortPairs(const KeyT*   d_keys_in,\n                               KeyT*         d_keys_out,\n                               const ValueT* d_values_in,\n                               ValueT*       d_values_out,\n                               NumItemsT     num_items,\n                               int           begin_bit = 0,\n                               int           end_bit   = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRadixSort::SortPairs(d_temp_storage,\n                                                              temp_storage_bytes,\n                                                              d_keys_in,\n                                                              d_keys_out,\n                                                              d_values_in,\n                                                              d_values_out,\n                                                              num_items,\n                                                              begin_bit,\n                                                              end_bit,\n                                                              _stream));\n    }\n\n    template &lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortPairs(DeviceVector&lt;std::byte&gt;&amp;   external_buffer,\n                               cub::DoubleBuffer&lt;KeyT&gt;&amp;   d_keys,\n                               cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                               NumItemsT                  num_items,\n                               int                        begin_bit = 0,\n                               int end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRadixSort::SortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortPairsDescending(const KeyT*   d_keys_in,\n                                         KeyT*         d_keys_out,\n                                         const ValueT* d_values_in,\n                                         ValueT*       d_values_out,\n                                         NumItemsT     num_items,\n                                         int           begin_bit = 0,\n                                         int end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRadixSort::SortPairsDescending(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, d_values_in, d_values_out, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortPairsDescending(cub::DoubleBuffer&lt;KeyT&gt;&amp;   d_keys,\n                                         cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                         NumItemsT                  num_items,\n                                         int begin_bit = 0,\n                                         int end_bit   = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRadixSort::SortPairsDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortKeys(const KeyT* d_keys_in,\n                              KeyT*       d_keys_out,\n                              NumItemsT   num_items,\n                              int         begin_bit = 0,\n                              int         end_bit   = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRadixSort::SortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortKeys(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                              NumItemsT                num_items,\n                              int                      begin_bit = 0,\n                              int end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRadixSort::SortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortKeysDescending(const KeyT* d_keys_in,\n                                        KeyT*       d_keys_out,\n                                        NumItemsT   num_items,\n                                        int         begin_bit = 0,\n                                        int         end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRadixSort::SortKeysDescending(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortKeysDescending(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                        NumItemsT                num_items,\n                                        int                      begin_bit = 0,\n                                        int end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRadixSort::SortKeysDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, begin_bit, end_bit, _stream));\n    }\n\n    // Origin:\n\n    template &lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortPairs(void*         d_temp_storage,\n                               size_t&amp;       temp_storage_bytes,\n                               const KeyT*   d_keys_in,\n                               KeyT*         d_keys_out,\n                               const ValueT* d_values_in,\n                               ValueT*       d_values_out,\n                               NumItemsT     num_items,\n                               int           begin_bit = 0,\n                               int           end_bit   = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRadixSort::SortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, d_values_in, d_values_out, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortPairs(void*                      d_temp_storage,\n                               size_t&amp;                    temp_storage_bytes,\n                               cub::DoubleBuffer&lt;KeyT&gt;&amp;   d_keys,\n                               cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                               NumItemsT                  num_items,\n                               int                        begin_bit = 0,\n                               int end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRadixSort::SortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortPairsDescending(void*         d_temp_storage,\n                                         size_t&amp;       temp_storage_bytes,\n                                         const KeyT*   d_keys_in,\n                                         KeyT*         d_keys_out,\n                                         const ValueT* d_values_in,\n                                         ValueT*       d_values_out,\n                                         NumItemsT     num_items,\n                                         int           begin_bit = 0,\n                                         int end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRadixSort::SortPairsDescending(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, d_values_in, d_values_out, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename ValueT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortPairsDescending(void*   d_temp_storage,\n                                         size_t&amp; temp_storage_bytes,\n                                         cub::DoubleBuffer&lt;KeyT&gt;&amp;   d_keys,\n                                         cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                         NumItemsT                  num_items,\n                                         int begin_bit = 0,\n                                         int end_bit   = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRadixSort::SortPairsDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortKeys(void*       d_temp_storage,\n                              size_t&amp;     temp_storage_bytes,\n                              const KeyT* d_keys_in,\n                              KeyT*       d_keys_out,\n                              NumItemsT   num_items,\n                              int         begin_bit = 0,\n                              int         end_bit   = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRadixSort::SortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortKeys(void*                    d_temp_storage,\n                              size_t&amp;                  temp_storage_bytes,\n                              cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                              NumItemsT                num_items,\n                              int                      begin_bit = 0,\n                              int end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRadixSort::SortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortKeysDescending(void*       d_temp_storage,\n                                        size_t&amp;     temp_storage_bytes,\n                                        const KeyT* d_keys_in,\n                                        KeyT*       d_keys_out,\n                                        NumItemsT   num_items,\n                                        int         begin_bit = 0,\n                                        int         end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRadixSort::SortKeysDescending(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items, begin_bit, end_bit, _stream));\n    }\n\n    template &lt;typename KeyT, typename NumItemsT&gt;\n    DeviceRadixSort&amp; SortKeysDescending(void*   d_temp_storage,\n                                        size_t&amp; temp_storage_bytes,\n                                        cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                        NumItemsT                num_items,\n                                        int                      begin_bit = 0,\n                                        int end_bit = sizeof(KeyT) * 8)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRadixSort::SortKeysDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, begin_bit, end_bit, _stream));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__reduce_8h/","title":"File device_reduce.h","text":"<p>FileList &gt; cub &gt; device &gt; device_reduce.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_reduce.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__reduce_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__reduce_8h/#classes","title":"Classes","text":"Type Name class DeviceReduce <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_reduce.h</code></p>"},{"location":"muda/device__reduce_8h_source/","title":"File device_reduce.h","text":"<p>File List &gt; cub &gt; device &gt; device_reduce.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_reduce.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_reduce.html\nclass DeviceReduce : public CubWrapper&lt;DeviceReduce&gt;\n{\n    using Base = CubWrapper&lt;DeviceReduce&gt;;\n\n  public:\n    using Base::Base;\n\n    // DeviceVector:\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename ReductionOpT, typename T&gt;\n    DeviceReduce&amp; Reduce(InputIteratorT  d_in,\n                         OutputIteratorT d_out,\n                         int             num_items,\n                         ReductionOpT    reduction_op,\n                         T               init)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceReduce::Reduce(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, reduction_op, init, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; Sum(InputIteratorT d_in, OutputIteratorT d_out, int num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceReduce::Sum(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; Min(InputIteratorT d_in, OutputIteratorT d_out, int num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceReduce::Min(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; ArgMin(InputIteratorT d_in, OutputIteratorT d_out, int num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceReduce::ArgMin(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; Max(InputIteratorT d_in, OutputIteratorT d_out, int num_items)\n    {\n\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceReduce::Max(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; ArgMax(InputIteratorT d_in, OutputIteratorT d_out, int num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceReduce::ArgMax(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename UniqueOutputIteratorT, typename ValuesInputIteratorT, typename AggregatesOutputIteratorT, typename NumRunsOutputIteratorT, typename ReductionOpT&gt;\n    DeviceReduce&amp; ReduceByKey(KeysInputIteratorT        d_keys_in,\n                              UniqueOutputIteratorT     d_unique_out,\n                              ValuesInputIteratorT      d_values_in,\n                              AggregatesOutputIteratorT d_aggregates_out,\n                              NumRunsOutputIteratorT    d_num_runs_out,\n                              ReductionOpT              reduction_op,\n                              int                       num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceReduce::ReduceByKey(d_temp_storage,\n                                                             temp_storage_bytes,\n                                                             d_keys_in,\n                                                             d_unique_out,\n                                                             d_values_in,\n                                                             d_aggregates_out,\n                                                             d_num_runs_out,\n                                                             reduction_op,\n                                                             num_items));\n    }\n\n\n    // Origin:\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename ReductionOpT, typename T&gt;\n    DeviceReduce&amp; Reduce(void*           d_temp_storage,\n                         size_t&amp;         temp_storage_bytes,\n                         InputIteratorT  d_in,\n                         OutputIteratorT d_out,\n                         int             num_items,\n                         ReductionOpT    reduction_op,\n                         T               init)\n    {\n\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceReduce::Reduce(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, reduction_op, init, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; Sum(void*           d_temp_storage,\n                      size_t&amp;         temp_storage_bytes,\n                      InputIteratorT  d_in,\n                      OutputIteratorT d_out,\n                      int             num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceReduce::Sum(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; Min(void*           d_temp_storage,\n                      size_t&amp;         temp_storage_bytes,\n                      InputIteratorT  d_in,\n                      OutputIteratorT d_out,\n                      int             num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceReduce::Min(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; ArgMin(void*           d_temp_storage,\n                         size_t&amp;         temp_storage_bytes,\n                         InputIteratorT  d_in,\n                         OutputIteratorT d_out,\n                         int             num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceReduce::ArgMin(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; Max(void*           d_temp_storage,\n                      size_t&amp;         temp_storage_bytes,\n                      InputIteratorT  d_in,\n                      OutputIteratorT d_out,\n                      int             num_items)\n    {\n\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceReduce::Max(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceReduce&amp; ArgMax(void*           d_temp_storage,\n                         size_t&amp;         temp_storage_bytes,\n                         InputIteratorT  d_in,\n                         OutputIteratorT d_out,\n                         int             num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceReduce::ArgMax(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename UniqueOutputIteratorT, typename ValuesInputIteratorT, typename AggregatesOutputIteratorT, typename NumRunsOutputIteratorT, typename ReductionOpT&gt;\n    DeviceReduce&amp; ReduceByKey(void*                     d_temp_storage,\n                              size_t&amp;                   temp_storage_bytes,\n                              KeysInputIteratorT        d_keys_in,\n                              UniqueOutputIteratorT     d_unique_out,\n                              ValuesInputIteratorT      d_values_in,\n                              AggregatesOutputIteratorT d_aggregates_out,\n                              NumRunsOutputIteratorT    d_num_runs_out,\n                              ReductionOpT              reduction_op,\n                              int                       num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceReduce::ReduceByKey(d_temp_storage,\n                                           temp_storage_bytes,\n                                           d_keys_in,\n                                           d_unique_out,\n                                           d_values_in,\n                                           d_aggregates_out,\n                                           d_num_runs_out,\n                                           reduction_op,\n                                           num_items));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__run__length__encode_8h/","title":"File device_run_length_encode.h","text":"<p>FileList &gt; cub &gt; device &gt; device_run_length_encode.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_run_length_encode.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__run__length__encode_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__run__length__encode_8h/#classes","title":"Classes","text":"Type Name class DeviceRunLengthEncode <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_run_length_encode.h</code></p>"},{"location":"muda/device__run__length__encode_8h_source/","title":"File device_run_length_encode.h","text":"<p>File List &gt; cub &gt; device &gt; device_run_length_encode.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_run_length_encode.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_run_length_encode.html\nclass DeviceRunLengthEncode : public CubWrapper&lt;DeviceRunLengthEncode&gt;\n{\n    using Base = CubWrapper&lt;DeviceRunLengthEncode&gt;;\n\n  public:\n    using Base::Base;\n\n    template &lt;typename InputIteratorT, typename UniqueOutputIteratorT, typename LengthsOutputIteratorT, typename NumRunsOutputIteratorT&gt;\n    DeviceRunLengthEncode&amp; Encode(InputIteratorT         d_in,\n                                  UniqueOutputIteratorT  d_unique_out,\n                                  LengthsOutputIteratorT d_counts_out,\n                                  NumRunsOutputIteratorT d_num_runs_out,\n                                  int                    num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRunLengthEncode::Encode(\n            d_temp_storage, temp_storage_bytes, d_in, d_unique_out, d_counts_out, d_num_runs_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OffsetsOutputIteratorT, typename LengthsOutputIteratorT, typename NumRunsOutputIteratorT&gt;\n    DeviceRunLengthEncode&amp; NonTrivialRuns(InputIteratorT         d_in,\n                                          OffsetsOutputIteratorT d_offsets_out,\n                                          LengthsOutputIteratorT d_lengths_out,\n                                          NumRunsOutputIteratorT d_num_runs_out,\n                                          int                    num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceRunLengthEncode::NonTrivialRuns(\n            d_temp_storage, temp_storage_bytes, d_in, d_offsets_out, d_lengths_out, d_num_runs_out, num_items, _stream, false));\n    }\n\n\n    // Origin:\n\n    template &lt;typename InputIteratorT, typename UniqueOutputIteratorT, typename LengthsOutputIteratorT, typename NumRunsOutputIteratorT&gt;\n    DeviceRunLengthEncode&amp; Encode(void*                  d_temp_storage,\n                                  size_t&amp;                temp_storage_bytes,\n                                  InputIteratorT         d_in,\n                                  UniqueOutputIteratorT  d_unique_out,\n                                  LengthsOutputIteratorT d_counts_out,\n                                  NumRunsOutputIteratorT d_num_runs_out,\n                                  int                    num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRunLengthEncode::Encode(\n            d_temp_storage, temp_storage_bytes, d_in, d_unique_out, d_counts_out, d_num_runs_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OffsetsOutputIteratorT, typename LengthsOutputIteratorT, typename NumRunsOutputIteratorT&gt;\n    DeviceRunLengthEncode&amp; NonTrivialRuns(void*          d_temp_storage,\n                                          size_t&amp;        temp_storage_bytes,\n                                          InputIteratorT d_in,\n                                          OffsetsOutputIteratorT d_offsets_out,\n                                          LengthsOutputIteratorT d_lengths_out,\n                                          NumRunsOutputIteratorT d_num_runs_out,\n                                          int                    num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceRunLengthEncode::NonTrivialRuns(\n            d_temp_storage, temp_storage_bytes, d_in, d_offsets_out, d_lengths_out, d_num_runs_out, num_items, _stream, false));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__scan_8h/","title":"File device_scan.h","text":"<p>FileList &gt; cub &gt; device &gt; device_scan.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_scan.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__scan_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__scan_8h/#classes","title":"Classes","text":"Type Name class DeviceScan <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_scan.h</code></p>"},{"location":"muda/device__scan_8h_source/","title":"File device_scan.h","text":"<p>File List &gt; cub &gt; device &gt; device_scan.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_scan.cuh&gt;\n#else\nnamespace cub\n{\nclass Equality\n{\n    //dummy class just for Intellisense\n};\n}  // namespace cub\n#endif\n\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_scan.html\nclass DeviceScan : public CubWrapper&lt;DeviceScan&gt;\n{\n    using Base = CubWrapper&lt;DeviceScan&gt;;\n\n  public:\n    using Base::Base;\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceScan&amp; ExclusiveSum(InputIteratorT d_in, OutputIteratorT d_out, int num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceScan::ExclusiveSum(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename ScanOpT, typename InitValueT&gt;\n    DeviceScan&amp; ExclusiveScan(InputIteratorT  d_in,\n                              OutputIteratorT d_out,\n                              ScanOpT         scan_op,\n                              InitValueT      init_value,\n                              int             num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceScan::ExclusiveScan(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, scan_op, init_value, num_items, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceScan&amp; InclusiveSum(InputIteratorT d_in, OutputIteratorT d_out, int num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceScan::InclusiveSum(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename ScanOpT&gt;\n    DeviceScan&amp; InclusiveScan(InputIteratorT d_in, OutputIteratorT d_out, ScanOpT scan_op, int num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceScan::InclusiveScan(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, scan_op, num_items, _stream, false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename EqualityOpT = cub::Equality&gt;\n    DeviceScan&amp; ExclusiveSumByKey(KeysInputIteratorT    d_keys_in,\n                                  ValuesInputIteratorT  d_values_in,\n                                  ValuesOutputIteratorT d_values_out,\n                                  int                   num_items,\n                                  EqualityOpT equality_op = EqualityOpT())\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceScan::ExclusiveSumByKey(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_values_in, d_values_out, num_items, equality_op, _stream, false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename ScanOpT, typename InitValueT, typename EqualityOpT = cub::Equality&gt;\n    DeviceScan&amp; ExclusiveScanByKey(KeysInputIteratorT    d_keys_in,\n                                   ValuesInputIteratorT  d_values_in,\n                                   ValuesOutputIteratorT d_values_out,\n                                   ScanOpT               scan_op,\n                                   InitValueT            init_value,\n                                   int                   num_items,\n                                   EqualityOpT equality_op = EqualityOpT())\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceScan::ExclusiveScanByKey(d_temp_storage,\n                                                                  temp_storage_bytes,\n                                                                  d_keys_in,\n                                                                  d_values_in,\n                                                                  d_values_out,\n                                                                  scan_op,\n                                                                  init_value,\n                                                                  num_items,\n                                                                  equality_op,\n                                                                  _stream,\n                                                                  false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename EqualityOpT = cub::Equality&gt;\n    DeviceScan&amp; InclusiveSumByKey(KeysInputIteratorT    d_keys_in,\n                                  ValuesInputIteratorT  d_values_in,\n                                  ValuesOutputIteratorT d_values_out,\n                                  int                   num_items,\n                                  EqualityOpT equality_op = EqualityOpT())\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceScan::InclusiveSumByKey(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_values_in, d_values_out, num_items, equality_op, _stream, false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename ScanOpT, typename EqualityOpT = cub::Equality&gt;\n    DeviceScan&amp; InclusiveScanByKey(KeysInputIteratorT    d_keys_in,\n                                   ValuesInputIteratorT  d_values_in,\n                                   ValuesOutputIteratorT d_values_out,\n                                   ScanOpT               scan_op,\n                                   int                   num_items,\n                                   EqualityOpT equality_op = EqualityOpT())\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceScan::InclusiveScanByKey(d_temp_storage,\n                                                                  temp_storage_bytes,\n                                                                  d_keys_in,\n                                                                  d_values_in,\n                                                                  d_values_out,\n                                                                  scan_op,\n                                                                  num_items,\n                                                                  equality_op,\n                                                                  _stream,\n                                                                  false));\n    }\n\n    // Origin:\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceScan&amp; ExclusiveSum(void*           d_temp_storage,\n                             size_t&amp;         temp_storage_bytes,\n                             InputIteratorT  d_in,\n                             OutputIteratorT d_out,\n                             int             num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceScan::ExclusiveSum(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename ScanOpT, typename InitValueT&gt;\n    DeviceScan&amp; ExclusiveScan(void*           d_temp_storage,\n                              size_t&amp;         temp_storage_bytes,\n                              InputIteratorT  d_in,\n                              OutputIteratorT d_out,\n                              ScanOpT         scan_op,\n                              InitValueT      init_value,\n                              int             num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceScan::ExclusiveScan(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, scan_op, init_value, num_items, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceScan&amp; InclusiveSum(void*           d_temp_storage,\n                             size_t&amp;         temp_storage_bytes,\n                             InputIteratorT  d_in,\n                             OutputIteratorT d_out,\n                             int             num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceScan::InclusiveSum(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename ScanOpT&gt;\n    DeviceScan&amp; InclusiveScan(void*           d_temp_storage,\n                              size_t&amp;         temp_storage_bytes,\n                              InputIteratorT  d_in,\n                              OutputIteratorT d_out,\n                              ScanOpT         scan_op,\n                              int             num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceScan::InclusiveScan(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, scan_op, num_items, _stream, false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename EqualityOpT = cub::Equality&gt;\n    DeviceScan&amp; ExclusiveSumByKey(void*                 d_temp_storage,\n                                  size_t&amp;               temp_storage_bytes,\n                                  KeysInputIteratorT    d_keys_in,\n                                  ValuesInputIteratorT  d_values_in,\n                                  ValuesOutputIteratorT d_values_out,\n                                  int                   num_items,\n                                  EqualityOpT equality_op = EqualityOpT())\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceScan::ExclusiveSumByKey(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_values_in, d_values_out, num_items, equality_op, _stream, false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename ScanOpT, typename InitValueT, typename EqualityOpT = cub::Equality&gt;\n    DeviceScan&amp; ExclusiveScanByKey(void*                 d_temp_storage,\n                                   size_t&amp;               temp_storage_bytes,\n                                   KeysInputIteratorT    d_keys_in,\n                                   ValuesInputIteratorT  d_values_in,\n                                   ValuesOutputIteratorT d_values_out,\n                                   ScanOpT               scan_op,\n                                   InitValueT            init_value,\n                                   int                   num_items,\n                                   EqualityOpT equality_op = EqualityOpT())\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceScan::ExclusiveScanByKey(d_temp_storage,\n                                                temp_storage_bytes,\n                                                d_keys_in,\n                                                d_values_in,\n                                                d_values_out,\n                                                scan_op,\n                                                init_value,\n                                                num_items,\n                                                equality_op,\n                                                _stream,\n                                                false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename EqualityOpT = cub::Equality&gt;\n    DeviceScan&amp; InclusiveSumByKey(void*                 d_temp_storage,\n                                  size_t&amp;               temp_storage_bytes,\n                                  KeysInputIteratorT    d_keys_in,\n                                  ValuesInputIteratorT  d_values_in,\n                                  ValuesOutputIteratorT d_values_out,\n                                  int                   num_items,\n                                  EqualityOpT equality_op = EqualityOpT())\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceScan::InclusiveSumByKey(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_values_in, d_values_out, num_items, equality_op, _stream, false));\n    }\n\n    template &lt;typename KeysInputIteratorT, typename ValuesInputIteratorT, typename ValuesOutputIteratorT, typename ScanOpT, typename EqualityOpT = cub::Equality&gt;\n    DeviceScan&amp; InclusiveScanByKey(void*                 d_temp_storage,\n                                   size_t&amp;               temp_storage_bytes,\n                                   KeysInputIteratorT    d_keys_in,\n                                   ValuesInputIteratorT  d_values_in,\n                                   ValuesOutputIteratorT d_values_out,\n                                   ScanOpT               scan_op,\n                                   int                   num_items,\n                                   EqualityOpT equality_op = EqualityOpT())\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceScan::InclusiveScanByKey(\n            d_temp_storage, temp_storage_bytes, d_keys_in, d_values_in, d_values_out, scan_op, num_items, equality_op, _stream, false));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__segmented__radix__sort_8h/","title":"File device_segmented_radix_sort.h","text":"<p>FileList &gt; cub &gt; device &gt; device_segmented_radix_sort.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_segmented_radix_sort.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__segmented__radix__sort_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__segmented__radix__sort_8h/#classes","title":"Classes","text":"Type Name class DeviceSegmentedRadixSort <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_segmented_radix_sort.h</code></p>"},{"location":"muda/device__segmented__radix__sort_8h_source/","title":"File device_segmented_radix_sort.h","text":"<p>File List &gt; cub &gt; device &gt; device_segmented_radix_sort.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_segmented_radix_sort.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_spmv.html\nclass DeviceSegmentedRadixSort : public CubWrapper&lt;DeviceSegmentedRadixSort&gt;\n{\n    using Base = CubWrapper&lt;DeviceSegmentedRadixSort&gt;;\n\n  public:\n    using Base::Base;\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortPairs(const KeyT*          d_keys_in,\n                                        KeyT*                d_keys_out,\n                                        const ValueT*        d_values_in,\n                                        ValueT*              d_values_out,\n                                        int                  num_items,\n                                        int                  num_segments,\n                                        BeginOffsetIteratorT d_begin_offsets,\n                                        EndOffsetIteratorT   d_end_offsets,\n                                        int                  begin_bit,\n                                        int                  end_bit)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedRadixSort::SortPairs(d_temp_storage,\n                                                     temp_storage_bytes,\n                                                     d_keys_in,\n                                                     d_keys_out,\n                                                     d_values_in,\n                                                     d_values_out,\n                                                     num_items,\n                                                     num_segments,\n                                                     d_begin_offsets,\n                                                     d_end_offsets,\n                                                     begin_bit,\n                                                     end_bit,\n                                                     _stream,\n                                                     false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortPairs(cub::DoubleBuffer&lt;KeyT&gt;&amp;   d_keys,\n                                        cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                        int                        num_items,\n                                        int                        num_segments,\n                                        BeginOffsetIteratorT d_begin_offsets,\n                                        EndOffsetIteratorT   d_end_offsets,\n                                        int                  begin_bit,\n                                        int                  end_bit)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedRadixSort::SortPairs(d_temp_storage,\n                                                                       temp_storage_bytes,\n                                                                       d_keys,\n                                                                       d_values,\n                                                                       num_items,\n                                                                       num_segments,\n                                                                       d_begin_offsets,\n                                                                       d_end_offsets,\n                                                                       begin_bit,\n                                                                       end_bit,\n                                                                       _stream,\n                                                                       false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortPairsDescending(const KeyT*   d_keys_in,\n                                                  KeyT*         d_keys_out,\n                                                  const ValueT* d_values_in,\n                                                  ValueT*       d_values_out,\n                                                  int           num_items,\n                                                  int           num_segments,\n                                                  BeginOffsetIteratorT d_begin_offsets,\n                                                  EndOffsetIteratorT d_end_offsets,\n                                                  int begin_bit,\n                                                  int end_bit)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedRadixSort::SortPairsDescending(d_temp_storage,\n                                                               temp_storage_bytes,\n                                                               d_keys_in,\n                                                               d_keys_out,\n                                                               d_values_in,\n                                                               d_values_out,\n                                                               num_items,\n                                                               num_segments,\n                                                               d_begin_offsets,\n                                                               d_end_offsets,\n                                                               begin_bit,\n                                                               end_bit,\n                                                               _stream,\n                                                               false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortPairsDescending(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                                  cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                                  int num_items,\n                                                  int num_segments,\n                                                  BeginOffsetIteratorT d_begin_offsets,\n                                                  EndOffsetIteratorT d_end_offsets,\n                                                  int begin_bit,\n                                                  int end_bit)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedRadixSort::SortPairsDescending(d_temp_storage,\n                                                               temp_storage_bytes,\n                                                               d_keys,\n                                                               d_values,\n                                                               num_items,\n                                                               num_segments,\n                                                               d_begin_offsets,\n                                                               d_end_offsets,\n                                                               begin_bit,\n                                                               end_bit,\n                                                               _stream,\n                                                               false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortKeys(const KeyT*          d_keys_in,\n                                       KeyT*                d_keys_out,\n                                       int                  num_items,\n                                       int                  num_segments,\n                                       BeginOffsetIteratorT d_begin_offsets,\n                                       EndOffsetIteratorT   d_end_offsets,\n                                       int                  begin_bit,\n                                       int                  end_bit)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedRadixSort::SortKeys(d_temp_storage,\n                                                                      temp_storage_bytes,\n                                                                      d_keys_in,\n                                                                      d_keys_out,\n                                                                      num_items,\n                                                                      num_segments,\n                                                                      d_begin_offsets,\n                                                                      d_end_offsets,\n                                                                      begin_bit,\n                                                                      end_bit,\n                                                                      _stream,\n                                                                      false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortKeys(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                       int                      num_items,\n                                       int                      num_segments,\n                                       BeginOffsetIteratorT     d_begin_offsets,\n                                       EndOffsetIteratorT       d_end_offsets,\n                                       int                      begin_bit,\n                                       int                      end_bit)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedRadixSort::SortKeys(d_temp_storage,\n                                                                      temp_storage_bytes,\n                                                                      d_keys,\n                                                                      num_items,\n                                                                      num_segments,\n                                                                      d_begin_offsets,\n                                                                      d_end_offsets,\n                                                                      begin_bit,\n                                                                      end_bit,\n                                                                      _stream,\n                                                                      false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortKeysDescending(const KeyT* d_keys_in,\n                                                 KeyT*       d_keys_out,\n                                                 int         num_items,\n                                                 int         num_segments,\n                                                 BeginOffsetIteratorT d_begin_offsets,\n                                                 EndOffsetIteratorT d_end_offsets,\n                                                 int begin_bit,\n                                                 int end_bit)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedRadixSort::SortKeysDescending(d_temp_storage,\n                                                              temp_storage_bytes,\n                                                              d_keys_in,\n                                                              d_keys_out,\n                                                              num_items,\n                                                              num_segments,\n                                                              d_begin_offsets,\n                                                              d_end_offsets,\n                                                              begin_bit,\n                                                              end_bit,\n                                                              _stream,\n                                                              false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortKeysDescending(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                                 int num_items,\n                                                 int num_segments,\n                                                 BeginOffsetIteratorT d_begin_offsets,\n                                                 EndOffsetIteratorT d_end_offsets,\n                                                 int begin_bit,\n                                                 int end_bit)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedRadixSort::SortKeysDescending(d_temp_storage,\n                                                              temp_storage_bytes,\n                                                              d_keys,\n                                                              num_items,\n                                                              num_segments,\n                                                              d_begin_offsets,\n                                                              d_end_offsets,\n                                                              begin_bit,\n                                                              end_bit,\n                                                              _stream,\n                                                              false));\n    }\n\n\n    // Origin:\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortPairs(void*                d_temp_storage,\n                                        size_t&amp;              temp_storage_bytes,\n                                        const KeyT*          d_keys_in,\n                                        KeyT*                d_keys_out,\n                                        const ValueT*        d_values_in,\n                                        ValueT*              d_values_out,\n                                        int                  num_items,\n                                        int                  num_segments,\n                                        BeginOffsetIteratorT d_begin_offsets,\n                                        EndOffsetIteratorT   d_end_offsets,\n                                        int                  begin_bit,\n                                        int                  end_bit)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedRadixSort::SortPairs(d_temp_storage,\n                                                     temp_storage_bytes,\n                                                     d_keys_in,\n                                                     d_keys_out,\n                                                     d_values_in,\n                                                     d_values_out,\n                                                     num_items,\n                                                     num_segments,\n                                                     d_begin_offsets,\n                                                     d_end_offsets,\n                                                     begin_bit,\n                                                     end_bit,\n                                                     _stream,\n                                                     false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortPairs(void*   d_temp_storage,\n                                        size_t&amp; temp_storage_bytes,\n                                        cub::DoubleBuffer&lt;KeyT&gt;&amp;   d_keys,\n                                        cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                        int                        num_items,\n                                        int                        num_segments,\n                                        BeginOffsetIteratorT d_begin_offsets,\n                                        EndOffsetIteratorT   d_end_offsets,\n                                        int                  begin_bit,\n                                        int                  end_bit)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedRadixSort::SortPairs(d_temp_storage,\n                                                     temp_storage_bytes,\n                                                     d_keys,\n                                                     d_values,\n                                                     num_items,\n                                                     num_segments,\n                                                     d_begin_offsets,\n                                                     d_end_offsets,\n                                                     begin_bit,\n                                                     end_bit,\n                                                     _stream,\n                                                     false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortPairsDescending(void*   d_temp_storage,\n                                                  size_t&amp; temp_storage_bytes,\n                                                  const KeyT*   d_keys_in,\n                                                  KeyT*         d_keys_out,\n                                                  const ValueT* d_values_in,\n                                                  ValueT*       d_values_out,\n                                                  int           num_items,\n                                                  int           num_segments,\n                                                  BeginOffsetIteratorT d_begin_offsets,\n                                                  EndOffsetIteratorT d_end_offsets,\n                                                  int begin_bit,\n                                                  int end_bit)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedRadixSort::SortPairsDescending(d_temp_storage,\n                                                               temp_storage_bytes,\n                                                               d_keys_in,\n                                                               d_keys_out,\n                                                               d_values_in,\n                                                               d_values_out,\n                                                               num_items,\n                                                               num_segments,\n                                                               d_begin_offsets,\n                                                               d_end_offsets,\n                                                               begin_bit,\n                                                               end_bit,\n                                                               _stream,\n                                                               false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortPairsDescending(void*   d_temp_storage,\n                                                  size_t&amp; temp_storage_bytes,\n                                                  cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                                  cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                                  int num_items,\n                                                  int num_segments,\n                                                  BeginOffsetIteratorT d_begin_offsets,\n                                                  EndOffsetIteratorT d_end_offsets,\n                                                  int begin_bit,\n                                                  int end_bit)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedRadixSort::SortPairsDescending(d_temp_storage,\n                                                               temp_storage_bytes,\n                                                               d_keys,\n                                                               d_values,\n                                                               num_items,\n                                                               num_segments,\n                                                               d_begin_offsets,\n                                                               d_end_offsets,\n                                                               begin_bit,\n                                                               end_bit,\n                                                               _stream,\n                                                               false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortKeys(void*                d_temp_storage,\n                                       size_t&amp;              temp_storage_bytes,\n                                       const KeyT*          d_keys_in,\n                                       KeyT*                d_keys_out,\n                                       int                  num_items,\n                                       int                  num_segments,\n                                       BeginOffsetIteratorT d_begin_offsets,\n                                       EndOffsetIteratorT   d_end_offsets,\n                                       int                  begin_bit,\n                                       int                  end_bit)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedRadixSort::SortKeys(d_temp_storage,\n                                                    temp_storage_bytes,\n                                                    d_keys_in,\n                                                    d_keys_out,\n                                                    num_items,\n                                                    num_segments,\n                                                    d_begin_offsets,\n                                                    d_end_offsets,\n                                                    begin_bit,\n                                                    end_bit,\n                                                    _stream,\n                                                    false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortKeys(void*   d_temp_storage,\n                                       size_t&amp; temp_storage_bytes,\n                                       cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                       int                      num_items,\n                                       int                      num_segments,\n                                       BeginOffsetIteratorT     d_begin_offsets,\n                                       EndOffsetIteratorT       d_end_offsets,\n                                       int                      begin_bit,\n                                       int                      end_bit)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedRadixSort::SortKeys(d_temp_storage,\n                                                    temp_storage_bytes,\n                                                    d_keys,\n                                                    num_items,\n                                                    num_segments,\n                                                    d_begin_offsets,\n                                                    d_end_offsets,\n                                                    begin_bit,\n                                                    end_bit,\n                                                    _stream,\n                                                    false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortKeysDescending(void*       d_temp_storage,\n                                                 size_t&amp;     temp_storage_bytes,\n                                                 const KeyT* d_keys_in,\n                                                 KeyT*       d_keys_out,\n                                                 int         num_items,\n                                                 int         num_segments,\n                                                 BeginOffsetIteratorT d_begin_offsets,\n                                                 EndOffsetIteratorT d_end_offsets,\n                                                 int begin_bit,\n                                                 int end_bit)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedRadixSort::SortKeysDescending(d_temp_storage,\n                                                              temp_storage_bytes,\n                                                              d_keys_in,\n                                                              d_keys_out,\n                                                              num_items,\n                                                              num_segments,\n                                                              d_begin_offsets,\n                                                              d_end_offsets,\n                                                              begin_bit,\n                                                              end_bit,\n                                                              _stream,\n                                                              false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedRadixSort&amp; SortKeysDescending(void*   d_temp_storage,\n                                                 size_t&amp; temp_storage_bytes,\n                                                 cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                                 int num_items,\n                                                 int num_segments,\n                                                 BeginOffsetIteratorT d_begin_offsets,\n                                                 EndOffsetIteratorT d_end_offsets,\n                                                 int begin_bit,\n                                                 int end_bit)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedRadixSort::SortKeysDescending(d_temp_storage,\n                                                              temp_storage_bytes,\n                                                              d_keys,\n                                                              num_items,\n                                                              num_segments,\n                                                              d_begin_offsets,\n                                                              d_end_offsets,\n                                                              begin_bit,\n                                                              end_bit,\n                                                              _stream,\n                                                              false));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__segmented__reduce_8h/","title":"File device_segmented_reduce.h","text":"<p>FileList &gt; cub &gt; device &gt; device_segmented_reduce.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_segmented_reduce.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__segmented__reduce_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__segmented__reduce_8h/#classes","title":"Classes","text":"Type Name class DeviceSegmentedReduce <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_segmented_reduce.h</code></p>"},{"location":"muda/device__segmented__reduce_8h_source/","title":"File device_segmented_reduce.h","text":"<p>File List &gt; cub &gt; device &gt; device_segmented_reduce.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_segmented_reduce.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_reduce.html\nclass DeviceSegmentedReduce : public CubWrapper&lt;DeviceSegmentedReduce&gt;\n{\n    using Base = CubWrapper&lt;DeviceSegmentedReduce&gt;;\n\n  public:\n    using Base::Base;\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT, typename ReductionOp, typename T&gt;\n    DeviceSegmentedReduce&amp; Reduce(InputIteratorT       d_in,\n                                  OutputIteratorT      d_out,\n                                  int                  num_segments,\n                                  BeginOffsetIteratorT d_begin_offsets,\n                                  EndOffsetIteratorT   d_end_offsets,\n                                  ReductionOp          reduction_op,\n                                  T                    initial_value)\n    {\n\n\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedReduce::Reduce(d_temp_storage,\n                                                                 temp_storage_bytes,\n                                                                 d_in,\n                                                                 d_out,\n                                                                 num_segments,\n                                                                 d_begin_offsets,\n                                                                 d_end_offsets,\n                                                                 reduction_op,\n                                                                 initial_value,\n                                                                 _stream,\n                                                                 false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; Sum(InputIteratorT       d_in,\n                               OutputIteratorT      d_out,\n                               int                  num_segments,\n                               BeginOffsetIteratorT d_begin_offsets,\n                               EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedReduce::Sum(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; Min(InputIteratorT       d_in,\n                               OutputIteratorT      d_out,\n                               int                  num_segments,\n                               BeginOffsetIteratorT d_begin_offsets,\n                               EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedReduce::Min(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; ArgMin(InputIteratorT       d_in,\n                                  OutputIteratorT      d_out,\n                                  int                  num_segments,\n                                  BeginOffsetIteratorT d_begin_offsets,\n                                  EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedReduce::ArgMin(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; Max(InputIteratorT       d_in,\n                               OutputIteratorT      d_out,\n                               int                  num_segments,\n                               BeginOffsetIteratorT d_begin_offsets,\n                               EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedReduce::Max(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; ArgMax(InputIteratorT       d_in,\n                                  OutputIteratorT      d_out,\n                                  int                  num_segments,\n                                  BeginOffsetIteratorT d_begin_offsets,\n                                  EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedReduce::ArgMax(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n    // Origin:\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT, typename ReductionOp, typename T&gt;\n    DeviceSegmentedReduce&amp; Reduce(void*                d_temp_storage,\n                                  size_t&amp;              temp_storage_bytes,\n                                  InputIteratorT       d_in,\n                                  OutputIteratorT      d_out,\n                                  int                  num_segments,\n                                  BeginOffsetIteratorT d_begin_offsets,\n                                  EndOffsetIteratorT   d_end_offsets,\n                                  ReductionOp          reduction_op,\n                                  T                    initial_value)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedReduce::Reduce(d_temp_storage,\n                                               temp_storage_bytes,\n                                               d_in,\n                                               d_out,\n                                               num_segments,\n                                               d_begin_offsets,\n                                               d_end_offsets,\n                                               reduction_op,\n                                               initial_value,\n                                               _stream,\n                                               false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; Sum(void*                d_temp_storage,\n                               size_t&amp;              temp_storage_bytes,\n                               InputIteratorT       d_in,\n                               OutputIteratorT      d_out,\n                               int                  num_segments,\n                               BeginOffsetIteratorT d_begin_offsets,\n                               EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedReduce::Sum(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; Min(void*                d_temp_storage,\n                               size_t&amp;              temp_storage_bytes,\n                               InputIteratorT       d_in,\n                               OutputIteratorT      d_out,\n                               int                  num_segments,\n                               BeginOffsetIteratorT d_begin_offsets,\n                               EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedReduce::Min(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; ArgMin(void*                d_temp_storage,\n                                  size_t&amp;              temp_storage_bytes,\n                                  InputIteratorT       d_in,\n                                  OutputIteratorT      d_out,\n                                  int                  num_segments,\n                                  BeginOffsetIteratorT d_begin_offsets,\n                                  EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedReduce::ArgMin(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; Max(void*                d_temp_storage,\n                               size_t&amp;              temp_storage_bytes,\n                               InputIteratorT       d_in,\n                               OutputIteratorT      d_out,\n                               int                  num_segments,\n                               BeginOffsetIteratorT d_begin_offsets,\n                               EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedReduce::Max(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT&gt;\n    DeviceSegmentedReduce&amp; ArgMax(void*           d_temp_storage,\n                                  size_t&amp;         temp_storage_bytes,\n                                  InputIteratorT  d_in,\n                                  OutputIteratorT d_out,\n                                  int             num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedReduce::ArgMax(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedReduce&amp; ArgMax(void*                d_temp_storage,\n                                  size_t&amp;              temp_storage_bytes,\n                                  InputIteratorT       d_in,\n                                  OutputIteratorT      d_out,\n                                  int                  num_segments,\n                                  BeginOffsetIteratorT d_begin_offsets,\n                                  EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedReduce::ArgMax(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__segmented__sort_8h/","title":"File device_segmented_sort.h","text":"<p>FileList &gt; cub &gt; device &gt; device_segmented_sort.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_segmented_sort.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__segmented__sort_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__segmented__sort_8h/#classes","title":"Classes","text":"Type Name class DeviceSegmentedSort <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_segmented_sort.h</code></p>"},{"location":"muda/device__segmented__sort_8h_source/","title":"File device_segmented_sort.h","text":"<p>File List &gt; cub &gt; device &gt; device_segmented_sort.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_segmented_sort.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_segmented_reduce.html\nclass DeviceSegmentedSort : public CubWrapper&lt;DeviceSegmentedSort&gt;\n{\n    using Base = CubWrapper&lt;DeviceSegmentedSort&gt;;\n\n  public:\n    using Base::Base;\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortKeys(const KeyT*          d_keys_in,\n                                  KeyT*                d_keys_out,\n                                  int                  num_items,\n                                  int                  num_segments,\n                                  BeginOffsetIteratorT d_begin_offsets,\n                                  EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::SortKeys(d_temp_storage,\n                                                                 temp_storage_bytes,\n                                                                 d_keys_in,\n                                                                 d_keys_out,\n                                                                 num_items,\n                                                                 num_segments,\n                                                                 d_begin_offsets,\n                                                                 d_end_offsets,\n                                                                 _stream,\n                                                                 false));\n    }\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortKeysDescending(const KeyT* d_keys_in,\n                                            KeyT*       d_keys_out,\n                                            int         num_items,\n                                            int         num_segments,\n                                            BeginOffsetIteratorT d_begin_offsets,\n                                            EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedSort::SortKeysDescending(d_temp_storage,\n                                                         temp_storage_bytes,\n                                                         d_keys_in,\n                                                         d_keys_out,\n                                                         num_items,\n                                                         num_segments,\n                                                         d_begin_offsets,\n                                                         d_end_offsets,\n                                                         _stream,\n                                                         false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortKeys(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                  int                      num_items,\n                                  int                      num_segments,\n                                  BeginOffsetIteratorT     d_begin_offsets,\n                                  EndOffsetIteratorT       d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::SortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortKeysDescending(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                            int                      num_items,\n                                            int num_segments,\n                                            BeginOffsetIteratorT d_begin_offsets,\n                                            EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::SortKeysDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortKeys(const KeyT*          d_keys_in,\n                                        KeyT*                d_keys_out,\n                                        int                  num_items,\n                                        int                  num_segments,\n                                        BeginOffsetIteratorT d_begin_offsets,\n                                        EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::StableSortKeys(d_temp_storage,\n                                                                       temp_storage_bytes,\n                                                                       d_keys_in,\n                                                                       d_keys_out,\n                                                                       num_items,\n                                                                       num_segments,\n                                                                       d_begin_offsets,\n                                                                       d_end_offsets,\n                                                                       _stream,\n                                                                       false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortKeysDescending(const KeyT* d_keys_in,\n                                                  KeyT*       d_keys_out,\n                                                  int         num_items,\n                                                  int         num_segments,\n                                                  BeginOffsetIteratorT d_begin_offsets,\n                                                  EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedSort::StableSortKeysDescending(d_temp_storage,\n                                                               temp_storage_bytes,\n                                                               d_keys_in,\n                                                               d_keys_out,\n                                                               num_items,\n                                                               num_segments,\n                                                               d_begin_offsets,\n                                                               d_end_offsets,\n                                                               _stream,\n                                                               false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortKeys(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                        int                      num_items,\n                                        int                      num_segments,\n                                        BeginOffsetIteratorT d_begin_offsets,\n                                        EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::StableSortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortKeysDescending(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                                  int num_items,\n                                                  int num_segments,\n                                                  BeginOffsetIteratorT d_begin_offsets,\n                                                  EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::StableSortKeysDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortPairs(const KeyT*          d_keys_in,\n                                   KeyT*                d_keys_out,\n                                   const ValueT*        d_values_in,\n                                   ValueT*              d_values_out,\n                                   int                  num_items,\n                                   int                  num_segments,\n                                   BeginOffsetIteratorT d_begin_offsets,\n                                   EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::SortPairs(d_temp_storage,\n                                                                  temp_storage_bytes,\n                                                                  d_keys_in,\n                                                                  d_keys_out,\n                                                                  d_values_in,\n                                                                  d_values_out,\n                                                                  num_items,\n                                                                  num_segments,\n                                                                  d_begin_offsets,\n                                                                  d_end_offsets,\n                                                                  _stream,\n                                                                  false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortPairsDescending(const KeyT*   d_keys_in,\n                                             KeyT*         d_keys_out,\n                                             const ValueT* d_values_in,\n                                             ValueT*       d_values_out,\n                                             int           num_items,\n                                             int           num_segments,\n                                             BeginOffsetIteratorT d_begin_offsets,\n                                             EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedSort::SortPairsDescending(d_temp_storage,\n                                                          temp_storage_bytes,\n                                                          d_keys_in,\n                                                          d_keys_out,\n                                                          d_values_in,\n                                                          d_values_out,\n                                                          num_items,\n                                                          num_segments,\n                                                          d_begin_offsets,\n                                                          d_end_offsets,\n                                                          _stream,\n                                                          false));\n    }\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortPairs(cub::DoubleBuffer&lt;KeyT&gt;&amp;   d_keys,\n                                   cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                   int                        num_items,\n                                   int                        num_segments,\n                                   BeginOffsetIteratorT       d_begin_offsets,\n                                   EndOffsetIteratorT         d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::SortPairs(d_temp_storage,\n                                                                  temp_storage_bytes,\n                                                                  d_keys,\n                                                                  d_values,\n                                                                  num_items,\n                                                                  num_segments,\n                                                                  d_begin_offsets,\n                                                                  d_end_offsets,\n                                                                  _stream,\n                                                                  false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortPairsDescending(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                             cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                             int num_items,\n                                             int num_segments,\n                                             BeginOffsetIteratorT d_begin_offsets,\n                                             EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::SortPairsDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortPairs(const KeyT*          d_keys_in,\n                                         KeyT*                d_keys_out,\n                                         const ValueT*        d_values_in,\n                                         ValueT*              d_values_out,\n                                         int                  num_items,\n                                         int                  num_segments,\n                                         BeginOffsetIteratorT d_begin_offsets,\n                                         EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedSort::StableSortPairs(d_temp_storage,\n                                                      temp_storage_bytes,\n                                                      d_keys_in,\n                                                      d_keys_out,\n                                                      d_values_in,\n                                                      d_values_out,\n                                                      num_items,\n                                                      num_segments,\n                                                      d_begin_offsets,\n                                                      d_end_offsets,\n                                                      _stream,\n                                                      false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortPairsDescending(const KeyT*   d_keys_in,\n                                                   KeyT*         d_keys_out,\n                                                   const ValueT* d_values_in,\n                                                   ValueT*       d_values_out,\n                                                   int           num_items,\n                                                   int           num_segments,\n                                                   BeginOffsetIteratorT d_begin_offsets,\n                                                   EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(\n            cub::DeviceSegmentedSort::StableSortPairsDescending(d_temp_storage,\n                                                                temp_storage_bytes,\n                                                                d_keys_in,\n                                                                d_keys_out,\n                                                                d_values_in,\n                                                                d_values_out,\n                                                                num_items,\n                                                                num_segments,\n                                                                d_begin_offsets,\n                                                                d_end_offsets,\n                                                                _stream,\n                                                                false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortPairs(cub::DoubleBuffer&lt;KeyT&gt;&amp;   d_keys,\n                                         cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                         int                        num_items,\n                                         int                  num_segments,\n                                         BeginOffsetIteratorT d_begin_offsets,\n                                         EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::StableSortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortPairsDescending(cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                                   cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                                   int num_items,\n                                                   int num_segments,\n                                                   BeginOffsetIteratorT d_begin_offsets,\n                                                   EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSegmentedSort::StableSortPairsDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n    // Origin:\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortKeys(void*                d_temp_storage,\n                                  size_t&amp;              temp_storage_bytes,\n                                  const KeyT*          d_keys_in,\n                                  KeyT*                d_keys_out,\n                                  int                  num_items,\n                                  int                  num_segments,\n                                  BeginOffsetIteratorT d_begin_offsets,\n                                  EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedSort::SortKeys(d_temp_storage,\n                                               temp_storage_bytes,\n                                               d_keys_in,\n                                               d_keys_out,\n                                               num_items,\n                                               num_segments,\n                                               d_begin_offsets,\n                                               d_end_offsets,\n                                               _stream,\n                                               false));\n    }\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortKeysDescending(void*       d_temp_storage,\n                                            size_t&amp;     temp_storage_bytes,\n                                            const KeyT* d_keys_in,\n                                            KeyT*       d_keys_out,\n                                            int         num_items,\n                                            int         num_segments,\n                                            BeginOffsetIteratorT d_begin_offsets,\n                                            EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedSort::SortKeysDescending(d_temp_storage,\n                                                         temp_storage_bytes,\n                                                         d_keys_in,\n                                                         d_keys_out,\n                                                         num_items,\n                                                         num_segments,\n                                                         d_begin_offsets,\n                                                         d_end_offsets,\n                                                         _stream,\n                                                         false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortKeys(void*                    d_temp_storage,\n                                  size_t&amp;                  temp_storage_bytes,\n                                  cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                  int                      num_items,\n                                  int                      num_segments,\n                                  BeginOffsetIteratorT     d_begin_offsets,\n                                  EndOffsetIteratorT       d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedSort::SortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortKeysDescending(void*   d_temp_storage,\n                                            size_t&amp; temp_storage_bytes,\n                                            cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                            int                      num_items,\n                                            int num_segments,\n                                            BeginOffsetIteratorT d_begin_offsets,\n                                            EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedSort::SortKeysDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortKeys(void*                d_temp_storage,\n                                        size_t&amp;              temp_storage_bytes,\n                                        const KeyT*          d_keys_in,\n                                        KeyT*                d_keys_out,\n                                        int                  num_items,\n                                        int                  num_segments,\n                                        BeginOffsetIteratorT d_begin_offsets,\n                                        EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedSort::StableSortKeys(d_temp_storage,\n                                                     temp_storage_bytes,\n                                                     d_keys_in,\n                                                     d_keys_out,\n                                                     num_items,\n                                                     num_segments,\n                                                     d_begin_offsets,\n                                                     d_end_offsets,\n                                                     _stream,\n                                                     false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortKeysDescending(void*   d_temp_storage,\n                                                  size_t&amp; temp_storage_bytes,\n                                                  const KeyT* d_keys_in,\n                                                  KeyT*       d_keys_out,\n                                                  int         num_items,\n                                                  int         num_segments,\n                                                  BeginOffsetIteratorT d_begin_offsets,\n                                                  EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedSort::StableSortKeysDescending(d_temp_storage,\n                                                               temp_storage_bytes,\n                                                               d_keys_in,\n                                                               d_keys_out,\n                                                               num_items,\n                                                               num_segments,\n                                                               d_begin_offsets,\n                                                               d_end_offsets,\n                                                               _stream,\n                                                               false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortKeys(void*   d_temp_storage,\n                                        size_t&amp; temp_storage_bytes,\n                                        cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                        int                      num_items,\n                                        int                      num_segments,\n                                        BeginOffsetIteratorT d_begin_offsets,\n                                        EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedSort::StableSortKeys(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortKeysDescending(void*   d_temp_storage,\n                                                  size_t&amp; temp_storage_bytes,\n                                                  cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                                  int num_items,\n                                                  int num_segments,\n                                                  BeginOffsetIteratorT d_begin_offsets,\n                                                  EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedSort::StableSortKeysDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortPairs(void*                d_temp_storage,\n                                   size_t&amp;              temp_storage_bytes,\n                                   const KeyT*          d_keys_in,\n                                   KeyT*                d_keys_out,\n                                   const ValueT*        d_values_in,\n                                   ValueT*              d_values_out,\n                                   int                  num_items,\n                                   int                  num_segments,\n                                   BeginOffsetIteratorT d_begin_offsets,\n                                   EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedSort::SortPairs(d_temp_storage,\n                                                temp_storage_bytes,\n                                                d_keys_in,\n                                                d_keys_out,\n                                                d_values_in,\n                                                d_values_out,\n                                                num_items,\n                                                num_segments,\n                                                d_begin_offsets,\n                                                d_end_offsets,\n                                                _stream,\n                                                false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortPairsDescending(void*         d_temp_storage,\n                                             size_t&amp;       temp_storage_bytes,\n                                             const KeyT*   d_keys_in,\n                                             KeyT*         d_keys_out,\n                                             const ValueT* d_values_in,\n                                             ValueT*       d_values_out,\n                                             int           num_items,\n                                             int           num_segments,\n                                             BeginOffsetIteratorT d_begin_offsets,\n                                             EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedSort::SortPairsDescending(d_temp_storage,\n                                                          temp_storage_bytes,\n                                                          d_keys_in,\n                                                          d_keys_out,\n                                                          d_values_in,\n                                                          d_values_out,\n                                                          num_items,\n                                                          num_segments,\n                                                          d_begin_offsets,\n                                                          d_end_offsets,\n                                                          _stream,\n                                                          false));\n    }\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortPairs(void*                    d_temp_storage,\n                                   size_t&amp;                  temp_storage_bytes,\n                                   cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                   cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                   int                        num_items,\n                                   int                        num_segments,\n                                   BeginOffsetIteratorT       d_begin_offsets,\n                                   EndOffsetIteratorT         d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedSort::SortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; SortPairsDescending(void*   d_temp_storage,\n                                             size_t&amp; temp_storage_bytes,\n                                             cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                             cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                             int num_items,\n                                             int num_segments,\n                                             BeginOffsetIteratorT d_begin_offsets,\n                                             EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedSort::SortPairsDescending(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortPairs(void*         d_temp_storage,\n                                         size_t&amp;       temp_storage_bytes,\n                                         const KeyT*   d_keys_in,\n                                         KeyT*         d_keys_out,\n                                         const ValueT* d_values_in,\n                                         ValueT*       d_values_out,\n                                         int           num_items,\n                                         int           num_segments,\n                                         BeginOffsetIteratorT d_begin_offsets,\n                                         EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedSort::StableSortPairs(d_temp_storage,\n                                                      temp_storage_bytes,\n                                                      d_keys_in,\n                                                      d_keys_out,\n                                                      d_values_in,\n                                                      d_values_out,\n                                                      num_items,\n                                                      num_segments,\n                                                      d_begin_offsets,\n                                                      d_end_offsets,\n                                                      _stream,\n                                                      false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortPairsDescending(void*   d_temp_storage,\n                                                   size_t&amp; temp_storage_bytes,\n                                                   const KeyT*   d_keys_in,\n                                                   KeyT*         d_keys_out,\n                                                   const ValueT* d_values_in,\n                                                   ValueT*       d_values_out,\n                                                   int           num_items,\n                                                   int           num_segments,\n                                                   BeginOffsetIteratorT d_begin_offsets,\n                                                   EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedSort::StableSortPairsDescending(d_temp_storage,\n                                                                temp_storage_bytes,\n                                                                d_keys_in,\n                                                                d_keys_out,\n                                                                d_values_in,\n                                                                d_values_out,\n                                                                num_items,\n                                                                num_segments,\n                                                                d_begin_offsets,\n                                                                d_end_offsets,\n                                                                _stream,\n                                                                false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortPairs(void*   d_temp_storage,\n                                         size_t&amp; temp_storage_bytes,\n                                         cub::DoubleBuffer&lt;KeyT&gt;&amp;   d_keys,\n                                         cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                         int                        num_items,\n                                         int                  num_segments,\n                                         BeginOffsetIteratorT d_begin_offsets,\n                                         EndOffsetIteratorT   d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSegmentedSort::StableSortPairs(\n            d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items, num_segments, d_begin_offsets, d_end_offsets, _stream, false));\n    }\n\n\n    template &lt;typename KeyT, typename ValueT, typename BeginOffsetIteratorT, typename EndOffsetIteratorT&gt;\n    DeviceSegmentedSort&amp; StableSortPairsDescending(void*   d_temp_storage,\n                                                   size_t&amp; temp_storage_bytes,\n                                                   cub::DoubleBuffer&lt;KeyT&gt;&amp; d_keys,\n                                                   cub::DoubleBuffer&lt;ValueT&gt;&amp; d_values,\n                                                   int num_items,\n                                                   int num_segments,\n                                                   BeginOffsetIteratorT d_begin_offsets,\n                                                   EndOffsetIteratorT d_end_offsets)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSegmentedSort::StableSortPairsDescending(d_temp_storage,\n                                                                temp_storage_bytes,\n                                                                d_keys,\n                                                                d_values,\n                                                                num_items,\n                                                                num_segments,\n                                                                d_begin_offsets,\n                                                                d_end_offsets,\n                                                                _stream,\n                                                                false));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__select_8h/","title":"File device_select.h","text":"<p>FileList &gt; cub &gt; device &gt; device_select.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_select.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__select_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__select_8h/#classes","title":"Classes","text":"Type Name class DeviceSelect <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_select.h</code></p>"},{"location":"muda/device__select_8h_source/","title":"File device_select.h","text":"<p>File List &gt; cub &gt; device &gt; device_select.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_select.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_select.html\nclass DeviceSelect : public CubWrapper&lt;DeviceSelect&gt;\n{\n    using Base = CubWrapper&lt;DeviceSelect&gt;;\n\n  public:\n    using Base::Base;\n\n    template &lt;typename InputIteratorT, typename FlagIterator, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\n    DeviceSelect&amp; Flagged(InputIteratorT       d_in,\n                          FlagIterator         d_flags,\n                          OutputIteratorT      d_out,\n                          NumSelectedIteratorT d_num_selected_out,\n                          int                  num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSelect::Flagged(\n            d_temp_storage, temp_storage_bytes, d_in, d_flags, d_out, d_num_selected_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT, typename SelectOp&gt;\n    DeviceSelect&amp; If(InputIteratorT       d_in,\n                     OutputIteratorT      d_out,\n                     NumSelectedIteratorT d_num_selected_out,\n                     int                  num_items,\n                     SelectOp             select_op)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSelect::If(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, d_num_selected_out, num_items, select_op, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\n    DeviceSelect&amp; Unique(InputIteratorT       d_in,\n                         OutputIteratorT      d_out,\n                         NumSelectedIteratorT d_num_selected_out,\n                         int                  num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSelect::Unique(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, d_num_selected_out, num_items, _stream, false));\n    }\n#if CUB_VERSION &gt;= 200200\n    template &lt;typename KeyInputIteratorT, typename ValueInputIteratorT, typename KeyOutputIteratorT, typename ValueOutputIteratorT, typename NumSelectedIteratorT&gt;\n    DeviceSelect&amp; UniqueByKey(KeyInputIteratorT    d_keys_in,\n                              ValueInputIteratorT  d_values_in,\n                              KeyOutputIteratorT   d_keys_out,\n                              ValueOutputIteratorT d_values_out,\n                              NumSelectedIteratorT d_num_selected_out,\n                              int                  num_items)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSelect::UniqueByKey(d_temp_storage,\n                                                             temp_storage_bytes,\n                                                             d_keys_in,\n                                                             d_values_in,\n                                                             d_keys_out,\n                                                             d_values_out,\n                                                             d_num_selected_out,\n                                                             num_items,\n                                                             _stream,\n                                                             false));\n    }\n#endif\n\n    // Origin:\n\n    template &lt;typename InputIteratorT, typename FlagIterator, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\n    DeviceSelect&amp; Flagged(void*                d_temp_storage,\n                          size_t&amp;              temp_storage_bytes,\n                          InputIteratorT       d_in,\n                          FlagIterator         d_flags,\n                          OutputIteratorT      d_out,\n                          NumSelectedIteratorT d_num_selected_out,\n                          int                  num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSelect::Flagged(\n            d_temp_storage, temp_storage_bytes, d_in, d_flags, d_out, d_num_selected_out, num_items, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT, typename SelectOp&gt;\n    DeviceSelect&amp; If(void*                d_temp_storage,\n                     size_t&amp;              temp_storage_bytes,\n                     InputIteratorT       d_in,\n                     OutputIteratorT      d_out,\n                     NumSelectedIteratorT d_num_selected_out,\n                     int                  num_items,\n                     SelectOp             select_op)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSelect::If(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, d_num_selected_out, num_items, select_op, _stream, false));\n    }\n\n    template &lt;typename InputIteratorT, typename OutputIteratorT, typename NumSelectedIteratorT&gt;\n    DeviceSelect&amp; Unique(void*                d_temp_storage,\n                         size_t&amp;              temp_storage_bytes,\n                         InputIteratorT       d_in,\n                         OutputIteratorT      d_out,\n                         NumSelectedIteratorT d_num_selected_out,\n                         int                  num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSelect::Unique(\n            d_temp_storage, temp_storage_bytes, d_in, d_out, d_num_selected_out, num_items, _stream, false));\n    }\n#if CUB_VERSION &gt;= 200200\n    template &lt;typename KeyInputIteratorT, typename ValueInputIteratorT, typename KeyOutputIteratorT, typename ValueOutputIteratorT, typename NumSelectedIteratorT&gt;\n    DeviceSelect&amp; UniqueByKey(void*                d_temp_storage,\n                              size_t&amp;              temp_storage_bytes,\n                              KeyInputIteratorT    d_keys_in,\n                              ValueInputIteratorT  d_values_in,\n                              KeyOutputIteratorT   d_keys_out,\n                              ValueOutputIteratorT d_values_out,\n                              NumSelectedIteratorT d_num_selected_out,\n                              int                  num_items)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(\n            cub::DeviceSelect::UniqueByKey(d_temp_storage,\n                                           temp_storage_bytes,\n                                           d_keys_in,\n                                           d_values_in,\n                                           d_keys_out,\n                                           d_values_out,\n                                           d_num_selected_out,\n                                           num_items,\n                                           _stream,\n                                           false));\n    }\n#endif\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/device__spmv_8h/","title":"File device_spmv.h","text":"<p>FileList &gt; cub &gt; device &gt; device_spmv.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/cub/device/cub_wrapper.h&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_def.inl\"</code></li> <li><code>#include &lt;cub/device/device_spmv.cuh&gt;</code></li> <li><code>#include \"details/cub_wrapper_macro_undef.inl\"</code></li> </ul>"},{"location":"muda/device__spmv_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__spmv_8h/#classes","title":"Classes","text":"Type Name class DeviceSpmv <p>The documentation for this class was generated from the following file <code>src/muda/cub/device/device_spmv.h</code></p>"},{"location":"muda/device__spmv_8h_source/","title":"File device_spmv.h","text":"<p>File List &gt; cub &gt; device &gt; device_spmv.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/cub/device/cub_wrapper.h&gt;\n#include \"details/cub_wrapper_macro_def.inl\"\n#ifndef __INTELLISENSE__\n#include &lt;cub/device/device_spmv.cuh&gt;\n#endif\n\nnamespace muda\n{\n//ref: https://nvlabs.github.io/cub/structcub_1_1_device_spmv.html\nclass DeviceSpmv : public CubWrapper&lt;DeviceSpmv&gt;\n{\n    using Base = CubWrapper&lt;DeviceSpmv&gt;;\n\n  public:\n    using Base::Base;\n\n    template &lt;typename ValueT&gt;\n    DeviceSpmv&amp; CsrMV(const ValueT* d_values,\n                      const int*    d_row_offsets,\n                      const int*    d_column_indices,\n                      const ValueT* d_vector_x,\n                      ValueT*       d_vector_y,\n                      int           num_rows,\n                      int           num_cols,\n                      int           num_nonzeros)\n    {\n        MUDA_CUB_WRAPPER_IMPL(cub::DeviceSpmv::CsrMV(d_temp_storage,\n                                                     temp_storage_bytes,\n                                                     d_values,\n                                                     d_row_offsets,\n                                                     d_column_indices,\n                                                     d_vector_x,\n                                                     d_vector_y,\n                                                     num_rows,\n                                                     num_cols,\n                                                     num_nonzeros,\n                                                     _stream,\n                                                     false));\n    }\n\n    // Origin:\n\n    template &lt;typename ValueT&gt;\n    DeviceSpmv&amp; CsrMV(void*         d_temp_storage,\n                      size_t&amp;       temp_storage_bytes,\n                      const ValueT* d_values,\n                      const int*    d_row_offsets,\n                      const int*    d_column_indices,\n                      const ValueT* d_vector_x,\n                      ValueT*       d_vector_y,\n                      int           num_rows,\n                      int           num_cols,\n                      int           num_nonzeros)\n    {\n        MUDA_CUB_WRAPPER_FOR_COMPUTE_GRAPH_IMPL(cub::DeviceSpmv::CsrMV(d_temp_storage,\n                                                                       temp_storage_bytes,\n                                                                       d_values,\n                                                                       d_row_offsets,\n                                                                       d_column_indices,\n                                                                       d_vector_x,\n                                                                       d_vector_y,\n                                                                       num_rows,\n                                                                       num_cols,\n                                                                       num_nonzeros,\n                                                                       _stream,\n                                                                       false));\n    }\n};\n}  // namespace muda\n\n#include \"details/cub_wrapper_macro_undef.inl\"\n</code></pre>"},{"location":"muda/util__type_8h/","title":"File util_type.h","text":"<p>FileList &gt; cub &gt; util_type.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cub/util_type.cuh&gt;</code></li> </ul>"},{"location":"muda/util__type_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/cub/util_type.h</code></p>"},{"location":"muda/util__type_8h_source/","title":"File util_type.h","text":"<p>File List &gt; cub &gt; util_type.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cub/util_type.cuh&gt;\nnamespace muda\n{\ntemplate &lt;typename Key, typename Value&gt;\nusing KeyValuePair = cub::KeyValuePair&lt;Key, Value&gt;;\n}\n</code></pre>"},{"location":"muda/dir_e7c11f96f9eccdf52a5e0655beb83835/","title":"Dir src/muda/cuda","text":"<p>FileList &gt; cuda</p>"},{"location":"muda/dir_e7c11f96f9eccdf52a5e0655beb83835/#files","title":"Files","text":"Type Name file cooperative_groups.h file cuda_runtime.h file cuda_runtime_api.h file device_atomic_functions.h file device_functions.h"},{"location":"muda/dir_e7c11f96f9eccdf52a5e0655beb83835/#directories","title":"Directories","text":"Type Name dir cooperative_groups <p>The documentation for this class was generated from the following file <code>src/muda/cuda/</code></p>"},{"location":"muda/cooperative__groups_8h/","title":"File cooperative_groups.h","text":"<p>FileList &gt; cuda &gt; cooperative_groups.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cooperative_groups.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cuda/cooperative_groups.h</code></p>"},{"location":"muda/cooperative__groups_8h_source/","title":"File cooperative_groups.h","text":"<p>File List &gt; cuda &gt; cooperative_groups.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef __INTELLISENSE__\n// This is a hack to make intellisense work with cooperative_groups.h\n#include &lt;muda/cuda/details/hack_cuda_define&gt;\n#undef _COOPERATIVE_GROUPS_H_\n#endif\n#include &lt;cooperative_groups.h&gt;\n</code></pre>"},{"location":"muda/cuda__runtime_8h/","title":"File cuda_runtime.h","text":"<p>FileList &gt; cuda &gt; cuda_runtime.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cuda/cuda_runtime.h</code></p>"},{"location":"muda/cuda__runtime_8h_source/","title":"File cuda_runtime.h","text":"<p>File List &gt; cuda &gt; cuda_runtime.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef __INTELLISENSE__\n#include &lt;muda/cuda/details/hack_cuda_define&gt;\n#undef __CUDA_RUNTIME_H__\n#endif\n#include &lt;cuda_runtime.h&gt;\n</code></pre>"},{"location":"muda/cuda__runtime__api_8h/","title":"File cuda_runtime_api.h","text":"<p>FileList &gt; cuda &gt; cuda_runtime_api.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cuda/cuda_runtime_api.h</code></p>"},{"location":"muda/cuda__runtime__api_8h_source/","title":"File cuda_runtime_api.h","text":"<p>File List &gt; cuda &gt; cuda_runtime_api.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef __INTELLISENSE__\n#include &lt;muda/cuda/details/hack_cuda_define&gt;\n#undef __CUDA_RUNTIME_API_H__\n#endif\n#include &lt;cuda_runtime_api.h&gt;\n</code></pre>"},{"location":"muda/device__atomic__functions_8h/","title":"File device_atomic_functions.h","text":"<p>FileList &gt; cuda &gt; device_atomic_functions.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;device_atomic_functions.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cuda/device_atomic_functions.h</code></p>"},{"location":"muda/device__atomic__functions_8h_source/","title":"File device_atomic_functions.h","text":"<p>File List &gt; cuda &gt; device_atomic_functions.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef __INTELLISENSE__\n#include &lt;muda/cuda/details/hack_cuda_define&gt;\n#undef __DEVICE_ATOMIC_FUNCTIONS_H__\n#endif\n#include &lt;device_atomic_functions.h&gt;\n</code></pre>"},{"location":"muda/device__functions_8h/","title":"File device_functions.h","text":"<p>FileList &gt; cuda &gt; device_functions.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;device_functions.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cuda/device_functions.h</code></p>"},{"location":"muda/device__functions_8h_source/","title":"File device_functions.h","text":"<p>File List &gt; cuda &gt; device_functions.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef __INTELLISENSE__\n#include &lt;muda/cuda/details/hack_cuda_define&gt;\n#undef __CUDA_INCLUDE_COMPILER_INTERNAL_HEADERS__\n#endif\n#include &lt;device_functions.h&gt;\n</code></pre>"},{"location":"muda/dir_53530ff3f1b052ab68c04b2b54c680d7/","title":"Dir src/muda/cuda/cooperative_groups","text":"<p>FileList &gt; cooperative_groups</p>"},{"location":"muda/dir_53530ff3f1b052ab68c04b2b54c680d7/#files","title":"Files","text":"Type Name file memcpy_async.h file reduce.h file scan.h <p>The documentation for this class was generated from the following file <code>src/muda/cuda/cooperative_groups/</code></p>"},{"location":"muda/memcpy__async_8h/","title":"File memcpy_async.h","text":"<p>FileList &gt; cooperative_groups &gt; memcpy_async.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cooperative_groups/memcpy_async.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cuda/cooperative_groups/memcpy_async.h</code></p>"},{"location":"muda/memcpy__async_8h_source/","title":"File memcpy_async.h","text":"<p>File List &gt; cooperative_groups &gt; memcpy_async.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef __INTELLISENSE__\n#include &lt;muda/cuda/details/hack_cuda_define&gt;\n#undef _COOPERATIVE_GROUPS_MEMCPY_ASYNC\n#endif\n#include &lt;cooperative_groups/memcpy_async.h&gt;\n</code></pre>"},{"location":"muda/reduce_8h/","title":"File reduce.h","text":"<p>FileList &gt; cooperative_groups &gt; reduce.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cooperative_groups/reduce.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cuda/cooperative_groups/reduce.h</code></p>"},{"location":"muda/reduce_8h_source/","title":"File reduce.h","text":"<p>File List &gt; cooperative_groups &gt; reduce.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef __INTELLISENSE__\n#include &lt;muda/cuda/details/hack_cuda_define&gt;\n#undef _COOPERATIVE_GROUPS_REDUCE_H\n#endif\n#include &lt;cooperative_groups/reduce.h&gt;\n</code></pre>"},{"location":"muda/scan_8h/","title":"File scan.h","text":"<p>FileList &gt; cooperative_groups &gt; scan.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cooperative_groups/scan.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/cuda/cooperative_groups/scan.h</code></p>"},{"location":"muda/scan_8h_source/","title":"File scan.h","text":"<p>File List &gt; cooperative_groups &gt; scan.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifdef __INTELLISENSE__\n#include &lt;muda/cuda/details/hack_cuda_define&gt;\n#undef _COOPERATIVE_GROUPS_SCAN_H\n#endif\n#include &lt;cooperative_groups/scan.h&gt;\n</code></pre>"},{"location":"muda/dir_dee31a662aa40cb7fc08cb07824f4a9a/","title":"Dir src/muda/ext","text":"<p>FileList &gt; ext</p>"},{"location":"muda/dir_dee31a662aa40cb7fc08cb07824f4a9a/#files","title":"Files","text":"Type Name file eigen.h file field.h file linear_system.h"},{"location":"muda/dir_dee31a662aa40cb7fc08cb07824f4a9a/#directories","title":"Directories","text":"Type Name dir eigen dir field dir geo dir linear_system <p>The documentation for this class was generated from the following file <code>src/muda/ext/</code></p>"},{"location":"muda/eigen_8h/","title":"File eigen.h","text":"<p>FileList &gt; ext &gt; eigen.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/eigen/log_proxy.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/atomic.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/as_eigen.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/inverse.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen.h</code></p>"},{"location":"muda/eigen_8h_source/","title":"File eigen.h","text":"<p>File List &gt; ext &gt; eigen.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/eigen/log_proxy.h&gt;\n#include &lt;muda/ext/eigen/atomic.h&gt;\n#include &lt;muda/ext/eigen/as_eigen.h&gt;\n#include &lt;muda/ext/eigen/inverse.h&gt;\n</code></pre>"},{"location":"muda/field_8h/","title":"File field.h","text":"<p>FileList &gt; ext &gt; field.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/field/field.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_builder.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field.h</code></p>"},{"location":"muda/field_8h_source/","title":"File field.h","text":"<p>File List &gt; ext &gt; field.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/field/field.h&gt;\n#include &lt;muda/ext/field/field_entry.h&gt;\n#include &lt;muda/ext/field/field_builder.h&gt;\n</code></pre>"},{"location":"muda/linear__system_8h/","title":"File linear_system.h","text":"<p>FileList &gt; ext &gt; linear_system.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/device_dense_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/dense_matrix_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/dense_matrix_viewer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_dense_vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/dense_vector_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/dense_vector_viewer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_triplet_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/triplet_matrix_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/triplet_matrix_viewer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_doublet_vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/doublet_vector_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/doublet_vector_viewer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bcoo_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bcoo_matrix_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bcoo_matrix_viewer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bcoo_vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bcoo_vector_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bcoo_vector_viewer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bsr_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bsr_matrix_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_csr_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/csr_matrix_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/matrix_format_converter.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/linear_system_context.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system.h</code></p>"},{"location":"muda/linear__system_8h_source/","title":"File linear_system.h","text":"<p>File List &gt; ext &gt; linear_system.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/device_dense_matrix.h&gt;\n#include &lt;muda/ext/linear_system/dense_matrix_view.h&gt;\n#include &lt;muda/ext/linear_system/dense_matrix_viewer.h&gt;\n#include &lt;muda/ext/linear_system/device_dense_vector.h&gt;\n#include &lt;muda/ext/linear_system/dense_vector_view.h&gt;\n#include &lt;muda/ext/linear_system/dense_vector_viewer.h&gt;\n#include &lt;muda/ext/linear_system/device_triplet_matrix.h&gt;\n#include &lt;muda/ext/linear_system/triplet_matrix_view.h&gt;\n#include &lt;muda/ext/linear_system/triplet_matrix_viewer.h&gt;\n#include &lt;muda/ext/linear_system/device_doublet_vector.h&gt;\n#include &lt;muda/ext/linear_system/doublet_vector_view.h&gt;\n#include &lt;muda/ext/linear_system/doublet_vector_viewer.h&gt;\n#include &lt;muda/ext/linear_system/device_bcoo_matrix.h&gt;\n#include &lt;muda/ext/linear_system/bcoo_matrix_view.h&gt;\n#include &lt;muda/ext/linear_system/bcoo_matrix_viewer.h&gt;\n#include &lt;muda/ext/linear_system/device_bcoo_vector.h&gt;\n#include &lt;muda/ext/linear_system/bcoo_vector_view.h&gt;\n#include &lt;muda/ext/linear_system/bcoo_vector_viewer.h&gt;\n#include &lt;muda/ext/linear_system/device_bsr_matrix.h&gt;\n#include &lt;muda/ext/linear_system/bsr_matrix_view.h&gt;\n#include &lt;muda/ext/linear_system/device_csr_matrix.h&gt;\n#include &lt;muda/ext/linear_system/csr_matrix_view.h&gt;\n#include &lt;muda/ext/linear_system/matrix_format_converter.h&gt;\n#include &lt;muda/ext/linear_system/linear_system_context.h&gt;\n</code></pre>"},{"location":"muda/dir_373cdbe7548ceaaa1c4b365fecb08d35/","title":"Dir src/muda/ext/eigen","text":"<p>FileList &gt; eigen</p>"},{"location":"muda/dir_373cdbe7548ceaaa1c4b365fecb08d35/#files","title":"Files","text":"Type Name file as_eigen.h file atomic.h file eigen_core_cxx20.h file eigen_cxx20.h file eigen_dense_cxx20.h file evd.h file inverse.h file log_proxy.h file svd.h"},{"location":"muda/dir_373cdbe7548ceaaa1c4b365fecb08d35/#directories","title":"Directories","text":"Type Name dir inverse dir svd <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/</code></p>"},{"location":"muda/as__eigen_8h/","title":"File as_eigen.h","text":"<p>FileList &gt; eigen &gt; as_eigen.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;vector_types.h&gt;</code></li> </ul>"},{"location":"muda/as__eigen_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace eigen <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/as_eigen.h</code></p>"},{"location":"muda/as__eigen_8h_source/","title":"File as_eigen.h","text":"<p>File List &gt; eigen &gt; as_eigen.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;vector_types.h&gt;\nnamespace muda\n{\nnamespace eigen\n{\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;float, 2, 1&gt;&gt; as_eigen(float2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;float, 2, 1&gt;&gt;(reinterpret_cast&lt;float*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;float, 2, 1&gt;&gt; as_eigen(const float2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;float, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const float*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;float, 3, 1&gt;&gt; as_eigen(float3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;float, 3, 1&gt;&gt;(reinterpret_cast&lt;float*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;float, 3, 1&gt;&gt; as_eigen(const float3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;float, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const float*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;float, 4, 1&gt;&gt; as_eigen(float4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;float, 4, 1&gt;&gt;(reinterpret_cast&lt;float*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;float, 4, 1&gt;&gt; as_eigen(const float4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;float, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const float*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;double, 2, 1&gt;&gt; as_eigen(double2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;double, 2, 1&gt;&gt;(reinterpret_cast&lt;double*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;double, 2, 1&gt;&gt; as_eigen(const double2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;double, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const double*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;double, 3, 1&gt;&gt; as_eigen(double3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;double, 3, 1&gt;&gt;(reinterpret_cast&lt;double*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;double, 3, 1&gt;&gt; as_eigen(const double3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;double, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const double*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;double, 4, 1&gt;&gt; as_eigen(double4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;double, 4, 1&gt;&gt;(reinterpret_cast&lt;double*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;double, 4, 1&gt;&gt; as_eigen(const double4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;double, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const double*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;int, 2, 1&gt;&gt; as_eigen(int2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;int, 2, 1&gt;&gt;(reinterpret_cast&lt;int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;int, 2, 1&gt;&gt; as_eigen(const int2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;int, 3, 1&gt;&gt; as_eigen(int3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;int, 3, 1&gt;&gt;(reinterpret_cast&lt;int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;int, 3, 1&gt;&gt; as_eigen(const int3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;int, 4, 1&gt;&gt; as_eigen(int4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;int, 4, 1&gt;&gt;(reinterpret_cast&lt;int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;int, 4, 1&gt;&gt; as_eigen(const int4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned int, 2, 1&gt;&gt; as_eigen(uint2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned int, 2, 1&gt;&gt; as_eigen(const uint2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned int, 3, 1&gt;&gt; as_eigen(uint3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned int, 3, 1&gt;&gt; as_eigen(const uint3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned int, 4, 1&gt;&gt; as_eigen(uint4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned int, 4, 1&gt;&gt; as_eigen(const uint4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;short, 2, 1&gt;&gt; as_eigen(short2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;short, 2, 1&gt;&gt;(reinterpret_cast&lt;short*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;short, 2, 1&gt;&gt; as_eigen(const short2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;short, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const short*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;short, 3, 1&gt;&gt; as_eigen(short3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;short, 3, 1&gt;&gt;(reinterpret_cast&lt;short*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;short, 3, 1&gt;&gt; as_eigen(const short3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;short, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const short*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;short, 4, 1&gt;&gt; as_eigen(short4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;short, 4, 1&gt;&gt;(reinterpret_cast&lt;short*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;short, 4, 1&gt;&gt; as_eigen(const short4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;short, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const short*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned short, 2, 1&gt;&gt; as_eigen(ushort2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned short, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned short*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned short, 2, 1&gt;&gt; as_eigen(const ushort2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned short, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned short*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned short, 3, 1&gt;&gt; as_eigen(ushort3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned short, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned short*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned short, 3, 1&gt;&gt; as_eigen(const ushort3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned short, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned short*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned short, 4, 1&gt;&gt; as_eigen(ushort4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned short, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned short*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned short, 4, 1&gt;&gt; as_eigen(const ushort4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned short, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned short*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;char, 2, 1&gt;&gt; as_eigen(char2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;char, 2, 1&gt;&gt;(reinterpret_cast&lt;char*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;char, 2, 1&gt;&gt; as_eigen(const char2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;char, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const char*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;char, 3, 1&gt;&gt; as_eigen(char3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;char, 3, 1&gt;&gt;(reinterpret_cast&lt;char*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;char, 3, 1&gt;&gt; as_eigen(const char3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;char, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const char*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;char, 4, 1&gt;&gt; as_eigen(char4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;char, 4, 1&gt;&gt;(reinterpret_cast&lt;char*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;char, 4, 1&gt;&gt; as_eigen(const char4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;char, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const char*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned char, 2, 1&gt;&gt; as_eigen(uchar2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned char, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned char*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned char, 2, 1&gt;&gt; as_eigen(const uchar2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned char, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned char*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned char, 3, 1&gt;&gt; as_eigen(uchar3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned char, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned char*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned char, 3, 1&gt;&gt; as_eigen(const uchar3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned char, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned char*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned char, 4, 1&gt;&gt; as_eigen(uchar4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned char, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned char*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned char, 4, 1&gt;&gt; as_eigen(const uchar4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned char, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned char*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;long int, 2, 1&gt;&gt; as_eigen(long2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;long int, 2, 1&gt;&gt;(reinterpret_cast&lt;long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;long int, 2, 1&gt;&gt; as_eigen(const long2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;long int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;long int, 3, 1&gt;&gt; as_eigen(long3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;long int, 3, 1&gt;&gt;(reinterpret_cast&lt;long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;long int, 3, 1&gt;&gt; as_eigen(const long3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;long int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;long int, 4, 1&gt;&gt; as_eigen(long4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;long int, 4, 1&gt;&gt;(reinterpret_cast&lt;long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;long int, 4, 1&gt;&gt; as_eigen(const long4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;long int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned long int, 2, 1&gt;&gt; as_eigen(ulong2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned long int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long int, 2, 1&gt;&gt; as_eigen(const ulong2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned long int, 3, 1&gt;&gt; as_eigen(ulong3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned long int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long int, 3, 1&gt;&gt; as_eigen(const ulong3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned long int, 4, 1&gt;&gt; as_eigen(ulong4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned long int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long int, 4, 1&gt;&gt; as_eigen(const ulong4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;long long int, 2, 1&gt;&gt; as_eigen(longlong2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;long long int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;long long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;long long int, 2, 1&gt;&gt; as_eigen(const longlong2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;long long int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const long long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;long long int, 3, 1&gt;&gt; as_eigen(longlong3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;long long int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;long long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;long long int, 3, 1&gt;&gt; as_eigen(const longlong3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;long long int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const long long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;long long int, 4, 1&gt;&gt; as_eigen(longlong4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;long long int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;long long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;long long int, 4, 1&gt;&gt; as_eigen(const longlong4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;long long int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const long long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned long long int, 2, 1&gt;&gt; as_eigen(ulonglong2&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned long long int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned long long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long long int, 2, 1&gt;&gt; as_eigen(\n        const ulonglong2&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long long int, 2, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned long long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned long long int, 3, 1&gt;&gt; as_eigen(ulonglong3&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned long long int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned long long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long long int, 3, 1&gt;&gt; as_eigen(\n        const ulonglong3&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long long int, 3, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned long long int*&gt;(&amp;val));\n    }\n\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;Eigen::Matrix&lt;unsigned long long int, 4, 1&gt;&gt; as_eigen(ulonglong4&amp; val)\n    {\n        return Eigen::Map&lt;Eigen::Matrix&lt;unsigned long long int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;unsigned long long int*&gt;(&amp;val));\n    }\n    MUDA_INLINE MUDA_GENERIC Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long long int, 4, 1&gt;&gt; as_eigen(\n        const ulonglong4&amp; val)\n    {\n        return Eigen::Map&lt;const Eigen::Matrix&lt;unsigned long long int, 4, 1&gt;&gt;(\n            reinterpret_cast&lt;const unsigned long long int*&gt;(&amp;val));\n    }\n}  // namespace eigen\n}  // namespace muda\n</code></pre>"},{"location":"muda/ext_2eigen_2atomic_8h/","title":"File atomic.h","text":"<p>FileList &gt; eigen &gt; atomic.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/atomic.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> </ul>"},{"location":"muda/ext_2eigen_2atomic_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace eigen <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/atomic.h</code></p>"},{"location":"muda/ext_2eigen_2atomic_8h_source/","title":"File atomic.h","text":"<p>File List &gt; eigen &gt; atomic.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/atomic.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::eigen\n{\ntemplate &lt;typename T, int M, int N&gt;\nMUDA_GENERIC Eigen::Matrix&lt;T, M, N&gt; atomic_add(Eigen::Matrix&lt;T, M, N&gt;&amp; dst,\n                                               const Eigen::Matrix&lt;T, M, N&gt;&amp; src)\n{\n    Eigen::Matrix&lt;T, M, N&gt; ret;\n\n#pragma unroll\n    for(int j = 0; j &lt; N; ++j)\n#pragma unroll\n        for(int i = 0; i &lt; M; ++i)\n        {\n            ret(i, j) = muda::atomic_add(&amp;dst(i, j), src(i, j));\n        }\n    return ret;\n}\n\ntemplate &lt;typename T, int M, int N&gt;\nMUDA_GENERIC Eigen::Matrix&lt;T, M, N&gt; atomic_add(Eigen::Map&lt;Eigen::Matrix&lt;T, M, N&gt;&gt;&amp; dst,\n                                               const Eigen::Matrix&lt;T, M, N&gt;&amp; src)\n{\n    Eigen::Matrix&lt;T, M, N&gt; ret;\n\n#pragma unroll\n    for(int j = 0; j &lt; N; ++j)\n#pragma unroll\n        for(int i = 0; i &lt; M; ++i)\n        {\n            ret(i, j) = muda::atomic_add(&amp;dst(i, j), src(i, j));\n        }\n\n    return ret;\n}\n}  // namespace muda::eigen\n</code></pre>"},{"location":"muda/eigen__core__cxx20_8h/","title":"File eigen_core_cxx20.h","text":"<p>FileList &gt; eigen &gt; eigen_core_cxx20.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/eigen/eigen_cxx20.h&gt;</code></li> <li><code>#include &lt;Eigen/Core&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/eigen_core_cxx20.h</code></p>"},{"location":"muda/eigen__core__cxx20_8h_source/","title":"File eigen_core_cxx20.h","text":"<p>File List &gt; eigen &gt; eigen_core_cxx20.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/eigen/eigen_cxx20.h&gt;\n#include &lt;Eigen/Core&gt;\n</code></pre>"},{"location":"muda/eigen__cxx20_8h/","title":"File eigen_cxx20.h","text":"<p>FileList &gt; eigen &gt; eigen_cxx20.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/eigen_cxx20.h</code></p>"},{"location":"muda/eigen__cxx20_8h_source/","title":"File eigen_cxx20.h","text":"<p>File List &gt; eigen &gt; eigen_cxx20.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#ifdef __CUDA_ARCH__\n#include &lt;complex&gt;\n// Fix eigen cuda cxx20 : can't find `arg` in global scope\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC T arg(const std::complex&lt;T&gt;&amp; z)\n{\n    return std::atan2(std::imag(z), std::real(z));\n}\n#endif\n</code></pre>"},{"location":"muda/eigen__dense__cxx20_8h/","title":"File eigen_dense_cxx20.h","text":"<p>FileList &gt; eigen &gt; eigen_dense_cxx20.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/eigen/eigen_cxx20.h&gt;</code></li> <li><code>#include &lt;Eigen/Dense&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/eigen_dense_cxx20.h</code></p>"},{"location":"muda/eigen__dense__cxx20_8h_source/","title":"File eigen_dense_cxx20.h","text":"<p>File List &gt; eigen &gt; eigen_dense_cxx20.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/eigen/eigen_cxx20.h&gt;\n#include &lt;Eigen/Dense&gt;\n</code></pre>"},{"location":"muda/evd_8h/","title":"File evd.h","text":"<p>FileList &gt; eigen &gt; evd.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;Eigen/Eigenvalues&gt;</code></li> </ul>"},{"location":"muda/evd_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace eigen <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/evd.h</code></p>"},{"location":"muda/evd_8h_source/","title":"File evd.h","text":"<p>File List &gt; eigen &gt; evd.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;Eigen/Eigenvalues&gt;\nnamespace muda\n{\nnamespace eigen\n{\n    template &lt;typename T, int N&gt;\n    MUDA_GENERIC void evd(const Eigen::Matrix&lt;T, N, N&gt;&amp; M,\n                          Eigen::Vector&lt;T, N&gt;&amp;          eigen_values,\n                          Eigen::Matrix&lt;T, N, N&gt;&amp;       eigen_vectors)\n    {\n        Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix&lt;T, N, N&gt;&gt; eigen_solver;\n        // NOTE:\n        //  On CUDA, if N &lt;= 3, compute() is not supported.\n        //  So, we use computeDirect() instead.\n        if constexpr(N &lt;= 3)\n            eigen_solver.computeDirect(M);\n        else\n            eigen_solver.compute(M);\n        eigen_values  = eigen_solver.eigenvalues();\n        eigen_vectors = eigen_solver.eigenvectors();\n    }\n}  // namespace eigen\n}  // namespace muda\n</code></pre>"},{"location":"muda/inverse_8h/","title":"File inverse.h","text":"<p>FileList &gt; eigen &gt; inverse.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/inverse/gauss_elimination.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/inverse/analytic_inverse.h&gt;</code></li> </ul>"},{"location":"muda/inverse_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace eigen <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/inverse.h</code></p>"},{"location":"muda/inverse_8h_source/","title":"File inverse.h","text":"<p>File List &gt; eigen &gt; inverse.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;muda/ext/eigen/inverse/gauss_elimination.h&gt;\n#include &lt;muda/ext/eigen/inverse/analytic_inverse.h&gt;\n\nnamespace muda::eigen\n{\ntemplate &lt;typename T, int N, typename InverseAlgorithm = muda::eigen::GaussEliminationInverse&gt;\nMUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt;T, N, N&gt; inverse(const Eigen::Matrix&lt;T, N, N&gt;&amp; m)\n{\n    return InverseAlgorithm{}(m);\n}\n\ntemplate &lt;typename T, typename InverseAlgorithm = muda::eigen::AnalyticalInverse&gt;\nMUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt;T, 2, 2&gt; inverse(const Eigen::Matrix&lt;T, 2, 2&gt;&amp; m)\n{\n    return InverseAlgorithm{}(m);\n}\n\ntemplate &lt;typename T, typename InverseAlgorithm = muda::eigen::AnalyticalInverse&gt;\nMUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt;T, 3, 3&gt; inverse(const Eigen::Matrix&lt;T, 3, 3&gt;&amp; m)\n{\n    return InverseAlgorithm{}(m);\n}\n\ntemplate &lt;typename T, typename InverseAlgorithm = muda::eigen::AnalyticalInverse&gt;\nMUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt;T, 4, 4&gt; inverse(const Eigen::Matrix&lt;T, 4, 4&gt;&amp; m)\n{\n    return InverseAlgorithm{}(m);\n}\n}  // namespace muda::eigen\n</code></pre>"},{"location":"muda/log__proxy_8h/","title":"File log_proxy.h","text":"<p>FileList &gt; eigen &gt; log_proxy.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;muda/logger/logger_viewer.h&gt;</code></li> <li><code>#include \"details/log_proxy.inl\"</code></li> </ul>"},{"location":"muda/log__proxy_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/log_proxy.h</code></p>"},{"location":"muda/log__proxy_8h_source/","title":"File log_proxy.h","text":"<p>File List &gt; eigen &gt; log_proxy.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;muda/logger/logger_viewer.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T, int M, int N&gt;\nMUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy o, const Eigen::Matrix&lt;T, M, N&gt;&amp; val);\n\ntemplate &lt;typename T, int M, int N, int MapOptions, typename StrideType&gt;\nMUDA_DEVICE LogProxy operator&lt;&lt;(\n    LogProxy o, const Eigen::Map&lt;Eigen::Matrix&lt;T, M, N&gt;, MapOptions, StrideType&gt;&amp; val);\n\ntemplate &lt;typename T, int M, int N, int MapOptions, typename StrideType&gt;\nMUDA_DEVICE LogProxy operator&lt;&lt;(\n    LogProxy o,\n    const Eigen::Map&lt;const Eigen::Matrix&lt;T, M, N&gt;, MapOptions, StrideType&gt;&amp; val);\n\ntemplate &lt;typename T&gt;\nMUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy o, const Eigen::MatrixX&lt;T&gt;&amp; val);\n\ntemplate &lt;typename T&gt;\nMUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy o, const Eigen::VectorX&lt;T&gt;&amp; val);\n\ntemplate &lt;typename T&gt;\nMUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy o, const Eigen::RowVectorX&lt;T&gt;&amp; val);\n}  // namespace muda\n\n#include \"details/log_proxy.inl\"\n</code></pre>"},{"location":"muda/dir_c61bd2e796e3edc48398972f7a794fc0/","title":"Dir src/muda/ext/eigen/inverse","text":"<p>FileList &gt; eigen &gt; inverse</p>"},{"location":"muda/dir_c61bd2e796e3edc48398972f7a794fc0/#files","title":"Files","text":"Type Name file analytic_inverse.h file gauss_elimination.h <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/inverse/</code></p>"},{"location":"muda/analytic__inverse_8h/","title":"File analytic_inverse.h","text":"<p>FileList &gt; eigen &gt; inverse &gt; analytic_inverse.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> </ul>"},{"location":"muda/analytic__inverse_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace eigen"},{"location":"muda/analytic__inverse_8h/#classes","title":"Classes","text":"Type Name struct AnalyticalInverse <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/inverse/analytic_inverse.h</code></p>"},{"location":"muda/analytic__inverse_8h_source/","title":"File analytic_inverse.h","text":"<p>File List &gt; eigen &gt; inverse &gt; analytic_inverse.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::eigen\n{\nstruct AnalyticalInverse\n{\n    template &lt;typename T&gt;\n    MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt;T, 2, 2&gt; operator()(const Eigen::Matrix&lt;T, 2, 2&gt;&amp; m)\n    {\n        Eigen::Matrix&lt;T, 2, 2&gt; result;\n        invert2x2(m.data(), result.data());\n        return result;\n    }\n\n    template &lt;typename T&gt;\n    MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt;T, 3, 3&gt; operator()(const Eigen::Matrix&lt;T, 3, 3&gt;&amp; m)\n    {\n        Eigen::Matrix&lt;T, 3, 3&gt; result;\n        invert3x3(m.data(), result.data());\n        return result;\n    }\n\n    template &lt;typename T&gt;\n    MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt;T, 4, 4&gt; operator()(const Eigen::Matrix&lt;T, 4, 4&gt;&amp; m)\n    {\n        Eigen::Matrix&lt;T, 4, 4&gt; result;\n        invert4x4(m.data(), result.data());\n        return result;\n    }\n\n  private:\n    template &lt;typename T&gt;\n    MUDA_INLINE MUDA_GENERIC void invert2x2(const T* src, T* dst)\n    {\n        T det;\n\n        /* Compute adjoint: */\n\n        dst[0] = +src[3];\n        dst[1] = -src[1];\n        dst[2] = -src[2];\n        dst[3] = +src[0];\n\n        /* Compute determinant: */\n\n        det = src[0] * dst[0] + src[1] * dst[2];\n\n        /* Multiply adjoint with reciprocal of determinant: */\n\n        det = 1.0f / det;\n\n        dst[0] *= det;\n        dst[1] *= det;\n        dst[2] *= det;\n        dst[3] *= det;\n    }\n\n    template &lt;typename T&gt;\n    MUDA_INLINE MUDA_GENERIC void invert3x3(const T* src, T* dst)\n    {\n        T det;\n\n        /* Compute adjoint: */\n\n        dst[0] = +src[4] * src[8] - src[5] * src[7];\n        dst[1] = -src[1] * src[8] + src[2] * src[7];\n        dst[2] = +src[1] * src[5] - src[2] * src[4];\n        dst[3] = -src[3] * src[8] + src[5] * src[6];\n        dst[4] = +src[0] * src[8] - src[2] * src[6];\n        dst[5] = -src[0] * src[5] + src[2] * src[3];\n        dst[6] = +src[3] * src[7] - src[4] * src[6];\n        dst[7] = -src[0] * src[7] + src[1] * src[6];\n        dst[8] = +src[0] * src[4] - src[1] * src[3];\n\n        /* Compute determinant: */\n\n        det = src[0] * dst[0] + src[1] * dst[3] + src[2] * dst[6];\n\n        /* Multiply adjoint with reciprocal of determinant: */\n\n        det = 1.0f / det;\n\n        dst[0] *= det;\n        dst[1] *= det;\n        dst[2] *= det;\n        dst[3] *= det;\n        dst[4] *= det;\n        dst[5] *= det;\n        dst[6] *= det;\n        dst[7] *= det;\n        dst[8] *= det;\n    }\n\n    template &lt;typename T&gt;\n    MUDA_INLINE MUDA_GENERIC void invert4x4(const T* src, T* dst)\n    {\n        T det;\n\n        /* Compute adjoint: */\n\n        dst[0] = +src[5] * src[10] * src[15] - src[5] * src[11] * src[14]\n                 - src[9] * src[6] * src[15] + src[9] * src[7] * src[14]\n                 + src[13] * src[6] * src[11] - src[13] * src[7] * src[10];\n\n        dst[1] = -src[1] * src[10] * src[15] + src[1] * src[11] * src[14]\n                 + src[9] * src[2] * src[15] - src[9] * src[3] * src[14]\n                 - src[13] * src[2] * src[11] + src[13] * src[3] * src[10];\n\n        dst[2] = +src[1] * src[6] * src[15] - src[1] * src[7] * src[14]\n                 - src[5] * src[2] * src[15] + src[5] * src[3] * src[14]\n                 + src[13] * src[2] * src[7] - src[13] * src[3] * src[6];\n\n        dst[3] = -src[1] * src[6] * src[11] + src[1] * src[7] * src[10]\n                 + src[5] * src[2] * src[11] - src[5] * src[3] * src[10]\n                 - src[9] * src[2] * src[7] + src[9] * src[3] * src[6];\n\n        dst[4] = -src[4] * src[10] * src[15] + src[4] * src[11] * src[14]\n                 + src[8] * src[6] * src[15] - src[8] * src[7] * src[14]\n                 - src[12] * src[6] * src[11] + src[12] * src[7] * src[10];\n\n        dst[5] = +src[0] * src[10] * src[15] - src[0] * src[11] * src[14]\n                 - src[8] * src[2] * src[15] + src[8] * src[3] * src[14]\n                 + src[12] * src[2] * src[11] - src[12] * src[3] * src[10];\n\n        dst[6] = -src[0] * src[6] * src[15] + src[0] * src[7] * src[14]\n                 + src[4] * src[2] * src[15] - src[4] * src[3] * src[14]\n                 - src[12] * src[2] * src[7] + src[12] * src[3] * src[6];\n\n        dst[7] = +src[0] * src[6] * src[11] - src[0] * src[7] * src[10]\n                 - src[4] * src[2] * src[11] + src[4] * src[3] * src[10]\n                 + src[8] * src[2] * src[7] - src[8] * src[3] * src[6];\n\n        dst[8] = +src[4] * src[9] * src[15] - src[4] * src[11] * src[13]\n                 - src[8] * src[5] * src[15] + src[8] * src[7] * src[13]\n                 + src[12] * src[5] * src[11] - src[12] * src[7] * src[9];\n\n        dst[9] = -src[0] * src[9] * src[15] + src[0] * src[11] * src[13]\n                 + src[8] * src[1] * src[15] - src[8] * src[3] * src[13]\n                 - src[12] * src[1] * src[11] + src[12] * src[3] * src[9];\n\n        dst[10] = +src[0] * src[5] * src[15] - src[0] * src[7] * src[13]\n                  - src[4] * src[1] * src[15] + src[4] * src[3] * src[13]\n                  + src[12] * src[1] * src[7] - src[12] * src[3] * src[5];\n\n        dst[11] = -src[0] * src[5] * src[11] + src[0] * src[7] * src[9]\n                  + src[4] * src[1] * src[11] - src[4] * src[3] * src[9]\n                  - src[8] * src[1] * src[7] + src[8] * src[3] * src[5];\n\n        dst[12] = -src[4] * src[9] * src[14] + src[4] * src[10] * src[13]\n                  + src[8] * src[5] * src[14] - src[8] * src[6] * src[13]\n                  - src[12] * src[5] * src[10] + src[12] * src[6] * src[9];\n\n        dst[13] = +src[0] * src[9] * src[14] - src[0] * src[10] * src[13]\n                  - src[8] * src[1] * src[14] + src[8] * src[2] * src[13]\n                  + src[12] * src[1] * src[10] - src[12] * src[2] * src[9];\n\n        dst[14] = -src[0] * src[5] * src[14] + src[0] * src[6] * src[13]\n                  + src[4] * src[1] * src[14] - src[4] * src[2] * src[13]\n                  - src[12] * src[1] * src[6] + src[12] * src[2] * src[5];\n\n        dst[15] = +src[0] * src[5] * src[10] - src[0] * src[6] * src[9]\n                  - src[4] * src[1] * src[10] + src[4] * src[2] * src[9]\n                  + src[8] * src[1] * src[6] - src[8] * src[2] * src[5];\n\n        /* Compute determinant: */\n\n        det = +src[0] * dst[0] + src[1] * dst[4] + src[2] * dst[8] + src[3] * dst[12];\n\n        /* Multiply adjoint with reciprocal of determinant: */\n\n        det = 1.0f / det;\n\n        dst[0] *= det;\n        dst[1] *= det;\n        dst[2] *= det;\n        dst[3] *= det;\n        dst[4] *= det;\n        dst[5] *= det;\n        dst[6] *= det;\n        dst[7] *= det;\n        dst[8] *= det;\n        dst[9] *= det;\n        dst[10] *= det;\n        dst[11] *= det;\n        dst[12] *= det;\n        dst[13] *= det;\n        dst[14] *= det;\n        dst[15] *= det;\n    }\n};\n}  // namespace muda::eigen::inverse\n</code></pre>"},{"location":"muda/gauss__elimination_8h/","title":"File gauss_elimination.h","text":"<p>FileList &gt; eigen &gt; inverse &gt; gauss_elimination.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> </ul>"},{"location":"muda/gauss__elimination_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace eigen"},{"location":"muda/gauss__elimination_8h/#classes","title":"Classes","text":"Type Name struct GaussEliminationInverse <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/inverse/gauss_elimination.h</code></p>"},{"location":"muda/gauss__elimination_8h_source/","title":"File gauss_elimination.h","text":"<p>File List &gt; eigen &gt; inverse &gt; gauss_elimination.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::eigen\n{\nstruct GaussEliminationInverse\n{\n    template &lt;typename T, int N&gt;\n    MUDA_INLINE MUDA_GENERIC Eigen::Matrix&lt;T, N, N&gt; operator()(const Eigen::Matrix&lt;T, N, N&gt;&amp; input)\n    {\n        Eigen::Matrix&lt;T, N, N&gt; result;\n\n        constexpr auto eps = std::numeric_limits&lt;T&gt;::epsilon();\n        constexpr int  dim = N;\n        T              mat[dim][dim * 2];\n        for(int i = 0; i &lt; dim; i++)\n        {\n            for(int j = 0; j &lt; 2 * dim; j++)\n            {\n                if(j &lt; dim)\n                {\n                    mat[i][j] = input(i, j);  //[i, j];\n                }\n                else\n                {\n                    mat[i][j] = j - dim == i ? 1 : 0;\n                }\n            }\n        }\n\n        for(int i = 0; i &lt; dim; i++)\n        {\n            if(abs(mat[i][i]) &lt; eps)\n            {\n                int j;\n                for(j = i + 1; j &lt; dim; j++)\n                {\n                    if(abs(mat[j][i]) &gt; eps)\n                        break;\n                }\n                if(j == dim)\n                    return result;\n                for(int r = i; r &lt; 2 * dim; r++)\n                {\n                    mat[i][r] += mat[j][r];\n                }\n            }\n            T ep = mat[i][i];\n            for(int r = i; r &lt; 2 * dim; r++)\n            {\n                mat[i][r] /= ep;\n            }\n\n            for(int j = i + 1; j &lt; dim; j++)\n            {\n                T e = -1 * (mat[j][i] / mat[i][i]);\n                for(int r = i; r &lt; 2 * dim; r++)\n                {\n                    mat[j][r] += e * mat[i][r];\n                }\n            }\n        }\n\n        for(int i = dim - 1; i &gt;= 0; i--)\n        {\n            for(int j = i - 1; j &gt;= 0; j--)\n            {\n                T e = -1 * (mat[j][i] / mat[i][i]);\n                for(int r = i; r &lt; 2 * dim; r++)\n                {\n                    mat[j][r] += e * mat[i][r];\n                }\n            }\n        }\n\n\n        for(int i = 0; i &lt; dim; i++)\n        {\n            for(int r = dim; r &lt; 2 * dim; r++)\n            {\n                result(i, r - dim) = mat[i][r];\n            }\n        }\n\n        return result;\n    }\n};\n}  // namespace muda::eigen\n</code></pre>"},{"location":"muda/dir_5674bb1d8d1f74c09df62e988fd37b50/","title":"Dir src/muda/ext/eigen/svd","text":"<p>FileList &gt; eigen &gt; svd</p>"},{"location":"muda/dir_5674bb1d8d1f74c09df62e988fd37b50/#files","title":"Files","text":"Type Name file svd_impl.h <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/svd/</code></p>"},{"location":"muda/svd__impl_8h/","title":"File svd_impl.h","text":"<p>FileList &gt; eigen &gt; svd &gt; svd_impl.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> </ul>"},{"location":"muda/svd__impl_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace eigen"},{"location":"muda/svd__impl_8h/#public-types","title":"Public Types","text":"Type Name union un"},{"location":"muda/svd__impl_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"muda/svd__impl_8h/#union-un","title":"union un","text":"<p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/svd/svd_impl.h</code></p>"},{"location":"muda/svd__impl_8h_source/","title":"File svd_impl.h","text":"<p>File List &gt; eigen &gt; svd &gt; svd_impl.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n\nnamespace muda::details::eigen\n{\n\nunion un\n{\n    float        f;\n    unsigned int ui;\n};\n\n__device__ __forceinline__ void svd3x3(float  a11,\n                                       float  a12,\n                                       float  a13,\n                                       float  a21,\n                                       float  a22,\n                                       float  a23,\n                                       float  a31,\n                                       float  a32,\n                                       float  a33,  // input A\n                                       float&amp; u11,\n                                       float&amp; u12,\n                                       float&amp; u13,\n                                       float&amp; u21,\n                                       float&amp; u22,\n                                       float&amp; u23,\n                                       float&amp; u31,\n                                       float&amp; u32,\n                                       float&amp; u33,  // output U\n                                       float&amp; s11,\n                                       //float &amp;s12, float &amp;s13, float &amp;s21,\n                                       float&amp; s22,\n                                       //float &amp;s23, float &amp;s31, float &amp;s32,\n                                       float&amp; s33,  // output S\n                                       float&amp; v11,\n                                       float&amp; v12,\n                                       float&amp; v13,\n                                       float&amp; v21,\n                                       float&amp; v22,\n                                       float&amp; v23,\n                                       float&amp; v31,\n                                       float&amp; v32,\n                                       float&amp; v33  // output V\n)\n{\n    constexpr auto  gone                  = 1065353216;\n    constexpr auto  gsine_pi_over_eight   = 1053028117;\n    constexpr auto  gcosine_pi_over_eight = 1064076127;\n    constexpr float gone_half             = 0.5;\n    constexpr float gsmall_number         = 1.e-12;\n    constexpr float gtiny_number          = 1.e-20;\n    constexpr float gfour_gamma_squared   = 5.8284273147583007813;\n\n    un Sa11, Sa21, Sa31, Sa12, Sa22, Sa32, Sa13, Sa23, Sa33;\n    un Su11, Su21, Su31, Su12, Su22, Su32, Su13, Su23, Su33;\n    un Sv11, Sv21, Sv31, Sv12, Sv22, Sv32, Sv13, Sv23, Sv33;\n    un Sc, Ss, Sch, Ssh;\n    un Stmp1, Stmp2, Stmp3, Stmp4, Stmp5;\n    un Ss11, Ss21, Ss31, Ss22, Ss32, Ss33;\n    un Sqvs, Sqvvx, Sqvvy, Sqvvz;\n\n    Sa11.f = a11;\n    Sa12.f = a12;\n    Sa13.f = a13;\n    Sa21.f = a21;\n    Sa22.f = a22;\n    Sa23.f = a23;\n    Sa31.f = a31;\n    Sa32.f = a32;\n    Sa33.f = a33;\n\n    //###########################################################\n    // Compute normal equations matrix\n    //###########################################################\n\n    Ss11.f  = Sa11.f * Sa11.f;\n    Stmp1.f = Sa21.f * Sa21.f;\n    Ss11.f  = __fadd_rn(Stmp1.f, Ss11.f);\n    Stmp1.f = Sa31.f * Sa31.f;\n    Ss11.f  = __fadd_rn(Stmp1.f, Ss11.f);\n\n    Ss21.f  = Sa12.f * Sa11.f;\n    Stmp1.f = Sa22.f * Sa21.f;\n    Ss21.f  = __fadd_rn(Stmp1.f, Ss21.f);\n    Stmp1.f = Sa32.f * Sa31.f;\n    Ss21.f  = __fadd_rn(Stmp1.f, Ss21.f);\n\n    Ss31.f  = Sa13.f * Sa11.f;\n    Stmp1.f = Sa23.f * Sa21.f;\n    Ss31.f  = __fadd_rn(Stmp1.f, Ss31.f);\n    Stmp1.f = Sa33.f * Sa31.f;\n    Ss31.f  = __fadd_rn(Stmp1.f, Ss31.f);\n\n    Ss22.f  = Sa12.f * Sa12.f;\n    Stmp1.f = Sa22.f * Sa22.f;\n    Ss22.f  = __fadd_rn(Stmp1.f, Ss22.f);\n    Stmp1.f = Sa32.f * Sa32.f;\n    Ss22.f  = __fadd_rn(Stmp1.f, Ss22.f);\n\n    Ss32.f  = Sa13.f * Sa12.f;\n    Stmp1.f = Sa23.f * Sa22.f;\n    Ss32.f  = __fadd_rn(Stmp1.f, Ss32.f);\n    Stmp1.f = Sa33.f * Sa32.f;\n    Ss32.f  = __fadd_rn(Stmp1.f, Ss32.f);\n\n    Ss33.f  = Sa13.f * Sa13.f;\n    Stmp1.f = Sa23.f * Sa23.f;\n    Ss33.f  = __fadd_rn(Stmp1.f, Ss33.f);\n    Stmp1.f = Sa33.f * Sa33.f;\n    Ss33.f  = __fadd_rn(Stmp1.f, Ss33.f);\n\n    Sqvs.f  = 1.f;\n    Sqvvx.f = 0.f;\n    Sqvvy.f = 0.f;\n    Sqvvz.f = 0.f;\n\n    //###########################################################\n    // Solve symmetric eigenproblem using Jacobi iteration\n    //###########################################################\n    for(int i = 0; i &lt; 4; i++)\n    {\n        Ssh.f   = Ss21.f * 0.5f;\n        Stmp5.f = __fsub_rn(Ss11.f, Ss22.f);\n\n        Stmp2.f  = Ssh.f * Ssh.f;\n        Stmp1.ui = (Stmp2.f &gt;= gtiny_number) ? 0xffffffff : 0;\n        Ssh.ui   = Stmp1.ui &amp; Ssh.ui;\n        Sch.ui   = Stmp1.ui &amp; Stmp5.ui;\n        Stmp2.ui = ~Stmp1.ui &amp; gone;\n        Sch.ui   = Sch.ui | Stmp2.ui;\n\n        Stmp1.f = Ssh.f * Ssh.f;\n        Stmp2.f = Sch.f * Sch.f;\n        Stmp3.f = __fadd_rn(Stmp1.f, Stmp2.f);\n        Stmp4.f = __frsqrt_rn(Stmp3.f);\n\n        Ssh.f    = Stmp4.f * Ssh.f;\n        Sch.f    = Stmp4.f * Sch.f;\n        Stmp1.f  = gfour_gamma_squared * Stmp1.f;\n        Stmp1.ui = (Stmp2.f &lt;= Stmp1.f) ? 0xffffffff : 0;\n\n        Stmp2.ui = gsine_pi_over_eight &amp; Stmp1.ui;\n        Ssh.ui   = ~Stmp1.ui &amp; Ssh.ui;\n        Ssh.ui   = Ssh.ui | Stmp2.ui;\n        Stmp2.ui = gcosine_pi_over_eight &amp; Stmp1.ui;\n        Sch.ui   = ~Stmp1.ui &amp; Sch.ui;\n        Sch.ui   = Sch.ui | Stmp2.ui;\n\n        Stmp1.f = Ssh.f * Ssh.f;\n        Stmp2.f = Sch.f * Sch.f;\n        Sc.f    = __fsub_rn(Stmp2.f, Stmp1.f);\n        Ss.f    = Sch.f * Ssh.f;\n        Ss.f    = __fadd_rn(Ss.f, Ss.f);\n\n#ifdef DEBUG_JACOBI_CONJUGATE\n        printf(\"GPU s %.20g, c %.20g, sh %.20g, ch %.20g\\n\", Ss.f, Sc.f, Ssh.f, Sch.f);\n#endif\n        //###########################################################\n        // Perform the actual Givens conjugation\n        //###########################################################\n\n        Stmp3.f = __fadd_rn(Stmp1.f, Stmp2.f);\n        Ss33.f  = Ss33.f * Stmp3.f;\n        Ss31.f  = Ss31.f * Stmp3.f;\n        Ss32.f  = Ss32.f * Stmp3.f;\n        Ss33.f  = Ss33.f * Stmp3.f;\n\n        Stmp1.f = Ss.f * Ss31.f;\n        Stmp2.f = Ss.f * Ss32.f;\n        Ss31.f  = Sc.f * Ss31.f;\n        Ss32.f  = Sc.f * Ss32.f;\n        Ss31.f  = __fadd_rn(Stmp2.f, Ss31.f);\n        Ss32.f  = __fsub_rn(Ss32.f, Stmp1.f);\n\n        Stmp2.f = Ss.f * Ss.f;\n        Stmp1.f = Ss22.f * Stmp2.f;\n        Stmp3.f = Ss11.f * Stmp2.f;\n        Stmp4.f = Sc.f * Sc.f;\n        Ss11.f  = Ss11.f * Stmp4.f;\n        Ss22.f  = Ss22.f * Stmp4.f;\n        Ss11.f  = __fadd_rn(Ss11.f, Stmp1.f);\n        Ss22.f  = __fadd_rn(Ss22.f, Stmp3.f);\n        Stmp4.f = __fsub_rn(Stmp4.f, Stmp2.f);\n        Stmp2.f = __fadd_rn(Ss21.f, Ss21.f);\n        Ss21.f  = Ss21.f * Stmp4.f;\n        Stmp4.f = Sc.f * Ss.f;\n        Stmp2.f = Stmp2.f * Stmp4.f;\n        Stmp5.f = Stmp5.f * Stmp4.f;\n        Ss11.f  = __fadd_rn(Ss11.f, Stmp2.f);\n        Ss21.f  = __fsub_rn(Ss21.f, Stmp5.f);\n        Ss22.f  = __fsub_rn(Ss22.f, Stmp2.f);\n\n#ifdef DEBUG_JACOBI_CONJUGATE\n        printf(\"%.20g\\n\", Ss11.f);\n        printf(\"%.20g %.20g\\n\", Ss21.f, Ss22.f);\n        printf(\"%.20g %.20g %.20g\\n\", Ss31.f, Ss32.f, Ss33.f);\n#endif\n\n        //###########################################################\n        // Compute the cumulative rotation, in quaternion form\n        //###########################################################\n\n        Stmp1.f = Ssh.f * Sqvvx.f;\n        Stmp2.f = Ssh.f * Sqvvy.f;\n        Stmp3.f = Ssh.f * Sqvvz.f;\n        Ssh.f   = Ssh.f * Sqvs.f;\n\n        Sqvs.f  = Sch.f * Sqvs.f;\n        Sqvvx.f = Sch.f * Sqvvx.f;\n        Sqvvy.f = Sch.f * Sqvvy.f;\n        Sqvvz.f = Sch.f * Sqvvz.f;\n\n        Sqvvz.f = __fadd_rn(Sqvvz.f, Ssh.f);\n        Sqvs.f  = __fsub_rn(Sqvs.f, Stmp3.f);\n        Sqvvx.f = __fadd_rn(Sqvvx.f, Stmp2.f);\n        Sqvvy.f = __fsub_rn(Sqvvy.f, Stmp1.f);\n\n#ifdef DEBUG_JACOBI_CONJUGATE\n        printf(\"GPU q %.20g %.20g %.20g %.20g\\n\", Sqvvx.f, Sqvvy.f, Sqvvz.f, Sqvs.f);\n#endif\n\n        // (1-&gt;3)\n        Ssh.f   = Ss32.f * 0.5f;\n        Stmp5.f = __fsub_rn(Ss22.f, Ss33.f);\n\n        Stmp2.f  = Ssh.f * Ssh.f;\n        Stmp1.ui = (Stmp2.f &gt;= gtiny_number) ? 0xffffffff : 0;\n        Ssh.ui   = Stmp1.ui &amp; Ssh.ui;\n        Sch.ui   = Stmp1.ui &amp; Stmp5.ui;\n        Stmp2.ui = ~Stmp1.ui &amp; gone;\n        Sch.ui   = Sch.ui | Stmp2.ui;\n\n        Stmp1.f = Ssh.f * Ssh.f;\n        Stmp2.f = Sch.f * Sch.f;\n        Stmp3.f = __fadd_rn(Stmp1.f, Stmp2.f);\n        Stmp4.f = __frsqrt_rn(Stmp3.f);\n\n        Ssh.f    = Stmp4.f * Ssh.f;\n        Sch.f    = Stmp4.f * Sch.f;\n        Stmp1.f  = gfour_gamma_squared * Stmp1.f;\n        Stmp1.ui = (Stmp2.f &lt;= Stmp1.f) ? 0xffffffff : 0;\n\n        Stmp2.ui = gsine_pi_over_eight &amp; Stmp1.ui;\n        Ssh.ui   = ~Stmp1.ui &amp; Ssh.ui;\n        Ssh.ui   = Ssh.ui | Stmp2.ui;\n        Stmp2.ui = gcosine_pi_over_eight &amp; Stmp1.ui;\n        Sch.ui   = ~Stmp1.ui &amp; Sch.ui;\n        Sch.ui   = Sch.ui | Stmp2.ui;\n\n        Stmp1.f = Ssh.f * Ssh.f;\n        Stmp2.f = Sch.f * Sch.f;\n        Sc.f    = __fsub_rn(Stmp2.f, Stmp1.f);\n        Ss.f    = Sch.f * Ssh.f;\n        Ss.f    = __fadd_rn(Ss.f, Ss.f);\n\n#ifdef DEBUG_JACOBI_CONJUGATE\n        printf(\"GPU s %.20g, c %.20g, sh %.20g, ch %.20g\\n\", Ss.f, Sc.f, Ssh.f, Sch.f);\n#endif\n\n        //###########################################################\n        // Perform the actual Givens conjugation\n        //###########################################################\n\n        Stmp3.f = __fadd_rn(Stmp1.f, Stmp2.f);\n        Ss11.f  = Ss11.f * Stmp3.f;\n        Ss21.f  = Ss21.f * Stmp3.f;\n        Ss31.f  = Ss31.f * Stmp3.f;\n        Ss11.f  = Ss11.f * Stmp3.f;\n\n        Stmp1.f = Ss.f * Ss21.f;\n        Stmp2.f = Ss.f * Ss31.f;\n        Ss21.f  = Sc.f * Ss21.f;\n        Ss31.f  = Sc.f * Ss31.f;\n        Ss21.f  = __fadd_rn(Stmp2.f, Ss21.f);\n        Ss31.f  = __fsub_rn(Ss31.f, Stmp1.f);\n\n        Stmp2.f = Ss.f * Ss.f;\n        Stmp1.f = Ss33.f * Stmp2.f;\n        Stmp3.f = Ss22.f * Stmp2.f;\n        Stmp4.f = Sc.f * Sc.f;\n        Ss22.f  = Ss22.f * Stmp4.f;\n        Ss33.f  = Ss33.f * Stmp4.f;\n        Ss22.f  = __fadd_rn(Ss22.f, Stmp1.f);\n        Ss33.f  = __fadd_rn(Ss33.f, Stmp3.f);\n        Stmp4.f = __fsub_rn(Stmp4.f, Stmp2.f);\n        Stmp2.f = __fadd_rn(Ss32.f, Ss32.f);\n        Ss32.f  = Ss32.f * Stmp4.f;\n        Stmp4.f = Sc.f * Ss.f;\n        Stmp2.f = Stmp2.f * Stmp4.f;\n        Stmp5.f = Stmp5.f * Stmp4.f;\n        Ss22.f  = __fadd_rn(Ss22.f, Stmp2.f);\n        Ss32.f  = __fsub_rn(Ss32.f, Stmp5.f);\n        Ss33.f  = __fsub_rn(Ss33.f, Stmp2.f);\n\n#ifdef DEBUG_JACOBI_CONJUGATE\n        printf(\"%.20g\\n\", Ss11.f);\n        printf(\"%.20g %.20g\\n\", Ss21.f, Ss22.f);\n        printf(\"%.20g %.20g %.20g\\n\", Ss31.f, Ss32.f, Ss33.f);\n#endif\n\n        //###########################################################\n        // Compute the cumulative rotation, in quaternion form\n        //###########################################################\n\n        Stmp1.f = Ssh.f * Sqvvx.f;\n        Stmp2.f = Ssh.f * Sqvvy.f;\n        Stmp3.f = Ssh.f * Sqvvz.f;\n        Ssh.f   = Ssh.f * Sqvs.f;\n\n        Sqvs.f  = Sch.f * Sqvs.f;\n        Sqvvx.f = Sch.f * Sqvvx.f;\n        Sqvvy.f = Sch.f * Sqvvy.f;\n        Sqvvz.f = Sch.f * Sqvvz.f;\n\n        Sqvvx.f = __fadd_rn(Sqvvx.f, Ssh.f);\n        Sqvs.f  = __fsub_rn(Sqvs.f, Stmp1.f);\n        Sqvvy.f = __fadd_rn(Sqvvy.f, Stmp3.f);\n        Sqvvz.f = __fsub_rn(Sqvvz.f, Stmp2.f);\n\n#ifdef DEBUG_JACOBI_CONJUGATE\n        printf(\"GPU q %.20g %.20g %.20g %.20g\\n\", Sqvvx.f, Sqvvy.f, Sqvvz.f, Sqvs.f);\n#endif\n#if 1\n        // 1 -&gt; 2\n\n        Ssh.f   = Ss31.f * 0.5f;\n        Stmp5.f = __fsub_rn(Ss33.f, Ss11.f);\n\n        Stmp2.f  = Ssh.f * Ssh.f;\n        Stmp1.ui = (Stmp2.f &gt;= gtiny_number) ? 0xffffffff : 0;\n        Ssh.ui   = Stmp1.ui &amp; Ssh.ui;\n        Sch.ui   = Stmp1.ui &amp; Stmp5.ui;\n        Stmp2.ui = ~Stmp1.ui &amp; gone;\n        Sch.ui   = Sch.ui | Stmp2.ui;\n\n        Stmp1.f = Ssh.f * Ssh.f;\n        Stmp2.f = Sch.f * Sch.f;\n        Stmp3.f = __fadd_rn(Stmp1.f, Stmp2.f);\n        Stmp4.f = __frsqrt_rn(Stmp3.f);\n\n        Ssh.f    = Stmp4.f * Ssh.f;\n        Sch.f    = Stmp4.f * Sch.f;\n        Stmp1.f  = gfour_gamma_squared * Stmp1.f;\n        Stmp1.ui = (Stmp2.f &lt;= Stmp1.f) ? 0xffffffff : 0;\n\n        Stmp2.ui = gsine_pi_over_eight &amp; Stmp1.ui;\n        Ssh.ui   = ~Stmp1.ui &amp; Ssh.ui;\n        Ssh.ui   = Ssh.ui | Stmp2.ui;\n        Stmp2.ui = gcosine_pi_over_eight &amp; Stmp1.ui;\n        Sch.ui   = ~Stmp1.ui &amp; Sch.ui;\n        Sch.ui   = Sch.ui | Stmp2.ui;\n\n        Stmp1.f = Ssh.f * Ssh.f;\n        Stmp2.f = Sch.f * Sch.f;\n        Sc.f    = __fsub_rn(Stmp2.f, Stmp1.f);\n        Ss.f    = Sch.f * Ssh.f;\n        Ss.f    = __fadd_rn(Ss.f, Ss.f);\n\n#ifdef DEBUG_JACOBI_CONJUGATE\n        printf(\"GPU s %.20g, c %.20g, sh %.20g, ch %.20g\\n\", Ss.f, Sc.f, Ssh.f, Sch.f);\n#endif\n\n        //###########################################################\n        // Perform the actual Givens conjugation\n        //###########################################################\n\n        Stmp3.f = __fadd_rn(Stmp1.f, Stmp2.f);\n        Ss22.f  = Ss22.f * Stmp3.f;\n        Ss32.f  = Ss32.f * Stmp3.f;\n        Ss21.f  = Ss21.f * Stmp3.f;\n        Ss22.f  = Ss22.f * Stmp3.f;\n\n        Stmp1.f = Ss.f * Ss32.f;\n        Stmp2.f = Ss.f * Ss21.f;\n        Ss32.f  = Sc.f * Ss32.f;\n        Ss21.f  = Sc.f * Ss21.f;\n        Ss32.f  = __fadd_rn(Stmp2.f, Ss32.f);\n        Ss21.f  = __fsub_rn(Ss21.f, Stmp1.f);\n\n        Stmp2.f = Ss.f * Ss.f;\n        Stmp1.f = Ss11.f * Stmp2.f;\n        Stmp3.f = Ss33.f * Stmp2.f;\n        Stmp4.f = Sc.f * Sc.f;\n        Ss33.f  = Ss33.f * Stmp4.f;\n        Ss11.f  = Ss11.f * Stmp4.f;\n        Ss33.f  = __fadd_rn(Ss33.f, Stmp1.f);\n        Ss11.f  = __fadd_rn(Ss11.f, Stmp3.f);\n        Stmp4.f = __fsub_rn(Stmp4.f, Stmp2.f);\n        Stmp2.f = __fadd_rn(Ss31.f, Ss31.f);\n        Ss31.f  = Ss31.f * Stmp4.f;\n        Stmp4.f = Sc.f * Ss.f;\n        Stmp2.f = Stmp2.f * Stmp4.f;\n        Stmp5.f = Stmp5.f * Stmp4.f;\n        Ss33.f  = __fadd_rn(Ss33.f, Stmp2.f);\n        Ss31.f  = __fsub_rn(Ss31.f, Stmp5.f);\n        Ss11.f  = __fsub_rn(Ss11.f, Stmp2.f);\n\n#ifdef DEBUG_JACOBI_CONJUGATE\n        printf(\"%.20g\\n\", Ss11.f);\n        printf(\"%.20g %.20g\\n\", Ss21.f, Ss22.f);\n        printf(\"%.20g %.20g %.20g\\n\", Ss31.f, Ss32.f, Ss33.f);\n#endif\n\n        //###########################################################\n        // Compute the cumulative rotation, in quaternion form\n        //###########################################################\n\n        Stmp1.f = Ssh.f * Sqvvx.f;\n        Stmp2.f = Ssh.f * Sqvvy.f;\n        Stmp3.f = Ssh.f * Sqvvz.f;\n        Ssh.f   = Ssh.f * Sqvs.f;\n\n        Sqvs.f  = Sch.f * Sqvs.f;\n        Sqvvx.f = Sch.f * Sqvvx.f;\n        Sqvvy.f = Sch.f * Sqvvy.f;\n        Sqvvz.f = Sch.f * Sqvvz.f;\n\n        Sqvvy.f = __fadd_rn(Sqvvy.f, Ssh.f);\n        Sqvs.f  = __fsub_rn(Sqvs.f, Stmp2.f);\n        Sqvvz.f = __fadd_rn(Sqvvz.f, Stmp1.f);\n        Sqvvx.f = __fsub_rn(Sqvvx.f, Stmp3.f);\n#endif\n    }\n\n    //###########################################################\n    // Normalize quaternion for matrix V\n    //###########################################################\n\n    Stmp2.f = Sqvs.f * Sqvs.f;\n    Stmp1.f = Sqvvx.f * Sqvvx.f;\n    Stmp2.f = __fadd_rn(Stmp1.f, Stmp2.f);\n    Stmp1.f = Sqvvy.f * Sqvvy.f;\n    Stmp2.f = __fadd_rn(Stmp1.f, Stmp2.f);\n    Stmp1.f = Sqvvz.f * Sqvvz.f;\n    Stmp2.f = __fadd_rn(Stmp1.f, Stmp2.f);\n\n    Stmp1.f = __frsqrt_rn(Stmp2.f);\n    Stmp4.f = Stmp1.f * 0.5f;\n    Stmp3.f = Stmp1.f * Stmp4.f;\n    Stmp3.f = Stmp1.f * Stmp3.f;\n    Stmp3.f = Stmp2.f * Stmp3.f;\n    Stmp1.f = __fadd_rn(Stmp1.f, Stmp4.f);\n    Stmp1.f = __fsub_rn(Stmp1.f, Stmp3.f);\n\n    Sqvs.f  = Sqvs.f * Stmp1.f;\n    Sqvvx.f = Sqvvx.f * Stmp1.f;\n    Sqvvy.f = Sqvvy.f * Stmp1.f;\n    Sqvvz.f = Sqvvz.f * Stmp1.f;\n\n    //###########################################################\n    // Transform quaternion to matrix V\n    //###########################################################\n\n    Stmp1.f = Sqvvx.f * Sqvvx.f;\n    Stmp2.f = Sqvvy.f * Sqvvy.f;\n    Stmp3.f = Sqvvz.f * Sqvvz.f;\n    Sv11.f  = Sqvs.f * Sqvs.f;\n    Sv22.f  = __fsub_rn(Sv11.f, Stmp1.f);\n    Sv33.f  = __fsub_rn(Sv22.f, Stmp2.f);\n    Sv33.f  = __fadd_rn(Sv33.f, Stmp3.f);\n    Sv22.f  = __fadd_rn(Sv22.f, Stmp2.f);\n    Sv22.f  = __fsub_rn(Sv22.f, Stmp3.f);\n    Sv11.f  = __fadd_rn(Sv11.f, Stmp1.f);\n    Sv11.f  = __fsub_rn(Sv11.f, Stmp2.f);\n    Sv11.f  = __fsub_rn(Sv11.f, Stmp3.f);\n    Stmp1.f = __fadd_rn(Sqvvx.f, Sqvvx.f);\n    Stmp2.f = __fadd_rn(Sqvvy.f, Sqvvy.f);\n    Stmp3.f = __fadd_rn(Sqvvz.f, Sqvvz.f);\n    Sv32.f  = Sqvs.f * Stmp1.f;\n    Sv13.f  = Sqvs.f * Stmp2.f;\n    Sv21.f  = Sqvs.f * Stmp3.f;\n    Stmp1.f = Sqvvy.f * Stmp1.f;\n    Stmp2.f = Sqvvz.f * Stmp2.f;\n    Stmp3.f = Sqvvx.f * Stmp3.f;\n    Sv12.f  = __fsub_rn(Stmp1.f, Sv21.f);\n    Sv23.f  = __fsub_rn(Stmp2.f, Sv32.f);\n    Sv31.f  = __fsub_rn(Stmp3.f, Sv13.f);\n    Sv21.f  = __fadd_rn(Stmp1.f, Sv21.f);\n    Sv32.f  = __fadd_rn(Stmp2.f, Sv32.f);\n    Sv13.f  = __fadd_rn(Stmp3.f, Sv13.f);\n\n    // Multiply (from the right) with V\n    //###########################################################\n\n    Stmp2.f = Sa12.f;\n    Stmp3.f = Sa13.f;\n    Sa12.f  = Sv12.f * Sa11.f;\n    Sa13.f  = Sv13.f * Sa11.f;\n    Sa11.f  = Sv11.f * Sa11.f;\n    Stmp1.f = Sv21.f * Stmp2.f;\n    Sa11.f  = __fadd_rn(Sa11.f, Stmp1.f);\n    Stmp1.f = Sv31.f * Stmp3.f;\n    Sa11.f  = __fadd_rn(Sa11.f, Stmp1.f);\n    Stmp1.f = Sv22.f * Stmp2.f;\n    Sa12.f  = __fadd_rn(Sa12.f, Stmp1.f);\n    Stmp1.f = Sv32.f * Stmp3.f;\n    Sa12.f  = __fadd_rn(Sa12.f, Stmp1.f);\n    Stmp1.f = Sv23.f * Stmp2.f;\n    Sa13.f  = __fadd_rn(Sa13.f, Stmp1.f);\n    Stmp1.f = Sv33.f * Stmp3.f;\n    Sa13.f  = __fadd_rn(Sa13.f, Stmp1.f);\n\n    Stmp2.f = Sa22.f;\n    Stmp3.f = Sa23.f;\n    Sa22.f  = Sv12.f * Sa21.f;\n    Sa23.f  = Sv13.f * Sa21.f;\n    Sa21.f  = Sv11.f * Sa21.f;\n    Stmp1.f = Sv21.f * Stmp2.f;\n    Sa21.f  = __fadd_rn(Sa21.f, Stmp1.f);\n    Stmp1.f = Sv31.f * Stmp3.f;\n    Sa21.f  = __fadd_rn(Sa21.f, Stmp1.f);\n    Stmp1.f = Sv22.f * Stmp2.f;\n    Sa22.f  = __fadd_rn(Sa22.f, Stmp1.f);\n    Stmp1.f = Sv32.f * Stmp3.f;\n    Sa22.f  = __fadd_rn(Sa22.f, Stmp1.f);\n    Stmp1.f = Sv23.f * Stmp2.f;\n    Sa23.f  = __fadd_rn(Sa23.f, Stmp1.f);\n    Stmp1.f = Sv33.f * Stmp3.f;\n    Sa23.f  = __fadd_rn(Sa23.f, Stmp1.f);\n\n    Stmp2.f = Sa32.f;\n    Stmp3.f = Sa33.f;\n    Sa32.f  = Sv12.f * Sa31.f;\n    Sa33.f  = Sv13.f * Sa31.f;\n    Sa31.f  = Sv11.f * Sa31.f;\n    Stmp1.f = Sv21.f * Stmp2.f;\n    Sa31.f  = __fadd_rn(Sa31.f, Stmp1.f);\n    Stmp1.f = Sv31.f * Stmp3.f;\n    Sa31.f  = __fadd_rn(Sa31.f, Stmp1.f);\n    Stmp1.f = Sv22.f * Stmp2.f;\n    Sa32.f  = __fadd_rn(Sa32.f, Stmp1.f);\n    Stmp1.f = Sv32.f * Stmp3.f;\n    Sa32.f  = __fadd_rn(Sa32.f, Stmp1.f);\n    Stmp1.f = Sv23.f * Stmp2.f;\n    Sa33.f  = __fadd_rn(Sa33.f, Stmp1.f);\n    Stmp1.f = Sv33.f * Stmp3.f;\n    Sa33.f  = __fadd_rn(Sa33.f, Stmp1.f);\n\n    //###########################################################\n    // Permute columns such that the singular values are sorted\n    //###########################################################\n\n    Stmp1.f = Sa11.f * Sa11.f;\n    Stmp4.f = Sa21.f * Sa21.f;\n    Stmp1.f = __fadd_rn(Stmp1.f, Stmp4.f);\n    Stmp4.f = Sa31.f * Sa31.f;\n    Stmp1.f = __fadd_rn(Stmp1.f, Stmp4.f);\n\n    Stmp2.f = Sa12.f * Sa12.f;\n    Stmp4.f = Sa22.f * Sa22.f;\n    Stmp2.f = __fadd_rn(Stmp2.f, Stmp4.f);\n    Stmp4.f = Sa32.f * Sa32.f;\n    Stmp2.f = __fadd_rn(Stmp2.f, Stmp4.f);\n\n    Stmp3.f = Sa13.f * Sa13.f;\n    Stmp4.f = Sa23.f * Sa23.f;\n    Stmp3.f = __fadd_rn(Stmp3.f, Stmp4.f);\n    Stmp4.f = Sa33.f * Sa33.f;\n    Stmp3.f = __fadd_rn(Stmp3.f, Stmp4.f);\n\n    // Swap columns 1-2 if necessary\n\n    Stmp4.ui = (Stmp1.f &lt; Stmp2.f) ? 0xffffffff : 0;\n    Stmp5.ui = Sa11.ui ^ Sa12.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sa11.ui  = Sa11.ui ^ Stmp5.ui;\n    Sa12.ui  = Sa12.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sa21.ui ^ Sa22.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sa21.ui  = Sa21.ui ^ Stmp5.ui;\n    Sa22.ui  = Sa22.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sa31.ui ^ Sa32.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sa31.ui  = Sa31.ui ^ Stmp5.ui;\n    Sa32.ui  = Sa32.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sv11.ui ^ Sv12.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sv11.ui  = Sv11.ui ^ Stmp5.ui;\n    Sv12.ui  = Sv12.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sv21.ui ^ Sv22.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sv21.ui  = Sv21.ui ^ Stmp5.ui;\n    Sv22.ui  = Sv22.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sv31.ui ^ Sv32.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sv31.ui  = Sv31.ui ^ Stmp5.ui;\n    Sv32.ui  = Sv32.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Stmp1.ui ^ Stmp2.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Stmp1.ui = Stmp1.ui ^ Stmp5.ui;\n    Stmp2.ui = Stmp2.ui ^ Stmp5.ui;\n\n    // If columns 1-2 have been swapped, negate 2nd column of A and V so that V is still a rotation\n\n    Stmp5.f  = -2.f;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Stmp4.f  = 1.f;\n    Stmp4.f  = __fadd_rn(Stmp4.f, Stmp5.f);\n\n    Sa12.f = Sa12.f * Stmp4.f;\n    Sa22.f = Sa22.f * Stmp4.f;\n    Sa32.f = Sa32.f * Stmp4.f;\n\n    Sv12.f = Sv12.f * Stmp4.f;\n    Sv22.f = Sv22.f * Stmp4.f;\n    Sv32.f = Sv32.f * Stmp4.f;\n\n    // Swap columns 1-3 if necessary\n\n    Stmp4.ui = (Stmp1.f &lt; Stmp3.f) ? 0xffffffff : 0;\n    Stmp5.ui = Sa11.ui ^ Sa13.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sa11.ui  = Sa11.ui ^ Stmp5.ui;\n    Sa13.ui  = Sa13.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sa21.ui ^ Sa23.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sa21.ui  = Sa21.ui ^ Stmp5.ui;\n    Sa23.ui  = Sa23.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sa31.ui ^ Sa33.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sa31.ui  = Sa31.ui ^ Stmp5.ui;\n    Sa33.ui  = Sa33.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sv11.ui ^ Sv13.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sv11.ui  = Sv11.ui ^ Stmp5.ui;\n    Sv13.ui  = Sv13.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sv21.ui ^ Sv23.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sv21.ui  = Sv21.ui ^ Stmp5.ui;\n    Sv23.ui  = Sv23.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sv31.ui ^ Sv33.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sv31.ui  = Sv31.ui ^ Stmp5.ui;\n    Sv33.ui  = Sv33.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Stmp1.ui ^ Stmp3.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Stmp1.ui = Stmp1.ui ^ Stmp5.ui;\n    Stmp3.ui = Stmp3.ui ^ Stmp5.ui;\n\n    // If columns 1-3 have been swapped, negate 1st column of A and V so that V is still a rotation\n\n    Stmp5.f  = -2.f;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Stmp4.f  = 1.f;\n    Stmp4.f  = __fadd_rn(Stmp4.f, Stmp5.f);\n\n    Sa11.f = Sa11.f * Stmp4.f;\n    Sa21.f = Sa21.f * Stmp4.f;\n    Sa31.f = Sa31.f * Stmp4.f;\n\n    Sv11.f = Sv11.f * Stmp4.f;\n    Sv21.f = Sv21.f * Stmp4.f;\n    Sv31.f = Sv31.f * Stmp4.f;\n\n    // Swap columns 2-3 if necessary\n\n    Stmp4.ui = (Stmp2.f &lt; Stmp3.f) ? 0xffffffff : 0;\n    Stmp5.ui = Sa12.ui ^ Sa13.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sa12.ui  = Sa12.ui ^ Stmp5.ui;\n    Sa13.ui  = Sa13.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sa22.ui ^ Sa23.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sa22.ui  = Sa22.ui ^ Stmp5.ui;\n    Sa23.ui  = Sa23.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sa32.ui ^ Sa33.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sa32.ui  = Sa32.ui ^ Stmp5.ui;\n    Sa33.ui  = Sa33.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sv12.ui ^ Sv13.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sv12.ui  = Sv12.ui ^ Stmp5.ui;\n    Sv13.ui  = Sv13.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sv22.ui ^ Sv23.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sv22.ui  = Sv22.ui ^ Stmp5.ui;\n    Sv23.ui  = Sv23.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Sv32.ui ^ Sv33.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Sv32.ui  = Sv32.ui ^ Stmp5.ui;\n    Sv33.ui  = Sv33.ui ^ Stmp5.ui;\n\n    Stmp5.ui = Stmp2.ui ^ Stmp3.ui;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Stmp2.ui = Stmp2.ui ^ Stmp5.ui;\n    Stmp3.ui = Stmp3.ui ^ Stmp5.ui;\n\n    // If columns 2-3 have been swapped, negate 3rd column of A and V so that V is still a rotation\n\n    Stmp5.f  = -2.f;\n    Stmp5.ui = Stmp5.ui &amp; Stmp4.ui;\n    Stmp4.f  = 1.f;\n    Stmp4.f  = __fadd_rn(Stmp4.f, Stmp5.f);\n\n    Sa13.f = Sa13.f * Stmp4.f;\n    Sa23.f = Sa23.f * Stmp4.f;\n    Sa33.f = Sa33.f * Stmp4.f;\n\n    Sv13.f = Sv13.f * Stmp4.f;\n    Sv23.f = Sv23.f * Stmp4.f;\n    Sv33.f = Sv33.f * Stmp4.f;\n\n    //###########################################################\n    // Construct QR factorization of A*V (=U*D) using Givens rotations\n    //###########################################################\n\n    Su11.f = 1.f;\n    Su12.f = 0.f;\n    Su13.f = 0.f;\n    Su21.f = 0.f;\n    Su22.f = 1.f;\n    Su23.f = 0.f;\n    Su31.f = 0.f;\n    Su32.f = 0.f;\n    Su33.f = 1.f;\n\n    Ssh.f  = Sa21.f * Sa21.f;\n    Ssh.ui = (Ssh.f &gt;= gsmall_number) ? 0xffffffff : 0;\n    Ssh.ui = Ssh.ui &amp; Sa21.ui;\n\n    Stmp5.f  = 0.f;\n    Sch.f    = __fsub_rn(Stmp5.f, Sa11.f);\n    Sch.f    = ::max(Sch.f, Sa11.f);\n    Sch.f    = ::max(Sch.f, gsmall_number);\n    Stmp5.ui = (Sa11.f &gt;= Stmp5.f) ? 0xffffffff : 0;\n\n    Stmp1.f = Sch.f * Sch.f;\n    Stmp2.f = Ssh.f * Ssh.f;\n    Stmp2.f = __fadd_rn(Stmp1.f, Stmp2.f);\n    Stmp1.f = __frsqrt_rn(Stmp2.f);\n\n    Stmp4.f = Stmp1.f * 0.5f;\n    Stmp3.f = Stmp1.f * Stmp4.f;\n    Stmp3.f = Stmp1.f * Stmp3.f;\n    Stmp3.f = Stmp2.f * Stmp3.f;\n    Stmp1.f = __fadd_rn(Stmp1.f, Stmp4.f);\n    Stmp1.f = __fsub_rn(Stmp1.f, Stmp3.f);\n    Stmp1.f = Stmp1.f * Stmp2.f;\n\n    Sch.f = __fadd_rn(Sch.f, Stmp1.f);\n\n    Stmp1.ui = ~Stmp5.ui &amp; Ssh.ui;\n    Stmp2.ui = ~Stmp5.ui &amp; Sch.ui;\n    Sch.ui   = Stmp5.ui &amp; Sch.ui;\n    Ssh.ui   = Stmp5.ui &amp; Ssh.ui;\n    Sch.ui   = Sch.ui | Stmp1.ui;\n    Ssh.ui   = Ssh.ui | Stmp2.ui;\n\n    Stmp1.f = Sch.f * Sch.f;\n    Stmp2.f = Ssh.f * Ssh.f;\n    Stmp2.f = __fadd_rn(Stmp1.f, Stmp2.f);\n    Stmp1.f = __frsqrt_rn(Stmp2.f);\n\n    Stmp4.f = Stmp1.f * 0.5f;\n    Stmp3.f = Stmp1.f * Stmp4.f;\n    Stmp3.f = Stmp1.f * Stmp3.f;\n    Stmp3.f = Stmp2.f * Stmp3.f;\n    Stmp1.f = __fadd_rn(Stmp1.f, Stmp4.f);\n    Stmp1.f = __fsub_rn(Stmp1.f, Stmp3.f);\n\n    Sch.f = Sch.f * Stmp1.f;\n    Ssh.f = Ssh.f * Stmp1.f;\n\n    Sc.f = Sch.f * Sch.f;\n    Ss.f = Ssh.f * Ssh.f;\n    Sc.f = __fsub_rn(Sc.f, Ss.f);\n    Ss.f = Ssh.f * Sch.f;\n    Ss.f = __fadd_rn(Ss.f, Ss.f);\n\n    //###########################################################\n    // Rotate matrix A\n    //###########################################################\n\n    Stmp1.f = Ss.f * Sa11.f;\n    Stmp2.f = Ss.f * Sa21.f;\n    Sa11.f  = Sc.f * Sa11.f;\n    Sa21.f  = Sc.f * Sa21.f;\n    Sa11.f  = __fadd_rn(Sa11.f, Stmp2.f);\n    Sa21.f  = __fsub_rn(Sa21.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Sa12.f;\n    Stmp2.f = Ss.f * Sa22.f;\n    Sa12.f  = Sc.f * Sa12.f;\n    Sa22.f  = Sc.f * Sa22.f;\n    Sa12.f  = __fadd_rn(Sa12.f, Stmp2.f);\n    Sa22.f  = __fsub_rn(Sa22.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Sa13.f;\n    Stmp2.f = Ss.f * Sa23.f;\n    Sa13.f  = Sc.f * Sa13.f;\n    Sa23.f  = Sc.f * Sa23.f;\n    Sa13.f  = __fadd_rn(Sa13.f, Stmp2.f);\n    Sa23.f  = __fsub_rn(Sa23.f, Stmp1.f);\n\n    //###########################################################\n    // Update matrix U\n    //###########################################################\n\n    Stmp1.f = Ss.f * Su11.f;\n    Stmp2.f = Ss.f * Su12.f;\n    Su11.f  = Sc.f * Su11.f;\n    Su12.f  = Sc.f * Su12.f;\n    Su11.f  = __fadd_rn(Su11.f, Stmp2.f);\n    Su12.f  = __fsub_rn(Su12.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Su21.f;\n    Stmp2.f = Ss.f * Su22.f;\n    Su21.f  = Sc.f * Su21.f;\n    Su22.f  = Sc.f * Su22.f;\n    Su21.f  = __fadd_rn(Su21.f, Stmp2.f);\n    Su22.f  = __fsub_rn(Su22.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Su31.f;\n    Stmp2.f = Ss.f * Su32.f;\n    Su31.f  = Sc.f * Su31.f;\n    Su32.f  = Sc.f * Su32.f;\n    Su31.f  = __fadd_rn(Su31.f, Stmp2.f);\n    Su32.f  = __fsub_rn(Su32.f, Stmp1.f);\n\n    // Second Givens rotation\n\n    Ssh.f  = Sa31.f * Sa31.f;\n    Ssh.ui = (Ssh.f &gt;= gsmall_number) ? 0xffffffff : 0;\n    Ssh.ui = Ssh.ui &amp; Sa31.ui;\n\n    Stmp5.f  = 0.f;\n    Sch.f    = __fsub_rn(Stmp5.f, Sa11.f);\n    Sch.f    = ::max(Sch.f, Sa11.f);\n    Sch.f    = ::max(Sch.f, gsmall_number);\n    Stmp5.ui = (Sa11.f &gt;= Stmp5.f) ? 0xffffffff : 0;\n\n    Stmp1.f = Sch.f * Sch.f;\n    Stmp2.f = Ssh.f * Ssh.f;\n    Stmp2.f = __fadd_rn(Stmp1.f, Stmp2.f);\n    Stmp1.f = __frsqrt_rn(Stmp2.f);\n\n    Stmp4.f = Stmp1.f * 0.5;\n    Stmp3.f = Stmp1.f * Stmp4.f;\n    Stmp3.f = Stmp1.f * Stmp3.f;\n    Stmp3.f = Stmp2.f * Stmp3.f;\n    Stmp1.f = __fadd_rn(Stmp1.f, Stmp4.f);\n    Stmp1.f = __fsub_rn(Stmp1.f, Stmp3.f);\n    Stmp1.f = Stmp1.f * Stmp2.f;\n\n    Sch.f = __fadd_rn(Sch.f, Stmp1.f);\n\n    Stmp1.ui = ~Stmp5.ui &amp; Ssh.ui;\n    Stmp2.ui = ~Stmp5.ui &amp; Sch.ui;\n    Sch.ui   = Stmp5.ui &amp; Sch.ui;\n    Ssh.ui   = Stmp5.ui &amp; Ssh.ui;\n    Sch.ui   = Sch.ui | Stmp1.ui;\n    Ssh.ui   = Ssh.ui | Stmp2.ui;\n\n    Stmp1.f = Sch.f * Sch.f;\n    Stmp2.f = Ssh.f * Ssh.f;\n    Stmp2.f = __fadd_rn(Stmp1.f, Stmp2.f);\n    Stmp1.f = __frsqrt_rn(Stmp2.f);\n\n    Stmp4.f = Stmp1.f * 0.5f;\n    Stmp3.f = Stmp1.f * Stmp4.f;\n    Stmp3.f = Stmp1.f * Stmp3.f;\n    Stmp3.f = Stmp2.f * Stmp3.f;\n    Stmp1.f = __fadd_rn(Stmp1.f, Stmp4.f);\n    Stmp1.f = __fsub_rn(Stmp1.f, Stmp3.f);\n\n    Sch.f = Sch.f * Stmp1.f;\n    Ssh.f = Ssh.f * Stmp1.f;\n\n    Sc.f = Sch.f * Sch.f;\n    Ss.f = Ssh.f * Ssh.f;\n    Sc.f = __fsub_rn(Sc.f, Ss.f);\n    Ss.f = Ssh.f * Sch.f;\n    Ss.f = __fadd_rn(Ss.f, Ss.f);\n\n    //###########################################################\n    // Rotate matrix A\n    //###########################################################\n\n    Stmp1.f = Ss.f * Sa11.f;\n    Stmp2.f = Ss.f * Sa31.f;\n    Sa11.f  = Sc.f * Sa11.f;\n    Sa31.f  = Sc.f * Sa31.f;\n    Sa11.f  = __fadd_rn(Sa11.f, Stmp2.f);\n    Sa31.f  = __fsub_rn(Sa31.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Sa12.f;\n    Stmp2.f = Ss.f * Sa32.f;\n    Sa12.f  = Sc.f * Sa12.f;\n    Sa32.f  = Sc.f * Sa32.f;\n    Sa12.f  = __fadd_rn(Sa12.f, Stmp2.f);\n    Sa32.f  = __fsub_rn(Sa32.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Sa13.f;\n    Stmp2.f = Ss.f * Sa33.f;\n    Sa13.f  = Sc.f * Sa13.f;\n    Sa33.f  = Sc.f * Sa33.f;\n    Sa13.f  = __fadd_rn(Sa13.f, Stmp2.f);\n    Sa33.f  = __fsub_rn(Sa33.f, Stmp1.f);\n\n    //###########################################################\n    // Update matrix U\n    //###########################################################\n\n    Stmp1.f = Ss.f * Su11.f;\n    Stmp2.f = Ss.f * Su13.f;\n    Su11.f  = Sc.f * Su11.f;\n    Su13.f  = Sc.f * Su13.f;\n    Su11.f  = __fadd_rn(Su11.f, Stmp2.f);\n    Su13.f  = __fsub_rn(Su13.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Su21.f;\n    Stmp2.f = Ss.f * Su23.f;\n    Su21.f  = Sc.f * Su21.f;\n    Su23.f  = Sc.f * Su23.f;\n    Su21.f  = __fadd_rn(Su21.f, Stmp2.f);\n    Su23.f  = __fsub_rn(Su23.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Su31.f;\n    Stmp2.f = Ss.f * Su33.f;\n    Su31.f  = Sc.f * Su31.f;\n    Su33.f  = Sc.f * Su33.f;\n    Su31.f  = __fadd_rn(Su31.f, Stmp2.f);\n    Su33.f  = __fsub_rn(Su33.f, Stmp1.f);\n\n    // Third Givens Rotation\n\n    Ssh.f  = Sa32.f * Sa32.f;\n    Ssh.ui = (Ssh.f &gt;= gsmall_number) ? 0xffffffff : 0;\n    Ssh.ui = Ssh.ui &amp; Sa32.ui;\n\n    Stmp5.f  = 0.f;\n    Sch.f    = __fsub_rn(Stmp5.f, Sa22.f);\n    Sch.f    = ::max(Sch.f, Sa22.f);\n    Sch.f    = ::max(Sch.f, gsmall_number);\n    Stmp5.ui = (Sa22.f &gt;= Stmp5.f) ? 0xffffffff : 0;\n\n    Stmp1.f = Sch.f * Sch.f;\n    Stmp2.f = Ssh.f * Ssh.f;\n    Stmp2.f = __fadd_rn(Stmp1.f, Stmp2.f);\n    Stmp1.f = __frsqrt_rn(Stmp2.f);\n\n    Stmp4.f = Stmp1.f * 0.5f;\n    Stmp3.f = Stmp1.f * Stmp4.f;\n    Stmp3.f = Stmp1.f * Stmp3.f;\n    Stmp3.f = Stmp2.f * Stmp3.f;\n    Stmp1.f = __fadd_rn(Stmp1.f, Stmp4.f);\n    Stmp1.f = __fsub_rn(Stmp1.f, Stmp3.f);\n    Stmp1.f = Stmp1.f * Stmp2.f;\n\n    Sch.f = __fadd_rn(Sch.f, Stmp1.f);\n\n    Stmp1.ui = ~Stmp5.ui &amp; Ssh.ui;\n    Stmp2.ui = ~Stmp5.ui &amp; Sch.ui;\n    Sch.ui   = Stmp5.ui &amp; Sch.ui;\n    Ssh.ui   = Stmp5.ui &amp; Ssh.ui;\n    Sch.ui   = Sch.ui | Stmp1.ui;\n    Ssh.ui   = Ssh.ui | Stmp2.ui;\n\n    Stmp1.f = Sch.f * Sch.f;\n    Stmp2.f = Ssh.f * Ssh.f;\n    Stmp2.f = __fadd_rn(Stmp1.f, Stmp2.f);\n    Stmp1.f = __frsqrt_rn(Stmp2.f);\n\n    Stmp4.f = Stmp1.f * 0.5f;\n    Stmp3.f = Stmp1.f * Stmp4.f;\n    Stmp3.f = Stmp1.f * Stmp3.f;\n    Stmp3.f = Stmp2.f * Stmp3.f;\n    Stmp1.f = __fadd_rn(Stmp1.f, Stmp4.f);\n    Stmp1.f = __fsub_rn(Stmp1.f, Stmp3.f);\n\n    Sch.f = Sch.f * Stmp1.f;\n    Ssh.f = Ssh.f * Stmp1.f;\n\n    Sc.f = Sch.f * Sch.f;\n    Ss.f = Ssh.f * Ssh.f;\n    Sc.f = __fsub_rn(Sc.f, Ss.f);\n    Ss.f = Ssh.f * Sch.f;\n    Ss.f = __fadd_rn(Ss.f, Ss.f);\n\n    //###########################################################\n    // Rotate matrix A\n    //###########################################################\n\n    Stmp1.f = Ss.f * Sa21.f;\n    Stmp2.f = Ss.f * Sa31.f;\n    Sa21.f  = Sc.f * Sa21.f;\n    Sa31.f  = Sc.f * Sa31.f;\n    Sa21.f  = __fadd_rn(Sa21.f, Stmp2.f);\n    Sa31.f  = __fsub_rn(Sa31.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Sa22.f;\n    Stmp2.f = Ss.f * Sa32.f;\n    Sa22.f  = Sc.f * Sa22.f;\n    Sa32.f  = Sc.f * Sa32.f;\n    Sa22.f  = __fadd_rn(Sa22.f, Stmp2.f);\n    Sa32.f  = __fsub_rn(Sa32.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Sa23.f;\n    Stmp2.f = Ss.f * Sa33.f;\n    Sa23.f  = Sc.f * Sa23.f;\n    Sa33.f  = Sc.f * Sa33.f;\n    Sa23.f  = __fadd_rn(Sa23.f, Stmp2.f);\n    Sa33.f  = __fsub_rn(Sa33.f, Stmp1.f);\n\n    //###########################################################\n    // Update matrix U\n    //###########################################################\n\n    Stmp1.f = Ss.f * Su12.f;\n    Stmp2.f = Ss.f * Su13.f;\n    Su12.f  = Sc.f * Su12.f;\n    Su13.f  = Sc.f * Su13.f;\n    Su12.f  = __fadd_rn(Su12.f, Stmp2.f);\n    Su13.f  = __fsub_rn(Su13.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Su22.f;\n    Stmp2.f = Ss.f * Su23.f;\n    Su22.f  = Sc.f * Su22.f;\n    Su23.f  = Sc.f * Su23.f;\n    Su22.f  = __fadd_rn(Su22.f, Stmp2.f);\n    Su23.f  = __fsub_rn(Su23.f, Stmp1.f);\n\n    Stmp1.f = Ss.f * Su32.f;\n    Stmp2.f = Ss.f * Su33.f;\n    Su32.f  = Sc.f * Su32.f;\n    Su33.f  = Sc.f * Su33.f;\n    Su32.f  = __fadd_rn(Su32.f, Stmp2.f);\n    Su33.f  = __fsub_rn(Su33.f, Stmp1.f);\n\n    v11 = Sv11.f;\n    v12 = Sv12.f;\n    v13 = Sv13.f;\n    v21 = Sv21.f;\n    v22 = Sv22.f;\n    v23 = Sv23.f;\n    v31 = Sv31.f;\n    v32 = Sv32.f;\n    v33 = Sv33.f;\n\n    u11 = Su11.f;\n    u12 = Su12.f;\n    u13 = Su13.f;\n    u21 = Su21.f;\n    u22 = Su22.f;\n    u23 = Su23.f;\n    u31 = Su31.f;\n    u32 = Su32.f;\n    u33 = Su33.f;\n\n    s11 = Sa11.f;\n    //s12 = Sa12.f; s13 = Sa13.f; s21 = Sa21.f;\n    s22 = Sa22.f;\n    //s23 = Sa23.f; s31 = Sa31.f; s32 = Sa32.f;\n    s33 = Sa33.f;\n}\n}  // namespace muda::details::eigen\n</code></pre>"},{"location":"muda/svd_8h/","title":"File svd.h","text":"<p>FileList &gt; eigen &gt; svd.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/svd/svd_impl.h&gt;</code></li> <li><code>#include \"details/svd.inl\"</code></li> </ul>"},{"location":"muda/svd_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace eigen <p>The documentation for this class was generated from the following file <code>src/muda/ext/eigen/svd.h</code></p>"},{"location":"muda/svd_8h_source/","title":"File svd.h","text":"<p>File List &gt; eigen &gt; svd.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;muda/ext/eigen/svd/svd_impl.h&gt;\n\nnamespace muda\n{\nnamespace eigen\n{\n    MUDA_GENERIC void svd(const Eigen::Matrix&lt;float, 3, 3&gt;&amp; F,\n                          Eigen::Matrix&lt;float, 3, 3&gt;&amp;       U,\n                          Eigen::Vector3&lt;float&gt;&amp;            Sigma,\n                          Eigen::Matrix&lt;float, 3, 3&gt;&amp;       V);\n\n    MUDA_GENERIC void pd(const Eigen::Matrix&lt;float, 3, 3&gt;&amp; F,\n                         Eigen::Matrix&lt;float, 3, 3&gt;&amp;       R,\n                         Eigen::Matrix&lt;float, 3, 3&gt;&amp;       S);\n\n    MUDA_GENERIC void svd(const Eigen::Matrix&lt;double, 3, 3&gt;&amp; F,\n                          Eigen::Matrix&lt;double, 3, 3&gt;&amp;       U,\n                          Eigen::Vector3&lt;double&gt;&amp;            Sigma,\n                          Eigen::Matrix&lt;double, 3, 3&gt;&amp;       V);\n\n    MUDA_GENERIC void pd(const Eigen::Matrix&lt;double, 3, 3&gt;&amp; F,\n                         Eigen::Matrix&lt;double, 3, 3&gt;&amp;       R,\n                         Eigen::Matrix&lt;double, 3, 3&gt;&amp;       S);\n}  // namespace eigen\n}  // namespace muda\n#include \"details/svd.inl\"\n</code></pre>"},{"location":"muda/dir_67616bafb1e973d10aec465c6be4ad46/","title":"Dir src/muda/ext/field","text":"<p>FileList &gt; ext &gt; field</p>"},{"location":"muda/dir_67616bafb1e973d10aec465c6be4ad46/#files","title":"Files","text":"Type Name file field.h file field_build_options.h file field_builder.h file field_entry.h file field_entry_base_data.h file field_entry_core.h file field_entry_launch.h file field_entry_layout.h file field_entry_type.h file field_entry_view.h file field_entry_viewer.h file field_viewer.h file matrix_map_info.h file sub_field.h file sub_field_interface.h"},{"location":"muda/dir_67616bafb1e973d10aec465c6be4ad46/#directories","title":"Directories","text":"Type Name dir sub_field <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/</code></p>"},{"location":"muda/field_2field_8h/","title":"File field.h","text":"<p>FileList &gt; ext &gt; field &gt; field.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;muda/tools/host_device_string_cache.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_layout.h&gt;</code></li> <li><code>#include \"details/field.inl\"</code></li> </ul>"},{"location":"muda/field_2field_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/field_2field_8h/#classes","title":"Classes","text":"Type Name class Field <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field.h</code></p>"},{"location":"muda/field_2field_8h_source/","title":"File field.h","text":"<p>File List &gt; ext &gt; field &gt; field.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;muda/tools/host_device_string_cache.h&gt;\n#include &lt;muda/ext/field/field_entry_layout.h&gt;\n\nnamespace muda\n{\nclass FieldEntryBase;\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntry;\nclass SubField;\nclass SubFieldInterface;\ntemplate &lt;FieldEntryLayout Layout&gt;\nclass SubFieldImpl;\n\nclass Field\n{\n    template &lt;typename T&gt;\n    using U = std::unique_ptr&lt;T&gt;;\n\n    friend class SubField;\n    friend class SubFieldInterface;\n    template &lt;FieldEntryLayout Layout&gt;\n    friend class SubFieldImpl;\n    friend class FieldEntryBase;\n\n    details::HostDeviceStringCache          m_string_cache;\n    std::vector&lt;U&lt;SubField&gt;&gt;                m_sub_fields;\n    std::unordered_map&lt;std::string, size_t&gt; m_name_to_index;\n\n  public:\n    using Layout = FieldEntryLayout;\n    Field();\n    ~Field();\n\n    // sub field count\n    size_t num_sub_fields() const { return m_sub_fields.size(); }\n\n    // create or find a subfield\n    SubField&amp; operator[](std::string_view name);\n};\n}  // namespace muda\n\n#include \"details/field.inl\"\n</code></pre>"},{"location":"muda/field__build__options_8h/","title":"File field_build_options.h","text":"<p>FileList &gt; ext &gt; field &gt; field_build_options.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/field/field_entry_layout.h&gt;</code></li> </ul>"},{"location":"muda/field__build__options_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/field__build__options_8h/#classes","title":"Classes","text":"Type Name class FieldBuildOptions <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_build_options.h</code></p>"},{"location":"muda/field__build__options_8h_source/","title":"File field_build_options.h","text":"<p>File List &gt; ext &gt; field &gt; field_build_options.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/field/field_entry_layout.h&gt;\nnamespace muda\n{\nclass FieldBuildOptions\n{\n  public:\n    uint32_t min_alignment = sizeof(int);  // bytes\n    uint32_t max_alignment = sizeof(std::max_align_t);\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/field__builder_8h/","title":"File field_builder.h","text":"<p>FileList &gt; ext &gt; field &gt; field_builder.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_type.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_layout.h&gt;</code></li> <li><code>#include \"details/field_builder.inl\"</code></li> </ul>"},{"location":"muda/field__builder_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/field__builder_8h/#classes","title":"Classes","text":"Type Name class FieldBuilder &lt;Layout&gt; class EntryProxy <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_builder.h</code></p>"},{"location":"muda/field__builder_8h_source/","title":"File field_builder.h","text":"<p>File List &gt; ext &gt; field &gt; field_builder.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;muda/ext/field/field_entry_type.h&gt;\n#include &lt;muda/ext/field/field_entry_layout.h&gt;\n\nnamespace muda\n{\nclass SubField;\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntry;\n\ntemplate &lt;FieldEntryLayout Layout&gt;\nclass FieldBuilder\n{\n  public:\n    class EntryProxy\n    {\n        FieldBuilder&lt;Layout&gt;&amp; m_builder;\n\n        std::string m_name;\n\n      public:\n        EntryProxy(FieldBuilder&lt;Layout&gt;&amp; builder, std::string_view name)\n            : m_builder(builder)\n            , m_name(name)\n        {\n        }\n        template &lt;typename T&gt;\n        FieldEntry&lt;T, Layout, 1, 1&gt;&amp; scalar() &amp;&amp;;\n\n        template &lt;typename T, int N&gt;\n        FieldEntry&lt;T, Layout, N, 1&gt;&amp; vector() &amp;&amp;;\n\n        template &lt;typename T&gt;\n        FieldEntry&lt;T, Layout, 2, 1&gt;&amp; vector2() &amp;&amp;;\n        template &lt;typename T&gt;\n        FieldEntry&lt;T, Layout, 3, 1&gt;&amp; vector3() &amp;&amp;;\n        template &lt;typename T&gt;\n        FieldEntry&lt;T, Layout, 4, 1&gt;&amp; vector4() &amp;&amp;;\n\n        template &lt;typename T, int M, int N&gt;\n        FieldEntry&lt;T, Layout, M, N&gt;&amp; matrix() &amp;&amp;;\n\n        template &lt;typename T&gt;\n        FieldEntry&lt;T, Layout, 2, 2&gt;&amp; matrix2x2() &amp;&amp;;\n        template &lt;typename T&gt;\n        FieldEntry&lt;T, Layout, 3, 3&gt;&amp; matrix3x3() &amp;&amp;;\n        template &lt;typename T&gt;\n        FieldEntry&lt;T, Layout, 4, 4&gt;&amp; matrix4x4() &amp;&amp;;\n    };\n\n  private:\n    friend class SubField;\n\n    SubField&amp;            m_subfield;\n    FieldEntryLayoutInfo m_layout;\n    FieldBuildOptions    m_options;\n    bool                 m_single_entry = false;\n    bool                 m_is_built     = false;\n\n    FieldBuilder(SubField&amp; subfield, FieldEntryLayoutInfo layout, const FieldBuildOptions&amp; options)\n        : m_subfield(subfield)\n        , m_layout(layout)\n        , m_options(options)\n    {\n        MUDA_ASSERT(Layout == FieldEntryLayout::RuntimeLayout || layout.layout() == Layout,\n                    \"Layout mismatching\");\n    }\n\n    template &lt;typename T, int M, int N&gt;\n    FieldEntry&lt;T, Layout, M, N&gt;&amp; create_entry(std::string_view name, FieldEntryType type);\n\n  public:\n    EntryProxy entry(std::string_view name);\n    EntryProxy entry();\n    void build();\n\n    ~FieldBuilder();\n};\n}  // namespace muda\n\n#include \"details/field_builder.inl\"\n</code></pre>"},{"location":"muda/field__entry_8h/","title":"File field_entry.h","text":"<p>FileList &gt; ext &gt; field &gt; field_entry.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;muda/tools/string_pointer.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_type.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_base_data.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_view.h&gt;</code></li> <li><code>#include &lt;muda/tools/host_device_config.h&gt;</code></li> <li><code>#include \"details/field_entry.inl\"</code></li> </ul>"},{"location":"muda/field__entry_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/field__entry_8h/#classes","title":"Classes","text":"Type Name class FieldEntry &lt;typename T, Layout, M, N&gt; class FieldEntryBase <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry.h</code></p>"},{"location":"muda/field__entry_8h_source/","title":"File field_entry.h","text":"<p>File List &gt; ext &gt; field &gt; field_entry.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;cinttypes&gt;\n#include &lt;muda/tools/string_pointer.h&gt;\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/ext/field/field_entry_type.h&gt;\n#include &lt;muda/ext/field/field_entry_base_data.h&gt;\n#include &lt;muda/ext/field/field_entry_view.h&gt;\n#include &lt;muda/tools/host_device_config.h&gt;\n\nnamespace muda\n{\nclass SubField;\nclass SubFieldInterface;\ntemplate &lt;FieldEntryLayout Layout&gt;\nclass SubFieldImpl;\n\nclass FieldEntryBase\n{\n    template &lt;FieldEntryLayout layout&gt;\n    friend class SubFieldImpl;\n\n  public:\n    FieldEntryBase(SubField&amp;            field,\n                   FieldEntryLayoutInfo layout_info,\n                   FieldEntryType       type,\n                   uint2                shape,\n                   uint32_t             m_elem_byte_size,\n                   std::string_view     name)\n        : m_field{field}\n        , m_name{name}\n    {\n        auto&amp; info          = m_core.m_info;\n        info.layout_info    = layout_info;\n        info.type           = type;\n        info.shape          = shape;\n        info.elem_byte_size = m_elem_byte_size;\n\n        m_core.m_name =\n            m_field.m_field.m_string_cache[std::string{m_field.name()} + \".\" + m_name];\n    }\n    ~FieldEntryBase() = default;\n\n  protected:\n    friend class SubField;\n    friend class SubFieldInterface;\n    template &lt;FieldEntryLayout Layout&gt;\n    friend class SubFieldImpl;\n\n    virtual void async_copy_to_new_place(HostDeviceConfigView&lt;FieldEntryCore&gt; vfc) const = 0;\n\n    // delete copy\n    FieldEntryBase(const FieldEntryBase&amp;)            = delete;\n    FieldEntryBase&amp; operator=(const FieldEntryBase&amp;) = delete;\n\n    SubField&amp;   m_field;\n    std::string m_name;\n    // a parameter struct that can be copy between host and device.\n    FieldEntryCore                   m_core;\n    HostDeviceConfig&lt;FieldEntryCore&gt; m_host_device_core;\n\n    MUDA_GENERIC const auto&amp; core() const { return m_core; }\n\n  public:\n    MUDA_GENERIC auto layout_info() const { return core().layout_info(); }\n    MUDA_GENERIC auto layout() const { return core().layout(); }\n    MUDA_GENERIC auto count() const { return core().count(); }\n    MUDA_GENERIC auto elem_byte_size() const { return core().elem_byte_size(); }\n    MUDA_GENERIC auto shape() const { return core().shape(); }\n    MUDA_GENERIC auto struct_stride() const { return core().struct_stride(); }\n    MUDA_GENERIC auto name() const { return std::string_view{m_name}; }\n};\n\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntry : public FieldEntryBase\n{\n    static_assert(M &gt; 0 &amp;&amp; N &gt; 0, \"M and N must be positive\");\n\n  public:\n    using ElementType = typename FieldEntryView&lt;T, Layout, M, N&gt;::ElementType;\n\n    FieldEntry(SubField&amp; field, FieldEntryLayoutInfo layout, FieldEntryType type, std::string_view name)\n        : FieldEntryBase{field,\n                         layout,\n                         type,\n                         make_uint2(static_cast&lt;uint32_t&gt;(M), static_cast&lt;uint32_t&gt;(N)),\n                         sizeof(T),\n                         name}\n    {\n    }\n    FieldEntry(SubField&amp; field, FieldEntryLayoutInfo layout, FieldEntryType type, uint2 shape, std::string_view name)\n        : FieldEntryBase{field, layout, type, shape, sizeof(T), name}\n    {\n    }\n\n    FieldEntryView&lt;T, Layout, M, N&gt; view()\n    {\n        MUDA_ASSERT(m_field.data_buffer() != nullptr, \"Resize the field before you use it!\");\n        return FieldEntryView&lt;T, Layout, M, N&gt;{\n            m_host_device_core.view(), 0, static_cast&lt;int&gt;(m_core.count())};\n    }\n\n    CFieldEntryView&lt;T, Layout, M, N&gt; view() const\n    {\n        MUDA_ASSERT(m_field.data_buffer() != nullptr, \"Resize the field before you use it!\");\n        return CFieldEntryView&lt;T, Layout, M, N&gt;{\n            m_host_device_core.view(), 0, static_cast&lt;int&gt;(m_core.count())};\n    }\n\n    auto view(int offset) { return view().subview(offset); }\n    auto view(int offset) const { return view().subview(offset); }\n\n    auto view(int offset, int count) { return view().subview(offset, count); }\n    auto view(int offset, int count) const\n    {\n        return view().subview(offset, count);\n    }\n\n    FieldEntryViewer&lt;T, Layout, M, N&gt;  viewer() { return view().viewer(); }\n    CFieldEntryViewer&lt;T, Layout, M, N&gt; cviewer() const\n    {\n        return view().viewer();\n    }\n\n    void copy_to(DeviceBuffer&lt;ElementType&gt;&amp; dst) const;\n    void copy_to(std::vector&lt;ElementType&gt;&amp; dst) const;\n\n    void copy_from(const DeviceBuffer&lt;ElementType&gt;&amp; src);\n    void copy_from(const std::vector&lt;ElementType&gt;&amp; src);\n\n    template &lt;FieldEntryLayout SrcLayout&gt;\n    void copy_from(const FieldEntry&lt;T, SrcLayout, M, N&gt;&amp; src);\n\n    virtual void async_copy_to_new_place(HostDeviceConfigView&lt;FieldEntryCore&gt; new_place) const override\n    {\n        using DstView = FieldEntryView&lt;T, Layout, M, N&gt;;\n        auto dst = DstView{new_place, 0, static_cast&lt;int&gt;(new_place-&gt;count())};\n\n        if(new_place-&gt;count() &lt; this-&gt;count())  // shrinking\n        {\n            if(!m_field.allow_inplace_shrink())  // typically SoA don't allow inplace shrinking\n            {\n                BufferLaunch().resize(m_workpace, new_place-&gt;count());\n                FieldEntryLaunch().copy(m_workpace.view(),\n                                        std::as_const(*this).view(0, new_place-&gt;count()));  // copy self to workspace\n                FieldEntryLaunch().copy(dst,\n                                        m_workpace.view());  // copy workspace to dst\n            }\n            // else do nothing, trivial shrink\n        }\n        else if(new_place-&gt;count() &gt; this-&gt;count())  // expanding\n        {\n            // safe direct copy\n            FieldEntryLaunch().copy(dst.subview(0, this-&gt;count()),\n                                    std::as_const(*this).view());\n        }\n        else\n        {\n            // do thing\n        }\n    }\n\n    void fill(const ElementType&amp; value);\n\n  private:\n    mutable DeviceBuffer&lt;ElementType&gt; m_workpace;  // for data copy, if needed\n};\n}  // namespace muda\n\n#include \"details/field_entry.inl\"\n</code></pre>"},{"location":"muda/field__entry__base__data_8h/","title":"File field_entry_base_data.h","text":"<p>FileList &gt; ext &gt; field &gt; field_entry_base_data.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/field/field_entry_type.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_layout.h&gt;</code></li> </ul>"},{"location":"muda/field__entry__base__data_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/field__entry__base__data_8h/#classes","title":"Classes","text":"Type Name class FieldEntryBaseData <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_base_data.h</code></p>"},{"location":"muda/field__entry__base__data_8h_source/","title":"File field_entry_base_data.h","text":"<p>File List &gt; ext &gt; field &gt; field_entry_base_data.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/field/field_entry_type.h&gt;\n#include &lt;muda/ext/field/field_entry_layout.h&gt;\nnamespace muda\n{\nclass FieldEntryBaseData\n{\n  public:\n    // common info\n    FieldEntryLayoutInfo layout_info;\n    FieldEntryType       type = FieldEntryType::None;\n    uint2                shape;\n    uint32_t             elem_byte_size = ~0;\n    //uint32_t             elem_alignment   = ~0;\n    uint32_t elem_count       = ~0;\n    uint32_t offset_in_struct = ~0;\n\n    // used by soa\n    uint32_t offset_in_base_struct = ~0;\n    union\n    {\n        // used by aos and aosoa\n        uint32_t struct_stride = ~0;\n        // used by soa\n        uint32_t elem_count_based_stride;\n    };\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/field__entry__core_8h/","title":"File field_entry_core.h","text":"<p>FileList &gt; ext &gt; field &gt; field_entry_core.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/string_pointer.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_layout.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_base_data.h&gt;</code></li> <li><code>#include \"details/field_entry_core.inl\"</code></li> </ul>"},{"location":"muda/field__entry__core_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/field__entry__core_8h/#classes","title":"Classes","text":"Type Name class FieldEntryCore <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_core.h</code></p>"},{"location":"muda/field__entry__core_8h_source/","title":"File field_entry_core.h","text":"<p>File List &gt; ext &gt; field &gt; field_entry_core.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/string_pointer.h&gt;\n#include &lt;muda/ext/field/field_entry_layout.h&gt;\n#include &lt;muda/ext/field/field_entry_base_data.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntry;\n\nclass FieldEntryBase;\n\n// basic field entry info to pass between different field objects\nclass FieldEntryCore\n{\n    friend class FieldEntryBase;\n    template &lt;FieldEntryLayout layout&gt;\n    friend class SubFieldImpl;\n    friend class SubFieldInterface;\n\n  public:\n    MUDA_GENERIC FieldEntryCore() {}\n\n    MUDA_GENERIC FieldEntryCore(std::byte*                buffer,\n                                const FieldEntryBaseData&amp; info,\n                                details::StringPointer    name)\n        : m_buffer(const_cast&lt;std::byte*&gt;(buffer))\n        , m_info(info)\n        , m_name(name)\n    {\n    }\n\n    MUDA_GENERIC FieldEntryCore(const FieldEntryCore&amp; rhs) = default;\n\n    template &lt;typename T&gt;\n    MUDA_GENERIC T&amp; cast(std::byte* data);\n    template &lt;typename T&gt;\n    MUDA_GENERIC const T&amp; cast(const std::byte* data) const;\n\n    // AOSOA\n    MUDA_GENERIC uint32_t aosoa_inner_index(int i) const;\n    MUDA_GENERIC std::byte* aosoa_struct_begin(int i) const;\n    MUDA_GENERIC std::byte* aosoa_elem_addr(int i) const;\n    MUDA_GENERIC std::byte* aosoa_elem_addr(int i, int j) const;\n    MUDA_GENERIC std::byte* aosoa_elem_addr(int i, int row_index, int col_index) const;\n\n    // SOA\n    MUDA_GENERIC std::byte* soa_elem_addr(int i) const;\n    MUDA_GENERIC std::byte* soa_elem_addr(int i, int j) const;\n    MUDA_GENERIC std::byte* soa_elem_addr(int i, int row_index, int col_index) const;\n\n    // AOS\n    MUDA_GENERIC std::byte* aos_struct_begin(int i) const;\n    MUDA_GENERIC std::byte* aos_elem_addr(int i) const;\n    MUDA_GENERIC std::byte* aos_elem_addr(int i, int j) const;\n    MUDA_GENERIC std::byte* aos_elem_addr(int i, int row_index, int col_index) const;\n\n    // generic access\n    template &lt;FieldEntryLayout Layout&gt;\n    MUDA_GENERIC std::byte* elem_addr(int i) const;\n    template &lt;typename T, FieldEntryLayout Layout&gt;\n    MUDA_GENERIC T* data(int i) const\n    {\n        return reinterpret_cast&lt;T*&gt;(elem_addr&lt;Layout&gt;(i));\n    }\n\n    template &lt;FieldEntryLayout Layout&gt;\n    MUDA_GENERIC std::byte* elem_addr(int i, int j) const;\n    template &lt;typename T, FieldEntryLayout Layout&gt;\n    MUDA_GENERIC T* data(int i, int j) const\n    {\n        return reinterpret_cast&lt;T*&gt;(elem_addr&lt;Layout&gt;(i, j));\n    }\n\n    template &lt;FieldEntryLayout Layout&gt;\n    MUDA_GENERIC std::byte* elem_addr(int i, int row_index, int col_index) const;\n    template &lt;typename T, FieldEntryLayout Layout&gt;\n    MUDA_GENERIC T* data(int i, int row_index, int col_index) const\n    {\n        return reinterpret_cast&lt;T*&gt;(elem_addr&lt;Layout&gt;(i, row_index, col_index));\n    }\n\n    MUDA_GENERIC auto layout_info() const { return m_info.layout_info; }\n    MUDA_GENERIC auto layout() const { return m_info.layout_info.layout(); }\n    MUDA_GENERIC auto count() const { return m_info.elem_count; }\n    MUDA_GENERIC auto elem_byte_size() const { return m_info.elem_byte_size; }\n    MUDA_GENERIC auto shape() const { return m_info.shape; }\n    MUDA_GENERIC auto struct_stride() const { return m_info.struct_stride; }\n    MUDA_GENERIC auto name() const { return m_name.auto_select(); }\n    MUDA_GENERIC auto name_string_pointer() const { return m_name; }\n\n  private:\n    mutable std::byte*     m_buffer = nullptr;\n    details::StringPointer m_name;\n    FieldEntryBaseData     m_info;\n};\n}  // namespace muda\n\n#include \"details/field_entry_core.inl\"\n</code></pre>"},{"location":"muda/field__entry__launch_8h/","title":"File field_entry_launch.h","text":"<p>FileList &gt; ext &gt; field &gt; field_entry_launch.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/launch/parallel_for.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_view.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include \"details/field_entry_launch.inl\"</code></li> </ul>"},{"location":"muda/field__entry__launch_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/field__entry__launch_8h/#classes","title":"Classes","text":"Type Name class FieldEntryLaunch <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_launch.h</code></p>"},{"location":"muda/field__entry__launch_8h_source/","title":"File field_entry_launch.h","text":"<p>File List &gt; ext &gt; field &gt; field_entry_launch.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/launch/parallel_for.h&gt;\n#include &lt;muda/ext/field/field_entry_view.h&gt;\n#include &lt;muda/buffer/buffer_view.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\nnamespace muda\n{\nclass FieldEntryLaunch : public LaunchBase&lt;FieldEntryLaunch&gt;\n{\n  public:\n    MUDA_GENERIC FieldEntryLaunch(cudaStream_t stream = nullptr)\n        : LaunchBase(stream)\n    {\n    }\n\n    /**********************************************************************************************\n    * \n    * EntryView &lt;- EntryView\n    * \n    **********************************************************************************************/\n    template &lt;typename T, FieldEntryLayout DstLayout, FieldEntryLayout SrcLayout, int M, int N&gt;\n    MUDA_HOST FieldEntryLaunch&amp; copy(FieldEntryView&lt;T, DstLayout, M, N&gt;  dst,\n                                     CFieldEntryView&lt;T, SrcLayout, M, N&gt; src);\n\n    /**********************************************************************************************\n    *   \n    * EntryView &lt;- Value\n    *   \n    * *********************************************************************************************/\n    template &lt;typename T, FieldEntryLayout DstLayout, int M, int N&gt;\n    MUDA_HOST FieldEntryLaunch&amp; fill(FieldEntryView&lt;T, DstLayout, M, N&gt; dst,\n                                     const typename FieldEntryView&lt;T, DstLayout, M, N&gt;::ElementType&amp; value);\n\n    /**********************************************************************************************\n    *   \n    * BufferView &lt;- EntryView\n    *   \n    * *********************************************************************************************/\n    template &lt;typename T, FieldEntryLayout SrcLayout, int M, int N&gt;\n    MUDA_HOST FieldEntryLaunch&amp; copy(\n        BufferView&lt;typename CFieldEntryView&lt;T, SrcLayout, M, N&gt;::ElementType&gt; dst,\n        CFieldEntryView&lt;T, SrcLayout, M, N&gt; src);\n\n    /**********************************************************************************************\n    *   \n    * EntryView &lt;- BufferView\n    *   \n    * *********************************************************************************************/\n    template &lt;typename T, FieldEntryLayout DstLayout, int M, int N&gt;\n    MUDA_HOST FieldEntryLaunch&amp; copy(\n        FieldEntryView&lt;T, DstLayout, M, N&gt; dst,\n        CBufferView&lt;typename FieldEntryView&lt;T, DstLayout, M, N&gt;::ElementType&gt; src);\n};\n}  // namespace muda\n\n#include \"details/field_entry_launch.inl\"\n</code></pre>"},{"location":"muda/field__entry__layout_8h/","title":"File field_entry_layout.h","text":"<p>FileList &gt; ext &gt; field &gt; field_entry_layout.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/tools/debug_log.h&gt;</code></li> </ul>"},{"location":"muda/field__entry__layout_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/field__entry__layout_8h/#classes","title":"Classes","text":"Type Name class FieldEntryLayoutInfo <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_layout.h</code></p>"},{"location":"muda/field__entry__layout_8h_source/","title":"File field_entry_layout.h","text":"<p>File List &gt; ext &gt; field &gt; field_entry_layout.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cinttypes&gt;\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/tools/debug_log.h&gt;\nnamespace muda\n{\nenum class FieldEntryLayout\n{\n    None,\n    // Array of Struct\n    AoS,\n    // Struct of Array\n    SoA,\n    // Array of Struct of Array\n    // The innermost Array must be fixed size\n    // e.g. size = 32 (warp size)\n    AoSoA,\n\n    // the layout is not known at compile time\n    RuntimeLayout,\n};\n\nclass FieldEntryLayoutInfo\n{\n    using Layout = FieldEntryLayout;\n\n  public:\n    MUDA_GENERIC auto layout() const MUDA_NOEXCEPT { return m_layout; }\n    MUDA_GENERIC auto innermost_array_size() const MUDA_NOEXCEPT\n    {\n        return m_innermost_array_size;\n    }\n\n    MUDA_GENERIC FieldEntryLayoutInfo(Layout layout, uint32_t innermost_array_size = 32) MUDA_NOEXCEPT\n        : m_layout(layout),\n          m_innermost_array_size(layout == Layout::AoSoA ? innermost_array_size : 0)\n    {\n        MUDA_ASSERT(layout != Layout::RuntimeLayout,\n                    \"RuntimeLayout is not allowed to use when constructing FieldEntryLayoutInfo, because it's meaningless.\"\n                    \"RuntimeLayout is only used in template argument.\");\n\n        MUDA_ASSERT((innermost_array_size &amp; (innermost_array_size - 1)) == 0,\n                    \"innermost_array_size must be power of 2\");\n    }\n\n    MUDA_GENERIC FieldEntryLayoutInfo() MUDA_NOEXCEPT {}\n\n  private:\n    Layout   m_layout               = Layout::AoSoA;\n    uint32_t m_innermost_array_size = 32;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/field__entry__type_8h/","title":"File field_entry_type.h","text":"<p>FileList &gt; ext &gt; field &gt; field_entry_type.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/field__entry__type_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_type.h</code></p>"},{"location":"muda/field__entry__type_8h_source/","title":"File field_entry_type.h","text":"<p>File List &gt; ext &gt; field &gt; field_entry_type.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace muda\n{\nenum class FieldEntryType\n{\n    None,\n    Scalar,\n    Vector,\n    Matrix,\n    Object\n};\n}\n</code></pre>"},{"location":"muda/field__entry__view_8h/","title":"File field_entry_view.h","text":"<p>FileList &gt; ext &gt; field &gt; field_entry_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/string_pointer.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_layout.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_base_data.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/matrix_map_info.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_core.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_viewer.h&gt;</code></li> <li><code>#include &lt;muda/tools/host_device_config.h&gt;</code></li> <li><code>#include \"details/entry_view/field_entry_view_matrix.inl\"</code></li> <li><code>#include \"details/entry_view/field_entry_view_vector.inl\"</code></li> <li><code>#include \"details/entry_view/field_entry_view_scalar.inl\"</code></li> </ul>"},{"location":"muda/field__entry__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/field__entry__view_8h/#classes","title":"Classes","text":"Type Name class FieldEntryViewCore &lt;IsConst, typename T, Layout, M, N&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_view.h</code></p>"},{"location":"muda/field__entry__view_8h_source/","title":"File field_entry_view.h","text":"<p>File List &gt; ext &gt; field &gt; field_entry_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/string_pointer.h&gt;\n#include &lt;muda/view/view_base.h&gt;\n#include &lt;muda/ext/field/field_entry_layout.h&gt;\n#include &lt;muda/ext/field/field_entry_base_data.h&gt;\n#include &lt;muda/ext/field/matrix_map_info.h&gt;\n#include &lt;muda/ext/field/field_entry_core.h&gt;\n#include &lt;muda/buffer/buffer_view.h&gt;\n#include &lt;muda/ext/field/field_entry_viewer.h&gt;\n#include &lt;muda/tools/host_device_config.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntryViewCore : public ViewBase&lt;IsConst&gt;\n{\n    using Base       = ViewBase&lt;IsConst&gt;;\n    using ViewerCore = FieldEntryViewerCore&lt;IsConst, T, Layout, M, N&gt;;\n    friend class FieldEntryLaunch;\n\n  public:\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    using ConstViewer    = CFieldEntryViewer&lt;T, Layout, M, N&gt;;\n    using NonConstViewer = FieldEntryViewer&lt;T, Layout, M, N&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n\n    using MatStride      = typename ViewerCore::MatStride;\n    using ConstMatMap    = typename ViewerCore::ConstMatMap;\n    using NonConstMatMap = typename ViewerCore::NonConstMatMap;\n    using ThisMatMap     = typename ViewerCore::ThisMatMap;\n\n  protected:\n    HostDeviceConfigView&lt;FieldEntryCore&gt; m_core;\n    MatStride                            m_stride;\n    int                                  m_offset = 0;\n    int                                  m_size   = 0;\n\n\n    MUDA_GENERIC T* data(int i) const\n    {\n        return m_core-&gt;template data&lt;T, Layout&gt;(m_offset + i);\n    }\n\n    MUDA_GENERIC T* data(int i, int j) const\n    {\n\n        return m_core-&gt;template data&lt;T, Layout&gt;(m_offset + i, j);\n    }\n\n    MUDA_GENERIC T* data(int i, int row_index, int col_index) const\n    {\n        return m_core-&gt;template data&lt;T, Layout&gt;(m_offset + i, row_index, col_index);\n    }\n\n  protected:\n    struct AsIterator\n    {\n    };\n\n    MUDA_GENERIC FieldEntryViewCore(HostDeviceConfigView&lt;FieldEntryCore&gt; core, int offset, int size, AsIterator)\n        : m_core{core}\n        , m_offset{offset}\n        , m_size{size}\n    {\n        m_stride = details::field::make_stride&lt;T, Layout, M, N&gt;(*m_core);\n    }\n\n  public:\n    MUDA_GENERIC FieldEntryViewCore() = default;\n    MUDA_GENERIC FieldEntryViewCore(HostDeviceConfigView&lt;FieldEntryCore&gt; core, int offset, int size)\n        : FieldEntryViewCore(core, offset, size, AsIterator{})\n    {\n        MUDA_KERNEL_ASSERT(offset &gt;= 0 &amp;&amp; size &gt;= 0 &amp;&amp; offset + size &lt;= core-&gt;count(),\n                           \"(offset,size) is out of range, offset=%d, size=%d, count=%d\",\n                           offset,\n                           size,\n                           core-&gt;count());\n    }\n\n    MUDA_GENERIC auto layout_info() const { return m_core-&gt;layout_info(); }\n    MUDA_GENERIC auto layout() const { return layout_info().layout(); }\n    MUDA_GENERIC auto offset() const { return m_offset; }\n    MUDA_GENERIC auto size() const { return m_size; }\n    MUDA_GENERIC auto total_count() const { return m_core-&gt;count(); }\n    MUDA_GENERIC auto elem_byte_size() const\n    {\n        return m_core-&gt;elem_byte_size();\n    }\n    MUDA_GENERIC auto shape() const { return m_core-&gt;shape(); }\n    MUDA_GENERIC auto struct_stride() const { return m_core-&gt;struct_stride(); }\n\n    MUDA_GENERIC auto name() const { return m_core-&gt;name(); }\n    MUDA_GENERIC auto viewer() { return ThisViewer{m_core, offset(), size()}; }\n    MUDA_GENERIC auto cviewer() const\n    {\n        return ConstViewer{m_core, offset(), size()};\n    }\n};\n}  // namespace muda\n\nnamespace muda\n{\n// forward declaration\ntemplate &lt;bool IsConst, typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntryViewBase;\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntryView;\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass CFieldEntryView;\n}  // namespace muda\n\n// implementation\n#include \"details/entry_view/field_entry_view_matrix.inl\"\n#include \"details/entry_view/field_entry_view_vector.inl\"\n#include \"details/entry_view/field_entry_view_scalar.inl\"\n\nnamespace muda\n{\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nstruct read_only_view&lt;FieldEntryView&lt;T, Layout, M, N&gt;&gt;\n{\n    using type = CFieldEntryView&lt;T, Layout, M, N&gt;;\n};\n\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nstruct read_write_view&lt;CFieldEntryView&lt;T, Layout, M, N&gt;&gt;\n{\n    using type = FieldEntryView&lt;T, Layout, M, N&gt;;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/field__entry__viewer_8h/","title":"File field_entry_viewer.h","text":"<p>FileList &gt; ext &gt; field &gt; field_entry_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_layout.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_base_data.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_core.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/matrix_map_info.h&gt;</code></li> <li><code>#include &lt;muda/tools/host_device_config.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include \"details/entry_viewers/field_entry_viewer_matrix.inl\"</code></li> <li><code>#include \"details/entry_viewers/field_entry_viewer_vector.inl\"</code></li> <li><code>#include \"details/entry_viewers/field_entry_viewer_scalar.inl\"</code></li> </ul>"},{"location":"muda/field__entry__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace field"},{"location":"muda/field__entry__viewer_8h/#classes","title":"Classes","text":"Type Name class FieldEntryViewerCore &lt;IsConst, typename T, Layout, M, N&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_entry_viewer.h</code></p>"},{"location":"muda/field__entry__viewer_8h_source/","title":"File field_entry_viewer.h","text":"<p>File List &gt; ext &gt; field &gt; field_entry_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/viewer/viewer_base.h&gt;\n#include &lt;muda/ext/field/field_entry_layout.h&gt;\n#include &lt;muda/ext/field/field_entry_base_data.h&gt;\n#include &lt;muda/ext/field/field_entry_core.h&gt;\n#include &lt;muda/ext/field/matrix_map_info.h&gt;\n#include &lt;muda/tools/host_device_config.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda\n{\nnamespace details::field\n{\n    using MatStride = Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;;\n    template &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\n    MUDA_GENERIC MatStride make_stride(const FieldEntryCore&amp; core)\n    {\n        MatStride ret;\n        if constexpr(M == 1 &amp;&amp; N == 1)\n        {\n            ret = MatStride{0, 0};\n        }\n        else if constexpr(N == 1)  // vector\n        {\n            auto begin = core.data&lt;T, Layout&gt;(0, 0);\n            auto next  = core.data&lt;T, Layout&gt;(0, 1);\n            ret        = MatStride{0, next - begin};\n        }\n        else  // matrix\n        {\n            auto begin      = core.data&lt;T, Layout&gt;(0, 0, 0);\n            auto inner_next = core.data&lt;T, Layout&gt;(0, 1, 0);\n            auto outer_next = core.data&lt;T, Layout&gt;(0, 0, 1);\n            ret             = MatStride{outer_next - begin, inner_next - begin};\n        }\n        return ret;\n    }\n}  // namespace details::field\n\ntemplate &lt;bool IsConst, typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntryViewerCore : protected ViewerBase&lt;IsConst&gt;\n{\n    using Base = ViewerBase&lt;IsConst&gt;;\n\n  public:\n    using MatStride = details::field::MatStride;\n\n    using ConstMatMap = Eigen::Map&lt;const Eigen::Matrix&lt;T, M, N&gt;, 0, MatStride&gt;;\n    using NonConstMatMap = Eigen::Map&lt;Eigen::Matrix&lt;T, M, N&gt;, 0, MatStride&gt;;\n    using ThisMatMap = std::conditional_t&lt;IsConst, ConstMatMap, NonConstMatMap&gt;;\n\n  protected:\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    HostDeviceConfigView&lt;FieldEntryCore&gt; m_core;\n    MatStride                            m_stride;\n    int                                  m_offset = 0;\n    int                                  m_size   = 0;\n\n  public:\n    MUDA_GENERIC FieldEntryViewerCore() {}\n\n    MUDA_GENERIC FieldEntryViewerCore(HostDeviceConfigView&lt;FieldEntryCore&gt; core, int offset, int size)\n        : m_core(core)\n        , m_offset(offset)\n        , m_size(size)\n    {\n        Base::name(core-&gt;name_string_pointer());\n\n        MUDA_KERNEL_ASSERT(m_offset &gt;= 0 &amp;&amp; m_size &gt;= 0 &amp;&amp; m_offset + m_size &lt;= total_count(),\n                           \"FieldEntryViewer[%s:%s]: offset/size indexing out of range, size=%d, offset=%d, size=%d\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           this-&gt;total_count(),\n                           m_offset,\n                           m_size);\n\n        m_stride = details::field::make_stride&lt;T, Layout, M, N&gt;(*m_core);\n    }\n\n    MUDA_GENERIC FieldEntryViewerCore(const FieldEntryViewerCore&amp;) = default;\n\n    // here we don't care about the const/non-const T* access\n    // we will impl that in the derived class\n    MUDA_GENERIC T* data(int i) const\n    {\n        check_index(i);\n        return m_core-&gt;template data&lt;T, Layout&gt;(m_offset + i);\n    }\n\n    MUDA_GENERIC T* data(int i, int j) const\n    {\n        check_index(i);\n\n        MUDA_KERNEL_ASSERT(j &lt; shape().x,\n                           \"FieldEntry[%s:%s]: vector component indexing out of range, shape=(%d, %d), index=%d\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           shape().x,\n                           shape().y,\n                           j);\n        return m_core-&gt;template data&lt;T, Layout&gt;(m_offset + i, j);\n    }\n\n    MUDA_GENERIC T* data(int i, int row_index, int col_index) const\n    {\n        check_index(i);\n\n        MUDA_KERNEL_ASSERT(row_index &lt; shape().x &amp;&amp; col_index &lt; shape().y,\n                           \"FieldEntry[%s:%s]: vector component indexing out of range, shape=(%d,%d), index=(%d,%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           shape().x,\n                           shape().y,\n                           row_index,\n                           col_index);\n        return m_core-&gt;template data&lt;T, Layout&gt;(m_offset + i, row_index, col_index);\n    }\n\n  public:\n    MUDA_GENERIC auto layout_info() const { return m_core-&gt;layout_info(); }\n    MUDA_GENERIC auto layout() const { return m_core-&gt;layout(); }\n    MUDA_GENERIC auto offset() const { return m_offset; }\n    MUDA_GENERIC auto size() const { return m_size; }\n    MUDA_GENERIC auto total_count() const { return m_core-&gt;count(); }\n    MUDA_GENERIC auto elem_byte_size() const\n    {\n        return m_core-&gt;elem_byte_size();\n    }\n    MUDA_GENERIC auto shape() const { return m_core-&gt;shape(); }\n    MUDA_GENERIC auto struct_stride() const { return m_core-&gt;struct_stride(); }\n    MUDA_GENERIC auto entry_name() const { return m_core-&gt;name(); }\n\n  private:\n    MUDA_INLINE MUDA_GENERIC void check_index(int i) const\n    {\n        MUDA_KERNEL_ASSERT(i &lt; m_size,\n                           \"FieldEntryViewer[%s:%s]: indexing out of range, index=%d, size=%d, offset=%d, entry_total_count=%d\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           i,\n                           m_size,\n                           m_offset,\n                           this-&gt;total_count());\n    }\n};\n}  // namespace muda\n\n\nnamespace muda\n{\n// forward declaration\ntemplate &lt;bool IsConst, typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntryViewerBase;\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntryViewer;\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass CFieldEntryViewer;\n}  // namespace muda\n\n// implementation\n#include \"details/entry_viewers/field_entry_viewer_matrix.inl\"\n#include \"details/entry_viewers/field_entry_viewer_vector.inl\"\n#include \"details/entry_viewers/field_entry_viewer_scalar.inl\"\n</code></pre>"},{"location":"muda/field__viewer_8h/","title":"File field_viewer.h","text":"<p>FileList &gt; ext &gt; field &gt; field_viewer.h</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/field_viewer.h</code></p>"},{"location":"muda/field__viewer_8h_source/","title":"File field_viewer.h","text":"<p>File List &gt; ext &gt; field &gt; field_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>//#pragma once\n//#include &lt;muda/viewer/viewer_base_accessor.h&gt;\n//#include &lt;muda/ext/field/field_entry_viewer.h&gt;\n//#include &lt;muda/viewer/dense.h&gt;\n//namespace muda\n//{\n//class FieldViewer : public ViewerBase\n//{\n//    MUDA_VIEWER_COMMON_NAME(FieldViewer);\n//\n//  private:\n//    friend class Field;\n//    Dense1D&lt;FieldEntryViewerBase&gt; m_entries;\n//    MUDA_GENERIC FieldViewer(const Dense1D&lt;FieldEntryViewerBase&gt;&amp; m)\n//        : m_entries(m)\n//    {\n//    }\n//\n//  public:\n//    template &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\n//    MUDA_DEVICE FieldEntryViewer&lt;T, Layout, M, N&gt; entry(const char* name)\n//    {\n//        using Viewer = FieldEntryViewer&lt;T, Layout, M, N&gt;;\n//\n//        auto strcmp = [] MUDA_DEVICE(const char* a, const char* b) -&gt; bool\n//        {\n//            while(*a &amp;&amp; *b &amp;&amp; *a == *b)\n//            {\n//                a++;\n//                b++;\n//            }\n//            return *a == *b;\n//        };\n//        for(int i = 0; i &lt; m_entries.total_size(); i++)\n//        {\n//            auto&amp; e = m_entries(i);\n//            if(strcmp(e.name(), name))\n//            {\n//                MUDA_KERNEL_ASSERT(e.elem_byte_size() == sizeof(T),\n//                                   \"FieldViewer[%s:%s]: FieldEntry[%s] Type size mismatching, entry type size=%d, your size=%d\",\n//                                   kernel_name(),\n//                                   this-&gt;name(),\n//                                   name,\n//                                   e.elem_byte_size(),\n//                                   sizeof(T));\n//#if MUDA_CHECK_ON\n//                using Acc           = details::ViewerBaseAccessor;\n//                Acc::kernel_name(e) = Acc::kernel_name(*this);\n//#endif\n//                return (Viewer&amp;)e;\n//            }\n//        }\n//        MUDA_KERNEL_ERROR_WITH_LOCATION(\"FieldViewer[%s:%s] FieldEntry[%s] not found\",\n//                                        kernel_name(),\n//                                        this-&gt;name(),\n//                                        name);\n//        return Viewer{};\n//    }\n//};\n//}  // namespace muda\n</code></pre>"},{"location":"muda/matrix__map__info_8h/","title":"File matrix_map_info.h","text":"<p>FileList &gt; ext &gt; field &gt; matrix_map_info.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/matrix__map__info_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/matrix__map__info_8h/#classes","title":"Classes","text":"Type Name class CMatrixMapInfo &lt;typename T, M, N&gt; class MatrixMapInfo &lt;typename T, M, N&gt;For MapMatrix e.g. Eigen::Map&lt; ... &gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/matrix_map_info.h</code></p>"},{"location":"muda/matrix__map__info_8h_source/","title":"File matrix_map_info.h","text":"<p>File List &gt; ext &gt; field &gt; matrix_map_info.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace muda\n{\ntemplate &lt;typename T, int M, int N&gt;\nclass MatrixMapInfo\n{\n  public:\n    T*  begin;\n    int outer_stride;\n    int inner_stride;\n};\n\ntemplate &lt;typename T, int M, int N&gt;\nclass CMatrixMapInfo\n{\n  public:\n    const T*  begin;\n    int outer_stride;\n    int inner_stride;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_d0784a59e778fb60ba75a554135ad43c/","title":"Dir src/muda/ext/field/sub_field","text":"<p>FileList &gt; ext &gt; field &gt; sub_field</p>"},{"location":"muda/dir_d0784a59e778fb60ba75a554135ad43c/#files","title":"Files","text":"Type Name file aos_sub_field.h file aosoa_sub_field.h file soa_sub_field.h <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/sub_field/</code></p>"},{"location":"muda/aos__sub__field_8h/","title":"File aos_sub_field.h","text":"<p>FileList &gt; ext &gt; field &gt; sub_field &gt; aos_sub_field.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/field/sub_field_interface.h&gt;</code></li> <li><code>#include \"details/aos_sub_field.inl\"</code></li> </ul>"},{"location":"muda/aos__sub__field_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/aos__sub__field_8h/#classes","title":"Classes","text":"Type Name class SubFieldImpl &lt;Layout&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/sub_field/aos_sub_field.h</code></p>"},{"location":"muda/aos__sub__field_8h_source/","title":"File aos_sub_field.h","text":"<p>File List &gt; ext &gt; field &gt; sub_field &gt; aos_sub_field.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/field/sub_field_interface.h&gt;\n\nnamespace muda\n{\ntemplate &lt;&gt;\nclass SubFieldImpl&lt;FieldEntryLayout::AoS&gt; : public SubFieldInterface\n{\n    friend class SubField;\n\n  protected:\n    virtual void build_impl() override;\n    virtual size_t require_total_buffer_byte_size(size_t element_count) override;\n\n    virtual void calculate_new_cores(std::byte*           byte_buffer,\n                                     size_t               total_bytes,\n                                     size_t               element_count,\n                                     span&lt;FieldEntryCore&gt; new_cores) override\n    {\n        // no need to implement anything\n    }\n\n  public:\n    using SubFieldInterface::SubFieldInterface;\n    virtual ~SubFieldImpl() override = default;\n};\n}  // namespace muda\n\n#include \"details/aos_sub_field.inl\"\n</code></pre>"},{"location":"muda/aosoa__sub__field_8h/","title":"File aosoa_sub_field.h","text":"<p>FileList &gt; ext &gt; field &gt; sub_field &gt; aosoa_sub_field.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/field/sub_field_interface.h&gt;</code></li> <li><code>#include \"details/aosoa_sub_field.inl\"</code></li> </ul>"},{"location":"muda/aosoa__sub__field_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/aosoa__sub__field_8h/#classes","title":"Classes","text":"Type Name class SubFieldImpl &lt;Layout&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/sub_field/aosoa_sub_field.h</code></p>"},{"location":"muda/aosoa__sub__field_8h_source/","title":"File aosoa_sub_field.h","text":"<p>File List &gt; ext &gt; field &gt; sub_field &gt; aosoa_sub_field.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/field/sub_field_interface.h&gt;\n\nnamespace muda\n{\ntemplate &lt;&gt;\nclass SubFieldImpl&lt;FieldEntryLayout::AoSoA&gt; : public SubFieldInterface\n{\n    friend class SubField;\n\n  protected:\n    virtual void build_impl() override;\n\n    virtual size_t require_total_buffer_byte_size(size_t element_count) override;\n    virtual void calculate_new_cores(std::byte*           byte_buffer,\n                                     size_t               total_bytes,\n                                     size_t               element_count,\n                                     span&lt;FieldEntryCore&gt; new_cores) override\n    {\n        // no need to update any other thing\n    }\n\n\n  public:\n    using SubFieldInterface::SubFieldInterface;\n    virtual ~SubFieldImpl() override = default;\n};\n\n}  // namespace muda\n\n#include \"details/aosoa_sub_field.inl\"\n</code></pre>"},{"location":"muda/soa__sub__field_8h/","title":"File soa_sub_field.h","text":"<p>FileList &gt; ext &gt; field &gt; sub_field &gt; soa_sub_field.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/field/sub_field_interface.h&gt;</code></li> <li><code>#include \"details/soa_sub_field.inl\"</code></li> </ul>"},{"location":"muda/soa__sub__field_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/soa__sub__field_8h/#classes","title":"Classes","text":"Type Name class SubFieldImpl &lt;Layout&gt; struct SoACopyMap <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/sub_field/soa_sub_field.h</code></p>"},{"location":"muda/soa__sub__field_8h_source/","title":"File soa_sub_field.h","text":"<p>File List &gt; ext &gt; field &gt; sub_field &gt; soa_sub_field.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/field/sub_field_interface.h&gt;\n\nnamespace muda\n{\nnamespace details\n{\n    struct SoACopyMap\n    {\n        uint32_t offset_in_base_struct;\n        uint32_t elem_byte_size;\n    };\n}  // namespace details\n\n\ntemplate &lt;&gt;\nclass SubFieldImpl&lt;FieldEntryLayout::SoA&gt; : public SubFieldInterface\n{\n    friend class SubField;\n\n    DeviceBuffer&lt;details::SoACopyMap&gt; m_copy_map_buffer;\n    std::vector&lt;details::SoACopyMap&gt;  m_h_copy_map_buffer;\n    uint32_t                          m_base_struct_stride = ~0;\n\n  protected:\n    virtual void build_impl() override;\n    virtual size_t require_total_buffer_byte_size(size_t element_count) override;\n    virtual void calculate_new_cores(std::byte*           byte_buffer,\n                                     size_t               total_bytes,\n                                     size_t               element_count,\n                                     span&lt;FieldEntryCore&gt; new_cores) override;\n    virtual bool allow_inplace_shrink() const { return false; }\n\n  public:\n    using SubFieldInterface::SubFieldInterface;\n    virtual ~SubFieldImpl() override = default;\n};\n}  // namespace muda\n\n#include \"details/soa_sub_field.inl\"\n</code></pre>"},{"location":"muda/sub__field_8h/","title":"File sub_field.h","text":"<p>FileList &gt; ext &gt; field &gt; sub_field.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;muda/tools/host_device_string_cache.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_build_options.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_type.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_builder.h&gt;</code></li> <li><code>#include \"details/sub_field.inl\"</code></li> </ul>"},{"location":"muda/sub__field_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/sub__field_8h/#classes","title":"Classes","text":"Type Name class SubField <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/sub_field.h</code></p>"},{"location":"muda/sub__field_8h_source/","title":"File sub_field.h","text":"<p>File List &gt; ext &gt; field &gt; sub_field.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;muda/tools/host_device_string_cache.h&gt;\n#include &lt;muda/ext/field/field_build_options.h&gt;\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/ext/field/field_entry_type.h&gt;\n#include &lt;muda/ext/field/field_builder.h&gt;\n\nnamespace muda\n{\nclass Field;\nclass FieldEntryBase;\ntemplate &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\nclass FieldEntry;\nclass SubFieldInterface;\n\nclass SubField\n{\n    template &lt;typename T&gt;\n    using U = std::unique_ptr&lt;T&gt;;\n\n    Field&amp;               m_field;\n    std::string          m_name;\n    U&lt;SubFieldInterface&gt; m_interface;\n    bool                 m_is_built = false;\n\n    std::byte* data_buffer() const;\n    size_t     num_entries() const;\n\n    FieldEntryBase* find_entry(std::string_view name) const;\n\n    template &lt;typename FieldEntryT&gt;\n    FieldEntryT* find_entry(std::string_view name) const;\n\n  public:\n    SubField(Field&amp; field, std::string_view name);\n    ~SubField();\n\n    std::string_view name() const { return m_name; }\n\n    size_t size() const;\n    void   resize(size_t num_elements);\n\n    template &lt;FieldEntryLayout Layout&gt;\n    FieldBuilder&lt;Layout&gt; builder(FieldEntryLayoutInfo layout = FieldEntryLayoutInfo{Layout},\n                                 const FieldBuildOptions&amp; options = {});\n    FieldBuilder&lt;FieldEntryLayout::RuntimeLayout&gt; builder(FieldEntryLayoutInfo layout,\n                                                          const FieldBuildOptions&amp; options = {});\n    FieldBuilder&lt;FieldEntryLayout::AoSoA&gt; AoSoA(uint32_t innermost_array_size = 32,\n                                                const FieldBuildOptions&amp; options = {});\n    FieldBuilder&lt;FieldEntryLayout::SoA&gt; SoA(const FieldBuildOptions&amp; options = {});\n    FieldBuilder&lt;FieldEntryLayout::AoS&gt; AoS(const FieldBuildOptions&amp; options = {});\n\n    // delete copy and move\n    SubField(const SubField&amp;)            = delete;\n    SubField(SubField&amp;&amp;)                 = delete;\n    SubField&amp; operator=(const SubField&amp;) = delete;\n    SubField&amp; operator=(SubField&amp;&amp;)      = delete;\n\n  private:\n    friend class Field;\n    friend class SubField;\n    template &lt;FieldEntryLayout Layout&gt;\n    friend class FieldBuilder;\n    friend class FieldEntryBase;\n    template &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\n    friend class FieldEntry;\n\n    template &lt;typename T, FieldEntryLayout Layout, int M, int N&gt;\n    FieldEntry&lt;T, Layout, M, N&gt;&amp; create_entry(std::string_view     name,\n                                              FieldEntryLayoutInfo layout,\n                                              FieldEntryType       type,\n                                              uint2                shape);\n\n    void build(const FieldBuildOptions&amp; options);\n    bool allow_inplace_shrink() const;\n};\n}  // namespace muda\n\n#include \"details/sub_field.inl\"\n</code></pre>"},{"location":"muda/sub__field__interface_8h/","title":"File sub_field_interface.h","text":"<p>FileList &gt; ext &gt; field &gt; sub_field_interface.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_build_options.h&gt;</code></li> <li><code>#include &lt;muda/ext/field/field_entry_type.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;muda/mstl/span.h&gt;</code></li> <li><code>#include \"details/sub_field_interface.inl\"</code></li> </ul>"},{"location":"muda/sub__field__interface_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/sub__field__interface_8h/#classes","title":"Classes","text":"Type Name class SubFieldInterface <p>The documentation for this class was generated from the following file <code>src/muda/ext/field/sub_field_interface.h</code></p>"},{"location":"muda/sub__field__interface_8h_source/","title":"File sub_field_interface.h","text":"<p>File List &gt; ext &gt; field &gt; sub_field_interface.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;muda/ext/field/field_build_options.h&gt;\n#include &lt;muda/ext/field/field_entry_type.h&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;muda/mstl/span.h&gt;\n\nnamespace muda\n{\nclass Field;\nclass FieldEntryBase;\n\nclass SubFieldInterface\n{\n    template &lt;typename T&gt;\n    using U = std::unique_ptr&lt;T&gt;;\n    friend class SubField;\n    template &lt;FieldEntryLayout Layout&gt;\n    friend class FieldBuilder;\n\n  protected:\n    Field&amp;                                  m_field;\n    std::vector&lt;U&lt;FieldEntryBase&gt;&gt;          m_entries;\n    FieldEntryLayoutInfo                    m_layout_info;\n    FieldBuildOptions                       m_build_options;\n    std::unordered_map&lt;std::string, size_t&gt; m_name_to_index;\n    size_t                                  m_num_elements     = 0;\n    uint32_t                                m_struct_stride    = ~0;\n    std::byte*                              m_data_buffer      = nullptr;\n    size_t                                  m_data_buffer_size = 0;\n\n    /***************************************************************************************************\n                                            Subclass Implement\n    ****************************************************************************************************/\n    virtual void   build_impl()                                         = 0;\n    virtual size_t require_total_buffer_byte_size(size_t element_count) = 0;\n    virtual void   calculate_new_cores(std::byte*           byte_buffer,\n                                       size_t               total_bytes,\n                                       size_t               element_count,\n                                       span&lt;FieldEntryCore&gt; new_cores)  = 0;\n    virtual bool   allow_inplace_shrink() const { return true; }\n\n\n    /***************************************************************************************************\n                                            Common Utilities\n    ****************************************************************************************************/\n    const FieldEntryLayoutInfo&amp; layout_info() const { return m_layout_info; }\n    const FieldBuildOptions&amp; build_options() const { return m_build_options; }\n    size_t                   num_elements() const { return m_num_elements; }\n    static uint32_t round_up(uint32_t total, uint32_t N);\n    static uint32_t align(uint32_t offset, uint32_t size, uint32_t min_alignment, uint32_t max_alignment);\n  public:\n    SubFieldInterface(Field&amp; field) MUDA_NOEXCEPT : m_field(field) {}\n    virtual ~SubFieldInterface();\n\n    // delete copy and move\n    SubFieldInterface(const SubFieldInterface&amp;)            = delete;\n    SubFieldInterface&amp; operator=(const SubFieldInterface&amp;) = delete;\n    SubFieldInterface(SubFieldInterface&amp;&amp;)                 = delete;\n    SubFieldInterface&amp; operator=(SubFieldInterface&amp;&amp;)      = delete;\n\n  private:\n    // used to resize the entry buffer.\n    std::vector&lt;FieldEntryCore&gt;                   m_new_cores;\n    std::vector&lt;HostDeviceConfig&lt;FieldEntryCore&gt;&gt; m_host_device_new_cores;\n\n    /***************************************************************************************************\n                                            Internal Utilities\n    ****************************************************************************************************/\n    void aync_upload_cores();\n    void async_upload_temp_cores();\n    template &lt;typename F&gt;  // F: void(std::byte* old_ptr, size_t old_size, std::byte* new_ptr, size_t new_size)\n    void resize_data_buffer(size_t size, F&amp;&amp; func);\n\n    /***************************************************************************************************\n                                             SubField Using Only\n    ****************************************************************************************************/\n    void resize(size_t num_elements);\n    void build();\n};\n}  // namespace muda\n\n#include \"details/sub_field_interface.inl\"\n</code></pre>"},{"location":"muda/dir_e05e4ae50bce28830f3a7b1d7f2eeff2/","title":"Dir src/muda/ext/geo","text":"<p>FileList &gt; ext &gt; geo</p>"},{"location":"muda/dir_e05e4ae50bce28830f3a7b1d7f2eeff2/#files","title":"Files","text":"Type Name file distance.h distance calculation for point/edge/triangle file lbvh.h file spatial_hash.h"},{"location":"muda/dir_e05e4ae50bce28830f3a7b1d7f2eeff2/#directories","title":"Directories","text":"Type Name dir distance dir lbvh dir spatial_hash <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/</code></p>"},{"location":"muda/distance_8h/","title":"File distance.h","text":"<p>FileList &gt; ext &gt; geo &gt; distance.h</p> <p>Go to the source code of this file</p> <p>distance calculation for point/edge/triangle More...</p> <ul> <li><code>#include &lt;muda/ext/geo/distance/distance_unclassified.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/distance/ccd.h&gt;</code></li> </ul>"},{"location":"muda/distance_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>MuGdxy </p> <p>Date:</p> <p>February 2024</p> <p>All files in directory <code>./distance/</code> is referenced from the following repository:</p> <p>https://github.com/ipc-sim/Codim-IPC/tree/main/Library/Math/Distance</p> <ul> <li>To make it more readable, logically consistent and GPU compatible, the original code is modified.</li> <li>Thanks to the original author for the great work.</li> <li>The original code is licensed under the Apache License, Version 2.0. </li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance.h</code></p>"},{"location":"muda/distance_8h_source/","title":"File distance.h","text":"<p>File List &gt; ext &gt; geo &gt; distance.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n/*****************************************************************/\n\n#include &lt;muda/ext/geo/distance/distance_unclassified.h&gt;\n#include &lt;muda/ext/geo/distance/ccd.h&gt;\n</code></pre>"},{"location":"muda/lbvh_8h/","title":"File lbvh.h","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/geo/lbvh/lbvh.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh.h</code></p>"},{"location":"muda/lbvh_8h_source/","title":"File lbvh.h","text":"<p>File List &gt; ext &gt; geo &gt; lbvh.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/geo/lbvh/lbvh.h&gt;\n\n//The main implementation of the LBVH is from Toru Niina (https://github.com/ToruNiina/lbvh)\n// with MIT license.\n// muda modified the code to fit the muda framework.\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2019 Toru Niina\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n</code></pre>"},{"location":"muda/spatial__hash_8h/","title":"File spatial_hash.h","text":"<p>FileList &gt; ext &gt; geo &gt; spatial_hash.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/geo/spatial_hash/sparse_spatial_hash.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash.h</code></p>"},{"location":"muda/spatial__hash_8h_source/","title":"File spatial_hash.h","text":"<p>File List &gt; ext &gt; geo &gt; spatial_hash.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/geo/spatial_hash/sparse_spatial_hash.h&gt;\n</code></pre>"},{"location":"muda/dir_eb002c7e2ab9cc8eedb85ee6f0f5ffd4/","title":"Dir src/muda/ext/geo/distance","text":"<p>FileList &gt; distance</p>"},{"location":"muda/dir_eb002c7e2ab9cc8eedb85ee6f0f5ffd4/#files","title":"Files","text":"Type Name file ccd.h file distance_type.h file distance_unclassified.h file edge_edge.h file edge_edge_mollified.h file point_edge.h file point_point.h file point_triangle.h <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/</code></p>"},{"location":"muda/ccd_8h/","title":"File ccd.h","text":"<p>FileList &gt; distance &gt; ccd.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/distance/distance_type.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/distance/distance_unclassified.h&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include \"details/ccd.inl\"</code></li> </ul>"},{"location":"muda/ccd_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace distance <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/ccd.h</code></p>"},{"location":"muda/ccd_8h_source/","title":"File ccd.h","text":"<p>File List &gt; distance &gt; ccd.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/geo/distance/distance_type.h&gt;\n#include &lt;muda/ext/geo/distance/distance_unclassified.h&gt;\n#include &lt;cmath&gt;\n\n//ref: https://github.com/ipc-sim/Codim-IPC/tree/main/Library/Math/Distance\nnamespace muda::distance\n{\ntemplate &lt;typename T, int dim&gt;\nMUDA_GENERIC bool point_edge_cd_broadphase(const Eigen::Matrix&lt;T, dim, 1&gt;&amp; x0,\n                                           const Eigen::Matrix&lt;T, dim, 1&gt;&amp; x1,\n                                           const Eigen::Matrix&lt;T, dim, 1&gt;&amp; x2,\n                                           T dist);\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool point_edge_ccd_broadphase(const Eigen::Matrix&lt;T, 2, 1&gt;&amp; p,\n                                            const Eigen::Matrix&lt;T, 2, 1&gt;&amp; e0,\n                                            const Eigen::Matrix&lt;T, 2, 1&gt;&amp; e1,\n                                            const Eigen::Matrix&lt;T, 2, 1&gt;&amp; dp,\n                                            const Eigen::Matrix&lt;T, 2, 1&gt;&amp; de0,\n                                            const Eigen::Matrix&lt;T, 2, 1&gt;&amp; de1,\n                                            T                             dist);\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool point_triangle_cd_broadphase(const Eigen::Matrix&lt;T, 3, 1&gt;&amp; p,\n                                               const Eigen::Matrix&lt;T, 3, 1&gt;&amp; t0,\n                                               const Eigen::Matrix&lt;T, 3, 1&gt;&amp; t1,\n                                               const Eigen::Matrix&lt;T, 3, 1&gt;&amp; t2,\n                                               T dist);\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool edge_edge_cd_broadphase(const Eigen::Matrix&lt;T, 3, 1&gt;&amp; ea0,\n                                          const Eigen::Matrix&lt;T, 3, 1&gt;&amp; ea1,\n                                          const Eigen::Matrix&lt;T, 3, 1&gt;&amp; eb0,\n                                          const Eigen::Matrix&lt;T, 3, 1&gt;&amp; eb1,\n                                          T                             dist);\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool point_triangle_ccd_broadphase(const Eigen::Matrix&lt;T, 3, 1&gt;&amp; p,\n                                                const Eigen::Matrix&lt;T, 3, 1&gt;&amp; t0,\n                                                const Eigen::Matrix&lt;T, 3, 1&gt;&amp; t1,\n                                                const Eigen::Matrix&lt;T, 3, 1&gt;&amp; t2,\n                                                const Eigen::Matrix&lt;T, 3, 1&gt;&amp; dp,\n                                                const Eigen::Matrix&lt;T, 3, 1&gt;&amp; dt0,\n                                                const Eigen::Matrix&lt;T, 3, 1&gt;&amp; dt1,\n                                                const Eigen::Matrix&lt;T, 3, 1&gt;&amp; dt2,\n                                                T dist);\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool edge_edge_ccd_broadphase(const Eigen::Matrix&lt;T, 3, 1&gt;&amp; ea0,\n                                           const Eigen::Matrix&lt;T, 3, 1&gt;&amp; ea1,\n                                           const Eigen::Matrix&lt;T, 3, 1&gt;&amp; eb0,\n                                           const Eigen::Matrix&lt;T, 3, 1&gt;&amp; eb1,\n                                           const Eigen::Matrix&lt;T, 3, 1&gt;&amp; dea0,\n                                           const Eigen::Matrix&lt;T, 3, 1&gt;&amp; dea1,\n                                           const Eigen::Matrix&lt;T, 3, 1&gt;&amp; deb0,\n                                           const Eigen::Matrix&lt;T, 3, 1&gt;&amp; deb1,\n                                           T                             dist);\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool point_edge_ccd_broadphase(const Eigen::Matrix&lt;T, 3, 1&gt;&amp; p,\n                                            const Eigen::Matrix&lt;T, 3, 1&gt;&amp; e0,\n                                            const Eigen::Matrix&lt;T, 3, 1&gt;&amp; e1,\n                                            const Eigen::Matrix&lt;T, 3, 1&gt;&amp; dp,\n                                            const Eigen::Matrix&lt;T, 3, 1&gt;&amp; de0,\n                                            const Eigen::Matrix&lt;T, 3, 1&gt;&amp; de1,\n                                            T                             dist);\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool point_point_ccd_broadphase(const Eigen::Matrix&lt;T, 3, 1&gt;&amp; p0,\n                                             const Eigen::Matrix&lt;T, 3, 1&gt;&amp; p1,\n                                             const Eigen::Matrix&lt;T, 3, 1&gt;&amp; dp0,\n                                             const Eigen::Matrix&lt;T, 3, 1&gt;&amp; dp1,\n                                             T dist);\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool point_triangle_ccd(Eigen::Matrix&lt;T, 3, 1&gt; p,\n                                     Eigen::Matrix&lt;T, 3, 1&gt; t0,\n                                     Eigen::Matrix&lt;T, 3, 1&gt; t1,\n                                     Eigen::Matrix&lt;T, 3, 1&gt; t2,\n                                     Eigen::Matrix&lt;T, 3, 1&gt; dp,\n                                     Eigen::Matrix&lt;T, 3, 1&gt; dt0,\n                                     Eigen::Matrix&lt;T, 3, 1&gt; dt1,\n                                     Eigen::Matrix&lt;T, 3, 1&gt; dt2,\n                                     T                      eta,\n                                     T                      thickness,\n                                     int                    max_iter,\n                                     T&amp;                     toc);\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool edge_edge_ccd(Eigen::Matrix&lt;T, 3, 1&gt; ea0,\n                                Eigen::Matrix&lt;T, 3, 1&gt; ea1,\n                                Eigen::Matrix&lt;T, 3, 1&gt; eb0,\n                                Eigen::Matrix&lt;T, 3, 1&gt; eb1,\n                                Eigen::Matrix&lt;T, 3, 1&gt; dea0,\n                                Eigen::Matrix&lt;T, 3, 1&gt; dea1,\n                                Eigen::Matrix&lt;T, 3, 1&gt; deb0,\n                                Eigen::Matrix&lt;T, 3, 1&gt; deb1,\n                                T                      eta,\n                                T                      thickness,\n                                int                    max_iter,\n                                T&amp;                     toc);\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool point_edge_ccd(const Eigen::Matrix&lt;T, 2, 1&gt;&amp; x0,\n                                 const Eigen::Matrix&lt;T, 2, 1&gt;&amp; x1,\n                                 const Eigen::Matrix&lt;T, 2, 1&gt;&amp; x2,\n                                 const Eigen::Matrix&lt;T, 2, 1&gt;&amp; d0,\n                                 const Eigen::Matrix&lt;T, 2, 1&gt;&amp; d1,\n                                 const Eigen::Matrix&lt;T, 2, 1&gt;&amp; d2,\n                                 T                             eta,\n                                 T&amp;                            toc);\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool point_edge_ccd(Eigen::Matrix&lt;T, 3, 1&gt; p,\n                                 Eigen::Matrix&lt;T, 3, 1&gt; e0,\n                                 Eigen::Matrix&lt;T, 3, 1&gt; e1,\n                                 Eigen::Matrix&lt;T, 3, 1&gt; dp,\n                                 Eigen::Matrix&lt;T, 3, 1&gt; de0,\n                                 Eigen::Matrix&lt;T, 3, 1&gt; de1,\n                                 T                      eta,\n                                 T                      thickness,\n                                 int                    max_iter,\n                                 T&amp;                     toc);\ntemplate &lt;typename T&gt;\nMUDA_GENERIC bool point_point_ccd(Eigen::Matrix&lt;T, 3, 1&gt; p0,\n                                  Eigen::Matrix&lt;T, 3, 1&gt; p1,\n                                  Eigen::Matrix&lt;T, 3, 1&gt; dp0,\n                                  Eigen::Matrix&lt;T, 3, 1&gt; dp1,\n                                  T                      eta,\n                                  T                      thickness,\n                                  int                    max_iter,\n                                  T&amp;                     toc);\n}  // namespace muda\n\n#include \"details/ccd.inl\"\n</code></pre>"},{"location":"muda/distance__type_8h/","title":"File distance_type.h","text":"<p>FileList &gt; distance &gt; distance_type.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/tools/debug_log.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;Eigen/Geometry&gt;</code></li> <li><code>#include \"details/distance_type.inl\"</code></li> </ul>"},{"location":"muda/distance__type_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace distance <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/distance_type.h</code></p>"},{"location":"muda/distance__type_8h_source/","title":"File distance_type.h","text":"<p>File List &gt; distance &gt; distance_type.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/tools/debug_log.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;Eigen/Geometry&gt;\n\nnamespace muda::distance\n{\nenum class PointPointDistanceType : unsigned char\n{\n    PP = 0,  // point-point, the shortest distance is the distance between the two points\n};\n\nenum class PointEdgeDistanceType : unsigned char\n{\n    PP_PE0 = 0,  // point-edge, the shortest distance is the distance between the point and the point 0 in edge\n    PP_PE1 = 1,  // point-edge, the shortest distance is the distance between the point and the point 1 in edge\n    PE = 2,  // point-edge, the shortest distance is the distance between the point and some point on the edge\n};\n\nenum class PointTriangleDistanceType : unsigned char\n{\n    PP_PT0 = 0,  // point-triangle, the closest point is the point 0 in triangle\n    PP_PT1 = 1,  // point-triangle, the closest point is the point 1 in triangle\n    PP_PT2 = 2,  // point-triangle, the closest point is the point 2 in triangle\n    PE_PT0T1 = 3,  // point-triangle, the closest point is on the edge (t0, t1)\n    PE_PT1T2 = 4,  // point-triangle, the closest point is on the edge (t1, t2)\n    PE_PT2T0 = 5,  // point-triangle, the closest point is on the edge (t2, t0)\n    PT       = 6,  // point-triangle, the closest point is on the triangle\n};\n\nenum class EdgeEdgeDistanceType : unsigned char\n{\n    PP_Ea0Eb0 = 0,  // point-point, the shortest distance is the distance between the point 0 in edge a and the point 0 in edge b\n    PP_Ea0Eb1 = 1,  // point-point, the shortest distance is the distance between the point 0 in edge a and the point 1 in edge b\n    PE_Ea0Eb0Eb1 = 2,  // point-edge, the shortest distance is the distance between the point 0 in edge a and some point the edge b\n    PP_Ea1Eb0 = 3,  // point-point, the shortest distance is the distance between the point 1 in edge a and the point 0 in edge b\n    PP_Ea1Eb1 = 4,  // point-point, the shortest distance is the distance between the point 1 in edge a and the point 1 in edge b\n    PE_Ea1Eb0Eb1 = 5,  // point-edge, the shortest distance is the distance between the point 1 in edge a and some point the edge b\n    PE_Eb0Ea0Ea1 = 6,  // point-edge, the shortest distance is the distance between the point 0 in edge b and some point the edge a\n    PE_Eb1Ea0Ea1 = 7,  // point-edge, the shortest distance is the distance between the point 1 in edge b and some point the edge a\n    EE = 8,  // edge-edge, the shortest distance is the distance between some point on edge a and some point on edge b\n};\n\n\ntemplate &lt;class T, int dim&gt;\nMUDA_GENERIC PointPointDistanceType point_point_distance_type(\n    const Eigen::Vector&lt;T, dim&gt;&amp; p0, const Eigen::Vector&lt;T, dim&gt;&amp; p1);\n\ntemplate &lt;class T, int dim&gt;\nMUDA_GENERIC PointEdgeDistanceType\npoint_edge_distance_type(const Eigen::Vector&lt;T, dim&gt;&amp; p,\n                         const Eigen::Vector&lt;T, dim&gt;&amp; e0,\n                         const Eigen::Vector&lt;T, dim&gt;&amp; e1);\n\ntemplate &lt;class T, int dim&gt;\nMUDA_GENERIC PointEdgeDistanceType\npoint_edge_distance_type(const Eigen::Vector&lt;T, dim&gt;&amp; p,\n                         const Eigen::Vector&lt;T, dim&gt;&amp; e0,\n                         const Eigen::Vector&lt;T, dim&gt;&amp; e1,\n                         T&amp;                           ratio);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC PointTriangleDistanceType\npoint_triangle_distance_type(const Eigen::Vector&lt;T, 3&gt;&amp; p,\n                             const Eigen::Vector&lt;T, 3&gt;&amp; t0,\n                             const Eigen::Vector&lt;T, 3&gt;&amp; t1,\n                             const Eigen::Vector&lt;T, 3&gt;&amp; t2);\n\n// a more robust implementation of http://geomalgorithms.com/a07-_distance.html\ntemplate &lt;class T&gt;\nMUDA_GENERIC EdgeEdgeDistanceType edge_edge_distance_type(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                                          const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                                          const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                                          const Eigen::Vector&lt;T, 3&gt;&amp; eb1);\n\n}  // namespace muda::distance\n\n#include \"details/distance_type.inl\"\n</code></pre>"},{"location":"muda/distance__unclassified_8h/","title":"File distance_unclassified.h","text":"<p>FileList &gt; distance &gt; distance_unclassified.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/distance/distance_type.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/distance/point_triangle.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/distance/point_edge.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/distance/point_point.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/distance/edge_edge.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/distance/edge_edge_mollified.h&gt;</code></li> <li><code>#include \"details/distance_unclassified.inl\"</code></li> </ul>"},{"location":"muda/distance__unclassified_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace distance <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/distance_unclassified.h</code></p>"},{"location":"muda/distance__unclassified_8h_source/","title":"File distance_unclassified.h","text":"<p>File List &gt; distance &gt; distance_unclassified.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/geo/distance/distance_type.h&gt;\n#include &lt;muda/ext/geo/distance/point_triangle.h&gt;\n#include &lt;muda/ext/geo/distance/point_edge.h&gt;\n#include &lt;muda/ext/geo/distance/point_point.h&gt;\n#include &lt;muda/ext/geo/distance/edge_edge.h&gt;\n#include &lt;muda/ext/geo/distance/edge_edge_mollified.h&gt;\n\nnamespace muda::distance\n{\ntemplate &lt;class T&gt;\nMUDA_GENERIC void point_point_distance_unclassified(const Eigen::Vector&lt;T, 3&gt;&amp; p0,\n                                                    const Eigen::Vector&lt;T, 3&gt;&amp; p1,\n                                                    T&amp; dist2);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void point_triangle_distance_unclassified(const Eigen::Vector&lt;T, 3&gt;&amp; p,\n                                                       const Eigen::Vector&lt;T, 3&gt;&amp; t0,\n                                                       const Eigen::Vector&lt;T, 3&gt;&amp; t1,\n                                                       const Eigen::Vector&lt;T, 3&gt;&amp; t2,\n                                                       T&amp; dist2);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_distance_unclassified(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                                  const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                                  const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                                  const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                                  T&amp; dist2);\n\n// http://geomalgorithms.com/a02-_lines.html\ntemplate &lt;class T&gt;\nMUDA_GENERIC void point_edge_distance_unclassified(const Eigen::Vector&lt;T, 3&gt;&amp; p,\n                                                   const Eigen::Vector&lt;T, 3&gt;&amp; e0,\n                                                   const Eigen::Vector&lt;T, 3&gt;&amp; e1,\n                                                   T&amp; dist2);\n\n}  // namespace muda::distance\n\n#include \"details/distance_unclassified.inl\"\n</code></pre>"},{"location":"muda/edge__edge_8h/","title":"File edge_edge.h","text":"<p>FileList &gt; distance &gt; edge_edge.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include \"details/edge_edge.inl\"</code></li> </ul>"},{"location":"muda/edge__edge_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace distance <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/edge_edge.h</code></p>"},{"location":"muda/edge__edge_8h_source/","title":"File edge_edge.h","text":"<p>File List &gt; distance &gt; edge_edge.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::distance\n{\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_distance(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                     const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                     const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                     const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                     T&amp;                         dist2);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_distance_gradient(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                              const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                              const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                              const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                              Eigen::Vector&lt;T, 12&gt;&amp;      grad);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_distance_hessian(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                             const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                             const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                             const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                             Eigen::Matrix&lt;T, 12, 12&gt;&amp; Hessian);\n\n}  // namespace muda\n\n#include \"details/edge_edge.inl\"\n</code></pre>"},{"location":"muda/edge__edge__mollified_8h/","title":"File edge_edge_mollified.h","text":"<p>FileList &gt; distance &gt; edge_edge_mollified.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include \"details/edge_edge_mollified.inl\"</code></li> </ul>"},{"location":"muda/edge__edge__mollified_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace distance <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/edge_edge_mollified.h</code></p>"},{"location":"muda/edge__edge__mollified_8h_source/","title":"File edge_edge_mollified.h","text":"<p>File List &gt; distance &gt; edge_edge_mollified.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::distance\n{\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_cross_norm2(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                        const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                        const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                        const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                        T&amp;                         result);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_cross_norm2_gradient(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                                 const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                                 const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                                 const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                                 Eigen::Vector&lt;T, 12&gt;&amp; grad);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_cross_norm2_hessian(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                                const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                                const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                                const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                                Eigen::Matrix&lt;T, 12, 12&gt;&amp; Hessian);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_mollifier(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                      const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                      const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                      const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                      T                          eps_x,\n                                      T&amp;                         e);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_mollifier_gradient(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                               const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                               const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                               const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                               T                          eps_x,\n                                               Eigen::Vector&lt;T, 12&gt;&amp;      g);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_mollifier_hessian(const Eigen::Vector&lt;T, 3&gt;&amp; ea0,\n                                              const Eigen::Vector&lt;T, 3&gt;&amp; ea1,\n                                              const Eigen::Vector&lt;T, 3&gt;&amp; eb0,\n                                              const Eigen::Vector&lt;T, 3&gt;&amp; eb1,\n                                              T                          eps_x,\n                                              Eigen::Matrix&lt;T, 12, 12&gt;&amp;  H);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void edge_edge_mollifier_threshold(const Eigen::Vector&lt;T, 3&gt;&amp; ea0_rest,\n                                                const Eigen::Vector&lt;T, 3&gt;&amp; ea1_rest,\n                                                const Eigen::Vector&lt;T, 3&gt;&amp; eb0_rest,\n                                                const Eigen::Vector&lt;T, 3&gt;&amp; eb1_rest,\n                                                T&amp; eps_x);\n}  // namespace muda::distance\n\n#include \"details/edge_edge_mollified.inl\"\n</code></pre>"},{"location":"muda/point__edge_8h/","title":"File point_edge.h","text":"<p>FileList &gt; distance &gt; point_edge.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include \"details/point_edge.inl\"</code></li> </ul>"},{"location":"muda/point__edge_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace distance <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/point_edge.h</code></p>"},{"location":"muda/point__edge_8h_source/","title":"File point_edge.h","text":"<p>File List &gt; distance &gt; point_edge.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::distance\n{\ntemplate &lt;class T, int dim&gt;\nMUDA_GENERIC void point_edge_distance(const Eigen::Vector&lt;T, dim&gt;&amp; p,\n                                      const Eigen::Vector&lt;T, dim&gt;&amp; e0,\n                                      const Eigen::Vector&lt;T, dim&gt;&amp; e1,\n                                      T&amp;                           dist2);\n\ntemplate &lt;class T, int dim&gt;\nMUDA_GENERIC void point_edge_distance_gradient(const Eigen::Vector&lt;T, dim&gt;&amp; p,\n                                               const Eigen::Vector&lt;T, dim&gt;&amp; e0,\n                                               const Eigen::Vector&lt;T, dim&gt;&amp; e1,\n                                               Eigen::Vector&lt;T, dim * 3&gt;&amp; grad);\n\ntemplate &lt;class T, int dim&gt;\nMUDA_GENERIC void point_edge_distance_hessian(const Eigen::Vector&lt;T, dim&gt;&amp; p,\n                                              const Eigen::Vector&lt;T, dim&gt;&amp; e0,\n                                              const Eigen::Vector&lt;T, dim&gt;&amp; e1,\n                                              Eigen::Matrix&lt;T, dim * 3, dim * 3&gt;&amp; Hessian);\n\n}  // namespace muda::distance\n\n#include \"details/point_edge.inl\"\n</code></pre>"},{"location":"muda/point__point_8h/","title":"File point_point.h","text":"<p>FileList &gt; distance &gt; point_point.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include \"details/point_point.inl\"</code></li> </ul>"},{"location":"muda/point__point_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace distance <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/point_point.h</code></p>"},{"location":"muda/point__point_8h_source/","title":"File point_point.h","text":"<p>File List &gt; distance &gt; point_point.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::distance\n{\ntemplate &lt;class T, int dim&gt;\nMUDA_GENERIC void point_point_distance(const Eigen::Vector&lt;T, dim&gt;&amp; a,\n                                       const Eigen::Vector&lt;T, dim&gt;&amp; b,\n                                       T&amp;                           dist2);\n\ntemplate &lt;class T, int dim&gt;\nMUDA_GENERIC void point_point_distance_gradient(const Eigen::Vector&lt;T, dim&gt;&amp; a,\n                                                const Eigen::Vector&lt;T, dim&gt;&amp; b,\n                                                Eigen::Vector&lt;T, dim * 2&gt;&amp; grad);\n\ntemplate &lt;class T, int dim&gt;\nMUDA_GENERIC void point_point_distance_hessian(const Eigen::Vector&lt;T, dim&gt;&amp; a,\n                                               const Eigen::Vector&lt;T, dim&gt;&amp; b,\n                                               Eigen::Matrix&lt;T, dim * 2, dim * 2&gt;&amp; Hessian);\n}  // namespace muda::distance\n\n#include \"details/point_point.inl\"\n</code></pre>"},{"location":"muda/point__triangle_8h/","title":"File point_triangle.h","text":"<p>FileList &gt; distance &gt; point_triangle.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include \"details/point_triangle.inl\"</code></li> </ul>"},{"location":"muda/point__triangle_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace distance <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/distance/point_triangle.h</code></p>"},{"location":"muda/point__triangle_8h_source/","title":"File point_triangle.h","text":"<p>File List &gt; distance &gt; point_triangle.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::distance\n{\ntemplate &lt;class T&gt;\nMUDA_GENERIC void point_triangle_distance(const Eigen::Vector&lt;T, 3&gt;&amp; p,\n                                          const Eigen::Vector&lt;T, 3&gt;&amp; t0,\n                                          const Eigen::Vector&lt;T, 3&gt;&amp; t1,\n                                          const Eigen::Vector&lt;T, 3&gt;&amp; t2,\n                                          T&amp;                         dist2);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void point_triangle_distance_gradient(const Eigen::Vector&lt;T, 3&gt;&amp; p,\n                                                   const Eigen::Vector&lt;T, 3&gt;&amp; t0,\n                                                   const Eigen::Vector&lt;T, 3&gt;&amp; t1,\n                                                   const Eigen::Vector&lt;T, 3&gt;&amp; t2,\n                                                   Eigen::Vector&lt;T, 12&gt;&amp; grad);\n\ntemplate &lt;class T&gt;\nMUDA_GENERIC void point_triangle_distance_hessian(const Eigen::Vector&lt;T, 3&gt;&amp; p,\n                                                  const Eigen::Vector&lt;T, 3&gt;&amp; t0,\n                                                  const Eigen::Vector&lt;T, 3&gt;&amp; t1,\n                                                  const Eigen::Vector&lt;T, 3&gt;&amp; t2,\n                                                  Eigen::Matrix&lt;T, 12, 12&gt;&amp; Hessian);\n}  // namespace muda::distance\n\n#include \"details/point_triangle.inl\"\n</code></pre>"},{"location":"muda/dir_f585754cebe27fbe41288242344b0f7f/","title":"Dir src/muda/ext/geo/lbvh","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh</p>"},{"location":"muda/dir_f585754cebe27fbe41288242344b0f7f/#files","title":"Files","text":"Type Name file aabb.h file bvh.h file bvh_viewer.h file lbvh.h file morton_code.h file predicator.h file query.h file utility.h <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/</code></p>"},{"location":"muda/aabb_8h/","title":"File aabb.h","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh &gt; aabb.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/geo/lbvh/utility.h&gt;</code></li> <li><code>#include &lt;thrust/swap.h&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> </ul>"},{"location":"muda/aabb_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace lbvh"},{"location":"muda/aabb_8h/#classes","title":"Classes","text":"Type Name struct AABB &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/aabb.h</code></p>"},{"location":"muda/aabb_8h_source/","title":"File aabb.h","text":"<p>File List &gt; ext &gt; geo &gt; lbvh &gt; aabb.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/geo/lbvh/utility.h&gt;\n#include &lt;thrust/swap.h&gt;\n#include &lt;cmath&gt;\n#include &lt;cuda_runtime.h&gt;\n\nnamespace muda::lbvh\n{\ntemplate &lt;typename T&gt;\nstruct AABB\n{\n    typename vector_of&lt;T&gt;::type upper;\n    typename vector_of&lt;T&gt;::type lower;\n\n    MUDA_GENERIC       AABB() noexcept                    = default;\n    MUDA_GENERIC       AABB(const AABB&lt;T&gt;&amp;) noexcept      = default;\n    MUDA_GENERIC       AABB(AABB&lt;T&gt;&amp;&amp;) noexcept           = default;\n    MUDA_GENERIC AABB&amp; operator=(const AABB&lt;T&gt;&amp;) noexcept = default;\n    MUDA_GENERIC AABB&amp; operator=(AABB&lt;T&gt;&amp;&amp;) noexcept      = default;\n};\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC inline bool intersects(const AABB&lt;T&gt;&amp; lhs, const AABB&lt;T&gt;&amp; rhs) noexcept\n{\n    if(lhs.upper.x &lt; rhs.lower.x || rhs.upper.x &lt; lhs.lower.x)\n    {\n        return false;\n    }\n    if(lhs.upper.y &lt; rhs.lower.y || rhs.upper.y &lt; lhs.lower.y)\n    {\n        return false;\n    }\n    if(lhs.upper.z &lt; rhs.lower.z || rhs.upper.z &lt; lhs.lower.z)\n    {\n        return false;\n    }\n    return true;\n}\n\nMUDA_GENERIC inline AABB&lt;double&gt; merge(const AABB&lt;double&gt;&amp; lhs, const AABB&lt;double&gt;&amp; rhs) noexcept\n{\n    AABB&lt;double&gt; merged;\n    merged.upper.x = ::fmax(lhs.upper.x, rhs.upper.x);\n    merged.upper.y = ::fmax(lhs.upper.y, rhs.upper.y);\n    merged.upper.z = ::fmax(lhs.upper.z, rhs.upper.z);\n    merged.lower.x = ::fmin(lhs.lower.x, rhs.lower.x);\n    merged.lower.y = ::fmin(lhs.lower.y, rhs.lower.y);\n    merged.lower.z = ::fmin(lhs.lower.z, rhs.lower.z);\n    return merged;\n}\n\nMUDA_GENERIC inline AABB&lt;float&gt; merge(const AABB&lt;float&gt;&amp; lhs, const AABB&lt;float&gt;&amp; rhs) noexcept\n{\n    AABB&lt;float&gt; merged;\n    merged.upper.x = ::fmaxf(lhs.upper.x, rhs.upper.x);\n    merged.upper.y = ::fmaxf(lhs.upper.y, rhs.upper.y);\n    merged.upper.z = ::fmaxf(lhs.upper.z, rhs.upper.z);\n    merged.lower.x = ::fminf(lhs.lower.x, rhs.lower.x);\n    merged.lower.y = ::fminf(lhs.lower.y, rhs.lower.y);\n    merged.lower.z = ::fminf(lhs.lower.z, rhs.lower.z);\n    return merged;\n}\n\n// metrics defined in\n// Nearest Neighbor Queries (1995) ACS-SIGMOD\n// - Nick Roussopoulos, Stephen Kelley FredericVincent\n\nMUDA_GENERIC inline float mindist(const AABB&lt;float&gt;&amp; lhs, const float4&amp; rhs) noexcept\n{\n    const float dx = ::fminf(lhs.upper.x, ::fmaxf(lhs.lower.x, rhs.x)) - rhs.x;\n    const float dy = ::fminf(lhs.upper.y, ::fmaxf(lhs.lower.y, rhs.y)) - rhs.y;\n    const float dz = ::fminf(lhs.upper.z, ::fmaxf(lhs.lower.z, rhs.z)) - rhs.z;\n    return dx * dx + dy * dy + dz * dz;\n}\n\nMUDA_GENERIC inline double mindist(const AABB&lt;double&gt;&amp; lhs, const double4&amp; rhs) noexcept\n{\n    const double dx = ::fmin(lhs.upper.x, ::fmax(lhs.lower.x, rhs.x)) - rhs.x;\n    const double dy = ::fmin(lhs.upper.y, ::fmax(lhs.lower.y, rhs.y)) - rhs.y;\n    const double dz = ::fmin(lhs.upper.z, ::fmax(lhs.lower.z, rhs.z)) - rhs.z;\n    return dx * dx + dy * dy + dz * dz;\n}\n\nMUDA_GENERIC inline float minmaxdist(const AABB&lt;float&gt;&amp; lhs, const float4&amp; rhs) noexcept\n{\n    float3 rm_sq = make_float3((lhs.lower.x - rhs.x) * (lhs.lower.x - rhs.x),\n                               (lhs.lower.y - rhs.y) * (lhs.lower.y - rhs.y),\n                               (lhs.lower.z - rhs.z) * (lhs.lower.z - rhs.z));\n    float3 rM_sq = make_float3((lhs.upper.x - rhs.x) * (lhs.upper.x - rhs.x),\n                               (lhs.upper.y - rhs.y) * (lhs.upper.y - rhs.y),\n                               (lhs.upper.z - rhs.z) * (lhs.upper.z - rhs.z));\n\n    if((lhs.upper.x + lhs.lower.x) * 0.5f &lt; rhs.x)\n    {\n        thrust::swap(rm_sq.x, rM_sq.x);\n    }\n    if((lhs.upper.y + lhs.lower.y) * 0.5f &lt; rhs.y)\n    {\n        thrust::swap(rm_sq.y, rM_sq.y);\n    }\n    if((lhs.upper.z + lhs.lower.z) * 0.5f &lt; rhs.z)\n    {\n        thrust::swap(rm_sq.z, rM_sq.z);\n    }\n\n    const float dx = rm_sq.x + rM_sq.y + rM_sq.z;\n    const float dy = rM_sq.x + rm_sq.y + rM_sq.z;\n    const float dz = rM_sq.x + rM_sq.y + rm_sq.z;\n    return ::fminf(dx, ::fminf(dy, dz));\n}\n\nMUDA_GENERIC inline double minmaxdist(const AABB&lt;double&gt;&amp; lhs, const double4&amp; rhs) noexcept\n{\n    double3 rm_sq = make_double3((lhs.lower.x - rhs.x) * (lhs.lower.x - rhs.x),\n                                 (lhs.lower.y - rhs.y) * (lhs.lower.y - rhs.y),\n                                 (lhs.lower.z - rhs.z) * (lhs.lower.z - rhs.z));\n    double3 rM_sq = make_double3((lhs.upper.x - rhs.x) * (lhs.upper.x - rhs.x),\n                                 (lhs.upper.y - rhs.y) * (lhs.upper.y - rhs.y),\n                                 (lhs.upper.z - rhs.z) * (lhs.upper.z - rhs.z));\n\n    if((lhs.upper.x + lhs.lower.x) * 0.5 &lt; rhs.x)\n    {\n        thrust::swap(rm_sq.x, rM_sq.x);\n    }\n    if((lhs.upper.y + lhs.lower.y) * 0.5 &lt; rhs.y)\n    {\n        thrust::swap(rm_sq.y, rM_sq.y);\n    }\n    if((lhs.upper.z + lhs.lower.z) * 0.5 &lt; rhs.z)\n    {\n        thrust::swap(rm_sq.z, rM_sq.z);\n    }\n\n    const double dx = rm_sq.x + rM_sq.y + rM_sq.z;\n    const double dy = rM_sq.x + rm_sq.y + rM_sq.z;\n    const double dz = rM_sq.x + rM_sq.y + rm_sq.z;\n    return ::fmin(dx, ::fmin(dy, dz));\n}\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC inline typename vector_of&lt;T&gt;::type centroid(const AABB&lt;T&gt;&amp; box) noexcept\n{\n    typename vector_of&lt;T&gt;::type c;\n    c.x = (box.upper.x + box.lower.x) * 0.5;\n    c.y = (box.upper.y + box.lower.y) * 0.5;\n    c.z = (box.upper.z + box.lower.z) * 0.5;\n    return c;\n}\n\n}  // namespace muda::lbvh\n</code></pre>"},{"location":"muda/bvh_8h/","title":"File bvh.h","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh &gt; bvh.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/geo/lbvh/bvh_viewer.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/aabb.h&gt;</code></li> <li><code>#include &lt;thrust/swap.h&gt;</code></li> <li><code>#include &lt;thrust/pair.h&gt;</code></li> <li><code>#include &lt;thrust/tuple.h&gt;</code></li> <li><code>#include &lt;thrust/host_vector.h&gt;</code></li> <li><code>#include &lt;thrust/device_vector.h&gt;</code></li> <li><code>#include &lt;thrust/functional.h&gt;</code></li> <li><code>#include &lt;thrust/scan.h&gt;</code></li> <li><code>#include &lt;thrust/sort.h&gt;</code></li> <li><code>#include &lt;thrust/fill.h&gt;</code></li> <li><code>#include &lt;thrust/for_each.h&gt;</code></li> <li><code>#include &lt;thrust/transform.h&gt;</code></li> <li><code>#include &lt;thrust/reduce.h&gt;</code></li> <li><code>#include &lt;thrust/iterator/constant_iterator.h&gt;</code></li> <li><code>#include &lt;thrust/iterator/counting_iterator.h&gt;</code></li> <li><code>#include &lt;thrust/unique.h&gt;</code></li> <li><code>#include &lt;thrust/execution_policy.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_reduce.h&gt;</code></li> </ul>"},{"location":"muda/bvh_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace lbvh namespace details"},{"location":"muda/bvh_8h/#classes","title":"Classes","text":"Type Name class BVH &lt;typename Real, typename Object, typename AABBGetter, typename MortonCodeCalculator&gt; struct DefaultMortonCodeCalculator &lt;typename Real, typename Object&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/bvh.h</code></p>"},{"location":"muda/bvh_8h_source/","title":"File bvh.h","text":"<p>File List &gt; ext &gt; geo &gt; lbvh &gt; bvh.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/geo/lbvh/bvh_viewer.h&gt;\n#include &lt;muda/ext/geo/lbvh/aabb.h&gt;\n#include &lt;thrust/swap.h&gt;\n#include &lt;thrust/pair.h&gt;\n#include &lt;thrust/tuple.h&gt;\n#include &lt;thrust/host_vector.h&gt;\n#include &lt;thrust/device_vector.h&gt;\n#include &lt;thrust/functional.h&gt;\n#include &lt;thrust/scan.h&gt;\n#include &lt;thrust/sort.h&gt;\n#include &lt;thrust/fill.h&gt;\n#include &lt;thrust/for_each.h&gt;\n#include &lt;thrust/transform.h&gt;\n#include &lt;thrust/reduce.h&gt;\n#include &lt;thrust/iterator/constant_iterator.h&gt;\n#include &lt;thrust/iterator/counting_iterator.h&gt;\n#include &lt;thrust/unique.h&gt;\n#include &lt;thrust/execution_policy.h&gt;\n#include &lt;muda/cub/device/device_reduce.h&gt;\n\nnamespace muda::lbvh\n{\nnamespace details\n{\n    template &lt;typename DerivedPolicy, typename UInt&gt;\n    void construct_internal_nodes(const thrust::detail::execution_policy_base&lt;DerivedPolicy&gt;&amp; policy,\n                                  Node*          nodes,\n                                  UInt const*    node_code,\n                                  const uint32_t num_objects)\n    {\n        thrust::for_each(\n            policy,\n            thrust::make_counting_iterator&lt;uint32_t&gt;(0),\n            thrust::make_counting_iterator&lt;uint32_t&gt;(num_objects - 1),\n            [nodes, node_code, num_objects] __device__(const uint32_t idx)\n            {\n                nodes[idx].object_idx = 0xFFFFFFFF;  //  internal nodes\n\n                const uint2 ij = determine_range(node_code, num_objects, idx);\n                const int gamma = find_split(node_code, num_objects, ij.x, ij.y);\n\n                nodes[idx].left_idx  = gamma;\n                nodes[idx].right_idx = gamma + 1;\n                if(thrust::min(ij.x, ij.y) == gamma)\n                {\n                    nodes[idx].left_idx += num_objects - 1;\n                }\n                if(thrust::max(ij.x, ij.y) == gamma + 1)\n                {\n                    nodes[idx].right_idx += num_objects - 1;\n                }\n                nodes[nodes[idx].left_idx].parent_idx  = idx;\n                nodes[nodes[idx].right_idx].parent_idx = idx;\n                return;\n            });\n    }\n}  // namespace details\n\ntemplate &lt;typename Real, typename Object&gt;\nstruct DefaultMortonCodeCalculator\n{\n    DefaultMortonCodeCalculator(AABB&lt;Real&gt; w)\n        : whole(w)\n    {\n    }\n    DefaultMortonCodeCalculator()                                   = default;\n    ~DefaultMortonCodeCalculator()                                  = default;\n    DefaultMortonCodeCalculator(DefaultMortonCodeCalculator const&amp;) = default;\n    DefaultMortonCodeCalculator(DefaultMortonCodeCalculator&amp;&amp;)      = default;\n    DefaultMortonCodeCalculator&amp; operator=(DefaultMortonCodeCalculator const&amp;) = default;\n    DefaultMortonCodeCalculator&amp; operator=(DefaultMortonCodeCalculator&amp;&amp;) = default;\n\n    __device__ __host__ inline uint32_t operator()(const Object&amp;, const AABB&lt;Real&gt;&amp; box) noexcept\n    {\n        auto p = centroid(box);\n        p.x -= whole.lower.x;\n        p.y -= whole.lower.y;\n        p.z -= whole.lower.z;\n        p.x /= (whole.upper.x - whole.lower.x);\n        p.y /= (whole.upper.y - whole.lower.y);\n        p.z /= (whole.upper.z - whole.lower.z);\n        return morton_code(p);\n    }\n    AABB&lt;Real&gt; whole;\n};\n\ntemplate &lt;typename Real, typename Object, typename AABBGetter, typename MortonCodeCalculator = DefaultMortonCodeCalculator&lt;Real, Object&gt;&gt;\nclass BVH\n{\n  public:\n    using real_type                   = Real;\n    using index_type                  = std::uint32_t;\n    using object_type                 = Object;\n    using aabb_type                   = AABB&lt;real_type&gt;;\n    using node_type                   = details::Node;\n    using aabb_getter_type            = AABBGetter;\n    using morton_code_calculator_type = MortonCodeCalculator;\n\n  public:\n    BVH()                      = default;\n    ~BVH()                     = default;\n    BVH(const BVH&amp;)            = default;\n    BVH(BVH&amp;&amp;)                 = default;\n    BVH&amp; operator=(const BVH&amp;) = default;\n    BVH&amp; operator=(BVH&amp;&amp;)      = default;\n\n    void clear()\n    {\n        this-&gt;m_objects.clear();\n        this-&gt;m_aabbs.clear();\n        this-&gt;m_nodes.clear();\n        return;\n    }\n\n    BVHViewer&lt;real_type, object_type&gt; viewer() noexcept\n    {\n        return BVHViewer&lt;real_type, object_type&gt;{\n            static_cast&lt;uint32_t&gt;(m_nodes.size()),\n            static_cast&lt;uint32_t&gt;(m_objects.size()),\n            thrust::raw_pointer_cast(m_nodes.data()),\n            thrust::raw_pointer_cast(m_aabbs.data()),\n            thrust::raw_pointer_cast(m_objects.data())};\n    }\n\n    CBVHViewer&lt;real_type, object_type&gt; cviewer() const noexcept\n    {\n        return CBVHViewer&lt;real_type, object_type&gt;{\n            static_cast&lt;uint32_t&gt;(m_nodes.size()),\n            static_cast&lt;uint32_t&gt;(m_objects.size()),\n            thrust::raw_pointer_cast(m_nodes.data()),\n            thrust::raw_pointer_cast(m_aabbs.data()),\n            thrust::raw_pointer_cast(m_objects.data())};\n    }\n\n\n    void build(cudaStream_t stream = nullptr)\n    {\n        auto policy = thrust::system::cuda::par_nosync.on(stream);\n        //auto policy = thrust::device;\n\n        if(m_objects.size() == 0u)\n        {\n            return;\n        }\n\n        m_host_dirty = true;\n\n        const uint32_t num_objects        = m_objects.size();\n        const uint32_t num_internal_nodes = num_objects - 1;\n        const uint32_t num_nodes          = num_objects * 2 - 1;\n\n        // --------------------------------------------------------------------\n        // calculate morton code of each points\n\n        const auto inf = std::numeric_limits&lt;real_type&gt;::infinity();\n        aabb_type  default_aabb;\n        default_aabb.upper.x = -inf;\n        default_aabb.lower.x = inf;\n        default_aabb.upper.y = -inf;\n        default_aabb.lower.y = inf;\n        default_aabb.upper.z = -inf;\n        default_aabb.lower.z = inf;\n\n        this-&gt;m_aabbs.resize(num_nodes, default_aabb);\n        m_morton.resize(num_objects);\n        m_indices.resize(num_objects);\n        m_morton64.resize(num_objects);\n        node_type default_node;\n        default_node.parent_idx = 0xFFFFFFFF;\n        default_node.left_idx   = 0xFFFFFFFF;\n        default_node.right_idx  = 0xFFFFFFFF;\n        default_node.object_idx = 0xFFFFFFFF;\n        m_nodes.resize(num_nodes, default_node);\n        m_flag_container.clear();\n        m_flag_container.resize(num_internal_nodes, 0);\n\n        thrust::transform(policy,\n                          this-&gt;m_objects.begin(),\n                          this-&gt;m_objects.end(),\n                          m_aabbs.begin() + num_internal_nodes,\n                          aabb_getter_type());\n\n        //muda::DeviceReduce(stream).Reduce(\n        //    m_aabbs.data() + num_internal_nodes,\n        //    m_aabb_whole.data(),\n        //    m_aabbs.size() - num_internal_nodes,\n        //    [] CUB_RUNTIME_FUNCTION(const aabb_type&amp; lhs, const aabb_type&amp; rhs) -&gt; aabb_type\n        //    { return merge(lhs, rhs); },\n        //    default_aabb);\n\n        const auto aabb_whole = thrust::reduce(\n            policy,\n            m_aabbs.data() + num_internal_nodes,\n            m_aabbs.data() + m_aabbs.size(),\n            default_aabb,\n            [] __device__ __host__(const aabb_type&amp; lhs, const aabb_type&amp; rhs) -&gt; aabb_type\n            { return merge(lhs, rhs); });\n\n        thrust::transform(policy,\n                          this-&gt;m_objects.begin(),\n                          this-&gt;m_objects.end(),\n                          m_aabbs.begin() + num_internal_nodes,\n                          m_morton.begin(),\n                          morton_code_calculator_type(aabb_whole));\n\n        // --------------------------------------------------------------------\n        // sort object-indices by morton code\n\n        // iota the indices\n        thrust::copy(policy,\n                     thrust::make_counting_iterator&lt;index_type&gt;(0),\n                     thrust::make_counting_iterator&lt;index_type&gt;(num_objects),\n                     m_indices.begin());\n\n        // keep indices ascending order\n        thrust::stable_sort_by_key(\n            policy,\n            m_morton.begin(),\n            m_morton.end(),\n            thrust::make_zip_iterator(thrust::make_tuple(m_aabbs.begin() + num_internal_nodes,\n                                                         m_indices.begin())));\n\n        // --------------------------------------------------------------------\n        // check morton codes are unique\n\n\n        const auto uniqued = thrust::unique_copy(\n            policy, m_morton.begin(), m_morton.end(), m_morton64.begin());\n\n        const bool morton_code_is_unique = (m_morton64.end() == uniqued);\n        if(!morton_code_is_unique)\n        {\n            thrust::transform(policy,\n                              m_morton.begin(),\n                              m_morton.end(),\n                              m_indices.begin(),\n                              m_morton64.begin(),\n                              [] __device__ __host__(const uint32_t m, const uint32_t idx)\n                              {\n                                  unsigned long long int m64 = m;\n                                  m64 &lt;&lt;= 32;\n                                  m64 |= idx;\n                                  return m64;\n                              });\n        }\n\n        // --------------------------------------------------------------------\n        // construct leaf nodes and aabbs\n\n        thrust::transform(policy,\n                          m_indices.begin(),\n                          m_indices.end(),\n                          this-&gt;m_nodes.begin() + num_internal_nodes,\n                          [] __device__ __host__(const index_type idx)\n                          {\n                              node_type n;\n                              n.parent_idx = 0xFFFFFFFF;\n                              n.left_idx   = 0xFFFFFFFF;\n                              n.right_idx  = 0xFFFFFFFF;\n                              n.object_idx = idx;\n                              return n;\n                          });\n\n        // --------------------------------------------------------------------\n        // construct internal nodes\n\n        if(morton_code_is_unique)\n        {\n            const uint32_t* node_code = thrust::raw_pointer_cast(m_morton.data());\n            details::construct_internal_nodes(\n                policy, thrust::raw_pointer_cast(m_nodes.data()), node_code, num_objects);\n        }\n        else  // 64bit version\n        {\n            const unsigned long long int* node_code =\n                thrust::raw_pointer_cast(m_morton64.data());\n            details::construct_internal_nodes(\n                policy, thrust::raw_pointer_cast(m_nodes.data()), node_code, num_objects);\n        }\n\n        // --------------------------------------------------------------------\n        // create AABB for each node by bottom-up strategy\n\n        const auto flags = thrust::raw_pointer_cast(m_flag_container.data());\n\n\n        thrust::for_each(policy,\n                         thrust::make_counting_iterator&lt;index_type&gt;(num_internal_nodes),\n                         thrust::make_counting_iterator&lt;index_type&gt;(num_nodes),\n                         [nodes = thrust::raw_pointer_cast(m_nodes.data()),\n                          aabbs = thrust::raw_pointer_cast(m_aabbs.data()),\n                          flags] __device__(index_type idx)\n                         {\n                             uint32_t parent = nodes[idx].parent_idx;\n                             while(parent != 0xFFFFFFFF)  // means idx == 0\n                             {\n                                 const int old = atomicCAS(flags + parent, 0, 1);\n                                 if(old == 0)\n                                 {\n                                     // this is the first thread entered here.\n                                     // wait the other thread from the other child node.\n                                     return;\n                                 }\n                                 MUDA_KERNEL_ASSERT(old == 1, \"old=%d\", old);\n                                 // here, the flag has already been 1. it means that this\n                                 // thread is the 2nd thread. merge AABB of both childlen.\n\n                                 const auto lidx = nodes[parent].left_idx;\n                                 const auto ridx = nodes[parent].right_idx;\n                                 const auto lbox = aabbs[lidx];\n                                 const auto rbox = aabbs[ridx];\n                                 aabbs[parent]   = merge(lbox, rbox);\n\n                                 // look the next parent...\n                                 parent = nodes[parent].parent_idx;\n                             }\n                             return;\n                         });\n    }\n\n    const auto&amp; objects() const noexcept { return m_objects; }\n    auto&amp;       objects() noexcept { return m_objects; }\n    const auto&amp; aabbs() const noexcept { return m_aabbs; }\n    const auto&amp; nodes() const noexcept { return m_nodes; }\n\n    const auto&amp; host_objects() const noexcept\n    {\n        download_if_dirty();\n        return m_h_objects;\n    }\n    const auto&amp; host_aabbs() const noexcept\n    {\n        download_if_dirty();\n        return m_h_aabbs;\n    }\n    const auto&amp; host_nodes() const noexcept\n    {\n        download_if_dirty();\n        return m_h_nodes;\n    }\n\n  private:\n    muda::DeviceVector&lt;uint32_t&gt;               m_morton;\n    muda::DeviceVector&lt;uint32_t&gt;               m_indices;\n    muda::DeviceVector&lt;unsigned long long int&gt; m_morton64;\n    muda::DeviceVector&lt;int&gt;                    m_flag_container;\n\n    muda::DeviceVector&lt;object_type&gt; m_objects;\n    muda::DeviceVector&lt;aabb_type&gt;   m_aabbs;\n    muda::DeviceVector&lt;node_type&gt;   m_nodes;\n\n    mutable bool                             m_host_dirty = true;\n    mutable thrust::host_vector&lt;object_type&gt; m_h_objects;\n    mutable thrust::host_vector&lt;aabb_type&gt;   m_h_aabbs;\n    mutable thrust::host_vector&lt;node_type&gt;   m_h_nodes;\n\n    void download_if_dirty() const\n    {\n        if(m_host_dirty)\n        {\n            m_h_objects  = m_objects;\n            m_h_aabbs    = m_aabbs;\n            m_h_nodes    = m_nodes;\n            m_host_dirty = false;\n        }\n    }\n};\n}  // namespace muda::lbvh\n</code></pre>"},{"location":"muda/bvh__viewer_8h/","title":"File bvh_viewer.h","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh &gt; bvh_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> <li><code>#include &lt;muda/container/vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/aabb.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/morton_code.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/predicator.h&gt;</code></li> </ul>"},{"location":"muda/bvh__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace lbvh namespace details"},{"location":"muda/bvh__viewer_8h/#classes","title":"Classes","text":"Type Name class BVHViewerBase &lt;IsConst, typename Real, typename Object&gt; struct DefaultQueryCallback struct Node struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/bvh_viewer.h</code></p>"},{"location":"muda/bvh__viewer_8h_source/","title":"File bvh_viewer.h","text":"<p>File List &gt; ext &gt; geo &gt; lbvh &gt; bvh_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/viewer/viewer_base.h&gt;\n#include &lt;muda/container/vector.h&gt;\n#include &lt;muda/ext/geo/lbvh/aabb.h&gt;\n#include &lt;muda/ext/geo/lbvh/morton_code.h&gt;\n#include &lt;muda/ext/geo/lbvh/predicator.h&gt;\n\nnamespace muda::lbvh\n{\ntemplate &lt;typename Real, typename Object, typename AABBGetter, typename MortonCodeCalculator&gt;\nclass BVH;\n\nnamespace details\n{\n    struct Node\n    {\n        std::uint32_t parent_idx;  // parent node\n        std::uint32_t left_idx;    // index of left  child node\n        std::uint32_t right_idx;   // index of right child node\n        std::uint32_t object_idx;  // == 0xFFFFFFFF if internal node.\n    };\n\n    template &lt;typename UInt&gt;\n    MUDA_GENERIC uint2 determine_range(UInt const* node_code, const uint32_t num_leaves, uint32_t idx)\n    {\n        if(idx == 0)\n        {\n            return make_uint2(0, num_leaves - 1);\n        }\n\n        // determine direction of the range\n        const UInt self_code = node_code[idx];\n        const int  L_delta   = common_upper_bits(self_code, node_code[idx - 1]);\n        const int  R_delta   = common_upper_bits(self_code, node_code[idx + 1]);\n        const int  d         = (R_delta &gt; L_delta) ? 1 : -1;\n\n        // Compute upper bound for the length of the range\n\n        const int delta_min = thrust::min(L_delta, R_delta);\n        int       l_max     = 2;\n        int       delta     = -1;\n        int       i_tmp     = idx + d * l_max;\n        if(0 &lt;= i_tmp &amp;&amp; i_tmp &lt; num_leaves)\n        {\n            delta = common_upper_bits(self_code, node_code[i_tmp]);\n        }\n        while(delta &gt; delta_min)\n        {\n            l_max &lt;&lt;= 1;\n            i_tmp = idx + d * l_max;\n            delta = -1;\n            if(0 &lt;= i_tmp &amp;&amp; i_tmp &lt; num_leaves)\n            {\n                delta = common_upper_bits(self_code, node_code[i_tmp]);\n            }\n        }\n\n        // Find the other end by binary search\n        int l = 0;\n        int t = l_max &gt;&gt; 1;\n        while(t &gt; 0)\n        {\n            i_tmp = idx + (l + t) * d;\n            delta = -1;\n            if(0 &lt;= i_tmp &amp;&amp; i_tmp &lt; num_leaves)\n            {\n                delta = common_upper_bits(self_code, node_code[i_tmp]);\n            }\n            if(delta &gt; delta_min)\n            {\n                l += t;\n            }\n            t &gt;&gt;= 1;\n        }\n        uint32_t jdx = idx + l * d;\n        if(d &lt; 0)\n        {\n            thrust::swap(idx, jdx);  // make it sure that idx &lt; jdx\n        }\n        return make_uint2(idx, jdx);\n    }\n\n    template &lt;typename UInt&gt;\n    MUDA_GENERIC uint32_t find_split(UInt const*    node_code,\n                                     const uint32_t num_leaves,\n                                     const uint32_t first,\n                                     const uint32_t last) noexcept\n    {\n        const UInt first_code = node_code[first];\n        const UInt last_code  = node_code[last];\n        if(first_code == last_code)\n        {\n            return (first + last) &gt;&gt; 1;\n        }\n        const int delta_node = common_upper_bits(first_code, last_code);\n\n        // binary search...\n        int split  = first;\n        int stride = last - first;\n        do\n        {\n            stride           = (stride + 1) &gt;&gt; 1;\n            const int middle = split + stride;\n            if(middle &lt; last)\n            {\n                const int delta = common_upper_bits(first_code, node_code[middle]);\n                if(delta &gt; delta_node)\n                {\n                    split = middle;\n                }\n            }\n        } while(stride &gt; 1);\n\n        return split;\n    }\n\n\n    template &lt;bool IsConst, typename Real, typename Object&gt;\n    class BVHViewerBase : muda::ViewerBase&lt;IsConst&gt;\n    {\n        MUDA_VIEWER_COMMON_NAME(BVHViewerBase);\n\n        using Base = muda::ViewerBase&lt;IsConst&gt;;\n        template &lt;typename U&gt;\n        using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n        template &lt;typename Real_, typename Object_, typename AABBGetter, typename MortonCodeCalculator&gt;\n        friend class BVH;\n\n      public:\n        using real_type   = Real;\n        using aabb_type   = AABB&lt;real_type&gt;;\n        using node_type   = details::Node;\n        using index_type  = std::uint32_t;\n        using object_type = Object;\n\n\n        using ConstViewer    = BVHViewerBase&lt;true, real_type, object_type&gt;;\n        using NonConstViewer = BVHViewerBase&lt;false, real_type, object_type&gt;;\n        using ThisViewer     = BVHViewerBase&lt;IsConst, real_type, object_type&gt;;\n\n        struct DefaultQueryCallback\n        {\n            MUDA_GENERIC void operator()(uint32_t obj_idx) const noexcept {}\n        };\n\n        MUDA_GENERIC BVHViewerBase(const uint32_t             num_nodes,\n                                   const uint32_t             num_objects,\n                                   auto_const_t&lt;node_type&gt;*   nodes,\n                                   auto_const_t&lt;aabb_type&gt;*   aabbs,\n                                   auto_const_t&lt;object_type&gt;* objects)\n            : m_num_nodes(num_nodes)\n            , m_num_objects(num_objects)\n            , m_nodes(nodes)\n            , m_aabbs(aabbs)\n            , m_objects(objects)\n        {\n            MUDA_KERNEL_ASSERT(m_nodes &amp;&amp; m_aabbs &amp;&amp; m_objects,\n                               \"BVHViewerBase[%s:%s]: nullptr is passed,\"\n                               \"nodes=%p,\"\n                               \"aabbs=%p,\"\n                               \"objects=%p\\n\",\n                               this-&gt;name(),\n                               this-&gt;kernel_name(),\n                               m_nodes,\n                               m_aabbs,\n                               m_objects);\n        }\n\n        MUDA_GENERIC auto as_const() const noexcept\n        {\n            return ConstViewer{m_num_nodes, m_num_objects, m_nodes, m_aabbs, m_objects};\n        }\n\n        MUDA_GENERIC operator ConstViewer() const noexcept\n        {\n            return as_const();\n        }\n\n        MUDA_GENERIC auto num_nodes() const noexcept { return m_num_nodes; }\n        MUDA_GENERIC auto num_objects() const noexcept { return m_num_objects; }\n\n        // query object indices that potentially overlaps with query aabb.\n        //\n        // requirements:\n        //  - F: void (uin32_t obj_idx)\n        template &lt;typename F, uint32_t StackNum = 64&gt;\n        MUDA_GENERIC uint32_t query(const query_overlap&lt;real_type&gt;&amp; q,\n                                    F callback = DefaultQueryCallback{}) const noexcept\n        {\n            index_type  stack[StackNum];\n            index_type* stack_ptr = stack;\n            index_type* stack_end = stack + StackNum;\n            *stack_ptr++          = 0;  // root node is always 0\n\n            uint32_t num_found = 0;\n            do\n            {\n                const index_type node  = *--stack_ptr;\n                const index_type L_idx = m_nodes[node].left_idx;\n                const index_type R_idx = m_nodes[node].right_idx;\n\n                if(intersects(q.target, m_aabbs[L_idx]))\n                {\n                    const auto obj_idx = m_nodes[L_idx].object_idx;\n                    if(obj_idx != 0xFFFFFFFF)\n                    {\n                        if constexpr(!std::is_same_v&lt;F, DefaultQueryCallback&gt;)\n                        {\n                            callback(obj_idx);\n                        }\n                        ++num_found;\n                    }\n                    else  // the node is not a leaf.\n                    {\n                        *stack_ptr++ = L_idx;\n                    }\n                }\n                if(intersects(q.target, m_aabbs[R_idx]))\n                {\n                    const auto obj_idx = m_nodes[R_idx].object_idx;\n                    if(obj_idx != 0xFFFFFFFF)\n                    {\n                        if constexpr(!std::is_same_v&lt;F, DefaultQueryCallback&gt;)\n                        {\n                            callback(obj_idx);\n                        }\n                        ++num_found;\n                    }\n                    else  // the node is not a leaf.\n                    {\n                        *stack_ptr++ = R_idx;\n                    }\n                }\n                MUDA_KERNEL_ASSERT(stack_ptr &lt; stack_end,\n                                   \"LBVHQuery[%s:%s]: stack overflow, try use a larger StackNum.\",\n                                   this-&gt;name(),\n                                   this-&gt;kernel_name());\n            } while(stack &lt; stack_ptr);\n            return num_found;\n        }\n\n        // query object index that is the nearst to the query point.\n        //\n        // requirements:\n        // - FDistanceCalculator must be able to calc distance between a point to an object.\n        //   which means FDistanceCalculator: Real (const object_type&amp; lhs, const object_type&amp; rhs)\n        //\n        template &lt;typename FDistanceCalculator, uint32_t StackNum = 64&gt;\n        MUDA_GENERIC thrust::pair&lt;uint32_t, real_type&gt; query(\n            const query_nearest&lt;real_type&gt;&amp; q, FDistanceCalculator calc_dist) const noexcept\n        {\n            // pair of {node_idx, mindist}\n            thrust::pair&lt;index_type, real_type&gt;  stack[StackNum];\n            thrust::pair&lt;index_type, real_type&gt;* stack_ptr = stack;\n            thrust::pair&lt;index_type, real_type&gt;* stack_end = stack + StackNum;\n\n            *stack_ptr++ = thrust::make_pair(0, mindist(m_aabbs[0], q.target));\n\n            uint32_t  nearest                = 0xFFFFFFFF;\n            real_type dist_to_nearest_object = infinity&lt;real_type&gt;();\n            do\n            {\n                const auto node = *--stack_ptr;\n                if(node.second &gt; dist_to_nearest_object)\n                {\n                    // if aabb mindist &gt; already_found_mindist, it cannot have a nearest\n                    continue;\n                }\n\n                const index_type L_idx = m_nodes[node.first].left_idx;\n                const index_type R_idx = m_nodes[node.first].right_idx;\n\n                const aabb_type&amp; L_box = m_aabbs[L_idx];\n                const aabb_type&amp; R_box = m_aabbs[R_idx];\n\n                const real_type L_mindist = mindist(L_box, q.target);\n                const real_type R_mindist = mindist(R_box, q.target);\n\n                const real_type L_minmaxdist = minmaxdist(L_box, q.target);\n                const real_type R_minmaxdist = minmaxdist(R_box, q.target);\n\n                // there should be an object that locates within minmaxdist.\n\n                if(L_mindist &lt;= R_minmaxdist)  // L is worth considering\n                {\n                    const auto obj_idx = m_nodes[L_idx].object_idx;\n                    if(obj_idx != 0xFFFFFFFF)  // leaf node\n                    {\n                        const real_type dist = calc_dist(q.target, m_objects[obj_idx]);\n                        if(dist &lt;= dist_to_nearest_object)\n                        {\n                            dist_to_nearest_object = dist;\n                            nearest                = obj_idx;\n                        }\n                    }\n                    else\n                    {\n                        *stack_ptr++ = thrust::make_pair(L_idx, L_mindist);\n                    }\n                }\n                if(R_mindist &lt;= L_minmaxdist)  // R is worth considering\n                {\n                    const auto obj_idx = m_nodes[R_idx].object_idx;\n                    if(obj_idx != 0xFFFFFFFF)  // leaf node\n                    {\n                        const real_type dist = calc_dist(q.target, m_objects[obj_idx]);\n                        if(dist &lt;= dist_to_nearest_object)\n                        {\n                            dist_to_nearest_object = dist;\n                            nearest                = obj_idx;\n                        }\n                    }\n                    else\n                    {\n                        *stack_ptr++ = thrust::make_pair(R_idx, R_mindist);\n                    }\n                }\n                MUDA_KERNEL_ASSERT(stack_ptr &lt; stack_end,\n                                   \"LBVHQuery[%s:%s]: stack overflow, try use a larger StackNum.\",\n                                   this-&gt;name(),\n                                   this-&gt;kernel_name());\n            } while(stack &lt; stack_ptr);\n            return thrust::make_pair(nearest, dist_to_nearest_object);\n        }\n\n        MUDA_GENERIC auto_const_t&lt;object_type&gt;&amp; object(const uint32_t idx) noexcept\n        {\n            check_index(idx);\n            return m_objects[idx];\n        }\n\n        MUDA_GENERIC const object_type&amp; object(const uint32_t idx) const noexcept\n        {\n            check_index(idx);\n            return m_objects[idx];\n        }\n\n      private:\n        uint32_t m_num_nodes;  // (# of internal node) + (# of leaves), 2N+1\n        uint32_t m_num_objects;  // (# of leaves), the same as the number of objects\n\n        auto_const_t&lt;node_type&gt;*   m_nodes;\n        auto_const_t&lt;aabb_type&gt;*   m_aabbs;\n        auto_const_t&lt;object_type&gt;* m_objects;\n\n        MUDA_INLINE MUDA_GENERIC void check_index(const uint32_t idx) const noexcept\n        {\n            MUDA_KERNEL_ASSERT(idx &lt; m_num_objects,\n                               \"BVHViewer[%s:%s]: index out of range, idx=%u, num_objects=%u\",\n                               this-&gt;name(),\n                               this-&gt;kernel_name(),\n                               idx,\n                               m_num_objects);\n        }\n    };\n}  // namespace details\n\ntemplate &lt;typename Real, typename Object&gt;\nusing BVHViewer = details::BVHViewerBase&lt;false, Real, Object&gt;;\ntemplate &lt;typename Real, typename Object&gt;\nusing CBVHViewer = details::BVHViewerBase&lt;true, Real, Object&gt;;\n}  // namespace muda::lbvh\n\nnamespace muda\n{\ntemplate &lt;typename Real, typename Object&gt;\nstruct read_only_view&lt;lbvh::BVHViewer&lt;Real, Object&gt;&gt;\n{\n    using type = lbvh::CBVHViewer&lt;Real, Object&gt;;\n};\n\ntemplate &lt;typename Real, typename Object&gt;\nstruct read_write_view&lt;lbvh::CBVHViewer&lt;Real, Object&gt;&gt;\n{\n    using type = lbvh::BVHViewer&lt;Real, Object&gt;;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/lbvh_2lbvh_8h/","title":"File lbvh.h","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh &gt; lbvh.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/geo/lbvh/aabb.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/bvh.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/morton_code.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/predicator.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/query.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/utility.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/lbvh.h</code></p>"},{"location":"muda/lbvh_2lbvh_8h_source/","title":"File lbvh.h","text":"<p>File List &gt; ext &gt; geo &gt; lbvh &gt; lbvh.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/geo/lbvh/aabb.h&gt;\n#include &lt;muda/ext/geo/lbvh/bvh.h&gt;\n#include &lt;muda/ext/geo/lbvh/morton_code.h&gt;\n#include &lt;muda/ext/geo/lbvh/predicator.h&gt;\n#include &lt;muda/ext/geo/lbvh/query.h&gt;\n#include &lt;muda/ext/geo/lbvh/utility.h&gt;\n</code></pre>"},{"location":"muda/morton__code_8h/","title":"File morton_code.h","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh &gt; morton_code.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector_types.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"muda/morton__code_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace lbvh <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/morton_code.h</code></p>"},{"location":"muda/morton__code_8h_source/","title":"File morton_code.h","text":"<p>File List &gt; ext &gt; geo &gt; lbvh &gt; morton_code.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;vector_types.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cstdint&gt;\n\nnamespace muda::lbvh\n{\nMUDA_GENERIC MUDA_INLINE std::uint32_t expand_bits(std::uint32_t v) noexcept\n{\n    v = (v * 0x00010001u) &amp; 0xFF0000FFu;\n    v = (v * 0x00000101u) &amp; 0x0F00F00Fu;\n    v = (v * 0x00000011u) &amp; 0xC30C30C3u;\n    v = (v * 0x00000005u) &amp; 0x49249249u;\n    return v;\n}\n\n// Calculates a 30-bit Morton code for the\n// given 3D point located within the unit cube [0,1].\nMUDA_GENERIC MUDA_INLINE std::uint32_t morton_code(float4 xyz, float resolution = 1024.0f) noexcept\n{\n    xyz.x = ::fminf(::fmaxf(xyz.x * resolution, 0.0f), resolution - 1.0f);\n    xyz.y = ::fminf(::fmaxf(xyz.y * resolution, 0.0f), resolution - 1.0f);\n    xyz.z = ::fminf(::fmaxf(xyz.z * resolution, 0.0f), resolution - 1.0f);\n    const std::uint32_t xx = expand_bits(static_cast&lt;std::uint32_t&gt;(xyz.x));\n    const std::uint32_t yy = expand_bits(static_cast&lt;std::uint32_t&gt;(xyz.y));\n    const std::uint32_t zz = expand_bits(static_cast&lt;std::uint32_t&gt;(xyz.z));\n    return xx * 4 + yy * 2 + zz;\n}\n\nMUDA_GENERIC MUDA_INLINE std::uint32_t morton_code(double4 xyz, double resolution = 1024.0) noexcept\n{\n    xyz.x = ::fmin(::fmax(xyz.x * resolution, 0.0), resolution - 1.0);\n    xyz.y = ::fmin(::fmax(xyz.y * resolution, 0.0), resolution - 1.0);\n    xyz.z = ::fmin(::fmax(xyz.z * resolution, 0.0), resolution - 1.0);\n    const std::uint32_t xx = expand_bits(static_cast&lt;std::uint32_t&gt;(xyz.x));\n    const std::uint32_t yy = expand_bits(static_cast&lt;std::uint32_t&gt;(xyz.y));\n    const std::uint32_t zz = expand_bits(static_cast&lt;std::uint32_t&gt;(xyz.z));\n    return xx * 4 + yy * 2 + zz;\n}\n\n__device__ MUDA_INLINE int common_upper_bits(const unsigned int lhs, const unsigned int rhs) noexcept\n{\n    return ::__clz(lhs ^ rhs);\n}\n__device__ MUDA_INLINE int common_upper_bits(const unsigned long long int lhs,\n                                             const unsigned long long int rhs) noexcept\n{\n    return ::__clzll(lhs ^ rhs);\n}\n\n}  // namespace muda::lbvh\n</code></pre>"},{"location":"muda/predicator_8h/","title":"File predicator.h","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh &gt; predicator.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/geo/lbvh/aabb.h&gt;</code></li> </ul>"},{"location":"muda/predicator_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace lbvh"},{"location":"muda/predicator_8h/#classes","title":"Classes","text":"Type Name struct query_nearest &lt;typename Real&gt; struct query_overlap &lt;typename Real&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/predicator.h</code></p>"},{"location":"muda/predicator_8h_source/","title":"File predicator.h","text":"<p>File List &gt; ext &gt; geo &gt; lbvh &gt; predicator.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/geo/lbvh/aabb.h&gt;\n\nnamespace muda::lbvh\n{\ntemplate &lt;typename Real&gt;\nstruct query_overlap\n{\n    MUDA_GENERIC query_overlap(const AABB&lt;Real&gt;&amp; tgt)\n        : target(tgt)\n    {\n    }\n\n    query_overlap()                                = default;\n    ~query_overlap()                               = default;\n    query_overlap(const query_overlap&amp;)            = default;\n    query_overlap(query_overlap&amp;&amp;)                 = default;\n    query_overlap&amp; operator=(const query_overlap&amp;) = default;\n    query_overlap&amp; operator=(query_overlap&amp;&amp;)      = default;\n\n    MUDA_GENERIC inline bool operator()(const AABB&lt;Real&gt;&amp; box) noexcept\n    {\n        return intersects(box, target);\n    }\n\n    AABB&lt;Real&gt; target;\n};\n\ntemplate &lt;typename Real&gt;\nMUDA_GENERIC query_overlap&lt;Real&gt; overlaps(const AABB&lt;Real&gt;&amp; region) noexcept\n{\n    return query_overlap&lt;Real&gt;(region);\n}\n\ntemplate &lt;typename Real&gt;\nstruct query_nearest\n{\n    // float4/double4\n    using vector_type = typename vector_of&lt;Real&gt;::type;\n\n    MUDA_GENERIC query_nearest(const vector_type&amp; tgt)\n        : target(tgt)\n    {\n    }\n\n    query_nearest()                                = default;\n    ~query_nearest()                               = default;\n    query_nearest(const query_nearest&amp;)            = default;\n    query_nearest(query_nearest&amp;&amp;)                 = default;\n    query_nearest&amp; operator=(const query_nearest&amp;) = default;\n    query_nearest&amp; operator=(query_nearest&amp;&amp;)      = default;\n\n    vector_type target;\n};\n\nMUDA_GENERIC inline query_nearest&lt;float&gt; nearest(const float4&amp; point) noexcept\n{\n    return query_nearest&lt;float&gt;(point);\n}\nMUDA_GENERIC inline query_nearest&lt;float&gt; nearest(const float3&amp; point) noexcept\n{\n    return query_nearest&lt;float&gt;(make_float4(point.x, point.y, point.z, 0.0f));\n}\nMUDA_GENERIC inline query_nearest&lt;double&gt; nearest(const double4&amp; point) noexcept\n{\n    return query_nearest&lt;double&gt;(point);\n}\nMUDA_GENERIC inline query_nearest&lt;double&gt; nearest(const double3&amp; point) noexcept\n{\n    return query_nearest&lt;double&gt;(make_double4(point.x, point.y, point.z, 0.0));\n}\n\n}  // namespace muda::lbvh\n</code></pre>"},{"location":"muda/query_8h/","title":"File query.h","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh &gt; query.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/geo/lbvh/bvh.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/lbvh/predicator.h&gt;</code></li> </ul>"},{"location":"muda/query_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace lbvh <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/query.h</code></p>"},{"location":"muda/query_8h_source/","title":"File query.h","text":"<p>File List &gt; ext &gt; geo &gt; lbvh &gt; query.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/geo/lbvh/bvh.h&gt;\n#include &lt;muda/ext/geo/lbvh/predicator.h&gt;\n\nnamespace muda::lbvh\n{\ntemplate &lt;typename Real, typename Objects, typename AABBGetter, typename MortonCodeCalculator, typename OutputBackInserter&gt;\nMUDA_HOST uint32_t query(const BVH&lt;Real, Objects, AABBGetter, MortonCodeCalculator&gt;&amp; tree,\n                         const query_overlap&lt;Real&gt; q,\n                         OutputBackInserter        outiter) noexcept\n{\n    using bvh_type   = BVH&lt;Real, Objects, AABBGetter, MortonCodeCalculator&gt;;\n    using index_type = typename bvh_type::index_type;\n    using aabb_type  = typename bvh_type::aabb_type;\n    using node_type  = typename bvh_type::node_type;\n\n    std::vector&lt;std::size_t&gt; stack;\n    stack.reserve(64);\n    stack.push_back(0);\n\n    uint32_t num_found = 0;\n    do\n    {\n        const index_type node = stack.back();\n        stack.pop_back();\n        const index_type L_idx = tree.host_nodes()[node].left_idx;\n        const index_type R_idx = tree.host_nodes()[node].right_idx;\n\n        if(intersects(q.target, tree.host_aabbs()[L_idx]))\n        {\n            const auto obj_idx = tree.host_nodes()[L_idx].object_idx;\n            if(obj_idx != 0xFFFFFFFF)\n            {\n                *outiter++ = obj_idx;\n                ++num_found;\n            }\n            else  // the node is not a leaf.\n            {\n                stack.push_back(L_idx);\n            }\n        }\n        if(intersects(q.target, tree.host_aabbs()[R_idx]))\n        {\n            const auto obj_idx = tree.host_nodes()[R_idx].object_idx;\n            if(obj_idx != 0xFFFFFFFF)\n            {\n                *outiter++ = obj_idx;\n                ++num_found;\n            }\n            else  // the node is not a leaf.\n            {\n                stack.push_back(R_idx);\n            }\n        }\n    } while(!stack.empty());\n    return num_found;\n}\n\ntemplate &lt;typename Real, typename Objects, typename AABBGetter, typename MortonCodeCalculator, typename DistanceCalculator&gt;\nMUDA_HOST std::pair&lt;uint32_t, Real&gt; query(const BVH&lt;Real, Objects, AABBGetter, MortonCodeCalculator&gt;&amp; tree,\n                                          const query_nearest&lt;Real&gt;&amp; q,\n                                          DistanceCalculator calc_dist) noexcept\n{\n    using bvh_type   = BVH&lt;Real, Objects, AABBGetter, MortonCodeCalculator&gt;;\n    using real_type  = typename bvh_type::real_type;\n    using index_type = typename bvh_type::index_type;\n    using aabb_type  = typename bvh_type::aabb_type;\n    using node_type  = typename bvh_type::node_type;\n\n    //if(!tree.query_host_enabled())\n    //{\n    //    throw std::runtime_error(\"lbvh::bvh query_host is not enabled\");\n    //}\n\n    // pair of {node_idx, mindist}\n    std::vector&lt;std::pair&lt;index_type, real_type&gt;&gt; stack = {\n        {0, mindist(tree.host_aabbs()[0], q.target)}};\n    stack.reserve(64);\n\n    uint32_t  nearest              = 0xFFFFFFFF;\n    real_type current_nearest_dist = infinity&lt;real_type&gt;();\n    do\n    {\n        const auto node = stack.back();\n        stack.pop_back();\n        if(node.second &gt; current_nearest_dist)\n        {\n            // if aabb mindist &gt; already_found_mindist, it cannot have a nearest\n            continue;\n        }\n\n        const index_type L_idx = tree.host_nodes()[node.first].left_idx;\n        const index_type R_idx = tree.host_nodes()[node.first].right_idx;\n\n        const aabb_type&amp; L_box = tree.host_aabbs()[L_idx];\n        const aabb_type&amp; R_box = tree.host_aabbs()[R_idx];\n\n        const real_type L_mindist = mindist(L_box, q.target);\n        const real_type R_mindist = mindist(R_box, q.target);\n\n        const real_type L_minmaxdist = minmaxdist(L_box, q.target);\n        const real_type R_minmaxdist = minmaxdist(R_box, q.target);\n\n        // there should be an object that locates within minmaxdist.\n\n        if(L_mindist &lt;= R_minmaxdist)  // L is worth considering\n        {\n            const auto obj_idx = tree.host_nodes()[L_idx].object_idx;\n            if(obj_idx != 0xFFFFFFFF)  // leaf node\n            {\n                const real_type dist = calc_dist(q.target, tree.objects_host()[obj_idx]);\n                if(dist &lt;= current_nearest_dist)\n                {\n                    current_nearest_dist = dist;\n                    nearest              = obj_idx;\n                }\n            }\n            else\n            {\n                stack.emplace_back(L_idx, L_mindist);\n            }\n        }\n        if(R_mindist &lt;= L_minmaxdist)  // R is worth considering\n        {\n            const auto obj_idx = tree.host_nodes()[R_idx].object_idx;\n            if(obj_idx != 0xFFFFFFFF)  // leaf node\n            {\n                const real_type dist = calc_dist(q.target, tree.objects_host()[obj_idx]);\n                if(dist &lt;= current_nearest_dist)\n                {\n                    current_nearest_dist = dist;\n                    nearest              = obj_idx;\n                }\n            }\n            else\n            {\n                stack.emplace_back(R_idx, R_mindist);\n            }\n        }\n    } while(!stack.empty());\n    return std::make_pair(nearest, current_nearest_dist);\n}\n}  // namespace muda::lbvh\n</code></pre>"},{"location":"muda/utility_8h/","title":"File utility.h","text":"<p>FileList &gt; ext &gt; geo &gt; lbvh &gt; utility.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;vector_types.h&gt;</code></li> <li><code>#include &lt;math_constants.h&gt;</code></li> </ul>"},{"location":"muda/utility_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace lbvh"},{"location":"muda/utility_8h/#classes","title":"Classes","text":"Type Name struct vector_of &lt;typename T&gt; struct vector_of &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/lbvh/utility.h</code></p>"},{"location":"muda/utility_8h_source/","title":"File utility.h","text":"<p>File List &gt; ext &gt; geo &gt; lbvh &gt; utility.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;vector_types.h&gt;\n#include &lt;math_constants.h&gt;\n\nnamespace muda::lbvh\n{\ntemplate &lt;typename T&gt;\nstruct vector_of;\ntemplate &lt;&gt;\nstruct vector_of&lt;float&gt;\n{\n    using type = float4;\n};\ntemplate &lt;&gt;\nstruct vector_of&lt;double&gt;\n{\n    using type = double4;\n};\n\ntemplate &lt;typename T&gt;\nusing vector_of_t = typename vector_of&lt;T&gt;::type;\n\ntemplate &lt;typename T&gt;\n__device__ inline T infinity() noexcept;\n\ntemplate &lt;&gt;\n__device__ inline float infinity&lt;float&gt;() noexcept\n{\n    return CUDART_INF_F;\n}\ntemplate &lt;&gt;\n__device__ inline double infinity&lt;double&gt;() noexcept\n{\n    return CUDART_INF;\n}\n\n}  // namespace muda::lbvh\n</code></pre>"},{"location":"muda/dir_58b30d2a266b6e98a9cbea81c385691b/","title":"Dir src/muda/ext/geo/spatial_hash","text":"<p>FileList &gt; ext &gt; geo &gt; spatial_hash</p>"},{"location":"muda/dir_58b30d2a266b6e98a9cbea81c385691b/#files","title":"Files","text":"Type Name file bounding_volume.h file collision_pair.h file morton_hash.h file sparse_spatial_hash.h file sparse_spatial_hash_impl.h <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/</code></p>"},{"location":"muda/bounding__volume_8h/","title":"File bounding_volume.h","text":"<p>FileList &gt; ext &gt; geo &gt; spatial_hash &gt; bounding_volume.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;Eigen/Geometry&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> </ul>"},{"location":"muda/bounding__volume_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace spatial_hash"},{"location":"muda/bounding__volume_8h/#classes","title":"Classes","text":"Type Name class AABB class BoundingSphere <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/bounding_volume.h</code></p>"},{"location":"muda/bounding__volume_8h_source/","title":"File bounding_volume.h","text":"<p>File List &gt; ext &gt; geo &gt; spatial_hash &gt; bounding_volume.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;Eigen/Geometry&gt;\n#include &lt;muda/muda_def.h&gt;\n\nnamespace muda::spatial_hash\n{\nclass BoundingSphere\n{\n    using Vector3 = Eigen::Vector3f;\n\n  public:\n    MUDA_GENERIC BoundingSphere(const Vector3&amp; o, float r)\n        : o(o)\n        , r(r)\n    {\n    }\n    MUDA_GENERIC BoundingSphere() = default;\n\n    Vector3 o     = Vector3::Zero();\n    float   r     = 0.0f;\n    int     level = 0;\n};\n\nclass AABB\n{\n    using Vector3 = Eigen::Vector3f;\n\n  public:\n    Vector3 max;\n    Vector3 min;\n\n    MUDA_GENERIC AABB(const Vector3&amp; min, const Vector3&amp; max)\n        : min(min)\n        , max(max)\n    {\n    }\n\n    MUDA_GENERIC AABB(const AABB&amp; l, const AABB&amp; r)\n    {\n        max = l.max.cwiseMax(r.max);\n        min = l.min.cwiseMin(r.min);\n    }\n\n    MUDA_GENERIC Vector3 center() const { return (max + min) / 2; }\n\n    MUDA_GENERIC float radius() const { return (max - min).norm() / 2; }\n};\n\nMUDA_INLINE MUDA_GENERIC float squared_distance(const Eigen::Vector3f&amp; p, AABB b)\n{\n    float sq_dist = 0.0f;\n#pragma unroll\n    for(int i = 0; i &lt; 3; i++)\n    {\n        // for each axis count any excess distance outside box extents\n        float v = p[i];\n        if(v &lt; b.min[i])\n            sq_dist += (b.min[i] - v) * (b.min[i] - v);\n        if(v &gt; b.max[i])\n            sq_dist += (v - b.max[i]) * (v - b.max[i]);\n    }\n    return sq_dist;\n}\n\nMUDA_INLINE MUDA_GENERIC float distance(const Eigen::Vector3f&amp; p, AABB b)\n{\n    return ::sqrt(squared_distance(p, b));\n}\n\nMUDA_INLINE MUDA_GENERIC bool intersect(const BoundingSphere&amp; s, const AABB&amp; b)\n{\n    // Compute squared distance between sphere center and AABB\n    // the sqrt(dist) is fine to use as well, but this is faster.\n    float sqDist = squared_distance(s.o, b);\n\n    // Sphere and AABB intersect if the (squared) distance between them is\n    // less than the (squared) sphere radius.\n    return sqDist &lt;= s.r * s.r;\n}\n\nMUDA_INLINE MUDA_GENERIC bool intersect(const BoundingSphere&amp; lhs, const BoundingSphere&amp; rhs)\n{\n    float r = lhs.r + rhs.r;\n    return (lhs.o - rhs.o).squaredNorm() &lt;= r * r;\n}\n\nMUDA_INLINE MUDA_GENERIC bool intersect(const AABB&amp; l, const AABB&amp; r)\n{\n    Eigen::Vector3i c;\n#pragma unroll\n    for(int i = 0; i &lt; 3; ++i)\n        c[i] = l.min[i] &lt;= r.max[i] &amp;&amp; l.max[i] &gt;= r.min[i];\n    return c.all();\n}\n}  // namespace muda::spatial_hash\n</code></pre>"},{"location":"muda/collision__pair_8h/","title":"File collision_pair.h","text":"<p>FileList &gt; ext &gt; geo &gt; spatial_hash &gt; collision_pair.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> </ul>"},{"location":"muda/collision__pair_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace spatial_hash"},{"location":"muda/collision__pair_8h/#classes","title":"Classes","text":"Type Name class CollisionPair <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/collision_pair.h</code></p>"},{"location":"muda/collision__pair_8h_source/","title":"File collision_pair.h","text":"<p>File List &gt; ext &gt; geo &gt; spatial_hash &gt; collision_pair.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;iostream&gt;\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::spatial_hash\n{\nclass CollisionPair\n{\n    Eigen::Vector2i id;\n\n  public:\n    Eigen::Vector2i IDs() const { return id; }\n\n    MUDA_GENERIC CollisionPair(int i, int j)\n    {\n        if(i &gt; j)\n        {\n            id[0] = j;\n            id[1] = i;\n        }\n        else\n        {\n            id[0] = i;\n            id[1] = j;\n        }\n    }\n\n    MUDA_GENERIC CollisionPair()\n        : id(-1, -1)\n    {\n    }\n\n    MUDA_GENERIC friend bool operator&lt;(const CollisionPair&amp; l, const CollisionPair&amp; r)\n    {\n        return (l.id[0] &lt; r.id[0]) || (l.id[0] == r.id[0] &amp;&amp; l.id[1] &lt; r.id[1]);\n    }\n\n    MUDA_GENERIC friend bool operator==(const CollisionPair&amp; l, const CollisionPair&amp; r)\n    {\n        return (l.id[0] == r.id[0] &amp;&amp; l.id[1] == r.id[1]);\n    }\n\n    MUDA_GENERIC bool is_valid() const { return id[0] != -1 &amp;&amp; id[1] != -1; }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CollisionPair&amp; c)\n    {\n        os &lt;&lt; \"(\" &lt;&lt; c.id[0] &lt;&lt; \",\" &lt;&lt; c.id[1] &lt;&lt; \")\";\n        return os;\n    }\n\n    MUDA_GENERIC static CollisionPair invalid()\n    {\n        return CollisionPair(-1, -1);\n    }\n};\n}  // namespace muda::spatial_hash\n</code></pre>"},{"location":"muda/morton__hash_8h/","title":"File morton_hash.h","text":"<p>FileList &gt; ext &gt; geo &gt; spatial_hash &gt; morton_hash.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> </ul>"},{"location":"muda/morton__hash_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace spatial_hash"},{"location":"muda/morton__hash_8h/#classes","title":"Classes","text":"Type Name class Morton &lt;typename T&gt; class Morton &lt;typename T&gt; class Morton &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/morton_hash.h</code></p>"},{"location":"muda/morton__hash_8h_source/","title":"File morton_hash.h","text":"<p>File List &gt; ext &gt; geo &gt; spatial_hash &gt; morton_hash.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;cinttypes&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\nnamespace muda::spatial_hash\n{\ntemplate &lt;typename T&gt;\nclass Morton\n{\n    static_assert(\"Morton not implemented for this type.\");\n};\n\ntemplate &lt;&gt;\nclass Morton&lt;uint32_t&gt;\n{\n  public:\n    using Vector3u = Eigen::Vector3&lt;uint32_t&gt;;\n\n    MUDA_GENERIC uint32_t operator()(const Vector3u&amp; p) const\n    {\n        return (*this)(p.x(), p.y(), p.z());\n    }\n\n    constexpr MUDA_GENERIC uint32_t operator()(uint32_t x, uint32_t y, uint32_t z) const\n    {\n        x = expand_bits(x);\n        y = expand_bits(y);\n        z = expand_bits(z);\n        return x | y &lt;&lt; 1 | z &lt;&lt; 2;\n    }\n\n  private:\n    // Expands a 10-bit integer into 30 bits\n    // by inserting 2 zeros after each bit.\n    constexpr MUDA_GENERIC static uint32_t expand_bits(uint32_t v)\n    {\n        //v = (v * 0x00010001u) &amp; 0xFF0000FFu;\n        //v = (v * 0x00000101u) &amp; 0x0F00F00Fu;\n        //v = (v * 0x00000011u) &amp; 0xC30C30C3u;\n        //v = (v * 0x00000005u) &amp; 0x49249249u;\n\n        v &amp;= 0x3ff;\n        v = (v | v &lt;&lt; 16) &amp; 0x30000ff;\n        v = (v | v &lt;&lt; 8) &amp; 0x300f00f;\n        v = (v | v &lt;&lt; 4) &amp; 0x30c30c3;\n        v = (v | v &lt;&lt; 2) &amp; 0x9249249;\n        return (uint32_t)v;\n    }\n};\n\ntemplate &lt;&gt;\nclass Morton&lt;uint64_t&gt;\n{\n  public:\n    using Vector3u = Eigen::Vector3&lt;uint32_t&gt;;\n\n    MUDA_GENERIC uint64_t operator()(const Vector3u&amp; p) const\n    {\n        return (*this)(p.x(), p.y(), p.z());\n    }\n\n    constexpr MUDA_GENERIC uint64_t operator()(uint32_t x, uint32_t y, uint32_t z) const\n    {\n        x = expand_bits(x);\n        y = expand_bits(y);\n        z = expand_bits(z);\n        return x | y &lt;&lt; 1 | z &lt;&lt; 2;\n    }\n\n  private:\n    // Expands a 21-bit integer into 63 bits\n    // by inserting 2 zeros after each bit.\n    constexpr MUDA_GENERIC static uint64_t expand_bits(uint64_t v)\n    {\n        v &amp;= 0x1fffff;\n        v = (v | v &lt;&lt; 32) &amp; 0x1f00000000ffff;\n        v = (v | v &lt;&lt; 16) &amp; 0x1f0000ff0000ff;\n        v = (v | v &lt;&lt; 8) &amp; 0x100f00f00f00f00f;\n        v = (v | v &lt;&lt; 4) &amp; 0x10c30c30c30c30c3;\n        v = (v | v &lt;&lt; 2) &amp; 0x1249249249249249;\n        return v;\n    }\n};\n}  // namespace muda::spatial_hash\n</code></pre>"},{"location":"muda/sparse__spatial__hash_8h/","title":"File sparse_spatial_hash.h","text":"<p>FileList &gt; ext &gt; geo &gt; spatial_hash &gt; sparse_spatial_hash.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/geo/spatial_hash/sparse_spatial_hash_impl.h&gt;</code></li> </ul>"},{"location":"muda/sparse__spatial__hash_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace spatial_hash"},{"location":"muda/sparse__spatial__hash_8h/#classes","title":"Classes","text":"Type Name class DefaultPredication class SparseSpatialHash &lt;typename Hash&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/sparse_spatial_hash.h</code></p>"},{"location":"muda/sparse__spatial__hash_8h_source/","title":"File sparse_spatial_hash.h","text":"<p>File List &gt; ext &gt; geo &gt; spatial_hash &gt; sparse_spatial_hash.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/geo/spatial_hash/sparse_spatial_hash_impl.h&gt;\n\nnamespace muda::spatial_hash\n{\nclass DefaultPredication\n{\n  public:\n    __device__ bool operator()(int i, int j) { return true; }\n};\n\ntemplate &lt;typename Hash = Morton&lt;uint32_t&gt;&gt;\nclass SparseSpatialHash\n{\n    // algorithm comes from:\n    // https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda\n  private:\n    using Impl = details::SparseSpatialHashImpl&lt;Hash&gt;;\n\n    Impl m_impl;\n\n  public:\n    SparseSpatialHash(muda::Stream&amp; stream = muda::Stream::Default())\n        : m_impl(stream)\n    {\n    }\n\n    template &lt;typename Pred = DefaultPredication&gt;\n    void detect(CBufferView&lt;BoundingSphere&gt;  spheres,\n                DeviceBuffer&lt;CollisionPair&gt;&amp; collisionPairs,\n                Pred&amp;&amp;                       pred = {})\n    {\n        m_impl.level = 0;\n        m_impl.detect(spheres, false, collisionPairs, std::forward&lt;Pred&gt;(pred));\n    }\n\n    template &lt;typename Pred = DefaultPredication&gt;\n    void detect(int                          level,\n                CBufferView&lt;BoundingSphere&gt;  spheres,\n                DeviceBuffer&lt;CollisionPair&gt;&amp; collisionPairs,\n                Pred&amp;&amp;                       pred = {})\n    {\n        MUDA_KERNEL_ASSERT(level &gt;= 0, \"invalid level\");\n        m_impl.level = level;\n        m_impl.detect(spheres, true, collisionPairs, std::forward&lt;Pred&gt;(pred));\n    }\n};\n}  // namespace muda::spatial_hash\n</code></pre>"},{"location":"muda/sparse__spatial__hash__impl_8h/","title":"File sparse_spatial_hash_impl.h","text":"<p>FileList &gt; ext &gt; geo &gt; spatial_hash &gt; sparse_spatial_hash_impl.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/spatial_hash/morton_hash.h&gt;</code></li> <li><code>#include &lt;muda/launch/launch.h&gt;</code></li> <li><code>#include &lt;muda/launch/parallel_for.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/spatial_hash/bounding_volume.h&gt;</code></li> <li><code>#include &lt;muda/ext/geo/spatial_hash/collision_pair.h&gt;</code></li> <li><code>#include \"details/sparse_spatial_hash_impl.inl\"</code></li> </ul>"},{"location":"muda/sparse__spatial__hash__impl_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace spatial_hash namespace details"},{"location":"muda/sparse__spatial__hash__impl_8h/#classes","title":"Classes","text":"Type Name class SpatialHashTableInfo &lt;typename Hash&gt; class SpatialPartitionCell To represent a cell-object pair in the spatial hash 3D grid e.g. (cell_id,object_id) = (1024, 32) for the meaning: the 32th object overlap with the 1024th cell. class SparseSpatialHashImpl &lt;typename Hash&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/geo/spatial_hash/sparse_spatial_hash_impl.h</code></p>"},{"location":"muda/sparse__spatial__hash__impl_8h_source/","title":"File sparse_spatial_hash_impl.h","text":"<p>File List &gt; ext &gt; geo &gt; spatial_hash &gt; sparse_spatial_hash_impl.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/ext/geo/spatial_hash/morton_hash.h&gt;\n#include &lt;muda/launch/launch.h&gt;\n#include &lt;muda/launch/parallel_for.h&gt;\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/ext/geo/spatial_hash/bounding_volume.h&gt;\n#include &lt;muda/ext/geo/spatial_hash/collision_pair.h&gt;\nnamespace muda::spatial_hash\n{\nclass SpatialPartitionCell\n{\n  public:\n    using Vector3u = Eigen::Vector3&lt;uint32_t&gt;;\n    using U32      = uint32_t;\n\n    struct\n    {\n        // most use unsigned int to avoid comparison problem\n        U32 pass : 3;\n        U32 home : 3;\n        U32 overlap : 8;\n    } ctlbit;  // controll bit\n\n    U32 cid;  // cell id\n    U32 oid;\n    // Vector3u ijk;\n\n    MUDA_GENERIC SpatialPartitionCell()\n        : cid(~0u)\n        , oid(~0u)\n    //, ijk(Vector3u::Zero())\n    {\n        ctlbit.home    = 0u;\n        ctlbit.overlap = 0u;\n        ctlbit.pass    = 0u;\n    }\n\n    MUDA_GENERIC SpatialPartitionCell(U32 cid, U32 oid)\n        : cid(cid)\n        , oid(oid)\n    //, ijk(Vector3u::Zero())\n    {\n        ctlbit.home    = 0u;\n        ctlbit.overlap = 0u;\n    }\n\n    MUDA_GENERIC bool is_phantom() const { return ctlbit.home != ctlbit.pass; }\n\n    MUDA_GENERIC bool is_home() const { return ctlbit.home == ctlbit.pass; }\n\n    MUDA_GENERIC void set_as_phantom(const Vector3u&amp; home_ijk, const Vector3u&amp; cell_ijk)\n    {\n        ctlbit.pass = pass_type(cell_ijk);\n        ctlbit.home = pass_type(home_ijk);\n    }\n\n    MUDA_GENERIC void set_as_home(const Vector3u&amp; ijk)\n    {\n        // bit   2           1           0\n        // home  (i % 2)     (j % 2)     (k % 2)\n        ctlbit.home = pass_type(ijk);\n        ctlbit.pass = ctlbit.home;\n        ctlbit.overlap |= (1 &lt;&lt; ctlbit.home);\n    }\n\n    MUDA_GENERIC void set_overlap(const Vector3u&amp; ijk)\n    {\n        ctlbit.overlap |= (1 &lt;&lt; pass_type(ijk));\n    }\n\n    MUDA_GENERIC static U32 pass_type(const Vector3u&amp; ijk)\n    {\n        return (((U32)ijk(0) % 2) &lt;&lt; 2) | (((U32)ijk(1) % 2) &lt;&lt; 1)\n               | (((U32)ijk(2) % 2) &lt;&lt; 0);\n    }\n\n    MUDA_GENERIC static bool allow_ignore(const SpatialPartitionCell&amp; l,\n                                          const SpatialPartitionCell&amp; r)\n    {\n        if(l.is_phantom() &amp;&amp; r.is_phantom())\n        {\n            return true;\n        }\n\n        const SpatialPartitionCell* arr[] = {&amp;l, &amp;r};\n\n        U32 pass           = l.ctlbit.pass;\n        U32 common_overlap = l.ctlbit.overlap &amp; r.ctlbit.overlap;\n#pragma unroll\n        for(U32 i = 0; i &lt; 2; ++i)\n        {\n            U32 encode_home = (1 &lt;&lt; arr[i]-&gt;ctlbit.home);\n            if(arr[i]-&gt;ctlbit.home &lt; pass &amp;&amp; (common_overlap &amp; encode_home))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\ntemplate &lt;typename Hash = Morton&lt;uint32_t&gt;&gt;\nclass SpatialHashTableInfo\n{\n    using Float    = float;\n    using Vector3  = Eigen::Vector&lt;Float, 3&gt;;\n    using Vector3i = Eigen::Vector&lt;int, 3&gt;;\n    using Vector3u = Eigen::Vector&lt;uint32_t, 3&gt;;\n    using U32      = uint32_t;\n\n  public:\n    Float   cell_size = 0.0f;\n    Vector3 coord_min = Vector3::Zero();\n\n    MUDA_GENERIC SpatialHashTableInfo() = default;\n\n    MUDA_GENERIC SpatialHashTableInfo(Float cell_size, const Vector3&amp; coord_min)\n        : cell_size(cell_size)\n        , coord_min(coord_min)\n    {\n    }\n\n    MUDA_GENERIC U32 hash_cell(const Vector3&amp; xyz) const\n    {\n        return hash_cell(cell(xyz));\n    }\n\n    MUDA_GENERIC U32 hash_cell(const Vector3u&amp; ijk) const\n    {\n        return Hash()(ijk) % 0x40000000;\n    }\n\n    MUDA_GENERIC Vector3u cell(const Vector3&amp; xyz) const\n    {\n        Vector3u ret;\n#pragma unroll\n        for(int i = 0; i &lt; 3; ++i)\n            ret(i) = (xyz(i) - coord_min(i)) / cell_size;\n        return ret;\n    }\n    MUDA_GENERIC Vector3 coord(const Vector3u&amp; ijk) const\n    {\n        Vector3 ret;\n#pragma unroll\n        for(int i = 0; i &lt; 3; ++i)\n            ret(i) = ijk(i) * cell_size + coord_min(i);\n        return ret;\n    }\n\n    MUDA_GENERIC Vector3 cell_center_coord(const Vector3u&amp; ijk) const\n    {\n        Vector3 ret;\n#pragma unroll\n        for(int i = 0; i &lt; 3; ++i)\n            ret(i) = (ijk(i) + 0.5f) * cell_size + coord_min(i);\n        return ret;\n    }\n};\n\nnamespace details\n{\n    template &lt;typename Hash = Morton&lt;uint32_t&gt;&gt;\n    class SparseSpatialHashImpl\n    {\n      public:\n        using Cell     = SpatialPartitionCell;\n        using U32      = uint32_t;\n        using I32      = int32_t;\n        using Vector3u = Eigen::Vector3&lt;U32&gt;;\n        using Vector3i = Eigen::Vector3&lt;I32&gt;;\n        using Vector3  = Eigen::Vector3f;\n\n        muda::Stream&amp; m_stream;\n\n        CBufferView&lt;BoundingSphere&gt; spheres;\n\n        DeviceVar&lt;int&gt;     cellCount;\n        DeviceVar&lt;int&gt;     pairCount;\n        DeviceVar&lt;float&gt;   maxRadius;\n        DeviceVar&lt;Vector3&gt; minCoord;\n\n        DeviceVar&lt;SpatialHashTableInfo&lt;Hash&gt;&gt; spatialHashConfig;\n        SpatialHashTableInfo&lt;Hash&gt;            h_spatialHashConfig;\n\n        DeviceBuffer&lt;SpatialPartitionCell&gt; cellArrayValue;\n        DeviceBuffer&lt;SpatialPartitionCell&gt; cellArrayValueSorted;\n        DeviceBuffer&lt;int&gt;                  cellArrayKey;\n        DeviceBuffer&lt;int&gt;                  cellArrayKeySorted;\n\n        DeviceBuffer&lt;int&gt; uniqueKey;\n        DeviceVar&lt;int&gt;    uniqueKeyCount;\n        int               validCellCount;\n        int               sum;\n        size_t            pairListOffset = 0;\n\n        DeviceBuffer&lt;int&gt; objCountInCell;\n        DeviceBuffer&lt;int&gt; objCountInCellPrefixSum;\n\n        DeviceBuffer&lt;int&gt; collisionPairCount;\n        DeviceBuffer&lt;int&gt; collisionPairPrefixSum;\n\n        int  level       = 0;\n        bool empty_level = false;\n\n        //using Hash = Hash;\n        SparseSpatialHashImpl(muda::Stream&amp; stream = muda::Stream::Default())\n            : m_stream(stream)\n        {\n        }\n\n        template &lt;typename Pred&gt;\n        void detect(CBufferView&lt;BoundingSphere&gt;  boundingSphereList,\n                    bool                         append,\n                    DeviceBuffer&lt;CollisionPair&gt;&amp; collisionPairs,\n                    Pred&amp;&amp;                       pred);\n\n        DeviceBuffer&lt;float&gt;         allRadius;\n        DeviceBuffer&lt;Vector3&gt;       allCoords;\n        DeviceBuffer&lt;int&gt;           cellToCollisionPairUpperBound;\n        DeviceBuffer&lt;int&gt;           cellToCollisionPairUpperBoundPrefixSum;\n        DeviceBuffer&lt;int&gt;           potentialCollisionPairIdToCellIndexBuffer;\n        DeviceBuffer&lt;int&gt;           potentialCollisionPairIdToCellIndex;\n        DeviceBuffer&lt;CollisionPair&gt; collisionPairBuffer;\n        DeviceVar&lt;int&gt;              validCollisionPairCount;\n\n        void calculate_hash_table_basic_info();\n\n        void setup_hash_table();\n\n        void fill_hash_cells();\n\n        void count_object_per_cell();\n\n        template &lt;typename Pred&gt;\n        void simple_setup_collision_pairs(Pred&amp;&amp; pred, DeviceBuffer&lt;CollisionPair&gt;&amp; collisionPairs);\n\n        template &lt;typename Pred&gt;\n        void simple_count_collision_pairs(Pred&amp;&amp; pred);\n\n        void alloc_collision_pair_list(DeviceBuffer&lt;CollisionPair&gt;&amp; collisionPairs,\n                                       int totalCollisionPairCount);\n\n        template &lt;typename Pred&gt;\n        void simple_fill_collision_pair_list(DeviceBuffer&lt;CollisionPair&gt;&amp; collisionPairs,\n                                             Pred&amp;&amp; pred);\n\n        template &lt;typename Pred&gt;\n        void balanced_setup_collision_pairs(bool append,\n                                            DeviceBuffer&lt;CollisionPair&gt;&amp; collisionPairs,\n                                            Pred&amp;&amp; pred);\n    };\n}  // namespace details\n}  // namespace muda::spatial_hash\n\n#include \"details/sparse_spatial_hash_impl.inl\"\n</code></pre>"},{"location":"muda/dir_6f09a74f7ee1db37d591c4a0fc2f2223/","title":"Dir src/muda/ext/linear_system","text":"<p>FileList &gt; ext &gt; linear_system</p>"},{"location":"muda/dir_6f09a74f7ee1db37d591c4a0fc2f2223/#files","title":"Files","text":"Type Name file bcoo_matrix_view.h file bcoo_matrix_viewer.h file bcoo_vector_view.h file bcoo_vector_viewer.h file bsr_matrix_view.h file common.h file csr_matrix_view.h file dense_matrix_view.h file dense_matrix_viewer.h file dense_vector_view.h file dense_vector_viewer.h file device_bcoo_matrix.h file device_bcoo_vector.h file device_bsr_matrix.h file device_csr_matrix.h file device_dense_matrix.h file device_dense_vector.h file device_doublet_vector.h file device_triplet_matrix.h file doublet_vector_view.h file doublet_vector_viewer.h file linear_system_context.h file linear_system_handles.h file linear_system_solve_reorder.h file linear_system_solve_tolerance.h file matrix_format_converter.h file matrix_format_converter_impl.h file triplet_matrix_view.h file triplet_matrix_viewer.h"},{"location":"muda/dir_6f09a74f7ee1db37d591c4a0fc2f2223/#directories","title":"Directories","text":"Type Name dir type_mapper <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/</code></p>"},{"location":"muda/bcoo__matrix__view_8h/","title":"File bcoo_matrix_view.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; bcoo_matrix_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/triplet_matrix_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bcoo_matrix_viewer.h&gt;</code></li> <li><code>#include \"details/bcoo_matrix_view.inl\"</code></li> </ul>"},{"location":"muda/bcoo__matrix__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/bcoo__matrix__view_8h/#classes","title":"Classes","text":"Type Name class COOMatrixViewT &lt;IsConst, typename Ty&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/bcoo_matrix_view.h</code></p>"},{"location":"muda/bcoo__matrix__view_8h_source/","title":"File bcoo_matrix_view.h","text":"<p>File List &gt; ext &gt; linear_system &gt; bcoo_matrix_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/triplet_matrix_view.h&gt;\n#include &lt;muda/ext/linear_system/bcoo_matrix_viewer.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T, int N&gt;\nusing BCOOMatrixView = TripletMatrixView&lt;T, N&gt;;\ntemplate &lt;typename T, int N&gt;\nusing CBCOOMatrixView = CTripletMatrixView&lt;T, N&gt;;\n}  // namespace muda\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename Ty&gt;\nclass COOMatrixViewT : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class COOMatrixViewT;\n\n  public:\n    static_assert(!std::is_const_v&lt;Ty&gt;, \"Ty must be non-const\");\n    using NonConstView = COOMatrixViewT&lt;false, Ty&gt;;\n    using ConstView    = COOMatrixViewT&lt;true, Ty&gt;;\n    using ThisView     = COOMatrixViewT&lt;IsConst, Ty&gt;;\n\n  protected:\n    // matrix info\n    int m_rows = 0;\n    int m_cols = 0;\n\n    // triplet info\n    int m_triplet_index_offset = 0;\n    int m_triplet_count        = 0;\n    int m_total_triplet_count  = 0;\n\n    // sub matrix info\n    int2 m_submatrix_offset = {0, 0};\n    int2 m_submatrix_extent = {0, 0};\n\n    // data\n    auto_const_t&lt;int&gt;* m_row_indices;\n    auto_const_t&lt;int&gt;* m_col_indices;\n    auto_const_t&lt;Ty&gt;*  m_values;\n\n    mutable cusparseMatDescr_t   m_legacy_descr = nullptr;\n    mutable cusparseSpMatDescr_t m_descr        = nullptr;\n    bool                         m_trans        = false;\n\n  public:\n    MUDA_GENERIC COOMatrixViewT() = default;\n\n    MUDA_GENERIC COOMatrixViewT(int                  rows,\n                                int                  cols,\n                                int                  triplet_index_offset,\n                                int                  triplet_count,\n                                int                  total_triplet_count,\n                                int2                 submatrix_offset,\n                                int2                 submatrix_extent,\n                                auto_const_t&lt;int&gt;*   row_indices,\n                                auto_const_t&lt;int&gt;*   col_indices,\n                                auto_const_t&lt;Ty&gt;*    values,\n                                cusparseSpMatDescr_t descr,\n                                cusparseMatDescr_t   legacy_descr,\n                                bool                 trans)\n\n        : m_rows(rows)\n        , m_cols(cols)\n        , m_triplet_index_offset(triplet_index_offset)\n        , m_triplet_count(triplet_count)\n        , m_total_triplet_count(total_triplet_count)\n        , m_row_indices(row_indices)\n        , m_col_indices(col_indices)\n        , m_values(values)\n        , m_submatrix_offset(submatrix_offset)\n        , m_submatrix_extent(submatrix_extent)\n        , m_descr(descr)\n        , m_legacy_descr(legacy_descr)\n        , m_trans(trans)\n    {\n        MUDA_KERNEL_ASSERT(triplet_index_offset + triplet_count &lt;= total_triplet_count,\n                           \"COOMatrixView: out of range, m_total_triplet_count=%d, \"\n                           \"your triplet_index_offset=%d, triplet_count=%d\",\n                           total_triplet_count,\n                           triplet_index_offset,\n                           triplet_count);\n\n\n        MUDA_KERNEL_ASSERT(submatrix_offset.x &gt;= 0 &amp;&amp; submatrix_offset.y &gt;= 0,\n                           \"TripletMatrixView: submatrix_offset is out of range, submatrix_offset.x=%d, submatrix_offset.y=%d\",\n                           submatrix_offset.x,\n                           submatrix_offset.y);\n\n        MUDA_KERNEL_ASSERT(submatrix_offset.x + submatrix_extent.x &lt;= rows,\n                           \"TripletMatrixView: submatrix is out of range, submatrix_offset.x=%d, submatrix_extent.x=%d, total_block_rows=%d\",\n                           submatrix_offset.x,\n                           submatrix_extent.x,\n                           rows);\n\n        MUDA_KERNEL_ASSERT(submatrix_offset.y + submatrix_extent.y &lt;= cols,\n                           \"TripletMatrixView: submatrix is out of range, submatrix_offset.y=%d, submatrix_extent.y=%d, total_block_cols=%d\",\n                           submatrix_offset.y,\n                           submatrix_extent.y,\n                           cols);\n    }\n\n    MUDA_GENERIC COOMatrixViewT(int                  rows,\n                                int                  cols,\n                                int                  total_triplet_count,\n                                auto_const_t&lt;int&gt;*   row_indices,\n                                auto_const_t&lt;int&gt;*   col_indices,\n                                auto_const_t&lt;Ty&gt;*    values,\n                                cusparseSpMatDescr_t descr,\n                                cusparseMatDescr_t   legacy_descr,\n                                bool                 trans)\n        : COOMatrixViewT(rows,\n                         cols,\n                         0,\n                         total_triplet_count,\n                         total_triplet_count,\n                         {0, 0},\n                         {rows, cols},\n                         row_indices,\n                         col_indices,\n                         values,\n                         descr,\n                         legacy_descr,\n                         trans)\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC COOMatrixViewT(const COOMatrixViewT&lt;OtherIsConst, Ty&gt;&amp; other)\n        : m_rows(other.m_rows)\n        , m_cols(other.m_cols)\n        , m_triplet_index_offset(other.m_triplet_index_offset)\n        , m_triplet_count(other.m_triplet_count)\n        , m_total_triplet_count(other.m_total_triplet_count)\n        , m_submatrix_offset(other.m_submatrix_offset)\n        , m_submatrix_extent(other.m_submatrix_extent)\n        , m_row_indices(other.m_row_indices)\n        , m_col_indices(other.m_col_indices)\n        , m_values(other.m_values)\n        , m_descr(other.m_descr)\n        , m_legacy_descr(other.m_legacy)\n    {\n    }\n\n    MUDA_GENERIC auto as_const() const\n    {\n        return ConstView{m_rows,\n                         m_cols,\n                         m_triplet_index_offset,\n                         m_triplet_count,\n                         m_total_triplet_count,\n                         m_submatrix_offset,\n                         m_submatrix_extent,\n                         m_row_indices,\n                         m_col_indices,\n                         m_values,\n                         m_descr,\n                         m_legacy_descr,\n                         m_trans};\n    }\n\n    MUDA_GENERIC auto cviewer() const\n    {\n        MUDA_KERNEL_ASSERT(!m_trans,\n                           \"COOMatrixView: cviewer() is not supported for \"\n                           \"transposed matrix, please use a non-transposed view of this matrix\");\n        return CTripletMatrixViewer&lt;Ty, 1&gt;{m_rows,\n                                           m_cols,\n                                           m_triplet_index_offset,\n                                           m_triplet_count,\n                                           m_total_triplet_count,\n                                           m_submatrix_offset,\n                                           m_submatrix_extent,\n                                           m_row_indices,\n                                           m_col_indices,\n                                           m_values};\n    }\n\n    MUDA_GENERIC auto viewer()\n    {\n        MUDA_ASSERT(!m_trans,\n                    \"COOMatrixView: viewer() is not supported for \"\n                    \"transposed matrix, please use a non-transposed view of this matrix\");\n        return TripletMatrixViewer&lt;Ty, 1&gt;{m_rows,\n                                          m_cols,\n                                          m_triplet_index_offset,\n                                          m_triplet_count,\n                                          m_total_triplet_count,\n                                          m_submatrix_offset,\n                                          m_submatrix_extent,\n                                          m_row_indices,\n                                          m_col_indices,\n                                          m_values};\n    }\n\n    // const access\n    auto values() const { return m_values; }\n    auto row_indices() const { return m_row_indices; }\n    auto col_indices() const { return m_col_indices; }\n\n    auto rows() const { return m_rows; }\n    auto cols() const { return m_cols; }\n    auto triplet_count() const { return m_triplet_count; }\n    auto tripet_index_offset() const { return m_triplet_index_offset; }\n    auto total_triplet_count() const { return m_total_triplet_count; }\n    auto is_trans() const { return m_trans; }\n\n    auto legacy_descr() const { return m_legacy_descr; }\n    auto descr() const { return m_descr; }\n};\n\ntemplate &lt;typename Ty&gt;\nusing COOMatrixView = COOMatrixViewT&lt;false, Ty&gt;;\ntemplate &lt;typename Ty&gt;\nusing CCOOMatrixView = COOMatrixViewT&lt;true, Ty&gt;;\n}  // namespace muda\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;COOMatrixView&lt;T&gt;&gt;\n{\n    using type = CCOOMatrixView&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CCOOMatrixView&lt;T&gt;&gt;\n{\n    using type = COOMatrixView&lt;T&gt;;\n};\n}  // namespace muda\n#include \"details/bcoo_matrix_view.inl\"\n</code></pre>"},{"location":"muda/bcoo__matrix__viewer_8h/","title":"File bcoo_matrix_viewer.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; bcoo_matrix_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/triplet_matrix_viewer.h&gt;</code></li> <li><code>#include \"details/bcoo_matrix_viewer.inl\"</code></li> </ul>"},{"location":"muda/bcoo__matrix__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/bcoo_matrix_viewer.h</code></p>"},{"location":"muda/bcoo__matrix__viewer_8h_source/","title":"File bcoo_matrix_viewer.h","text":"<p>File List &gt; ext &gt; linear_system &gt; bcoo_matrix_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/triplet_matrix_viewer.h&gt;\nnamespace muda\n{\ntemplate &lt;typename T, int N&gt;\nusing BCOOMatrixViewer = CTripletMatrixViewer&lt;T, N&gt;;\n\ntemplate &lt;typename T, int N&gt;\nusing CBCOOMatrixViewer = CTripletMatrixViewer&lt;T, N&gt;;\n\ntemplate &lt;typename T&gt;\nusing COOMatrixViewer = BCOOMatrixViewer&lt;T, 1&gt;;\n\ntemplate &lt;typename T&gt;\nusing CCOOMatrixViewer = CBCOOMatrixViewer&lt;T, 1&gt;;\n}  // namespace muda\n\n#include \"details/bcoo_matrix_viewer.inl\"\n</code></pre>"},{"location":"muda/bcoo__vector__view_8h/","title":"File bcoo_vector_view.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; bcoo_vector_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/doublet_vector_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bcoo_vector_viewer.h&gt;</code></li> <li><code>#include \"details/bcoo_vector_view.inl\"</code></li> </ul>"},{"location":"muda/bcoo__vector__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/bcoo__vector__view_8h/#classes","title":"Classes","text":"Type Name class COOVectorViewBase &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/bcoo_vector_view.h</code></p>"},{"location":"muda/bcoo__vector__view_8h_source/","title":"File bcoo_vector_view.h","text":"<p>File List &gt; ext &gt; linear_system &gt; bcoo_vector_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/doublet_vector_view.h&gt;\n#include &lt;muda/ext/linear_system/bcoo_vector_viewer.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T, int N&gt;\nusing BCOOVectorView = DoubletVectorView&lt;T, N&gt;;\ntemplate &lt;typename T, int N&gt;\nusing CBCOOVectorView = CDoubletVectorView&lt;T, N&gt;;\n}  // namespace muda\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass COOVectorViewBase : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n  public:\n    static_assert(!std::is_const_v&lt;T&gt;, \"T must be non-const\");\n    using NonConstView = COOVectorViewBase&lt;false, T&gt;;\n    using ConstView    = COOVectorViewBase&lt;true, T&gt;;\n    using ThisView     = COOVectorViewBase&lt;IsConst, T&gt;;\n\n    using CViewer    = CCOOVectorViewer&lt;T&gt;;\n    using Viewer     = COOVectorViewer&lt;T&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n\n  protected:\n    // vector info\n    int m_size = 0;\n\n    //doublet info\n    int m_doublet_index_offset = 0;\n    int m_doublet_count        = 0;\n    int m_total_doublet_count  = 0;\n\n    // data\n    auto_const_t&lt;int&gt;* m_indices = nullptr;\n    auto_const_t&lt;T&gt;*   m_values  = nullptr;\n\n    mutable cusparseSpVecDescr_t m_descr = nullptr;\n\n  public:\n    MUDA_GENERIC COOVectorViewBase() = default;\n    MUDA_GENERIC COOVectorViewBase(int                  size,\n                                   int                  doublet_index_offset,\n                                   int                  doublet_count,\n                                   int                  total_doublet_count,\n                                   auto_const_t&lt;int&gt;*   indices,\n                                   auto_const_t&lt;T&gt;*     values,\n                                   cusparseSpVecDescr_t descr)\n        : m_size(size)\n        , m_doublet_index_offset(doublet_index_offset)\n        , m_doublet_count(doublet_count)\n        , m_total_doublet_count(total_doublet_count)\n        , m_indices(indices)\n        , m_values(values)\n        , m_descr(descr)\n    {\n        MUDA_KERNEL_ASSERT(doublet_index_offset + doublet_count &lt;= total_doublet_count,\n                           \"COOVectorView: out of range, m_total_doublet_count=%d, \"\n                           \"your doublet_index_offset=%d, doublet_count=%d\",\n                           total_doublet_count,\n                           doublet_index_offset,\n                           doublet_count);\n    }\n\n    // implicit conversion\n\n    MUDA_GENERIC auto as_const() const -&gt; ConstView\n    {\n        return ConstView{m_size,\n                         m_doublet_index_offset,\n                         m_doublet_count,\n                         m_total_doublet_count,\n                         m_indices,\n                         m_values,\n                         m_descr};\n    }\n\n    MUDA_GENERIC operator ConstView() const { return as_const(); }\n\n    // non-const accessor\n\n    MUDA_GENERIC auto viewer()\n    {\n        return ThisViewer{\n            m_size, m_doublet_index_offset, m_doublet_count, m_total_doublet_count, m_indices, m_values};\n    }\n\n    MUDA_GENERIC auto subview(int offset, int count)\n    {\n        return ThisView{m_size,\n                        m_doublet_index_offset + offset,\n                        count,\n                        m_total_doublet_count,\n                        m_indices,\n                        m_values,\n                        m_descr};\n    }\n\n    MUDA_GENERIC auto subview(int offset)\n    {\n        return subview(offset, m_doublet_count - offset);\n    }\n\n    // const accessor\n\n    MUDA_GENERIC ConstView subview(int offset, int count) const\n    {\n        return remove_const(*this).subview(offset, count);\n    }\n\n    MUDA_GENERIC ConstView subview(int offset) const\n    {\n        return remove_const(*this).subview(offset);\n    }\n\n    MUDA_GENERIC auto cviewer() const { return remove_const(*this).viewer(); }\n\n\n    MUDA_GENERIC auto vector_size() const { return m_size; }\n\n    MUDA_GENERIC auto doublet_index_offset() const\n    {\n        return m_doublet_index_offset;\n    }\n\n    MUDA_GENERIC auto doublet_count() const { return m_doublet_count; }\n\n    MUDA_GENERIC auto total_doublet_count() const\n    {\n        return m_total_doublet_count;\n    }\n\n    MUDA_GENERIC auto descr() const { return m_descr; }\n};\n\ntemplate &lt;typename T&gt;\nusing COOVectorView = COOVectorViewBase&lt;false, T&gt;;\ntemplate &lt;typename T&gt;\nusing CCOOVectorView = COOVectorViewBase&lt;true, T&gt;;\n}  // namespace muda\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;COOVectorView&lt;T&gt;&gt;\n{\n    using type = CCOOVectorView&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CCOOVectorView&lt;T&gt;&gt;\n{\n    using type = COOVectorView&lt;T&gt;;\n};\n}  // namespace muda\n\n#include \"details/bcoo_vector_view.inl\"\n</code></pre>"},{"location":"muda/bcoo__vector__viewer_8h/","title":"File bcoo_vector_viewer.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; bcoo_vector_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/doublet_vector_viewer.h&gt;</code></li> <li><code>#include \"details/bcoo_vector_viewer.inl\"</code></li> </ul>"},{"location":"muda/bcoo__vector__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/bcoo_vector_viewer.h</code></p>"},{"location":"muda/bcoo__vector__viewer_8h_source/","title":"File bcoo_vector_viewer.h","text":"<p>File List &gt; ext &gt; linear_system &gt; bcoo_vector_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/doublet_vector_viewer.h&gt;\nnamespace muda\n{\ntemplate &lt;typename T, int N&gt;\nusing BCOOVectorViewer = CDoubletVectorViewer&lt;T, N&gt;;\n\ntemplate &lt;typename T, int N&gt;\nusing CBCOOVectorViewer = CDoubletVectorViewer&lt;T, N&gt;;\n\ntemplate &lt;typename T&gt;\nusing COOVectorViewer = BCOOVectorViewer&lt;T, 1&gt;;\n\ntemplate &lt;typename T&gt;\nusing CCOOVectorViewer = CBCOOVectorViewer&lt;T, 1&gt;;\n}  // namespace muda\n\n#include \"details/bcoo_vector_viewer.inl\"\n</code></pre>"},{"location":"muda/bsr__matrix__view_8h/","title":"File bsr_matrix_view.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; bsr_matrix_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cusparse_v2.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include \"details/bsr_matrix_view.inl\"</code></li> </ul>"},{"location":"muda/bsr__matrix__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/bsr__matrix__view_8h/#classes","title":"Classes","text":"Type Name class BSRMatrixViewT &lt;IsConst, typename Ty, N&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/bsr_matrix_view.h</code></p>"},{"location":"muda/bsr__matrix__view_8h_source/","title":"File bsr_matrix_view.h","text":"<p>File List &gt; ext &gt; linear_system &gt; bsr_matrix_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cusparse_v2.h&gt;\n#include &lt;muda/view/view_base.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename Ty, int N&gt;\nclass BSRMatrixViewT : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U, int M&gt;\n    friend class BSRMatrixViewT;\n\n  public:\n    static_assert(!std::is_const_v&lt;Ty&gt;, \"Ty must be non-const\");\n\n    using ValueT    = std::conditional_t&lt;N == 1, Ty, Eigen::Matrix&lt;Ty, N, N&gt;&gt;;\n    using ConstView = BSRMatrixViewT&lt;true, Ty, N&gt;;\n    using NonConstView = BSRMatrixViewT&lt;false, Ty, N&gt;;\n    using ThisView     = BSRMatrixViewT&lt;IsConst, Ty, N&gt;;\n\n  protected:\n    // data\n    int m_row = 0;\n    int m_col = 0;\n\n    auto_const_t&lt;int&gt;*    m_row_offsets = nullptr;\n    auto_const_t&lt;int&gt;*    m_col_indices = nullptr;\n    auto_const_t&lt;ValueT&gt;* m_values      = nullptr;\n    int                   m_non_zeros   = 0;\n\n    mutable cusparseMatDescr_t   m_legacy_descr = nullptr;\n    mutable cusparseSpMatDescr_t m_descr        = nullptr;\n\n    bool m_trans = false;\n\n  public:\n    MUDA_GENERIC BSRMatrixViewT() noexcept = default;\n    MUDA_GENERIC BSRMatrixViewT(int                   row,\n                                int                   col,\n                                auto_const_t&lt;int&gt;*    block_row_offsets,\n                                auto_const_t&lt;int&gt;*    block_col_indices,\n                                auto_const_t&lt;ValueT&gt;* block_values,\n                                int                   non_zeros,\n                                cusparseSpMatDescr_t  descr,\n                                cusparseMatDescr_t    legacy_descr,\n                                bool                  trans) noexcept\n        : m_row(row)\n        , m_col(col)\n        , m_row_offsets(block_row_offsets)\n        , m_col_indices(block_col_indices)\n        , m_values(block_values)\n        , m_non_zeros(non_zeros)\n        , m_descr(descr)\n        , m_legacy_descr(legacy_descr)\n        , m_trans(trans)\n\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC BSRMatrixViewT(const BSRMatrixViewT&lt;OtherIsConst, Ty, N&gt;&amp; other) noexcept\n        MUDA_REQUIRES(IsConst)\n        : m_row(other.m_row)\n        , m_col(other.m_col)\n        , m_row_offsets(other.m_row_offsets)\n        , m_col_indices(other.m_col_indices)\n        , m_values(other.m_values)\n        , m_non_zeros(other.m_non_zeros)\n        , m_descr(other.m_descr)\n        , m_legacy_descr(other.m_legacy)\n    {\n        static_assert(IsConst);\n    }\n\n    MUDA_GENERIC ConstView as_const() const\n    {\n        return ConstView{\n            m_row, m_col, m_row_offsets, m_col_indices, m_values, m_non_zeros, m_descr, m_legacy_descr, m_trans};\n    }\n\n    MUDA_GENERIC auto values() const { return m_values; }\n    MUDA_GENERIC auto row_offsets() const { return m_row_offsets; }\n    MUDA_GENERIC auto col_indices() const { return m_col_indices; }\n\n    MUDA_GENERIC auto rows() const { return m_row; }\n    MUDA_GENERIC auto cols() const { return m_col; }\n    MUDA_GENERIC auto non_zeros() const { return m_non_zeros; }\n\n    MUDA_GENERIC auto legacy_descr() const { return m_legacy_descr; }\n    MUDA_GENERIC auto descr() const { return m_descr; }\n    MUDA_GENERIC auto is_trans() const { return m_trans; }\n\n    MUDA_GENERIC auto T() const\n    {\n        return ThisView{\n            m_row, m_col, m_row_offsets, m_col_indices, m_values, m_non_zeros, m_descr, m_legacy_descr, !m_trans};\n    }\n};\n\ntemplate &lt;typename Ty, int N&gt;\nusing BSRMatrixView = BSRMatrixViewT&lt;false, Ty, N&gt;;\ntemplate &lt;typename Ty, int N&gt;\nusing CBSRMatrixView = BSRMatrixViewT&lt;true, Ty, N&gt;;\n}  // namespace muda\n\nnamespace muda\n{\ntemplate &lt;typename Ty, int N&gt;\nstruct read_only_view&lt;BSRMatrixView&lt;Ty, N&gt;&gt;\n{\n    using type = CBSRMatrixView&lt;Ty, N&gt;;\n};\n\ntemplate &lt;typename Ty, int N&gt;\nstruct read_write_view&lt;CBSRMatrixView&lt;Ty, N&gt;&gt;\n{\n    using type = BSRMatrixView&lt;Ty, N&gt;;\n};\n}  // namespace muda\n\n\n#include \"details/bsr_matrix_view.inl\"\n</code></pre>"},{"location":"muda/common_8h/","title":"File common.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; common.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/common.h</code></p>"},{"location":"muda/common_8h_source/","title":"File common.h","text":"<p>File List &gt; ext &gt; linear_system &gt; common.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n</code></pre>"},{"location":"muda/csr__matrix__view_8h/","title":"File csr_matrix_view.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; csr_matrix_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/common.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bsr_matrix_view.h&gt;</code></li> <li><code>#include \"details/csr_matrix_view.inl\"</code></li> </ul>"},{"location":"muda/csr__matrix__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/csr_matrix_view.h</code></p>"},{"location":"muda/csr__matrix__view_8h_source/","title":"File csr_matrix_view.h","text":"<p>File List &gt; ext &gt; linear_system &gt; csr_matrix_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/common.h&gt;\n#include &lt;muda/view/view_base.h&gt;\n#include &lt;muda/ext/linear_system/bsr_matrix_view.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename Ty&gt;\nusing CSRMatrixViewT = BSRMatrixViewT&lt;IsConst, Ty, 1&gt;;\n\ntemplate &lt;typename Ty&gt;\nusing CSRMatrixView = CSRMatrixViewT&lt;false, Ty&gt;;\ntemplate &lt;typename Ty&gt;\nusing CCSRMatrixView = CSRMatrixViewT&lt;true, Ty&gt;;\n}  // namespace muda\n\n#include \"details/csr_matrix_view.inl\"\n</code></pre>"},{"location":"muda/dense__matrix__view_8h/","title":"File dense_matrix_view.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; dense_matrix_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/dense_matrix_viewer.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_2d_view.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include \"details/dense_matrix_view.inl\"</code></li> </ul>"},{"location":"muda/dense__matrix__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/dense__matrix__view_8h/#classes","title":"Classes","text":"Type Name class DenseMatrixViewT &lt;IsConst, typename Ty&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/dense_matrix_view.h</code></p>"},{"location":"muda/dense__matrix__view_8h_source/","title":"File dense_matrix_view.h","text":"<p>File List &gt; ext &gt; linear_system &gt; dense_matrix_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/dense_matrix_viewer.h&gt;\n#include &lt;muda/buffer/buffer_2d_view.h&gt;\n#include &lt;muda/view/view_base.h&gt;\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename Ty&gt;\nclass DenseMatrixViewT : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class DenseMatrixViewT;\n\n  public:\n    static_assert(std::is_same_v&lt;Ty, float&gt; || std::is_same_v&lt;Ty, double&gt;,\n                  \"now only support real number\");\n\n    using ConstView    = DenseMatrixViewT&lt;true, Ty&gt;;\n    using NonConstView = DenseMatrixViewT&lt;false, Ty&gt;;\n    using ThisView     = DenseMatrixViewT&lt;IsConst, Ty&gt;;\n\n    using CBuffer2DView = CBuffer2DView&lt;Ty&gt;;\n    using Buffer2DView  = Buffer2DView&lt;Ty&gt;;\n    using ThisBuffer2DView = std::conditional_t&lt;IsConst, CBuffer2DView, Buffer2DView&gt;;\n\n    using CViewer    = CDenseMatrixViewer&lt;Ty&gt;;\n    using Viewer     = DenseMatrixViewer&lt;Ty&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n\n  protected:\n    ThisBuffer2DView m_view;\n    size_t           m_row   = 0;\n    size_t           m_col   = 0;\n    bool             m_trans = false;\n    bool             m_sym   = false;\n\n  public:\n    MUDA_GENERIC DenseMatrixViewT(ThisBuffer2DView view,\n                                  size_t           row,\n                                  size_t           col,\n                                  bool             trans = false,\n                                  bool sym = false) MUDA_NOEXCEPT : m_view(view),\n                                                                    m_row(row),\n                                                                    m_col(col),\n                                                                    m_trans(trans),\n                                                                    m_sym(sym)\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC DenseMatrixViewT(const DenseMatrixViewT&lt;OtherIsConst, Ty&gt;&amp; other) MUDA_NOEXCEPT\n        MUDA_REQUIRES(IsConst)\n        : m_view(other.m_view)\n        , m_row(other.m_row)\n        , m_col(other.m_col)\n    {\n        static_assert(IsConst);\n    }\n\n    MUDA_GENERIC auto as_const() const MUDA_NOEXCEPT\n    {\n        return ConstView{m_view, m_row, m_col, m_trans, m_sym};\n    }\n\n    MUDA_GENERIC auto T() MUDA_NOEXCEPT\n    {\n        return ThisView{m_view, m_row, m_col, !m_trans, m_sym};\n    }\n\n    MUDA_GENERIC auto viewer() MUDA_NOEXCEPT\n    {\n        MUDA_ASSERT(!m_trans,\n                    \"DenseMatrixViewer doesn't support transpose, \"\n                    \"please use the original matrix to create a viewer\");\n        return ThisViewer{m_view, 0, 0, m_row, m_col};\n    }\n\n    MUDA_GENERIC auto cviewer() MUDA_NOEXCEPT\n    {\n        MUDA_ASSERT(!m_trans,\n                    \"DenseMatrixViewer doesn't support transpose, \"\n                    \"please use the original matrix to create a viewer\");\n        return CViewer{m_view, 0, 0, m_row, m_col};\n    }\n\n\n    MUDA_GENERIC auto data() const MUDA_NOEXCEPT\n    {\n        return m_view.origin_data();\n    }\n    MUDA_GENERIC auto buffer_view() const MUDA_NOEXCEPT { return m_view; }\n\n    MUDA_GENERIC bool is_trans() const MUDA_NOEXCEPT { return m_trans; }\n\n    MUDA_GENERIC bool is_sym() const MUDA_NOEXCEPT { return m_sym; }\n\n    MUDA_GENERIC size_t row() const MUDA_NOEXCEPT { return m_row; }\n\n    MUDA_GENERIC size_t col() const MUDA_NOEXCEPT { return m_col; }\n\n    MUDA_GENERIC size_t lda() const MUDA_NOEXCEPT\n    {\n        return m_view.pitch_bytes() / sizeof(Ty);\n    }\n};\n\ntemplate &lt;typename Ty&gt;\nusing DenseMatrixView = DenseMatrixViewT&lt;false, Ty&gt;;\ntemplate &lt;typename Ty&gt;\nusing CDenseMatrixView = DenseMatrixViewT&lt;true, Ty&gt;;\n}  // namespace muda\n\n#include \"details/dense_matrix_view.inl\"\n</code></pre>"},{"location":"muda/dense__matrix__viewer_8h/","title":"File dense_matrix_viewer.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; dense_matrix_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_2d_view.h&gt;</code></li> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> <li><code>#include &lt;muda/atomic.h&gt;</code></li> <li><code>#include \"details/dense_matrix_viewer.inl\"</code></li> </ul>"},{"location":"muda/dense__matrix__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/dense__matrix__viewer_8h/#classes","title":"Classes","text":"Type Name class DenseMatrixViewerT &lt;IsConst, typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/dense_matrix_viewer.h</code></p>"},{"location":"muda/dense__matrix__viewer_8h_source/","title":"File dense_matrix_viewer.h","text":"<p>File List &gt; ext &gt; linear_system &gt; dense_matrix_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;muda/buffer/buffer_2d_view.h&gt;\n#include &lt;muda/viewer/viewer_base.h&gt;\n#include &lt;muda/atomic.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass DenseMatrixViewerT : public ViewerBase&lt;IsConst&gt;\n{\n    static_assert(std::is_same_v&lt;T, float&gt; || std::is_same_v&lt;T, double&gt;,\n                  \"now only support real number\");\n    static_assert(!std::is_const_v&lt;T&gt;, \"T must be non-const type\");\n\n    using Base = ViewerBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class DenseMatrixViewerT;\n\n\n  public:\n    using CBuffer2DView = CBuffer2DView&lt;T&gt;;\n    using Buffer2DView  = Buffer2DView&lt;T&gt;;\n    using ThisBuffer2DView = std::conditional_t&lt;IsConst, CBuffer2DView, Buffer2DView&gt;;\n\n    using ConstViewer    = DenseMatrixViewerT&lt;true, T&gt;;\n    using NonConstViewer = DenseMatrixViewerT&lt;false, T&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n\n    using MatrixType = Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor&gt;;\n    template &lt;typename U&gt;\n    using MapMatrixT =\n        Eigen::Map&lt;U, Eigen::AlignmentType::Unaligned, Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;&gt;;\n    using MapMatrix     = MapMatrixT&lt;MatrixType&gt;;\n    using CMapMatrix    = MapMatrixT&lt;const MatrixType&gt;;\n    using ThisMapMatrix = std::conditional_t&lt;IsConst, CMapMatrix, MapMatrix&gt;;\n\n    MUDA_VIEWER_COMMON_NAME(DenseMatrixViewerT);\n\n  protected:\n    ThisBuffer2DView m_view;\n    size_t           m_row_offset = 0;\n    size_t           m_col_offset = 0;\n    size_t           m_row_size   = 0;\n    size_t           m_col_size   = 0;\n\n  public:\n    MUDA_GENERIC DenseMatrixViewerT(ThisBuffer2DView view,\n                                    size_t           row_offset,\n                                    size_t           col_offset,\n                                    size_t           row_size,\n                                    size_t           col_size)\n        : m_view(view)\n        , m_row_offset(row_offset)\n        , m_col_offset(col_offset)\n        , m_row_size(row_size)\n        , m_col_size(col_size)\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC DenseMatrixViewerT(const DenseMatrixViewerT&lt;OtherIsConst, T&gt;&amp; other)\n        MUDA_REQUIRES(IsConst)\n        : m_view(other.m_view)\n        , m_row_offset(other.m_row_offset)\n        , m_col_offset(other.m_col_offset)\n        , m_row_size(other.m_row_size)\n        , m_col_size(other.m_col_size)\n    {\n        static_assert(IsConst);\n    }\n\n    MUDA_GENERIC auto as_const() const\n    {\n        return ConstViewer{m_view, m_row_offset, m_col_offset, m_row_size, m_col_size};\n    }\n\n    MUDA_GENERIC ThisViewer block(size_t row_offset, size_t col_offset, size_t row_size, size_t col_size) const\n    {\n        MUDA_ASSERT(row_offset + row_size &lt;= m_row_size &amp;&amp; col_offset + col_size &lt;= m_col_size,\n                    \"DenseMatrixViewerBase [%s:%s]: block index out of range, shape=(%lld,%lld), yours index=(%lld,%lld). %s(%d)\",\n                    this-&gt;name(),\n                    this-&gt;kernel_name(),\n                    m_row_size,\n                    m_col_size,\n                    row_offset,\n                    col_offset,\n                    this-&gt;kernel_file(),\n                    this-&gt;kernel_line());\n\n        auto ret = DenseMatrixViewerT{\n            m_view, m_row_offset + row_offset, m_col_offset + col_offset, row_size, col_size};\n        ret.copy_label(*this);\n        return ret;\n    }\n\n    template &lt;int M, int N&gt;\n    MUDA_GENERIC ThisViewer block(int row_offset, int col_offset)\n    {\n        return block(row_offset, col_offset, M, N);\n    }\n    MUDA_GENERIC Eigen::Block&lt;ThisMapMatrix&gt; as_eigen() const\n    {\n        auto outer = m_view.pitch_bytes() / sizeof(T);\n\n        return ThisMapMatrix{m_view.origin_data(),\n                             (int)origin_row(),\n                             (int)origin_col(),\n                             Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;{(int)outer, 1}}\n            .block(m_row_offset, m_col_offset, m_row_size, m_col_size);\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator()(size_t i, size_t j) const\n    {\n        if constexpr(DEBUG_VIEWER)\n        {\n            MUDA_ASSERT(m_view.data(0),\n                        \"DenseMatrixViewer [%s:%s]: data is null\",\n                        this-&gt;name(),\n                        this-&gt;kernel_name());\n            if(m_row_offset == 0 &amp;&amp; m_col_offset == 0)\n            {\n                MUDA_ASSERT(i &lt; m_row_size &amp;&amp; j &lt; m_col_size,\n                            \"DenseMatrixViewer [%s:%s]: index out of range, shape=(%lld,%lld), yours index=(%lld,%lld)\",\n                            this-&gt;name(),\n                            this-&gt;kernel_name(),\n                            m_row_size,\n                            m_col_size,\n                            i,\n                            j);\n            }\n            else\n            {\n                MUDA_ASSERT(i &lt; m_row_size &amp;&amp; j &lt; m_col_size,\n                            \"DenseMatrixViewer [%s:%s]:index out of range, block shape=(%lld,%lld), your index=(%lld,%lld)\",\n                            this-&gt;name(),\n                            this-&gt;kernel_name(),\n                            m_row_size,\n                            m_col_size,\n                            i,\n                            j);\n            }\n        }\n        i += m_row_offset;\n        j += m_col_offset;\n        return *m_view.data(j, i);\n    }\n\n    MUDA_GENERIC auto buffer_view() const { return m_view; }\n\n    MUDA_GENERIC size_t row() const { return m_row_size; }\n\n    MUDA_GENERIC size_t col() const { return m_col_size; }\n\n    MUDA_GENERIC size_t origin_row() const\n    {\n        size_t ret;\n        ret = m_view.extent().width();\n        return ret;\n    }\n\n    MUDA_GENERIC size_t origin_col() const\n    {\n        size_t ret;\n        ret = m_view.extent().height();\n        return ret;\n    }\n\n    MUDA_GENERIC auto row_offset() const { return m_row_offset; }\n\n    MUDA_GENERIC auto col_offset() const { return m_col_offset; }\n\n    MUDA_DEVICE T atomic_add(size_t i, size_t j, T val) const MUDA_REQUIRES(!IsConst)\n    {\n        static_assert(!IsConst, \"Cannot assign to a const viewer\");\n        auto ptr = &amp;this-&gt;operator()(i, j);\n        muda::atomic_add(ptr, val);\n        return val;\n    }\n\n    template &lt;int M, int N&gt;\n    MUDA_DEVICE Eigen::Matrix&lt;T, M, N&gt; atomic_add(const Eigen::Matrix&lt;T, M, N&gt;&amp; other) const\n        MUDA_REQUIRES(!IsConst)\n    {\n        static_assert(!IsConst, \"Cannot assign to a const viewer\");\n        check_size_matching(M, N);\n        Eigen::Matrix&lt;T, M, N&gt; ret;\n#pragma unroll\n        for(int i = 0; i &lt; M; ++i)\n#pragma unroll\n            for(int j = 0; j &lt; N; ++j)\n            {\n                ret(i, j) = atomic_add(i, j, other(i, j));\n            }\n        return ret;\n    }\n\n    template &lt;int M, int N&gt;\n    MUDA_GENERIC DenseMatrixViewerT&amp; operator=(const Eigen::Matrix&lt;T, M, N&gt;&amp; other) const\n        MUDA_REQUIRES(!IsConst)\n    {\n        static_assert(!IsConst, \"Cannot assign to a const viewer\");\n        check_size_matching(M, N);\n#pragma unroll\n        for(int i = 0; i &lt; M; ++i)\n#pragma unroll\n            for(int j = 0; j &lt; N; ++j)\n                (*this)(i, j) = other(i, j);\n        return *this;\n    }\n\n  private:\n    MUDA_GENERIC void check_size_matching(int M, int N) const\n    {\n        MUDA_ASSERT(this-&gt;m_row_size == M &amp;&amp; this-&gt;m_col_size == N,\n                    \"DenseMatrixViewer [%s:%s] shape mismatching, Viewer=(%lld,%lld), yours=(%lld,%lld). %s(%d)\",\n                    this-&gt;name(),\n                    this-&gt;kernel_name(),\n                    this-&gt;m_row_size,\n                    this-&gt;m_col_size,\n                    M,\n                    N,\n                    this-&gt;kernel_file(),\n                    this-&gt;kernel_line());\n    }\n};\n\ntemplate &lt;typename T&gt;\nusing DenseMatrixViewer = DenseMatrixViewerT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CDenseMatrixViewer = DenseMatrixViewerT&lt;true, T&gt;;\n}  // namespace muda\n\n#include \"details/dense_matrix_viewer.inl\"\n</code></pre>"},{"location":"muda/dense__vector__view_8h/","title":"File dense_vector_view.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; dense_vector_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cusparse_v2.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/dense_vector_viewer.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_view.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include \"details/dense_vector_view.inl\"</code></li> </ul>"},{"location":"muda/dense__vector__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/dense__vector__view_8h/#classes","title":"Classes","text":"Type Name class DenseVectorViewT &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/dense_vector_view.h</code></p>"},{"location":"muda/dense__vector__view_8h_source/","title":"File dense_vector_view.h","text":"<p>File List &gt; ext &gt; linear_system &gt; dense_vector_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cusparse_v2.h&gt;\n#include &lt;muda/ext/linear_system/dense_vector_viewer.h&gt;\n#include &lt;muda/buffer/buffer_view.h&gt;\n#include &lt;muda/view/view_base.h&gt;\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass DenseVectorViewT : public ViewBase&lt;IsConst&gt;\n{\n    static_assert(std::is_same_v&lt;T, float&gt; || std::is_same_v&lt;T, double&gt;,\n                  \"now only support real number\");\n\n    using Base = ViewBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class DenseVectorViewT;\n\n  public:\n    using NonConstView = DenseVectorViewT&lt;false, T&gt;;\n    using ConstView    = DenseVectorViewT&lt;true, T&gt;;\n    using ThisView     = DenseVectorViewT&lt;IsConst, T&gt;;\n\n    using CBufferView    = CBufferView&lt;T&gt;;\n    using BufferView     = BufferView&lt;T&gt;;\n    using ThisBufferView = std::conditional_t&lt;IsConst, CBufferView, BufferView&gt;;\n\n    using CViewer    = CDenseVectorViewer&lt;T&gt;;\n    using Viewer     = DenseVectorViewer&lt;T&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, CViewer, Viewer&gt;;\n\n  protected:\n    auto_const_t&lt;T&gt;*             m_data        = nullptr;\n    mutable cusparseDnVecDescr_t m_descr       = nullptr;\n    int                          m_offset      = -1;\n    int                          m_inc         = -1;\n    int                          m_size        = -1;\n    int                          m_origin_size = -1;\n\n  public:\n    MUDA_GENERIC DenseVectorViewT() = default;\n\n    MUDA_GENERIC DenseVectorViewT(auto_const_t&lt;T&gt;*     data,\n                                  cusparseDnVecDescr_t descr,\n                                  int                  offset,\n                                  int                  inc,\n                                  int                  size,\n                                  int                  origin_size)\n        : m_data(data)\n        , m_descr(descr)\n        , m_offset(offset)\n        , m_inc(inc)\n        , m_size(size)\n        , m_origin_size(origin_size)\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC DenseVectorViewT(const DenseVectorViewT&lt;OtherIsConst, T&gt;&amp; other)\n        MUDA_REQUIRES(IsConst)\n        : m_data(other.m_data)\n        , m_descr(other.m_descr)\n        , m_offset(other.m_offset)\n        , m_inc(other.m_inc)\n        , m_size(other.m_size)\n        , m_origin_size(other.m_origin_size)\n    {\n        static_assert(IsConst, \"Cannot assign to a const viewer\");\n    }\n\n    MUDA_GENERIC ConstView as_const() const\n    {\n        return ConstView{m_data, m_descr, m_offset, m_inc, m_size, m_origin_size};\n    }\n\n    // non-const accessor\n    MUDA_GENERIC auto viewer() const\n    {\n        return ThisViewer{m_data, m_offset, m_size, m_origin_size};\n    }\n    MUDA_GENERIC auto buffer_view() const\n    {\n        return ThisBufferView{m_data, size_t(m_offset), size_t(m_inc * m_size)};\n    }\n\n    MUDA_GENERIC auto data() const { return m_data + m_offset; }\n\n    MUDA_GENERIC auto origin_data() const { return m_data; }\n\n    MUDA_GENERIC auto offset() const { return m_offset; }\n\n    MUDA_GENERIC auto size() const { return m_size; }\n\n    MUDA_GENERIC auto cviewer() const\n    {\n        MUDA_ASSERT(inc() == 1, \"When using cviewer(), inc!=1 is not allowed\");\n        return CViewer{m_data, m_offset, m_size, m_origin_size};\n    }\n\n    MUDA_GENERIC auto inc() const { return m_inc; }\n\n    MUDA_GENERIC auto descr() const\n    {\n        MUDA_ASSERT(inc() == 1, \"When using descr(), inc!=1 is not allowed\");\n        return m_descr;\n    }\n\n    MUDA_GENERIC auto subview(int offset, int size) const\n    {\n        MUDA_ASSERT(inc() == 1, \"When using subview(), inc!=1 is not allowed\");\n        MUDA_ASSERT(offset + size &lt;= m_size, \"subview out of range\");\n        return ThisView{m_data, m_descr, m_offset + offset, m_inc, size, m_origin_size};\n    }\n};\n\ntemplate &lt;typename Ty&gt;\nusing DenseVectorView = DenseVectorViewT&lt;false, Ty&gt;;\ntemplate &lt;typename Ty&gt;\nusing CDenseVectorView = DenseVectorViewT&lt;true, Ty&gt;;\n}  // namespace muda\n\nnamespace muda\n{\ntemplate &lt;typename Ty&gt;\nstruct read_only_view&lt;DenseVectorView&lt;Ty&gt;&gt;\n{\n    using type = CDenseVectorView&lt;Ty&gt;;\n};\n\ntemplate &lt;typename Ty&gt;\nstruct read_write_view&lt;DenseVectorView&lt;Ty&gt;&gt;\n{\n    using type = DenseVectorView&lt;Ty&gt;;\n};\n}  // namespace muda\n\n\n#include \"details/dense_vector_view.inl\"\n</code></pre>"},{"location":"muda/dense__vector__viewer_8h/","title":"File dense_vector_viewer.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; dense_vector_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;muda/buffer/buffer_2d_view.h&gt;</code></li> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> <li><code>#include &lt;cublas_v2.h&gt;</code></li> <li><code>#include &lt;muda/atomic.h&gt;</code></li> <li><code>#include \"details/dense_vector_viewer.inl\"</code></li> </ul>"},{"location":"muda/dense__vector__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/dense__vector__viewer_8h/#classes","title":"Classes","text":"Type Name class DenseVectorViewerT &lt;IsConst, typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/dense_vector_viewer.h</code></p>"},{"location":"muda/dense__vector__viewer_8h_source/","title":"File dense_vector_viewer.h","text":"<p>File List &gt; ext &gt; linear_system &gt; dense_vector_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;muda/buffer/buffer_2d_view.h&gt;\n#include &lt;muda/viewer/viewer_base.h&gt;\n#include &lt;cublas_v2.h&gt;\n#include &lt;muda/atomic.h&gt;\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass DenseVectorViewerT : public ViewerBase&lt;IsConst&gt;\n{\n    static_assert(std::is_same_v&lt;T, float&gt; || std::is_same_v&lt;T, double&gt;,\n                  \"now only support real number\");\n\n    using Base = ViewerBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class DenseVectorViewerT;\n\n  public:\n    using CBufferView    = CBufferView&lt;T&gt;;\n    using BufferView     = BufferView&lt;T&gt;;\n    using ThisBufferView = std::conditional_t&lt;IsConst, CBufferView, BufferView&gt;;\n\n    using ConstViewer    = DenseVectorViewerT&lt;true, T&gt;;\n    using NonConstViewer = DenseVectorViewerT&lt;false, T&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n\n    using VectorType = Eigen::Vector&lt;T, Eigen::Dynamic&gt;;\n    template &lt;typename U&gt;\n    using MapVectorT =\n        Eigen::Map&lt;U, Eigen::AlignmentType::Unaligned, Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;&gt;;\n    using MapVector     = MapVectorT&lt;VectorType&gt;;\n    using CMapVector    = MapVectorT&lt;const VectorType&gt;;\n    using ThisMapVector = std::conditional_t&lt;IsConst, CMapVector, MapVector&gt;;\n\n    MUDA_VIEWER_COMMON_NAME(DenseVectorViewerT);\n\n  protected:\n    auto_const_t&lt;T&gt;* m_data;\n    int              m_offset      = 0;\n    int              m_size        = 0;\n    int              m_origin_size = 0;\n\n  public:\n    MUDA_GENERIC DenseVectorViewerT(auto_const_t&lt;T&gt;* data, int offset, int size, int origin_size)\n        : m_data(data)\n        , m_offset(offset)\n        , m_size(size)\n        , m_origin_size(origin_size)\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC DenseVectorViewerT(const DenseVectorViewerT&lt;OtherIsConst, T&gt;&amp; other)\n        MUDA_REQUIRES(IsConst)\n        : m_data(other.m_data)\n        , m_offset(other.m_offset)\n        , m_size(other.m_size)\n        , m_origin_size(other.m_origin_size)\n    {\n        static_assert(IsConst);\n    }\n\n    MUDA_GENERIC auto as_const() const\n    {\n        return ConstViewer{m_data, m_offset, m_size, m_origin_size};\n    }\n\n    MUDA_GENERIC auto segment(int offset, int size) const\n    {\n        check_segment(offset, size);\n        auto ret = ThisViewer{m_data, m_offset + offset, size, m_origin_size};\n        ret.copy_label(*this);\n        return ret;\n    }\n\n    template &lt;int N&gt;\n    MUDA_GENERIC auto segment(int offset) const\n    {\n        return segment(offset, N);\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator()(int i) const\n    {\n        return m_data[index(i)];\n    }\n\n    MUDA_GENERIC Eigen::VectorBlock&lt;ThisMapVector&gt; as_eigen() const\n    {\n        check_data();\n        return ThisMapVector{m_data,\n                             (int)origin_size(),\n                             Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;{1, 1}}\n            .segment(m_offset, m_size);\n    }\n\n    MUDA_GENERIC operator Eigen::VectorBlock&lt;ThisMapVector&gt;()\n    {\n        return as_eigen();\n    }\n\n    MUDA_GENERIC auto size() const { return m_size; }\n\n    MUDA_GENERIC auto offset() const { return m_offset; }\n\n    MUDA_GENERIC auto origin_data() const { return m_data; }\n\n    MUDA_GENERIC auto origin_size() const { return m_origin_size; }\n\n    MUDA_DEVICE T atomic_add(int i, T val) const MUDA_REQUIRES(!IsConst)\n    {\n        auto ptr = &amp;this-&gt;operator()(i);\n        return muda::atomic_add(ptr, val);\n    }\n\n    template &lt;int N&gt;\n    MUDA_DEVICE Eigen::Vector&lt;T, N&gt; atomic_add(const Eigen::Vector&lt;T, N&gt;&amp; val) const\n        MUDA_REQUIRES(!IsConst)\n    {\n        this-&gt;check_size_matching(N);\n        Eigen::Vector&lt;T, N&gt; ret;\n#pragma unroll\n        for(int i = 0; i &lt; N; ++i)\n        {\n            ret(i) = atomic_add(i, val(i));\n        }\n        return ret;\n    }\n\n    MUDA_DEVICE T atomic_add(const T&amp; val)\n    {\n        this-&gt;check_size_matching(1);\n        T ret = atomic_add(0, val);\n        return ret;\n    }\n\n    template &lt;int N&gt;\n    MUDA_GENERIC DenseVectorViewerT&amp; operator=(const Eigen::Vector&lt;T, N&gt;&amp; other)\n    {\n        this-&gt;check_size_matching(N);\n#pragma unroll\n        for(int i = 0; i &lt; N; ++i)\n        {\n            this-&gt;operator()(i) = other(i);\n        }\n        return *this;\n    }\n\n\n  protected:\n    MUDA_INLINE MUDA_GENERIC void check_size_matching(int N) const\n    {\n        MUDA_KERNEL_ASSERT(m_size == N,\n                           \"DenseVectorViewerBase [%s:%s]: size not match, yours size=%d, expected size=%d. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           m_size,\n                           N,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n    }\n\n    MUDA_INLINE MUDA_GENERIC int index(int i) const\n    {\n        MUDA_KERNEL_ASSERT(origin_data(),\n                           \"DenseVectorViewerBase [%s:%s]: data is null. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n        MUDA_KERNEL_ASSERT(i &lt; m_size,\n                           \"DenseVectorViewerBase [%s:%s]: index out of range, size=%d, yours index=%d. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           m_size,\n                           i,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n        return m_offset + i;\n    }\n\n    MUDA_INLINE MUDA_GENERIC void check_data() const\n    {\n        MUDA_KERNEL_ASSERT(origin_data(),\n                           \"DenseVectorViewerBase [%s:%s]: data is null. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n    }\n\n    MUDA_INLINE MUDA_GENERIC void check_segment(int offset, int size) const\n    {\n        MUDA_KERNEL_ASSERT(offset + size &lt;= m_size,\n                           \"DenseVectorViewerBase [%s:%s]: segment out of range, m_size=%d, offset=%d, size=%d. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           m_size,\n                           offset,\n                           size,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n    }\n};\n\ntemplate &lt;typename T&gt;\nusing DenseVectorViewer = DenseVectorViewerT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CDenseVectorViewer = DenseVectorViewerT&lt;true, T&gt;;\n}  // namespace muda\n\n#include \"details/dense_vector_viewer.inl\"\n</code></pre>"},{"location":"muda/device__bcoo__matrix_8h/","title":"File device_bcoo_matrix.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; device_bcoo_matrix.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bcoo_matrix_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_triplet_matrix.h&gt;</code></li> <li><code>#include &lt;cusparse.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/type_mapper/data_type_mapper.h&gt;</code></li> <li><code>#include \"details/device_bcoo_matrix.inl\"</code></li> </ul>"},{"location":"muda/device__bcoo__matrix_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/device__bcoo__matrix_8h/#classes","title":"Classes","text":"Type Name class DeviceBCOOMatrix &lt;typename T, N&gt; class DeviceBCOOMatrix &lt;typename T, N&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_bcoo_matrix.h</code></p>"},{"location":"muda/device__bcoo__matrix_8h_source/","title":"File device_bcoo_matrix.h","text":"<p>File List &gt; ext &gt; linear_system &gt; device_bcoo_matrix.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/ext/linear_system/bcoo_matrix_view.h&gt;\n#include &lt;muda/ext/linear_system/device_triplet_matrix.h&gt;\n#include &lt;cusparse.h&gt;\n#include &lt;muda/ext/linear_system/type_mapper/data_type_mapper.h&gt;\n\nnamespace muda::details\n{\ntemplate &lt;typename T, int N&gt;\nclass MatrixFormatConverter;\n}\n\nnamespace muda\n{\ntemplate &lt;typename T, int N&gt;\nclass DeviceBCOOMatrix : public DeviceTripletMatrix&lt;T, N&gt;\n{\n    friend class details::MatrixFormatConverter&lt;T, N&gt;;\n\n  public:\n    DeviceBCOOMatrix()                                   = default;\n    ~DeviceBCOOMatrix()                                  = default;\n    DeviceBCOOMatrix(const DeviceBCOOMatrix&amp;)            = default;\n    DeviceBCOOMatrix(DeviceBCOOMatrix&amp;&amp;)                 = default;\n    DeviceBCOOMatrix&amp; operator=(const DeviceBCOOMatrix&amp;) = default;\n    DeviceBCOOMatrix&amp; operator=(DeviceBCOOMatrix&amp;&amp;)      = default;\n    auto              non_zeros() const { return this-&gt;m_values.size(); }\n};\n\ntemplate &lt;typename Ty&gt;\nclass DeviceBCOOMatrix&lt;Ty, 1&gt; : public DeviceTripletMatrix&lt;Ty, 1&gt;\n{\n    template &lt;typename U, int M&gt;\n    friend class details::MatrixFormatConverter;\n\n  protected:\n    mutable cusparseMatDescr_t   m_legacy_descr = nullptr;\n    mutable cusparseSpMatDescr_t m_descr        = nullptr;\n\n  public:\n    DeviceBCOOMatrix() = default;\n    ~DeviceBCOOMatrix() { destroy_all_descr(); }\n\n    DeviceBCOOMatrix(const DeviceBCOOMatrix&amp; other)\n        : DeviceTripletMatrix&lt;Ty, 1&gt;{other}\n        , m_legacy_descr{nullptr}\n        , m_descr{nullptr}\n    {\n    }\n\n    DeviceBCOOMatrix(DeviceBCOOMatrix&amp;&amp; other)\n        : DeviceTripletMatrix&lt;Ty, 1&gt;{std::move(other)}\n        , m_legacy_descr{other.m_legacy_descr}\n        , m_descr{other.m_descr}\n    {\n        other.m_legacy_descr = nullptr;\n        other.m_descr        = nullptr;\n    }\n\n    DeviceBCOOMatrix&amp; operator=(const DeviceBCOOMatrix&amp; other)\n    {\n        if(this == &amp;other)\n            return *this;\n        DeviceTripletMatrix&lt;Ty, 1&gt;::operator=(other);\n        destroy_all_descr();\n        m_legacy_descr = nullptr;\n        m_descr        = nullptr;\n        return *this;\n    }\n\n    DeviceBCOOMatrix&amp; operator=(DeviceBCOOMatrix&amp;&amp; other)\n    {\n        if(this == &amp;other)\n            return *this;\n        DeviceTripletMatrix&lt;Ty, 1&gt;::operator=(std::move(other));\n        destroy_all_descr();\n        m_legacy_descr       = other.m_legacy_descr;\n        m_descr              = other.m_descr;\n        other.m_legacy_descr = nullptr;\n        other.m_descr        = nullptr;\n        return *this;\n    }\n\n\n    auto view()\n    {\n        return COOMatrixView&lt;Ty&gt;{this-&gt;m_rows,\n                                 this-&gt;m_cols,\n                                 (int)this-&gt;m_values.size(),\n                                 this-&gt;m_row_indices.data(),\n                                 this-&gt;m_col_indices.data(),\n                                 this-&gt;m_values.data(),\n                                 descr(),\n                                 legacy_descr(),\n                                 false};\n    }\n\n    auto view() const\n    {\n        return CCOOMatrixView&lt;Ty&gt;{this-&gt;m_rows,\n                                  this-&gt;m_cols,\n                                  (int)this-&gt;m_values.size(),\n                                  this-&gt;m_row_indices.data(),\n                                  this-&gt;m_col_indices.data(),\n                                  this-&gt;m_values.data(),\n                                  descr(),\n                                  legacy_descr(),\n                                  false};\n    }\n\n    auto cview() const { return view(); }\n\n    auto viewer() { return view().viewer(); }\n\n    auto cviewer() const { return view().cviewer(); }\n\n    auto non_zeros() const { return this-&gt;m_values.size(); }\n\n    auto legacy_descr() const\n    {\n        if(m_legacy_descr == nullptr)\n        {\n            checkCudaErrors(cusparseCreateMatDescr(&amp;m_legacy_descr));\n            checkCudaErrors(cusparseSetMatType(m_legacy_descr, CUSPARSE_MATRIX_TYPE_GENERAL));\n            checkCudaErrors(cusparseSetMatIndexBase(m_legacy_descr, CUSPARSE_INDEX_BASE_ZERO));\n        }\n        return m_legacy_descr;\n    }\n\n    auto descr() const\n    {\n        if(m_descr == nullptr)\n        {\n            checkCudaErrors(cusparseCreateCoo(&amp;m_descr,\n                                              this-&gt;m_rows,\n                                              this-&gt;m_cols,\n                                              non_zeros(),\n                                              (void*)this-&gt;m_row_indices.data(),\n                                              (void*)this-&gt;m_col_indices.data(),\n                                              (void*)this-&gt;m_values.data(),\n                                              CUSPARSE_INDEX_32I,\n                                              CUSPARSE_INDEX_BASE_ZERO,\n                                              cuda_data_type&lt;Ty&gt;()));\n        }\n        return m_descr;\n    }\n\n    //auto T() const { return view().T(); }\n    //auto T() { return view().T(); }\n\n    operator COOMatrixView&lt;Ty&gt;() { return view(); }\n    operator CCOOMatrixView&lt;Ty&gt;() const { return view(); }\n\n    void clear()\n    {\n        DeviceTripletMatrix&lt;Ty, 1&gt;::clear();\n        destroy_all_descr();\n    }\n\n  private:\n    void destroy_all_descr()\n    {\n        if(m_legacy_descr != nullptr)\n        {\n            checkCudaErrors(cusparseDestroyMatDescr(m_legacy_descr));\n            m_legacy_descr = nullptr;\n        }\n        if(m_descr != nullptr)\n        {\n            checkCudaErrors(cusparseDestroySpMat(m_descr));\n            m_descr = nullptr;\n        }\n    }\n};\n\ntemplate &lt;typename T&gt;\nusing DeviceCOOMatrix = DeviceBCOOMatrix&lt;T, 1&gt;;\n}  // namespace muda\n\n#include \"details/device_bcoo_matrix.inl\"\n</code></pre>"},{"location":"muda/device__bcoo__vector_8h/","title":"File device_bcoo_vector.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; device_bcoo_vector.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bcoo_vector_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_doublet_vector.h&gt;</code></li> <li><code>#include \"details/device_bcoo_vector.inl\"</code></li> </ul>"},{"location":"muda/device__bcoo__vector_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/device__bcoo__vector_8h/#classes","title":"Classes","text":"Type Name class DeviceBCOOVector &lt;typename T, N&gt; class DeviceBCOOVector &lt;typename T, N&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_bcoo_vector.h</code></p>"},{"location":"muda/device__bcoo__vector_8h_source/","title":"File device_bcoo_vector.h","text":"<p>File List &gt; ext &gt; linear_system &gt; device_bcoo_vector.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/ext/linear_system/bcoo_vector_view.h&gt;\n#include &lt;muda/ext/linear_system/device_doublet_vector.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T, int N&gt;\nclass DeviceBCOOVector : public DeviceDoubletVector&lt;T, N&gt;\n{\n    friend class details::MatrixFormatConverter&lt;T, N&gt;;\n\n  public:\n    using SegmentVector = Eigen::Matrix&lt;T, N, 1&gt;;\n\n    DeviceBCOOVector()                                   = default;\n    ~DeviceBCOOVector()                                  = default;\n    DeviceBCOOVector(const DeviceBCOOVector&amp;)            = default;\n    DeviceBCOOVector(DeviceBCOOVector&amp;&amp;)                 = default;\n    DeviceBCOOVector&amp; operator=(const DeviceBCOOVector&amp;) = default;\n    DeviceBCOOVector&amp; operator=(DeviceBCOOVector&amp;&amp;)      = default;\n\n    auto non_zeros() const { return this-&gt;m_values.size(); }\n};\n\ntemplate &lt;typename T&gt;\nclass DeviceBCOOVector&lt;T, 1&gt; : public DeviceDoubletVector&lt;T, 1&gt;\n{\n    template &lt;typename U, int N&gt;\n    friend class details::MatrixFormatConverter;\n\n  protected:\n    mutable cusparseSpVecDescr_t m_descr = nullptr;\n\n  public:\n    DeviceBCOOVector() = default;\n    ~DeviceBCOOVector() { destroy_descr(); }\n\n    DeviceBCOOVector(const DeviceBCOOVector&amp; other)\n        : DeviceDoubletVector&lt;T, 1&gt;(other)\n        , m_descr(nullptr)\n    {\n    }\n\n    DeviceBCOOVector(DeviceBCOOVector&amp;&amp; other)\n        : DeviceDoubletVector&lt;T, 1&gt;(std::move(other))\n        , m_descr(other.m_descr)\n    {\n        other.m_descr = nullptr;\n    }\n\n    DeviceBCOOVector&amp; operator=(const DeviceBCOOVector&amp; other)\n    {\n        DeviceDoubletVector&lt;T, 1&gt;::operator=(other);\n        destroy_descr();\n        return *this;\n    }\n\n    DeviceBCOOVector&amp; operator=(DeviceBCOOVector&amp;&amp; other)\n    {\n        DeviceDoubletVector&lt;T, 1&gt;::operator=(std::move(other));\n        destroy_descr();\n        m_descr       = other.m_descr;\n        other.m_descr = nullptr;\n        return *this;\n    }\n\n    auto non_zeros() const { return this-&gt;m_values.size(); }\n\n    auto descr() const\n    {\n        if(!m_descr)\n        {\n            checkCudaErrors(cusparseCreateSpVec(\n                &amp;m_descr,\n                this-&gt;m_size,\n                this-&gt;m_values.size(),\n                (int*)this-&gt;m_indices.data(),\n                (T*)this-&gt;m_values.data(),\n                cusparse_index_type&lt;decltype(this-&gt;m_indices)::value_type&gt;(),\n                CUSPARSE_INDEX_BASE_ZERO,\n                cuda_data_type&lt;T&gt;()));\n        }\n        return m_descr;\n    }\n\n  private:\n    void destroy_descr() const\n    {\n        if(m_descr)\n        {\n            checkCudaErrors(cusparseDestroySpVec(m_descr));\n            m_descr = nullptr;\n        }\n    }\n};\n\ntemplate &lt;typename T&gt;\nusing DeviceCOOVector = DeviceBCOOVector&lt;T, 1&gt;;\n}  // namespace muda\n\n\n#include \"details/device_bcoo_vector.inl\"\n</code></pre>"},{"location":"muda/device__bsr__matrix_8h/","title":"File device_bsr_matrix.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; device_bsr_matrix.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/bsr_matrix_view.h&gt;</code></li> <li><code>#include &lt;cusparse.h&gt;</code></li> <li><code>#include \"details/device_bsr_matrix.inl\"</code></li> </ul>"},{"location":"muda/device__bsr__matrix_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/device__bsr__matrix_8h/#classes","title":"Classes","text":"Type Name class DeviceBSRMatrix &lt;typename Ty, N&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_bsr_matrix.h</code></p>"},{"location":"muda/device__bsr__matrix_8h_source/","title":"File device_bsr_matrix.h","text":"<p>File List &gt; ext &gt; linear_system &gt; device_bsr_matrix.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/ext/linear_system/bsr_matrix_view.h&gt;\n#include &lt;cusparse.h&gt;\n\nnamespace muda::details\n{\ntemplate &lt;typename T, int N&gt;\nclass MatrixFormatConverter;\n}\n\nnamespace muda\n{\ntemplate &lt;typename Ty, int N&gt;\nclass DeviceBSRMatrix\n{\n    template &lt;typename U, int M&gt;\n    friend class details::MatrixFormatConverter;\n\n  public:\n    using ValueT = std::conditional_t&lt;N == 1, Ty, Eigen::Matrix&lt;Ty, N, N&gt;&gt;;\n    static constexpr bool IsBlockMatrix = (N &gt; 1);\n\n  protected:\n    muda::DeviceBuffer&lt;ValueT&gt;   m_values;\n    muda::DeviceBuffer&lt;int&gt;      m_row_offsets;\n    muda::DeviceBuffer&lt;int&gt;      m_col_indices;\n    mutable cusparseSpMatDescr_t m_descr        = nullptr;\n    mutable cusparseMatDescr_t   m_legacy_descr = nullptr;\n\n    int m_row = 0;\n    int m_col = 0;\n\n  public:\n    DeviceBSRMatrix() = default;\n    ~DeviceBSRMatrix();\n\n    DeviceBSRMatrix(const DeviceBSRMatrix&amp;);\n    DeviceBSRMatrix(DeviceBSRMatrix&amp;&amp;);\n\n    DeviceBSRMatrix&amp; operator=(const DeviceBSRMatrix&amp;);\n    DeviceBSRMatrix&amp; operator=(DeviceBSRMatrix&amp;&amp;);\n\n    void reshape(int row, int col);\n    void reserve(int non_zero_blocks);\n    void reserve_offsets(int size);\n    void resize(int non_zero_blocks);\n\n    static constexpr int block_size() { return N; }\n\n    auto values() { return m_values.view(); }\n    auto values() const { return m_values.view(); }\n\n    auto row_offsets() { return m_row_offsets.view(); }\n    auto row_offsets() const { return m_row_offsets.view(); }\n\n    auto col_indices() { return m_col_indices.view(); }\n    auto col_indices() const { return m_col_indices.view(); }\n\n    auto rows() const { return m_row; }\n    auto cols() const { return m_col; }\n    auto non_zeros() const { return m_values.size(); }\n\n    cusparseSpMatDescr_t descr() const;\n    cusparseMatDescr_t   legacy_descr() const;\n\n    auto view()\n    {\n        return BSRMatrixView&lt;Ty, N&gt;{m_row,\n                                    m_col,\n                                    m_row_offsets.data(),\n                                    m_col_indices.data(),\n                                    m_values.data(),\n                                    (int)m_values.size(),\n                                    descr(),\n                                    legacy_descr(),\n                                    false};\n    }\n\n    operator BSRMatrixView&lt;Ty, N&gt;() { return view(); }\n\n    auto view() const\n    {\n        return CBSRMatrixView&lt;Ty, N&gt;{m_row,\n                                     m_col,\n                                     m_row_offsets.data(),\n                                     m_col_indices.data(),\n                                     m_values.data(),\n                                     (int)m_values.size(),\n                                     descr(),\n                                     legacy_descr(),\n                                     false};\n    }\n\n    operator CBSRMatrixView&lt;Ty, N&gt;() const { return view(); }\n\n    auto cview() const { return view(); }\n\n    auto T() const { return view().T(); }\n    auto T() { return view().T(); }\n\n    void clear();\n\n  private:\n    void destroy_all_descr() const;\n};\n}  // namespace muda\n\n#include \"details/device_bsr_matrix.inl\"\n</code></pre>"},{"location":"muda/device__csr__matrix_8h/","title":"File device_csr_matrix.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; device_csr_matrix.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bsr_matrix.h&gt;</code></li> <li><code>#include &lt;cusparse.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/csr_matrix_view.h&gt;</code></li> <li><code>#include \"details/device_csr_matrix.inl\"</code></li> </ul>"},{"location":"muda/device__csr__matrix_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_csr_matrix.h</code></p>"},{"location":"muda/device__csr__matrix_8h_source/","title":"File device_csr_matrix.h","text":"<p>File List &gt; ext &gt; linear_system &gt; device_csr_matrix.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/ext/linear_system/device_bsr_matrix.h&gt;\n#include &lt;cusparse.h&gt;\n#include &lt;muda/ext/linear_system/csr_matrix_view.h&gt;\n\nnamespace muda::details\n{\ntemplate &lt;typename T, int N&gt;\nclass MatrixFormatConverter;\n}\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nusing DeviceCSRMatrix = DeviceBSRMatrix&lt;T, 1&gt;;\n}  // namespace muda\n#include \"details/device_csr_matrix.inl\"\n</code></pre>"},{"location":"muda/device__dense__matrix_8h/","title":"File device_dense_matrix.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; device_dense_matrix.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/dense_matrix_view.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_buffer_2d.h&gt;</code></li> <li><code>#include \"details/device_dense_matrix.inl\"</code></li> </ul>"},{"location":"muda/device__dense__matrix_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/device__dense__matrix_8h/#classes","title":"Classes","text":"Type Name class DeviceDenseMatrix &lt;typename Ty&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_dense_matrix.h</code></p>"},{"location":"muda/device__dense__matrix_8h_source/","title":"File device_dense_matrix.h","text":"<p>File List &gt; ext &gt; linear_system &gt; device_dense_matrix.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/dense_matrix_view.h&gt;\n#include &lt;muda/buffer/device_buffer_2d.h&gt;\n\nnamespace muda::details\n{\ntemplate &lt;typename T, int N&gt;\nclass MatrixFormatConverter;\n}\n\nnamespace muda\n{\n// A column major dense matrix on device.\ntemplate &lt;typename Ty&gt;\nclass DeviceDenseMatrix\n{\n    static_assert(std::is_same_v&lt;Ty, float&gt; || std::is_same_v&lt;Ty, double&gt;,\n                  \"now only support real number\");\n\n    DeviceBuffer2D&lt;Ty&gt; m_data;\n    size_t             m_row = 0;\n    size_t             m_col = 0;\n    bool               m_sym = false;\n\n  public:\n    using value_type    = Ty;\n    DeviceDenseMatrix() = default;\n    DeviceDenseMatrix(size_t row, size_t col, bool sym = false);\n    void sym(bool sym = true) { m_sym = sym; }\n    bool sym() const { return m_sym; }\n\n    DeviceDenseMatrix(const DeviceDenseMatrix&amp;) = default;\n    DeviceDenseMatrix(DeviceDenseMatrix&amp;&amp;);\n\n    DeviceDenseMatrix&amp; operator=(const DeviceDenseMatrix&amp;) = default;\n    DeviceDenseMatrix&amp; operator=(DeviceDenseMatrix&amp;&amp;);\n\n    size_t row() const { return m_row; }\n    size_t col() const { return m_col; }\n\n    void reshape(size_t row, size_t col);\n    void fill(Ty value);\n    void copy_to(Eigen::MatrixX&lt;Ty&gt;&amp; mat) const;\n    void copy_to(std::vector&lt;Ty&gt;&amp; vec) const;\n\n    DeviceDenseMatrix(const Eigen::MatrixX&lt;Ty&gt;&amp;);\n    DeviceDenseMatrix&amp; operator=(const Eigen::MatrixX&lt;Ty&gt;&amp;);\n\n    DenseMatrixViewer&lt;Ty&gt;  viewer() { return view().viewer(); }\n    CDenseMatrixViewer&lt;Ty&gt; cviewer() const { return view().cviewer(); }\n\n    auto buffer_view() const { return m_data.view(); }\n    auto buffer_view() { return m_data.view(); }\n\n    DenseMatrixView&lt;Ty&gt;  T();\n    CDenseMatrixView&lt;Ty&gt; T() const;\n\n    DenseMatrixView&lt;Ty&gt;  view();\n    CDenseMatrixView&lt;Ty&gt; view() const;\n    CDenseMatrixView&lt;Ty&gt; cview() const { return view(); }\n\n    operator DenseMatrixView&lt;Ty&gt;();\n    operator CDenseMatrixView&lt;Ty&gt;() const;\n};\n}  // namespace muda\n\n#include \"details/device_dense_matrix.inl\"\n</code></pre>"},{"location":"muda/device__dense__vector_8h/","title":"File device_dense_vector.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; device_dense_vector.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/dense_vector_view.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;cusparse.h&gt;</code></li> <li><code>#include \"details/device_dense_vector.inl\"</code></li> </ul>"},{"location":"muda/device__dense__vector_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/device__dense__vector_8h/#classes","title":"Classes","text":"Type Name class DeviceDenseVector &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_dense_vector.h</code></p>"},{"location":"muda/device__dense__vector_8h_source/","title":"File device_dense_vector.h","text":"<p>File List &gt; ext &gt; linear_system &gt; device_dense_vector.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/dense_vector_view.h&gt;\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;cusparse.h&gt;\n\nnamespace muda::details\n{\ntemplate &lt;typename T, int N&gt;\nclass MatrixFormatConverter;\n}\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass DeviceDenseVector\n{\n    static_assert(std::is_same_v&lt;T, float&gt; || std::is_same_v&lt;T, double&gt;,\n                  \"now only support real number\");\n\n    muda::DeviceBuffer&lt;T&gt; m_data;\n    cusparseDnVecDescr_t  m_descr = nullptr;\n\n  public:\n    DeviceDenseVector() = default;\n    DeviceDenseVector(size_t size);\n    ~DeviceDenseVector();\n\n    DeviceDenseVector(const DeviceDenseVector&amp;);\n    DeviceDenseVector(DeviceDenseVector&amp;&amp;);\n    DeviceDenseVector&amp; operator=(const DeviceDenseVector&amp;);\n    DeviceDenseVector&amp; operator=(DeviceDenseVector&amp;&amp;);\n\n    void reserve(size_t size);\n    void resize(size_t size);\n    void fill(T value);\n    void copy_to(Eigen::VectorX&lt;T&gt;&amp; vec) const;\n    void copy_to(std::vector&lt;T&gt;&amp; vec) const;\n\n    DeviceDenseVector(const Eigen::VectorX&lt;T&gt;&amp; vec);\n    DeviceDenseVector&amp; operator=(const Eigen::VectorX&lt;T&gt;&amp; vec);\n\n    DenseVectorViewer&lt;T&gt;  viewer() { return view().viewer(); }\n    CDenseVectorViewer&lt;T&gt; viewer() const { return view().cviewer(); }\n\n    auto capacity() const { return m_data.capacity(); }\n    auto size() const { return m_data.size(); }\n    auto buffer_view() const { return m_data.view(); }\n    auto buffer_view() { return m_data.view(); }\n\n    CDenseVectorView&lt;T&gt; view() const;\n    DenseVectorView&lt;T&gt;  view();\n    CDenseVectorView&lt;T&gt; cview() const { return view(); }\n\n    operator CDenseVectorView&lt;T&gt;() const { return view(); }\n    operator DenseVectorView&lt;T&gt;() { return view(); }\n\n    cusparseDnVecDescr_t descr() const { return m_descr; }\n};\n}  // namespace muda\n\n#include \"details/device_dense_vector.inl\"\n</code></pre>"},{"location":"muda/device__doublet__vector_8h/","title":"File device_doublet_vector.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; device_doublet_vector.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/doublet_vector_view.h&gt;</code></li> <li><code>#include \"details/device_doublet_vector.inl\"</code></li> </ul>"},{"location":"muda/device__doublet__vector_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/device__doublet__vector_8h/#classes","title":"Classes","text":"Type Name class DeviceDoubletVector &lt;typename T, N&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_doublet_vector.h</code></p>"},{"location":"muda/device__doublet__vector_8h_source/","title":"File device_doublet_vector.h","text":"<p>File List &gt; ext &gt; linear_system &gt; device_doublet_vector.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n#include &lt;muda/ext/linear_system/doublet_vector_view.h&gt;\n\nnamespace muda::details\n{\ntemplate &lt;typename T, int N&gt;\nclass MatrixFormatConverter;\n}\n\nnamespace muda\n{\ntemplate &lt;typename T, int N&gt;\nclass DeviceDoubletVector\n{\n    template &lt;typename U, int M&gt;\n    friend class details::MatrixFormatConverter;\n\n  public:\n    using ValueT = std::conditional_t&lt;N == 1, T, Eigen::Vector&lt;T, N&gt;&gt;;\n    static constexpr bool IsSegmentVector = (N &gt; 1);\n\n  protected:\n    muda::DeviceBuffer&lt;ValueT&gt; m_values;\n    muda::DeviceBuffer&lt;int&gt;    m_indices;\n    int                        m_count = 0;\n\n  public:\n    DeviceDoubletVector()  = default;\n    ~DeviceDoubletVector() = default;\n\n    void reshape(int num_segment) { m_count = num_segment; }\n\n    void resize_doublets(size_t nonzero_count)\n    {\n        m_values.resize(nonzero_count);\n        m_indices.resize(nonzero_count);\n    }\n\n    void reserve_doublets(size_t nonzero_count)\n    {\n        m_values.reserve(nonzero_count);\n        m_indices.reserve(nonzero_count);\n    }\n\n    void resize(int num_segment, size_t nonzero_count)\n    {\n        reshape(num_segment);\n        resize_doublets(nonzero_count);\n    }\n\n    void clear()\n    {\n        m_values.clear();\n        m_indices.clear();\n    }\n\n    auto count() const { return m_count; }\n    auto values() { return m_values.view(); }\n    auto values() const { return m_values.view(); }\n    auto indices() { return m_indices.view(); }\n    auto indices() const { return m_indices.view(); }\n\n    auto doublet_count() const { return m_values.size(); }\n    auto doublet_capacity() const { return m_values.capacity(); }\n\n    auto view()\n    {\n        return DoubletVectorView&lt;T, N&gt;{\n            m_count, (int)m_values.size(), m_indices.data(), m_values.data()};\n    }\n\n    auto view() const { return remove_const(*this).view().as_const(); }\n\n    auto cview() const { return view(); }\n    auto viewer() { return view().viewer(); }\n    auto viewer() const { return view().cviewer(); };\n    auto cviewer() const { return view().cviewer(); };\n};\n}  // namespace muda\n\n#include \"details/device_doublet_vector.inl\"\n</code></pre>"},{"location":"muda/device__triplet__matrix_8h/","title":"File device_triplet_matrix.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; device_triplet_matrix.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/triplet_matrix_view.h&gt;</code></li> <li><code>#include \"details/device_triplet_matrix.inl\"</code></li> </ul>"},{"location":"muda/device__triplet__matrix_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/device__triplet__matrix_8h/#classes","title":"Classes","text":"Type Name class DeviceTripletMatrix &lt;typename T, N&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/device_triplet_matrix.h</code></p>"},{"location":"muda/device__triplet__matrix_8h_source/","title":"File device_triplet_matrix.h","text":"<p>File List &gt; ext &gt; linear_system &gt; device_triplet_matrix.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/ext/linear_system/triplet_matrix_view.h&gt;\n\nnamespace muda::details\n{\ntemplate &lt;typename T, int N&gt;\nclass MatrixFormatConverter;\n}\n\nnamespace muda\n{\ntemplate &lt;typename T, int N&gt;\nclass DeviceTripletMatrix\n{\n  public:\n    template &lt;typename U, int M&gt;\n    friend class details::MatrixFormatConverter;\n\n    using ValueT = std::conditional_t&lt;N == 1, T, Eigen::Matrix&lt;T, N, N&gt;&gt;;\n    static constexpr bool IsBlockMatrix = (N &gt; 1);\n\n  protected:\n    DeviceBuffer&lt;ValueT&gt; m_values;\n    DeviceBuffer&lt;int&gt;    m_row_indices;\n    DeviceBuffer&lt;int&gt;    m_col_indices;\n\n    int m_rows = 0;\n    int m_cols = 0;\n\n  public:\n    DeviceTripletMatrix()                                      = default;\n    ~DeviceTripletMatrix()                                     = default;\n    DeviceTripletMatrix(const DeviceTripletMatrix&amp;)            = default;\n    DeviceTripletMatrix(DeviceTripletMatrix&amp;&amp;)                 = default;\n    DeviceTripletMatrix&amp; operator=(const DeviceTripletMatrix&amp;) = default;\n    DeviceTripletMatrix&amp; operator=(DeviceTripletMatrix&amp;&amp;)      = default;\n\n    void reshape(int row, int col)\n    {\n        m_rows = row;\n        m_cols = col;\n    }\n\n    void resize_triplets(size_t nonzero_count)\n    {\n        m_values.resize(nonzero_count);\n        m_row_indices.resize(nonzero_count);\n        m_col_indices.resize(nonzero_count);\n    }\n\n    void reserve_triplets(size_t nonzero_count)\n    {\n        m_values.reserve(nonzero_count);\n        m_row_indices.reserve(nonzero_count);\n        m_col_indices.reserve(nonzero_count);\n    }\n\n    void resize(int row, int col, size_t nonzero_count)\n    {\n        reshape(row, col);\n        resize_triplets(nonzero_count);\n    }\n\n    static constexpr int block_dim() { return N; }\n\n    auto values() { return m_values.view(); }\n    auto values() const { return m_values.view(); }\n    auto row_indices() { return m_row_indices.view(); }\n    auto row_indices() const { return m_row_indices.view(); }\n    auto col_indices() { return m_col_indices.view(); }\n    auto col_indices() const { return m_col_indices.view(); }\n\n    auto rows() const { return m_rows; }\n    auto cols() const { return m_cols; }\n    auto triplet_count() const { return m_values.size(); }\n    auto triplet_capacity() const { return m_values.capacity(); }\n\n    auto view()\n    {\n        return TripletMatrixView&lt;T, N&gt;{m_rows,\n                                       m_cols,\n                                       (int)m_values.size(),\n                                       m_row_indices.data(),\n                                       m_col_indices.data(),\n                                       m_values.data()};\n    }\n\n    auto view() const { return remove_const(*this).view().as_const(); }\n\n    auto cview() const { return view(); }\n\n    auto viewer() { return view().viewer(); }\n\n    auto cviewer() const { return view().cviewer(); }\n\n    operator TripletMatrixView&lt;T, N&gt;() { return view(); }\n    operator CTripletMatrixView&lt;T, N&gt;() const { return view(); }\n\n    void clear()\n    {\n        m_rows = 0;\n        m_cols = 0;\n        m_values.clear();\n        m_row_indices.clear();\n        m_col_indices.clear();\n    }\n};\n}  // namespace muda\n#include \"details/device_triplet_matrix.inl\"\n</code></pre>"},{"location":"muda/doublet__vector__view_8h/","title":"File doublet_vector_view.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; doublet_vector_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/doublet_vector_viewer.h&gt;</code></li> <li><code>#include \"details/doublet_vector_view.inl\"</code></li> </ul>"},{"location":"muda/doublet__vector__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/doublet__vector__view_8h/#classes","title":"Classes","text":"Type Name class DoubletVectorViewT &lt;IsConst, typename T, N&gt; class DoubletVectorViewT &lt;IsConst, typename T, N&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/doublet_vector_view.h</code></p>"},{"location":"muda/doublet__vector__view_8h_source/","title":"File doublet_vector_view.h","text":"<p>File List &gt; ext &gt; linear_system &gt; doublet_vector_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/view/view_base.h&gt;\n#include &lt;muda/ext/linear_system/doublet_vector_viewer.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T, int N&gt;\nclass DoubletVectorViewT : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U, int M&gt;\n    friend class DoubletVectorViewT;\n\n  public:\n    using SegmentVector = Eigen::Matrix&lt;T, N, 1&gt;;\n    using ConstView     = DoubletVectorViewT&lt;true, T, N&gt;;\n    using NonConstView  = DoubletVectorViewT&lt;false, T, N&gt;;\n    using ThisView      = DoubletVectorViewT&lt;IsConst, T, N&gt;;\n\n    using ConstViewer    = CDoubletVectorViewer&lt;T, N&gt;;\n    using NonConstViewer = DoubletVectorViewer&lt;T, N&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n\n  protected:\n    // vector info\n    int m_total_segment_count = 0;\n\n    // doublet info\n    int m_doublet_index_offset = 0;\n    int m_doublet_count        = 0;\n    int m_total_doublet_count  = 0;\n\n    // subvector info\n    int m_subvector_offset = 0;\n    int m_subvector_extent = 0;\n\n    // data\n    auto_const_t&lt;int&gt;*           m_segment_indices;\n    auto_const_t&lt;SegmentVector&gt;* m_segment_values;\n\n  public:\n    MUDA_GENERIC DoubletVectorViewT() = default;\n    MUDA_GENERIC DoubletVectorViewT(int total_segment_count,\n                                    int doublet_index_offset,\n                                    int doublet_count,\n                                    int total_doublet_count,\n\n                                    int subvector_offset,\n                                    int subvector_extent,\n\n                                    auto_const_t&lt;int&gt;* segment_indices,\n                                    auto_const_t&lt;SegmentVector&gt;* segment_values)\n        : m_total_segment_count(total_segment_count)\n        , m_doublet_index_offset(doublet_index_offset)\n        , m_doublet_count(doublet_count)\n        , m_total_doublet_count(total_doublet_count)\n        , m_subvector_offset(subvector_offset)\n        , m_subvector_extent(subvector_extent)\n        , m_segment_indices(segment_indices)\n        , m_segment_values(segment_values)\n    {\n        MUDA_KERNEL_ASSERT(doublet_index_offset + doublet_count &lt;= total_doublet_count,\n                           \"DoubletVectorView: out of range, m_total_doublet_count=%d, \"\n                           \"your doublet_index_offset=%d, doublet_count=%d\",\n                           m_total_doublet_count,\n                           doublet_index_offset,\n                           doublet_count);\n\n        MUDA_KERNEL_ASSERT(subvector_offset + subvector_extent &lt;= total_segment_count,\n                           \"DoubletVectorView: out of range, m_total_segment_count=%d, \"\n                           \"your subvector_offset=%d, subvector_extent=%d\",\n                           m_total_segment_count,\n                           subvector_offset,\n                           subvector_extent);\n    }\n\n    MUDA_GENERIC DoubletVectorViewT(int                total_segment_count,\n                                    int                total_doublet_count,\n                                    auto_const_t&lt;int&gt;* segment_indices,\n                                    auto_const_t&lt;SegmentVector&gt;* segment_values)\n        : DoubletVectorViewT(total_segment_count,\n                             0,\n                             total_doublet_count,\n                             total_doublet_count,\n                             0,\n                             total_segment_count,\n                             segment_indices,\n                             segment_values)\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC DoubletVectorViewT(const DoubletVectorViewT&lt;OtherIsConst, T, N&gt;&amp; other) noexcept\n        : m_total_segment_count(other.m_total_segment_count)\n        , m_doublet_index_offset(other.m_doublet_index_offset)\n        , m_doublet_count(other.m_doublet_count)\n        , m_total_doublet_count(other.m_total_doublet_count)\n        , m_subvector_offset(other.m_subvector_offset)\n        , m_subvector_extent(other.m_subvector_extent)\n        , m_segment_indices(other.m_segment_indices)\n        , m_segment_values(other.m_segment_values)\n    {\n    }\n\n    MUDA_GENERIC ConstView as_const() const noexcept\n    {\n        return ConstView{m_total_segment_count,\n                         m_doublet_index_offset,\n                         m_doublet_count,\n                         m_total_doublet_count,\n                         m_subvector_offset,\n                         m_subvector_extent,\n                         m_segment_indices,\n                         m_segment_values};\n    }\n\n    MUDA_GENERIC ThisView subview(int offset, int count) const noexcept\n    {\n\n        MUDA_KERNEL_ASSERT(offset + count &lt;= m_doublet_count,\n                           \"DoubletVectorView : offset is out of range, size=%d, your offset=%d\",\n                           m_doublet_count,\n                           offset);\n\n        return ThisView{m_total_segment_count,\n                        m_doublet_index_offset + offset,\n                        count,\n                        m_total_doublet_count,\n                        m_subvector_offset,\n                        m_subvector_extent,\n                        m_segment_indices,\n                        m_segment_values};\n    }\n\n    MUDA_GENERIC ThisView subview(int offset) const noexcept\n    {\n        return subview(offset, m_doublet_count - offset);\n    }\n\n    MUDA_GENERIC auto subvector(int offset, int extent) const noexcept\n    {\n        MUDA_KERNEL_ASSERT(offset + extent &lt;= m_subvector_extent,\n                           \"DoubletVectorView : subvector out of range, extent=%d, your offset=%d, your extent=%d\",\n                           m_subvector_extent,\n                           offset,\n                           extent);\n\n        return ThisView{m_total_segment_count,\n                        m_doublet_index_offset,\n                        m_doublet_count,\n                        m_total_doublet_count,\n                        m_subvector_offset + offset,\n                        extent,\n                        m_segment_indices,\n                        m_segment_values};\n    }\n\n    MUDA_GENERIC ThisViewer viewer() noexcept\n    {\n        return ThisViewer{m_total_segment_count,\n                          m_doublet_index_offset,\n                          m_doublet_count,\n                          m_total_doublet_count,\n                          m_subvector_offset,\n                          m_subvector_extent,\n                          m_segment_indices,\n                          m_segment_values};\n    }\n\n    MUDA_GENERIC ConstViewer cviewer() const noexcept\n    {\n        return ConstViewer{m_total_segment_count,\n                           m_doublet_index_offset,\n                           m_doublet_count,\n                           m_total_doublet_count,\n                           m_subvector_offset,\n                           m_subvector_extent,\n                           m_segment_indices,\n                           m_segment_values};\n    }\n\n    MUDA_GENERIC int extent() const noexcept { return m_subvector_extent; }\n\n    MUDA_GENERIC int total_extent() const noexcept\n    {\n        return m_total_segment_count;\n    }\n\n    MUDA_GENERIC int subvector_offset() const noexcept\n    {\n        return m_subvector_offset;\n    }\n\n    MUDA_GENERIC int doublet_count() const noexcept { return m_doublet_count; }\n    MUDA_GENERIC int total_doublet_count() const noexcept\n    {\n        return m_total_doublet_count;\n    }\n};\n\ntemplate &lt;bool IsConst, typename T&gt;\nclass DoubletVectorViewT&lt;IsConst, T, 1&gt; : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n\n    template &lt;bool OtherIsConst, typename U, int M&gt;\n    friend class DoubletVectorViewT;\n\n  protected:\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n  public:\n    using ConstView    = DoubletVectorViewT&lt;true, T, 1&gt;;\n    using NonConstView = DoubletVectorViewT&lt;false, T, 1&gt;;\n    using ThisView     = DoubletVectorViewT&lt;IsConst, T, 1&gt;;\n\n    using ConstViewer    = CDoubletVectorViewer&lt;T, 1&gt;;\n    using NonConstViewer = DoubletVectorViewer&lt;T, 1&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n\n  protected:\n    int m_total_count = 0;\n\n    int m_doublet_index_offset = 0;\n    int m_doublet_count        = 0;\n    int m_total_doublet_count  = 0;\n\n    int m_subvector_offset = 0;\n    int m_subvector_extent = 0;\n\n    auto_const_t&lt;int&gt;* m_indices;\n    auto_const_t&lt;T&gt;*   m_values;\n\n\n  public:\n    MUDA_GENERIC DoubletVectorViewT() = default;\n    MUDA_GENERIC DoubletVectorViewT(int                total_count,\n                                    int                doublet_index_offset,\n                                    int                doublet_count,\n                                    int                total_doublet_count,\n                                    int                subvector_offset,\n                                    int                subvector_extent,\n                                    auto_const_t&lt;int&gt;* indices,\n                                    auto_const_t&lt;T&gt;*   values)\n        : m_total_count(total_count)\n        , m_doublet_index_offset(doublet_index_offset)\n        , m_doublet_count(doublet_count)\n        , m_total_doublet_count(total_doublet_count)\n        , m_subvector_offset(subvector_offset)\n        , m_subvector_extent(subvector_extent)\n        , m_indices(indices)\n        , m_values(values)\n    {\n        MUDA_ASSERT(doublet_index_offset + doublet_count &lt;= total_doublet_count,\n                    \"DoubletVectorView: out of range, m_total_count=%d, \"\n                    \"your doublet_index_offset=%d, doublet_count=%d\",\n                    m_total_doublet_count,\n                    doublet_index_offset,\n                    doublet_count);\n\n        MUDA_ASSERT(subvector_offset + subvector_extent &lt;= total_count,\n                    \"DoubletVectorView: out of range, m_total_count=%d, \"\n                    \"your subvector_offset=%d, subvector_extent=%d\",\n                    total_count,\n                    subvector_offset,\n                    subvector_extent);\n    }\n\n    MUDA_GENERIC DoubletVectorViewT(int                total_count,\n                                    int                total_doublet_count,\n                                    auto_const_t&lt;int&gt;* indices,\n                                    auto_const_t&lt;T&gt;*   values)\n        : DoubletVectorViewT(\n            total_count, 0, total_doublet_count, total_doublet_count, 0, total_count, indices, values)\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC DoubletVectorViewT(const DoubletVectorViewT&lt;OtherIsConst, T, 1&gt;&amp; other) noexcept\n        : m_total_count(other.m_total_count)\n        , m_doublet_index_offset(other.m_doublet_index_offset)\n        , m_doublet_count(other.m_doublet_count)\n        , m_total_doublet_count(other.m_total_doublet_count)\n        , m_subvector_offset(other.m_subvector_offset)\n        , m_subvector_extent(other.m_subvector_extent)\n        , m_indices(other.m_indices)\n        , m_values(other.m_values)\n    {\n    }\n\n    MUDA_GENERIC ConstView as_const() const noexcept\n    {\n        return ConstView{m_total_count,\n                         m_doublet_index_offset,\n                         m_doublet_count,\n                         m_total_doublet_count,\n                         m_subvector_offset,\n                         m_subvector_extent,\n                         m_indices,\n                         m_values};\n    }\n\n    MUDA_GENERIC auto subview(int offset, int count) const noexcept\n    {\n        MUDA_KERNEL_ASSERT(offset + count &lt;= m_doublet_count,\n                           \"DoubletVectorView : offset is out of range, size=%d, your offset=%d\",\n                           m_doublet_count,\n                           offset);\n\n        return ThisView{m_total_count,\n                        m_doublet_index_offset + offset,\n                        count,\n                        m_total_doublet_count,\n                        m_subvector_offset,\n                        m_subvector_extent,\n                        m_indices,\n                        m_values};\n    }\n\n    MUDA_GENERIC auto subview(int offset) const noexcept\n    {\n        return subview(offset, m_doublet_count - offset);\n    }\n\n    MUDA_GENERIC auto subvector(int offset, int extent) const noexcept\n    {\n        MUDA_KERNEL_ASSERT(offset + extent &lt;= m_subvector_extent,\n                           \"DoubletVectorView : subvector out of range, extent=%d, your offset=%d, your extent=%d\",\n                           m_subvector_extent,\n                           offset,\n                           extent);\n\n        return ThisView{m_total_count,\n                        m_doublet_index_offset,\n                        m_doublet_count,\n                        m_total_doublet_count,\n                        m_subvector_offset + offset,\n                        extent,\n                        m_indices,\n                        m_values};\n    }\n\n    MUDA_GENERIC ThisViewer viewer() noexcept\n    {\n        return ThisViewer{m_total_count,\n                          m_doublet_index_offset,\n                          m_doublet_count,\n                          m_total_doublet_count,\n\n                          m_subvector_offset,\n                          m_subvector_extent,\n\n                          m_indices,\n                          m_values};\n    }\n\n    MUDA_GENERIC ConstViewer cviewer() const noexcept\n    {\n        return ConstViewer{m_total_count,\n                           m_doublet_index_offset,\n                           m_doublet_count,\n                           m_total_doublet_count,\n                           m_subvector_offset,\n                           m_subvector_extent,\n                           m_indices,\n                           m_values};\n    }\n\n\n    MUDA_GENERIC int doublet_count() const noexcept { return m_doublet_count; }\n    MUDA_GENERIC int total_doublet_count() const noexcept\n    {\n        return m_total_doublet_count;\n    }\n\n    MUDA_GENERIC int extent() const noexcept { return m_subvector_extent; }\n    MUDA_GENERIC int total_extent() const noexcept { return m_total_count; }\n\n    MUDA_GENERIC int subvector_offset() const noexcept\n    {\n        return m_subvector_offset;\n    }\n};\n\ntemplate &lt;typename T, int N&gt;\nusing DoubletVectorView = DoubletVectorViewT&lt;false, T, N&gt;;\ntemplate &lt;typename T, int N&gt;\nusing CDoubletVectorView = DoubletVectorViewT&lt;true, T, N&gt;;\n}  // namespace muda\n\nnamespace muda\n{\ntemplate &lt;typename Ty, int N&gt;\nstruct read_only_view&lt;DoubletVectorView&lt;Ty, N&gt;&gt;\n{\n    using type = CDoubletVectorView&lt;Ty, N&gt;;\n};\n\ntemplate &lt;typename Ty, int N&gt;\nstruct read_write_view&lt;CDoubletVectorView&lt;Ty, N&gt;&gt;\n{\n    using type = DoubletVectorView&lt;Ty, N&gt;;\n};\n}  // namespace muda\n\n#include \"details/doublet_vector_view.inl\"\n</code></pre>"},{"location":"muda/doublet__vector__viewer_8h/","title":"File doublet_vector_viewer.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; doublet_vector_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include \"details/doublet_vector_viewer.inl\"</code></li> </ul>"},{"location":"muda/doublet__vector__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/doublet__vector__viewer_8h/#classes","title":"Classes","text":"Type Name class DoubletVectorViewerT &lt;IsConst, typename T, N&gt; struct CDoublet class Proxy <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/doublet_vector_viewer.h</code></p>"},{"location":"muda/doublet__vector__viewer_8h_source/","title":"File doublet_vector_viewer.h","text":"<p>File List &gt; ext &gt; linear_system &gt; doublet_vector_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;muda/viewer/viewer_base.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\n/*\n* - 2024/2/23 remove viewer's subview, view's subview is enough\n*/\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T, int N&gt;\nclass DoubletVectorViewerT : public ViewerBase&lt;IsConst&gt;\n{\n    using Base = ViewerBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U, int M&gt;\n    friend class DoubletVectorViewerT;\n\n    MUDA_VIEWER_COMMON_NAME(DoubletVectorViewerT);\n\n  public:\n    using ValueT      = std::conditional_t&lt;N == 1, T, Eigen::Matrix&lt;T, N, 1&gt;&gt;;\n    using ConstViewer = DoubletVectorViewerT&lt;true, T, N&gt;;\n    using NonConstViewer = DoubletVectorViewerT&lt;false, T, N&gt;;\n    using ThisViewer     = DoubletVectorViewerT&lt;IsConst, T, N&gt;;\n\n    struct CDoublet\n    {\n        MUDA_GENERIC CDoublet(int index, const ValueT&amp; segment)\n            : index(index)\n            , value(segment)\n        {\n        }\n        int           index;\n        const ValueT&amp; value;\n    };\n\n    class Proxy\n    {\n        friend class DoubletVectorViewerT;\n        const DoubletVectorViewerT&amp; m_viewer;\n        int                         m_index = 0;\n\n      private:\n        MUDA_GENERIC Proxy(const DoubletVectorViewerT&amp; viewer, int index)\n            : m_viewer(viewer)\n            , m_index(index)\n        {\n        }\n\n      public:\n        MUDA_GENERIC auto read() &amp;&amp; { return m_viewer.at(m_index); }\n\n        MUDA_GENERIC void write(int segment_i, const ValueT&amp; value) &amp;&amp;\n        {\n            auto index = m_viewer.get_index(m_index);\n\n            m_viewer.check_in_subvector(segment_i);\n\n            auto global_i = segment_i + m_viewer.m_subvector_offset;\n\n            m_viewer.m_segment_indices[index] = global_i;\n            m_viewer.m_segment_values[index]  = value;\n        }\n\n        MUDA_GENERIC ~Proxy() = default;\n    };\n\n  protected:\n    // vector info\n    int m_total_segment_count = 0;\n\n    // doublet info\n    int m_doublet_index_offset = 0;\n    int m_doublet_count        = 0;\n    int m_total_doublet_count  = 0;\n\n    // subvector info\n    int m_subvector_offset = 0;\n    int m_subvector_extent = 0;\n\n    // data\n    auto_const_t&lt;int&gt;*    m_segment_indices;\n    auto_const_t&lt;ValueT&gt;* m_segment_values;\n\n  public:\n    MUDA_GENERIC DoubletVectorViewerT() = default;\n    MUDA_GENERIC DoubletVectorViewerT(int                total_segment_count,\n                                      int                doublet_index_offset,\n                                      int                doublet_count,\n                                      int                total_doublet_count,\n                                      int                subvector_offset,\n                                      int                subvector_extent,\n                                      auto_const_t&lt;int&gt;* segment_indices,\n                                      auto_const_t&lt;ValueT&gt;* segment_values)\n        : m_total_segment_count(total_segment_count)\n        , m_doublet_index_offset(doublet_index_offset)\n        , m_doublet_count(doublet_count)\n        , m_total_doublet_count(total_doublet_count)\n        , m_subvector_offset(subvector_offset)\n        , m_subvector_extent(subvector_extent)\n        , m_segment_indices(segment_indices)\n        , m_segment_values(segment_values)\n    {\n        MUDA_KERNEL_ASSERT(doublet_index_offset + doublet_count &lt;= total_doublet_count,\n                           \"DoubletVectorViewer: out of range, m_total_doublet_count=%d, \"\n                           \"your doublet_index_offset=%d, doublet_count=%d. %s(%d)\",\n                           m_total_doublet_count,\n                           doublet_index_offset,\n                           doublet_count,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n\n        MUDA_KERNEL_ASSERT(subvector_offset + subvector_extent &lt;= total_segment_count,\n                           \"DoubletVectorViewer: out of range, m_total_segment_count=%d, \"\n                           \"your subvector_offset=%d, subvector_extent=%d. %s(%d)\",\n                           m_total_segment_count,\n                           subvector_offset,\n                           subvector_extent,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC DoubletVectorViewerT(const DoubletVectorViewerT&lt;OtherIsConst, T, N&gt;&amp; other) noexcept\n        MUDA_REQUIRES(IsConst)\n        : m_total_segment_count(other.m_total_segment_count)\n        , m_doublet_index_offset(other.m_doublet_index_offset)\n        , m_doublet_count(other.m_doublet_count)\n        , m_total_doublet_count(other.m_total_doublet_count)\n        , m_subvector_offset(other.m_subvector_offset)\n        , m_subvector_extent(other.m_subvector_extent)\n        , m_segment_indices(other.m_segment_indices)\n        , m_segment_values(other.m_segment_values)\n    {\n        static_assert(IsConst);\n    }\n\n    MUDA_GENERIC ConstViewer as_const() const noexcept\n    {\n        return ConstViewer{m_total_segment_count,\n                           m_doublet_index_offset,\n                           m_doublet_count,\n                           m_total_doublet_count,\n                           m_subvector_offset,\n                           m_subvector_extent,\n                           m_segment_indices,\n                           m_segment_values};\n    }\n\n    MUDA_GENERIC int doublet_count() const noexcept { return m_doublet_count; }\n\n    MUDA_GENERIC int total_doublet_count() const noexcept\n    {\n        return m_total_doublet_count;\n    }\n\n    MUDA_GENERIC auto operator()(int i) const\n    {\n        if constexpr(IsConst)\n        {\n            return at(i);\n        }\n        else\n        {\n            return Proxy{*this, i};\n        }\n    }\n\n  protected:\n    MUDA_INLINE MUDA_GENERIC CDoublet at(int i) const\n    {\n        auto index    = get_index(i);\n        auto global_i = m_segment_indices[index];\n        auto sub_i    = global_i - m_subvector_offset;\n\n        check_in_subvector(sub_i);\n        return CDoublet{sub_i, m_segment_values[index]};\n    }\n\n\n    MUDA_INLINE MUDA_GENERIC int get_index(int i) const noexcept\n    {\n        MUDA_KERNEL_ASSERT(i &gt;= 0 &amp;&amp; i &lt; m_doublet_count,\n                           \"DoubletVectorViewer [%s:%s]: index out of range, m_doublet_count=%d, your index=%d. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           m_doublet_count,\n                           i,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n        auto index = i + m_doublet_index_offset;\n        return index;\n    }\n\n    MUDA_INLINE MUDA_GENERIC void check_in_subvector(int i) const noexcept\n    {\n        MUDA_KERNEL_ASSERT(i &gt;= 0 &amp;&amp; i &lt; m_subvector_extent,\n                           \"DoubletVectorViewer [%s:%s]: index out of range, m_subvector_extent=%d, your index=%d. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           m_subvector_extent,\n                           i,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n    }\n};\n\ntemplate &lt;typename T, int N&gt;\nusing DoubletVectorViewer = DoubletVectorViewerT&lt;false, T, N&gt;;\n\ntemplate &lt;typename T, int N&gt;\nusing CDoubletVectorViewer = DoubletVectorViewerT&lt;true, T, N&gt;;\n}  // namespace muda\n\n#include \"details/doublet_vector_viewer.inl\"\n</code></pre>"},{"location":"muda/linear__system__context_8h/","title":"File linear_system_context.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; linear_system_context.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cublas_v2.h&gt;</code></li> <li><code>#include &lt;cusparse_v2.h&gt;</code></li> <li><code>#include &lt;cusolverDn.h&gt;</code></li> <li><code>#include &lt;cusolverSp.h&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/literal/unit.h&gt;</code></li> <li><code>#include &lt;muda/mstl/span.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/dense_vector_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/dense_matrix_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/matrix_format_converter.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/linear_system_handles.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/linear_system_solve_tolerance.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/linear_system_solve_reorder.h&gt;</code></li> <li><code>#include \"details/linear_system_context.inl\"</code></li> <li><code>#include \"details/routines/convert.inl\"</code></li> <li><code>#include \"details/routines/norm.inl\"</code></li> <li><code>#include \"details/routines/dot.inl\"</code></li> <li><code>#include \"details/routines/axpby.inl\"</code></li> <li><code>#include \"details/routines/spmv.inl\"</code></li> <li><code>#include \"details/routines/mv.inl\"</code></li> <li><code>#include \"details/routines/solve.inl\"</code></li> <li><code>#include \"details/routines/mm.inl\"</code></li> </ul>"},{"location":"muda/linear__system__context_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/linear__system__context_8h/#classes","title":"Classes","text":"Type Name class LinearSystemContext class LinearSystemContextCreateInfo <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/linear_system_context.h</code></p>"},{"location":"muda/linear__system__context_8h_source/","title":"File linear_system_context.h","text":"<p>File List &gt; ext &gt; linear_system &gt; linear_system_context.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cublas_v2.h&gt;\n#include &lt;cusparse_v2.h&gt;\n#include &lt;cusolverDn.h&gt;\n#include &lt;cusolverSp.h&gt;\n#include &lt;list&gt;\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/literal/unit.h&gt;\n#include &lt;muda/mstl/span.h&gt;\n#include &lt;muda/ext/linear_system/dense_vector_view.h&gt;\n#include &lt;muda/ext/linear_system/dense_matrix_view.h&gt;\n#include &lt;muda/ext/linear_system/matrix_format_converter.h&gt;\n#include &lt;muda/ext/linear_system/linear_system_handles.h&gt;\n#include &lt;muda/ext/linear_system/linear_system_solve_tolerance.h&gt;\n#include &lt;muda/ext/linear_system/linear_system_solve_reorder.h&gt;\nnamespace muda\n{\nclass LinearSystemContextCreateInfo\n{\n  public:\n    cudaStream_t stream = nullptr;\n    // base size of temp buffer, if buffer is not enough\n    // we create a new buffer with size = buffer_byte_size_base * 2 / 4 / 8 / 16 / ...\n    // and we will not release the old buffer because of safety\n    size_t buffer_byte_size_base = 256_M;\n};\nclass LinearSystemContext\n{\n  private:\n    LinearSystemHandles                m_handles;\n    std::list&lt;DeviceBuffer&lt;std::byte&gt;&gt; m_buffers;\n    std::list&lt;std::vector&lt;std::byte&gt;&gt;  m_host_buffers;\n    DeviceBuffer&lt;std::byte&gt;            m_scalar_buffer;\n\n    LinearSystemContextCreateInfo    m_create_info;\n    std::list&lt;std::function&lt;void()&gt;&gt; m_sync_callbacks;\n    std::string                      m_current_label;\n\n    void                  set_pointer_mode_device();\n    void                  set_pointer_mode_host();\n    void                  shrink_temp_buffers();\n    void                  add_sync_callback(std::function&lt;void()&gt;&amp;&amp; callback);\n    BufferView&lt;std::byte&gt; temp_buffer(size_t size);\n    span&lt;std::byte&gt;       temp_host_buffer(size_t size);\n    template &lt;typename T&gt;\n    BufferView&lt;T&gt; temp_buffer(size_t size);\n    template &lt;typename T&gt;\n    span&lt;T&gt; temp_host_buffer(size_t size);\n    template &lt;typename T&gt;\n    std::vector&lt;T*&gt; temp_buffers(size_t size_in_buffer, size_t num_buffer);\n    template &lt;typename T&gt;\n    std::vector&lt;T*&gt; temp_host_buffers(size_t size_in_buffer, size_t num_buffer);\n\n    LinearSystemSolveTolerance m_tolerance;\n    LinearSystemSolveReorder   m_reorder;\n    MatrixFormatConverter      m_converter;\n\n  private:\n    auto cublas() const { return m_handles.cublas(); }\n    auto cusparse() const { return m_handles.cusparse(); }\n    auto cusolver_dn() const { return m_handles.cusolver_dn(); }\n    auto cusolver_sp() const { return m_handles.cusolver_sp(); }\n\n  public:\n    LinearSystemContext(const LinearSystemContextCreateInfo&amp; info = {});\n    LinearSystemContext(const LinearSystemContext&amp;)            = delete;\n    LinearSystemContext&amp; operator=(const LinearSystemContext&amp;) = delete;\n    LinearSystemContext(LinearSystemContext&amp;&amp;)                 = delete;\n    LinearSystemContext&amp; operator=(LinearSystemContext&amp;&amp;)      = delete;\n    ~LinearSystemContext();\n\n    void label(std::string_view label) { m_current_label = label; }\n    auto label() const -&gt; std::string_view { return m_current_label; }\n    auto stream() const { return m_handles.stream(); }\n    void stream(cudaStream_t stream);\n    void sync();\n\n    /***********************************************************************************************\n                                                Settings\n    ***********************************************************************************************/\n\n    auto&amp; tolerance() { return m_tolerance; }\n    auto&amp; reorder() { return m_reorder; }\n    auto  reserve_ratio() const { return m_handles.m_reserve_ratio; }\n    void  reserve_ratio(float ratio) { m_handles.m_reserve_ratio = ratio; }\n\n\n  public:\n    /***********************************************************************************************\n                                              Converter\n    ***********************************************************************************************/\n    // Triplet -&gt; BCOO\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceTripletMatrix&lt;T, N&gt;&amp; from, DeviceBCOOMatrix&lt;T, N&gt;&amp; to);\n\n    // BCOO -&gt; Dense Matrix\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from,\n                 DeviceDenseMatrix&lt;T&gt;&amp;         to,\n                 bool                          clear_dense_matrix = true);\n\n    // BCOO -&gt; COO\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from, DeviceCOOMatrix&lt;T&gt;&amp; to);\n\n    // BCOO -&gt; BSR\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from, DeviceBSRMatrix&lt;T, N&gt;&amp; to);\n\n    // Doublet -&gt; BCOO\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceDoubletVector&lt;T, N&gt;&amp; from, DeviceBCOOVector&lt;T, N&gt;&amp; to);\n\n    // BCOO -&gt; Dense Vector\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBCOOVector&lt;T, N&gt;&amp; from,\n                 DeviceDenseVector&lt;T&gt;&amp;         to,\n                 bool                          clear_dense_vector = true);\n\n    // Doublet -&gt; Dense Vector\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceDoubletVector&lt;T, N&gt;&amp; from,\n                 DeviceDenseVector&lt;T&gt;&amp;            to,\n                 bool                             clear_dense_vector = true);\n\n    // BSR -&gt; CSR\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBSRMatrix&lt;T, N&gt;&amp; from, DeviceCSRMatrix&lt;T&gt;&amp; to);\n\n    // Triplet -&gt; COO\n    template &lt;typename T&gt;\n    void convert(const DeviceTripletMatrix&lt;T, 1&gt;&amp; from, DeviceCOOMatrix&lt;T&gt;&amp; to);\n\n    // COO -&gt; Dense Matrix\n    template &lt;typename T&gt;\n    void convert(const DeviceCOOMatrix&lt;T&gt;&amp; from,\n                 DeviceDenseMatrix&lt;T&gt;&amp;     to,\n                 bool                      clear_dense_matrix = true);\n\n    // COO -&gt; CSR\n    template &lt;typename T&gt;\n    void convert(const DeviceCOOMatrix&lt;T&gt;&amp; from, DeviceCSRMatrix&lt;T&gt;&amp; to);\n    template &lt;typename T&gt;\n    void convert(DeviceCOOMatrix&lt;T&gt;&amp;&amp; from, DeviceCSRMatrix&lt;T&gt;&amp; to);\n\n    // Doublet -&gt; COO\n    template &lt;typename T&gt;\n    void convert(const DeviceDoubletVector&lt;T, 1&gt;&amp; from, DeviceCOOVector&lt;T&gt;&amp; to);\n\n    // COO -&gt; Dense Vector\n    template &lt;typename T&gt;\n    void convert(const DeviceCOOVector&lt;T&gt;&amp; from,\n                 DeviceDenseVector&lt;T&gt;&amp;     to,\n                 bool                      clear_dense_vector = true);\n\n    // Doublet -&gt; Dense Vector\n    template &lt;typename T&gt;\n    void convert(const DeviceDoubletVector&lt;T, 1&gt;&amp; from,\n                 DeviceDenseVector&lt;T&gt;&amp;            to,\n                 bool                             clear_dense_vector = true);\n\n  public:\n    /***********************************************************************************************\n                                                Norm\n    ***********************************************************************************************/\n    template &lt;typename T&gt;\n    T norm(CDenseVectorView&lt;T&gt; x);\n    template &lt;typename T&gt;\n    void norm(CDenseVectorView&lt;T&gt; x, VarView&lt;T&gt; result);\n    template &lt;typename T&gt;\n    void norm(CDenseVectorView&lt;T&gt; x, T* result);\n\n    /***********************************************************************************************\n                                                Dot\n    ***********************************************************************************************/\n    template &lt;typename T&gt;\n    T dot(CDenseVectorView&lt;T&gt; x, CDenseVectorView&lt;T&gt; y);\n    template &lt;typename T&gt;\n    void dot(CDenseVectorView&lt;T&gt; x, CDenseVectorView&lt;T&gt; y, VarView&lt;T&gt; result);\n    template &lt;typename T&gt;\n    void dot(CDenseVectorView&lt;T&gt; x, CDenseVectorView&lt;T&gt; y, T* result);\n\n    /***********************************************************************************************\n                                              Max/Min\n    ***********************************************************************************************/\n    //TODO:\n\n\n    /***********************************************************************************************\n                                               Axpby\n                                      y = alpha * x + beta * y\n    ***********************************************************************************************/\n    // y = alpha * x + beta * y\n    template &lt;typename T&gt;\n    void axpby(const T&amp; alpha, CDenseVectorView&lt;T&gt; x, const T&amp; beta, DenseVectorView&lt;T&gt; y);\n    // y = alpha * x + beta * y\n    template &lt;typename T&gt;\n    void axpby(CVarView&lt;T&gt; alpha, CDenseVectorView&lt;T&gt; x, CVarView&lt;T&gt; beta, DenseVectorView&lt;T&gt; y);\n    // z = x + y\n    template &lt;typename T&gt;\n    void plus(CDenseVectorView&lt;T&gt; x, CDenseVectorView&lt;T&gt; y, DenseVectorView&lt;T&gt; z);\n\n    /***********************************************************************************************\n                                                Spmv\n                                        y = a * A * x + b * y\n    ***********************************************************************************************/\n    // BSR\n    template &lt;typename T, int N&gt;\n    void spmv(const T&amp;             a,\n              CBSRMatrixView&lt;T, N&gt; A,\n              CDenseVectorView&lt;T&gt;  x,\n              const T&amp;             b,\n              DenseVectorView&lt;T&gt;&amp;  y);\n    template &lt;typename T, int N&gt;\n    void spmv(CBSRMatrixView&lt;T, N&gt; A, CDenseVectorView&lt;T&gt; x, DenseVectorView&lt;T&gt; y);\n    // CSR\n    template &lt;typename T&gt;\n    void spmv(const T&amp; a, CCSRMatrixView&lt;T&gt; A, CDenseVectorView&lt;T&gt; x, const T&amp; b, DenseVectorView&lt;T&gt;&amp; y);\n    template &lt;typename T&gt;\n    void spmv(CCSRMatrixView&lt;T&gt; A, CDenseVectorView&lt;T&gt; x, DenseVectorView&lt;T&gt; y);\n    // BCOO &amp; Triplet\n    template &lt;typename T, int N&gt;\n    void spmv(const T&amp;                 a,\n              CTripletMatrixView&lt;T, N&gt; A,\n              CDenseVectorView&lt;T&gt;      x,\n              const T&amp;                 b,\n              DenseVectorView&lt;T&gt;&amp;      y);\n    template &lt;typename T, int N&gt;\n    void spmv(CTripletMatrixView&lt;T, N&gt; A, CDenseVectorView&lt;T&gt; x, DenseVectorView&lt;T&gt; y);\n    // COO\n    template &lt;typename T&gt;\n    void spmv(const T&amp; a, CCOOMatrixView&lt;T&gt; A, CDenseVectorView&lt;T&gt; x, const T&amp; b, DenseVectorView&lt;T&gt;&amp; y);\n    template &lt;typename T&gt;\n    void spmv(CCOOMatrixView&lt;T&gt; A, CDenseVectorView&lt;T&gt; x, DenseVectorView&lt;T&gt; y);\n\n\n    /***********************************************************************************************\n                                                 Mv\n                                        y = a * A * x + b * y\n    ***********************************************************************************************/\n    template &lt;typename T&gt;\n    void mv(CDenseMatrixView&lt;T&gt; A,\n            const T&amp;            alpha,\n            CDenseVectorView&lt;T&gt; x,\n            const T&amp;            beta,\n            DenseVectorView&lt;T&gt;  y);\n    template &lt;typename T&gt;\n    void mv(CDenseMatrixView&lt;T&gt; A,\n            CVarView&lt;T&gt;         alpha,\n            CDenseVectorView&lt;T&gt; x,\n            CVarView&lt;T&gt;         beta,\n            DenseVectorView&lt;T&gt;  y);\n    template &lt;typename T&gt;\n    void mv(CDenseMatrixView&lt;T&gt; A, CDenseVectorView&lt;T&gt; x, DenseVectorView&lt;T&gt; y);\n\n    /***********************************************************************************************\n                                                Solve\n                                              A * x = b\n    ***********************************************************************************************/\n    // solve Ax = b, A will be modified for factorization\n    // and b will be modified to store the solution\n    template &lt;typename T&gt;\n    void solve(DenseMatrixView&lt;T&gt; A_to_fact, DenseVectorView&lt;T&gt; b_to_x);\n    // solve Ax = b\n    // A is the CSR Matrix\n    template &lt;typename T&gt;\n    void solve(DenseVectorView&lt;T&gt; x, CCSRMatrixView&lt;T&gt; A, CDenseVectorView&lt;T&gt; b);\n\n  private:\n    template &lt;typename T&gt;\n    void generic_spmv(const T&amp;                  a,\n                      cusparseOperation_t       op,\n                      cusparseSpMatDescr_t      A,\n                      const cusparseDnVecDescr* x,\n                      const T&amp;                  b,\n                      cusparseDnVecDescr_t      y);\n    template &lt;typename T&gt;\n    void sysv(DenseMatrixView&lt;T&gt; A_to_fact, DenseVectorView&lt;T&gt; b_to_x);\n    template &lt;typename T&gt;\n    void gesv(DenseMatrixView&lt;T&gt; A_to_fact, DenseVectorView&lt;T&gt; b_to_x);\n};\n}  // namespace muda\n\n#include \"details/linear_system_context.inl\"\n#include \"details/routines/convert.inl\"\n#include \"details/routines/norm.inl\"\n#include \"details/routines/dot.inl\"\n#include \"details/routines/axpby.inl\"\n#include \"details/routines/spmv.inl\"\n#include \"details/routines/mv.inl\"\n#include \"details/routines/solve.inl\"\n#include \"details/routines/mm.inl\"\n</code></pre>"},{"location":"muda/linear__system__handles_8h/","title":"File linear_system_handles.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; linear_system_handles.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cublas_v2.h&gt;</code></li> <li><code>#include &lt;cusparse_v2.h&gt;</code></li> <li><code>#include &lt;cusolverDn.h&gt;</code></li> <li><code>#include &lt;cusolverSp.h&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cusparse.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cublas.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cusolver.h&gt;</code></li> <li><code>#include &lt;muda/check/check.h&gt;</code></li> </ul>"},{"location":"muda/linear__system__handles_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/linear__system__handles_8h/#classes","title":"Classes","text":"Type Name class LinearSystemHandles <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/linear_system_handles.h</code></p>"},{"location":"muda/linear__system__handles_8h_source/","title":"File linear_system_handles.h","text":"<p>File List &gt; ext &gt; linear_system &gt; linear_system_handles.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cublas_v2.h&gt;\n#include &lt;cusparse_v2.h&gt;\n#include &lt;cusolverDn.h&gt;\n#include &lt;cusolverSp.h&gt;\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/check/check_cusparse.h&gt;\n#include &lt;muda/check/check_cublas.h&gt;\n#include &lt;muda/check/check_cusolver.h&gt;\n#include &lt;muda/check/check.h&gt;\n\nnamespace muda\n{\nclass LinearSystemContext;\nclass LinearSystemHandles\n{\n    friend class LinearSystemContext;\n    cudaStream_t       m_stream              = nullptr;\n    cublasHandle_t     m_cublas              = nullptr;\n    cusparseHandle_t   m_cusparse            = nullptr;\n    cusolverDnHandle_t m_cusolver_dn         = nullptr;\n    cusolverSpHandle_t m_cusolver_sp         = nullptr;\n    bool               m_pointer_mode_device = false;\n    float              m_reserve_ratio         = 1.5f;\n\n  public:\n    LinearSystemHandles(cudaStream_t s)\n        : m_stream(s)\n    {\n        checkCudaErrors(cusparseCreate(&amp;m_cusparse));\n        checkCudaErrors(cublasCreate(&amp;m_cublas));\n        checkCudaErrors(cusolverDnCreate(&amp;m_cusolver_dn));\n        checkCudaErrors(cusparseSetStream(m_cusparse, m_stream));\n        checkCudaErrors(cublasSetStream(m_cublas, m_stream));\n        checkCudaErrors(cusolverDnSetStream(m_cusolver_dn, m_stream));\n        checkCudaErrors(cusolverSpCreate(&amp;m_cusolver_sp));\n        checkCudaErrors(cusolverSpSetStream(m_cusolver_sp, m_stream));\n        set_pointer_mode_host();\n    }\n    ~LinearSystemHandles()\n    {\n        if(m_cusparse)\n            checkCudaErrors(cusparseDestroy(m_cusparse));\n        if(m_cublas)\n            checkCudaErrors(cublasDestroy(m_cublas));\n        if(m_cusolver_dn)\n            checkCudaErrors(cusolverDnDestroy(m_cusolver_dn));\n        if(m_cusolver_sp)\n            checkCudaErrors(cusolverSpDestroy(m_cusolver_sp));\n    }\n\n    void stream(cudaStream_t s)\n    {\n        m_stream = s;\n        checkCudaErrors(cusparseSetStream(m_cusparse, m_stream));\n        checkCudaErrors(cublasSetStream(m_cublas, m_stream));\n        checkCudaErrors(cusolverDnSetStream(m_cusolver_dn, m_stream));\n        checkCudaErrors(cusolverSpSetStream(m_cusolver_sp, m_stream));\n    }\n\n    MUDA_INLINE void set_pointer_mode_device()\n    {\n        if(m_pointer_mode_device)\n            return;\n        checkCudaErrors(cusparseSetPointerMode(m_cusparse, CUSPARSE_POINTER_MODE_DEVICE));\n        checkCudaErrors(cublasSetPointerMode(m_cublas, CUBLAS_POINTER_MODE_DEVICE));\n        m_pointer_mode_device = true;\n    }\n\n    MUDA_INLINE void set_pointer_mode_host()\n    {\n        if(!m_pointer_mode_device)\n            return;\n        checkCudaErrors(cusparseSetPointerMode(m_cusparse, CUSPARSE_POINTER_MODE_HOST));\n        checkCudaErrors(cublasSetPointerMode(m_cublas, CUBLAS_POINTER_MODE_HOST));\n        m_pointer_mode_device = false;\n    }\n\n    cudaStream_t       stream() const { return m_stream; }\n    cublasHandle_t     cublas() const { return m_cublas; }\n    cusparseHandle_t   cusparse() const { return m_cusparse; }\n    cusolverDnHandle_t cusolver_dn() const { return m_cusolver_dn; }\n    cusolverSpHandle_t cusolver_sp() const { return m_cusolver_sp; }\n    auto reserve_ratio() const { return m_reserve_ratio; }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/linear__system__solve__reorder_8h/","title":"File linear_system_solve_reorder.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; linear_system_solve_reorder.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/linear__system__solve__reorder_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/linear__system__solve__reorder_8h/#classes","title":"Classes","text":"Type Name class LinearSystemSolveReorder <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/linear_system_solve_reorder.h</code></p>"},{"location":"muda/linear__system__solve__reorder_8h_source/","title":"File linear_system_solve_reorder.h","text":"<p>File List &gt; ext &gt; linear_system &gt; linear_system_solve_reorder.h</p> <p>Go to the documentation of this file</p> <pre><code>namespace muda\n{\nenum class LinearSystemReorderMethod\n{\n    None       = 0,\n    Symrcm     = 1,\n    Symamd     = 2,\n    Csrmetisnd = 3,\n};\nclass LinearSystemSolveReorder\n{\n    LinearSystemReorderMethod m_reorder_method = LinearSystemReorderMethod::None;\n\n  public:\n    LinearSystemReorderMethod reorder_method() const\n    {\n        return m_reorder_method;\n    }\n    void reoder_method(LinearSystemReorderMethod method)\n    {\n        m_reorder_method = method;\n    }\n    int reorder_method_int() const\n    {\n        return static_cast&lt;int&gt;(m_reorder_method);\n    }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/linear__system__solve__tolerance_8h/","title":"File linear_system_solve_tolerance.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; linear_system_solve_tolerance.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;numeric&gt;</code></li> </ul>"},{"location":"muda/linear__system__solve__tolerance_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/linear__system__solve__tolerance_8h/#classes","title":"Classes","text":"Type Name class LinearSystemSolveTolerance <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/linear_system_solve_tolerance.h</code></p>"},{"location":"muda/linear__system__solve__tolerance_8h_source/","title":"File linear_system_solve_tolerance.h","text":"<p>File List &gt; ext &gt; linear_system &gt; linear_system_solve_tolerance.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;numeric&gt;\n\nnamespace muda\n{\nclass LinearSystemSolveTolerance\n{\n    double m_solve_sparse_error_threshold = -1.0;\n\n  public:\n    void solve_sparse_error_threshold(double threshold)\n    {\n        m_solve_sparse_error_threshold = threshold;\n    }\n\n    template &lt;typename T&gt;\n    T solve_sparse_error_threshold()\n    {\n        if(m_solve_sparse_error_threshold &lt; 0.0)\n        {\n            constexpr auto eps = std::numeric_limits&lt;T&gt;::epsilon();\n            return eps;\n        }\n        else\n        {\n            return static_cast&lt;T&gt;(m_solve_sparse_error_threshold);\n        }\n    }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/matrix__format__converter_8h/","title":"File matrix_format_converter.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; matrix_format_converter.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/linear_system_handles.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_dense_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_dense_vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_triplet_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_doublet_vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bcoo_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bcoo_vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bsr_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_csr_matrix.h&gt;</code></li> <li><code>#include \"details/matrix_format_converter.inl\"</code></li> </ul>"},{"location":"muda/matrix__format__converter_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace std"},{"location":"muda/matrix__format__converter_8h/#classes","title":"Classes","text":"Type Name class MatrixFormatConverter class MatrixFormatConverterType struct hash&lt; muda::details::MatrixFormatConverterType &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/matrix_format_converter.h</code></p>"},{"location":"muda/matrix__format__converter_8h_source/","title":"File matrix_format_converter.h","text":"<p>File List &gt; ext &gt; linear_system &gt; matrix_format_converter.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/linear_system_handles.h&gt;\n#include &lt;muda/ext/linear_system/device_dense_matrix.h&gt;\n#include &lt;muda/ext/linear_system/device_dense_vector.h&gt;\n#include &lt;muda/ext/linear_system/device_triplet_matrix.h&gt;\n#include &lt;muda/ext/linear_system/device_doublet_vector.h&gt;\n#include &lt;muda/ext/linear_system/device_bcoo_matrix.h&gt;\n#include &lt;muda/ext/linear_system/device_bcoo_vector.h&gt;\n#include &lt;muda/ext/linear_system/device_bsr_matrix.h&gt;\n#include &lt;muda/ext/linear_system/device_csr_matrix.h&gt;\n\nnamespace muda::details\n{\nclass MatrixFormatConverterBase;\ntemplate &lt;typename T, int N&gt;\nclass MatrixFormatConverter;\n\nclass MatrixFormatConverterType\n{\n  public:\n    cudaDataType_t data_type;\n    int            N;\n    bool friend    operator==(const MatrixFormatConverterType&amp; lhs,\n                           const MatrixFormatConverterType&amp; rhs)\n    {\n        return lhs.data_type == rhs.data_type &amp;&amp; lhs.N == rhs.N;\n    }\n};\n}  // namespace muda::details\n\nnamespace std\n{\ntemplate &lt;&gt;\nstruct hash&lt;muda::details::MatrixFormatConverterType&gt;\n{\n    size_t operator()(const muda::details::MatrixFormatConverterType&amp; x) const\n    {\n        return (std::hash&lt;int&gt;()(x.data_type) &lt;&lt; 8) ^ std::hash&lt;int&gt;()(x.N);\n    }\n};\n}  // namespace std\n\n\nnamespace muda\n{\n\nclass MatrixFormatConverter\n{\n    template &lt;typename T&gt;\n    using U = std::unique_ptr&lt;T&gt;;\n    LinearSystemHandles&amp; m_handles;\n    using TypeN = std::pair&lt;cudaDataType_t, int&gt;;\n    std::unordered_map&lt;details::MatrixFormatConverterType, U&lt;details::MatrixFormatConverterBase&gt;&gt; m_impls;\n    details::MatrixFormatConverterBase* current = nullptr;\n    template &lt;typename T, int N&gt;\n    details::MatrixFormatConverter&lt;T, N&gt;&amp; impl();\n\n  public:\n    MatrixFormatConverter(LinearSystemHandles&amp; handles)\n        : m_handles(handles)\n    {\n    }\n    ~MatrixFormatConverter();\n\n    // Triplet -&gt; BCOO\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceTripletMatrix&lt;T, N&gt;&amp; from, DeviceBCOOMatrix&lt;T, N&gt;&amp; to);\n\n    // BCOO -&gt; Dense Matrix\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from,\n                 DeviceDenseMatrix&lt;T&gt;&amp;         to,\n                 bool                          clear_dense_matrix = true);\n\n    // BCOO -&gt; COO\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from, DeviceCOOMatrix&lt;T&gt;&amp; to);\n\n    // BCOO -&gt; BSR\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from, DeviceBSRMatrix&lt;T, N&gt;&amp; to);\n\n    // Doublet -&gt; BCOO\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceDoubletVector&lt;T, N&gt;&amp; from, DeviceBCOOVector&lt;T, N&gt;&amp; to);\n\n    // BCOO -&gt; Dense Vector\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBCOOVector&lt;T, N&gt;&amp; from,\n                 DeviceDenseVector&lt;T&gt;&amp;         to,\n                 bool                          clear_dense_vector = true);\n\n    // Doublet -&gt; Dense Vector\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceDoubletVector&lt;T, N&gt;&amp; from,\n                 DeviceDenseVector&lt;T&gt;&amp;            to,\n                 bool                             clear_dense_vector = true);\n\n    // BSR -&gt; CSR\n    template &lt;typename T, int N&gt;\n    void convert(const DeviceBSRMatrix&lt;T, N&gt;&amp; from, DeviceCSRMatrix&lt;T&gt;&amp; to);\n\n    // Triplet -&gt; COO\n    template &lt;typename T&gt;\n    void convert(const DeviceTripletMatrix&lt;T, 1&gt;&amp; from, DeviceCOOMatrix&lt;T&gt;&amp; to);\n\n    // COO -&gt; Dense Matrix\n    template &lt;typename T&gt;\n    void convert(const DeviceCOOMatrix&lt;T&gt;&amp; from,\n                 DeviceDenseMatrix&lt;T&gt;&amp;     to,\n                 bool                      clear_dense_matrix = true);\n\n    // COO -&gt; CSR\n    template &lt;typename T&gt;\n    void convert(const DeviceCOOMatrix&lt;T&gt;&amp; from, DeviceCSRMatrix&lt;T&gt;&amp; to);\n    template &lt;typename T&gt;\n    void convert(DeviceCOOMatrix&lt;T&gt;&amp;&amp; from, DeviceCSRMatrix&lt;T&gt;&amp; to);\n\n    // Doublet -&gt; COO\n    template &lt;typename T&gt;\n    void convert(const DeviceDoubletVector&lt;T, 1&gt;&amp; from, DeviceCOOVector&lt;T&gt;&amp; to);\n\n    // COO -&gt; Dense Vector\n    template &lt;typename T&gt;\n    void convert(const DeviceCOOVector&lt;T&gt;&amp; from,\n                 DeviceDenseVector&lt;T&gt;&amp;     to,\n                 bool                      clear_dense_vector = true);\n\n    // Doublet -&gt; Dense Vector\n    template &lt;typename T&gt;\n    void convert(const DeviceDoubletVector&lt;T, 1&gt;&amp; from,\n                 DeviceDenseVector&lt;T&gt;&amp;            to,\n                 bool                             clear_dense_vector = true);\n};\n}  // namespace muda\n\n#include \"details/matrix_format_converter.inl\"\n</code></pre>"},{"location":"muda/matrix__format__converter__impl_8h/","title":"File matrix_format_converter_impl.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; matrix_format_converter_impl.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/ext/linear_system/linear_system_handles.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_dense_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_dense_vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_triplet_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_doublet_vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bcoo_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bcoo_vector.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_bsr_matrix.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/device_csr_matrix.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_merge_sort.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_radix_sort.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_run_length_encode.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_scan.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_segmented_reduce.h&gt;</code></li> <li><code>#include &lt;muda/cub/device/device_reduce.h&gt;</code></li> <li><code>#include &lt;muda/type_traits/cuda_arch.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_var.h&gt;</code></li> <li><code>#include &lt;muda/launch.h&gt;</code></li> </ul>"},{"location":"muda/matrix__format__converter__impl_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/matrix__format__converter__impl_8h/#classes","title":"Classes","text":"Type Name class MatrixFormatConverter &lt;typename T, N&gt; class MatrixFormatConverterBase"},{"location":"muda/matrix__format__converter__impl_8h/#public-functions","title":"Public Functions","text":"Type Name MUDA_GENERIC constexpr bool operator== (const int2 &amp; a, const int2 &amp; b)"},{"location":"muda/matrix__format__converter__impl_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/matrix__format__converter__impl_8h/#function-operator","title":"function operator==","text":"<pre><code>MUDA_GENERIC constexpr bool operator== (\n    const int2 &amp; a,\n    const int2 &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/matrix_format_converter_impl.h</code></p>"},{"location":"muda/matrix__format__converter__impl_8h_source/","title":"File matrix_format_converter_impl.h","text":"<p>File List &gt; ext &gt; linear_system &gt; matrix_format_converter_impl.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/ext/linear_system/linear_system_handles.h&gt;\n#include &lt;muda/ext/linear_system/device_dense_matrix.h&gt;\n#include &lt;muda/ext/linear_system/device_dense_vector.h&gt;\n#include &lt;muda/ext/linear_system/device_triplet_matrix.h&gt;\n#include &lt;muda/ext/linear_system/device_doublet_vector.h&gt;\n#include &lt;muda/ext/linear_system/device_bcoo_matrix.h&gt;\n#include &lt;muda/ext/linear_system/device_bcoo_vector.h&gt;\n#include &lt;muda/ext/linear_system/device_bsr_matrix.h&gt;\n#include &lt;muda/ext/linear_system/device_csr_matrix.h&gt;\n\n#include &lt;muda/cub/device/device_merge_sort.h&gt;\n#include &lt;muda/cub/device/device_radix_sort.h&gt;\n#include &lt;muda/cub/device/device_run_length_encode.h&gt;\n#include &lt;muda/cub/device/device_scan.h&gt;\n#include &lt;muda/cub/device/device_segmented_reduce.h&gt;\n#include &lt;muda/cub/device/device_reduce.h&gt;\n\n#include &lt;muda/type_traits/cuda_arch.h&gt;\n#include &lt;muda/buffer/device_var.h&gt;\n\n#include &lt;muda/launch.h&gt;\n\n// for encode run length usage\nMUDA_GENERIC constexpr bool operator==(const int2&amp; a, const int2&amp; b)\n{\n    return a.x == b.x &amp;&amp; a.y == b.y;\n}\n\nnamespace muda\n{\nnamespace details\n{\n    class MatrixFormatConverterBase\n    {\n      protected:\n        LinearSystemHandles&amp; m_handles;\n        cudaDataType_t       m_data_type;\n        int                  m_N;\n\n      public:\n        MatrixFormatConverterBase(LinearSystemHandles&amp; context, cudaDataType_t data_type, int N)\n            : m_handles(context)\n            , m_data_type(data_type)\n            , m_N(N)\n        {\n        }\n\n        virtual ~MatrixFormatConverterBase() = default;\n\n        auto dim() const { return m_N; }\n        auto data_type() const { return m_data_type; }\n        auto cublas() const { return m_handles.cublas(); }\n        auto cusparse() const { return m_handles.cusparse(); }\n        auto cusolver_sp() const { return m_handles.cusolver_sp(); }\n        auto cusolver_dn() const { return m_handles.cusolver_dn(); }\n\n        template &lt;typename T&gt;\n        void loose_resize(DeviceBuffer&lt;T&gt;&amp; buf, size_t new_size)\n        {\n            if(buf.capacity() &lt; new_size)\n                buf.reserve(new_size * m_handles.reserve_ratio());\n            buf.resize(new_size);\n        }\n    };\n\n    //using T         = float;\n    //constexpr int N = 3;\n    //template &lt;&gt;\n    //class MatrixFormatConverter&lt;T, N&gt; : public MatrixFormatConverterBase\n\n    template &lt;typename T, int N&gt;\n    class MatrixFormatConverter : public MatrixFormatConverterBase\n    {\n        using MatrixValueT = typename DeviceTripletMatrix&lt;T, N&gt;::ValueT;\n        using VectorValueT = typename DeviceDoubletVector&lt;T, N&gt;::ValueT;\n\n        MatrixValueT MatrixValueTZero() const\n        {\n            if constexpr(N &gt; 1)\n            {\n                return MatrixValueT::Zero().eval();\n            }\n            else\n            {\n                return MatrixValueT{0};\n            }\n        }\n\n        VectorValueT VectorValueTZero() const\n        {\n            if constexpr(N &gt; 1)\n            {\n                return VectorValueT::Zero().eval();\n            }\n            else\n            {\n                return VectorValueT{0};\n            }\n        }\n\n        DeviceBuffer&lt;int&gt; sort_index;\n        DeviceBuffer&lt;int&gt; sort_index_input;\n        DeviceBuffer&lt;int&gt; sort_index_tmp;\n\n        DeviceBuffer&lt;int&gt; col_tmp;\n        DeviceBuffer&lt;int&gt; row_tmp;\n\n        DeviceBCOOMatrix&lt;T, N&gt; temp_bcoo_matrix;\n        DeviceBCOOVector&lt;T, N&gt; temp_bcoo_vector;\n\n        DeviceBuffer&lt;int&gt; unique_indices;\n        DeviceBuffer&lt;int&gt; unique_counts;\n        DeviceBuffer&lt;int&gt; offsets;\n\n        DeviceVar&lt;int&gt; count;\n\n        DeviceBuffer&lt;int2&gt;    ij_pairs;\n        DeviceBuffer&lt;int64_t&gt; ij_hash;\n        DeviceBuffer&lt;int64_t&gt; ij_hash_input;\n        DeviceBuffer&lt;int2&gt;    unique_ij_pairs;\n\n        muda::DeviceBuffer&lt;MatrixValueT&gt; blocks_sorted;\n        DeviceBuffer&lt;MatrixValueT&gt;       unique_blocks;\n        DeviceBuffer&lt;VectorValueT&gt;       unique_segments;\n        DeviceBuffer&lt;VectorValueT&gt;       temp_segments;\n\n        DeviceBuffer&lt;T&gt; unique_values;\n\n      public:\n        MatrixFormatConverter(LinearSystemHandles&amp; handles)\n            : MatrixFormatConverterBase(handles, cuda_data_type&lt;T&gt;(), N)\n        {\n        }\n\n        virtual ~MatrixFormatConverter() = default;\n\n\n        // Triplet -&gt; BCOO\n        void convert(const DeviceTripletMatrix&lt;T, N&gt;&amp; from, DeviceBCOOMatrix&lt;T, N&gt;&amp; to)\n        {\n            to.reshape(from.rows(), from.cols());\n            to.resize_triplets(from.triplet_count());\n\n\n            if(to.triplet_count() == 0)\n                return;\n\n            if constexpr(N &lt;= 3)\n            {\n                radix_sort_indices_and_blocks(from, to);\n                make_unique_indices_and_blocks(from, to);\n            }\n            else\n            {\n                merge_sort_indices_and_blocks(from, to);\n                make_unique_indices(from, to);\n                make_unique_blocks(from, to);\n            }\n        }\n\n        void radix_sort_indices_and_blocks(const DeviceTripletMatrix&lt;T, N&gt;&amp; from,\n                                           DeviceBCOOMatrix&lt;T, N&gt;&amp; to)\n        {\n            auto src_row_indices = from.row_indices();\n            auto src_col_indices = from.col_indices();\n            auto src_blocks      = from.values();\n\n            loose_resize(ij_hash_input, src_row_indices.size());\n            loose_resize(sort_index_input, src_row_indices.size());\n\n            loose_resize(ij_hash, src_row_indices.size());\n            loose_resize(sort_index, src_row_indices.size());\n            ij_pairs.resize(src_row_indices.size());\n\n\n            // hash ij\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(src_row_indices.size(),\n                       [row_indices = src_row_indices.cviewer().name(\"row_indices\"),\n                        col_indices = src_col_indices.cviewer().name(\"col_indices\"),\n                        ij_hash = ij_hash_input.viewer().name(\"ij_hash\"),\n                        sort_index = sort_index_input.viewer().name(\"sort_index\")] __device__(int i) mutable\n                       {\n                           ij_hash(i) = (int64_t{row_indices(i)} &lt;&lt; 32)\n                                        + int64_t{col_indices(i)};\n                           sort_index(i) = i;\n                       });\n\n            DeviceRadixSort().SortPairs(ij_hash_input.data(),\n                                        ij_hash.data(),\n                                        sort_index_input.data(),\n                                        sort_index.data(),\n                                        ij_hash.size());\n\n            // set ij_hash back to row_indices and col_indices\n            auto dst_row_indices = to.row_indices();\n            auto dst_col_indices = to.col_indices();\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(dst_row_indices.size(),\n                       [ij_hash = ij_hash.viewer().name(\"ij_hash\"),\n                        ij_pairs = ij_pairs.viewer().name(\"ij_pairs\")] __device__(int i) mutable\n                       {\n                           auto hash      = ij_hash(i);\n                           auto row_index = int{hash &gt;&gt; 32};\n                           auto col_index = int{hash &amp; 0xFFFFFFFF};\n                           ij_pairs(i).x  = row_index;\n                           ij_pairs(i).y  = col_index;\n                       });\n\n            // sort the block values\n\n            {\n                loose_resize(blocks_sorted, from.values().size());\n                ParallelFor()\n                    .file_line(__FILE__, __LINE__)\n                    .apply(src_blocks.size(),\n                           [src_blocks = src_blocks.cviewer().name(\"blocks\"),\n                            sort_index = sort_index.cviewer().name(\"sort_index\"),\n                            dst_blocks = blocks_sorted.viewer().name(\n                                \"block_values\")] __device__(int i) mutable\n                           { dst_blocks(i) = src_blocks(sort_index(i)); });\n            }\n        }\n\n\n        void make_unique_indices_and_blocks(const DeviceTripletMatrix&lt;T, N&gt;&amp; from,\n                                            DeviceBCOOMatrix&lt;T, N&gt;&amp; to)\n        {\n            // alias to reuse the memory\n            auto&amp; unique_ij_hash = ij_hash_input;\n\n            muda::DeviceReduce().ReduceByKey(\n                ij_hash.data(),\n                unique_ij_hash.data(),\n                blocks_sorted.data(),\n                to.values().data(),\n                count.data(),\n                [] CUB_RUNTIME_FUNCTION(const MatrixValueT&amp; l, const MatrixValueT&amp; r) -&gt; MatrixValueT\n                { return l + r; },\n                ij_hash.size());\n\n            int h_count = count;\n\n            to.resize_triplets(h_count);\n\n            // set ij_hash back to row_indices and col_indices\n            ParallelFor()\n                .kernel_name(\"set col row indices\")\n                .apply(to.row_indices().size(),\n                       [ij_hash = unique_ij_hash.viewer().name(\"ij_hash\"),\n                        row_indices = to.row_indices().viewer().name(\"row_indices\"),\n                        col_indices = to.col_indices().viewer().name(\n                            \"col_indices\")] __device__(int i) mutable\n                       {\n                           auto hash      = ij_hash(i);\n                           auto row_index = int{hash &gt;&gt; 32};\n                           auto col_index = int{hash &amp; 0xFFFFFFFF};\n                           row_indices(i) = row_index;\n                           col_indices(i) = col_index;\n                       });\n        }\n\n        void merge_sort_indices_and_blocks(const DeviceTripletMatrix&lt;T, N&gt;&amp; from,\n                                           DeviceBCOOMatrix&lt;T, N&gt;&amp; to)\n        {\n            using namespace muda;\n\n            auto src_row_indices = from.row_indices();\n            auto src_col_indices = from.col_indices();\n            auto src_blocks      = from.values();\n\n            loose_resize(sort_index, src_row_indices.size());\n            loose_resize(ij_pairs, src_row_indices.size());\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(src_row_indices.size(),\n                       [row_indices = src_row_indices.cviewer().name(\"row_indices\"),\n                        col_indices = src_col_indices.cviewer().name(\"col_indices\"),\n                        ij_pairs = ij_pairs.viewer().name(\"ij_pairs\")] __device__(int i) mutable\n                       {\n                           ij_pairs(i).x = row_indices(i);\n                           ij_pairs(i).y = col_indices(i);\n                       });\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)  //\n                .apply(src_row_indices.size(),\n                       [sort_index = sort_index.viewer().name(\"sort_index\")] __device__(\n                           int i) mutable { sort_index(i) = i; });\n\n            DeviceMergeSort().SortPairs(ij_pairs.data(),\n                                        sort_index.data(),\n                                        ij_pairs.size(),\n                                        [] __device__(const int2&amp; a, const int2&amp; b) {\n                                            return a.x &lt; b.x\n                                                   || (a.x == b.x &amp;&amp; a.y &lt; b.y);\n                                        });\n\n\n            // set ij_pairs back to row_indices and col_indices\n\n            auto dst_row_indices = to.row_indices();\n            auto dst_col_indices = to.col_indices();\n\n            ParallelFor()\n                .kernel_name(\"set col row indices\")\n                .apply(dst_row_indices.size(),\n                       [row_indices = dst_row_indices.viewer().name(\"row_indices\"),\n                        col_indices = dst_col_indices.viewer().name(\"col_indices\"),\n                        ij_pairs = ij_pairs.viewer().name(\"ij_pairs\")] __device__(int i) mutable\n                       {\n                           row_indices(i) = ij_pairs(i).x;\n                           col_indices(i) = ij_pairs(i).y;\n                       });\n\n\n            // sort the block values\n\n            loose_resize(unique_blocks, from.m_values.size());\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(src_blocks.size(),\n                       [src_blocks = src_blocks.cviewer().name(\"blocks\"),\n                        sort_index = sort_index.cviewer().name(\"sort_index\"),\n                        dst_blocks = unique_blocks.viewer().name(\"block_values\")] __device__(int i) mutable\n                       { dst_blocks(i) = src_blocks(sort_index(i)); });\n        }\n\n        void make_unique_indices(const DeviceTripletMatrix&lt;T, N&gt;&amp; from,\n                                 DeviceBCOOMatrix&lt;T, N&gt;&amp;          to)\n        {\n            using namespace muda;\n\n            auto&amp; row_indices = to.m_row_indices;\n            auto&amp; col_indices = to.m_col_indices;\n\n            loose_resize(unique_ij_pairs, ij_pairs.size());\n            loose_resize(unique_counts, ij_pairs.size());\n\n\n            DeviceRunLengthEncode().Encode(ij_pairs.data(),\n                                           unique_ij_pairs.data(),\n                                           unique_counts.data(),\n                                           count.data(),\n                                           ij_pairs.size());\n\n            int h_count = count;\n\n            unique_ij_pairs.resize(h_count);\n            unique_counts.resize(h_count);\n\n            offsets.resize(unique_counts.size() + 1);  // +1 for the last offset_end\n\n            DeviceScan().ExclusiveSum(\n                unique_counts.data(), offsets.data(), unique_counts.size());\n\n\n            muda::ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(unique_counts.size(),\n                       [unique_ij_pairs = unique_ij_pairs.viewer().name(\"unique_ij_pairs\"),\n                        row_indices = row_indices.viewer().name(\"row_indices\"),\n                        col_indices = col_indices.viewer().name(\"col_indices\")] __device__(int i) mutable\n                       {\n                           row_indices(i) = unique_ij_pairs(i).x;\n                           col_indices(i) = unique_ij_pairs(i).y;\n                       });\n\n            row_indices.resize(h_count);\n            col_indices.resize(h_count);\n        }\n\n        void make_unique_blocks(const DeviceTripletMatrix&lt;T, N&gt;&amp; from,\n                                DeviceBCOOMatrix&lt;T, N&gt;&amp;          to)\n        {\n            using namespace muda;\n\n            auto&amp; row_indices = to.m_row_indices;\n            auto&amp; values      = to.m_values;\n            values.resize(row_indices.size());\n            // first we add the offsets to counts, to get the offset_ends\n\n            Launch()\n                .file_line(__FILE__, __LINE__)\n                .apply([offsets = offsets.viewer().name(\"offset\"),\n                        counts  = unique_counts.cviewer().name(\"counts\"),\n                        last    = unique_counts.size() - 1] __device__() mutable\n                       { offsets(last + 1) = offsets(last) + counts(last); });\n\n            // auto&amp; begin_offset = offsets;\n            // auto&amp; end_offset = unique_counts;  // already contains the offset_ends\n\n            // then we do a segmented reduce to get the unique blocks\n\n            DeviceSegmentedReduce().Reduce(\n                unique_blocks.data(),\n                values.data(),\n                values.size(),\n                offsets.data(),\n                offsets.data() + 1,\n                [] __host__ __device__(const MatrixValueT&amp; a, const MatrixValueT&amp; b) -&gt; MatrixValueT\n                { return a + b; },\n                MatrixValueTZero());\n        }\n\n\n        // BCOO -&gt; Dense Matrix\n        void convert(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from,\n                     DeviceDenseMatrix&lt;T&gt;&amp;         to,\n                     bool                          clear_dense_matrix = true)\n        {\n            using namespace muda;\n            auto size = N * from.rows();\n            to.reshape(size, size);\n\n            if(clear_dense_matrix)\n                to.fill(0);\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(from.values().size(),\n                       [triplets = from.cviewer().name(\"src_sparse_matrix\"),\n                        dst = to.viewer().name(\"dst_dense_matrix\")] __device__(int i) mutable\n                       {\n                           auto triplet = triplets(i);\n                           auto row     = triplet.row_index * N;\n                           auto col     = triplet.col_index * N;\n\n                           if constexpr(N == 1)\n                           {\n                               dst(row, col) += triplet.value;\n                           }\n                           else\n                           {\n                               dst.block&lt;N, N&gt;(row, col).as_eigen() += triplet.value;\n                           }\n                       });\n        }\n\n        // BCOO -&gt; COO\n        void convert(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from, DeviceCOOMatrix&lt;T&gt;&amp; to)\n            MUDA_REQUIRES(N &gt; 1)\n        {\n            static_assert(N &gt; 1, \"N must be greater than 1\");\n            expand_blocks(from, to);\n            sort_indices_and_values(from, to);\n        }\n\n        void expand_blocks(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from, DeviceCOOMatrix&lt;T&gt;&amp; to)\n            MUDA_REQUIRES(N &gt; 1)\n        {\n            static_assert(N &gt; 1, \"N must be greater than 1\");\n            using namespace muda;\n\n            constexpr int N2 = N * N;\n\n            to.reshape(from.rows() * N, from.cols() * N);\n            to.resize_triplets(from.non_zeros() * N2);\n\n            auto&amp; dst_row_indices = to.m_row_indices;\n            auto&amp; dst_col_indices = to.m_col_indices;\n            auto&amp; dst_values      = to.m_values;\n\n            auto&amp; src_row_indices = from.m_row_indices;\n            auto&amp; src_col_indices = from.m_col_indices;\n            auto&amp; src_values      = from.m_values;\n\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(src_row_indices.size(),\n                       [src_row_indices = src_row_indices.cviewer().name(\"src_row_indices\"),\n                        src_col_indices = src_col_indices.cviewer().name(\"src_col_indices\"),\n                        src_values = src_values.cviewer().name(\"src_values\"),\n\n                        dst_row_indices = dst_row_indices.viewer().name(\"dst_row_indices\"),\n                        dst_col_indices = dst_col_indices.viewer().name(\"dst_col_indices\"),\n                        dst_values = dst_values.viewer().name(\"dst_values\")] __device__(int i) mutable\n                       {\n                           auto src_row_index = src_row_indices(i);\n                           auto src_col_index = src_col_indices(i);\n                           auto src_value     = src_values(i);\n\n                           auto row = src_row_index * N;\n                           auto col = src_col_index * N;\n\n                           auto index = i * N2;\n#pragma unroll\n                           for(int r = 0; r &lt; N; ++r)\n                           {\n#pragma unroll\n                               for(int c = 0; c &lt; N; ++c)\n                               {\n                                   dst_row_indices(index) = row + r;\n                                   dst_col_indices(index) = col + c;\n                                   dst_values(index)      = src_value(r, c);\n                                   ++index;\n                               }\n                           }\n                       });\n        }\n\n        void sort_indices_and_values(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from,\n                                     DeviceCOOMatrix&lt;T&gt;&amp; to) MUDA_REQUIRES(N &gt; 1)\n        {\n            static_assert(N &gt; 1, \"N must be greater than 1\");\n\n            using namespace muda;\n\n            auto&amp; row_indices = to.m_row_indices;\n            auto&amp; col_indices = to.m_col_indices;\n            auto&amp; values      = to.m_values;\n\n            ij_pairs.resize(row_indices.size());\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(row_indices.size(),\n                       [row_indices = row_indices.cviewer().name(\"row_indices\"),\n                        col_indices = col_indices.cviewer().name(\"col_indices\"),\n                        ij_pairs = ij_pairs.viewer().name(\"ij_pairs\")] __device__(int i) mutable\n                       {\n                           ij_pairs(i).x = row_indices(i);\n                           ij_pairs(i).y = col_indices(i);\n                       });\n\n            DeviceMergeSort().SortPairs(ij_pairs.data(),\n                                        to.m_values.data(),\n                                        ij_pairs.size(),\n                                        [] __device__(const int2&amp; a, const int2&amp; b) {\n                                            return a.x &lt; b.x\n                                                   || (a.x == b.x &amp;&amp; a.y &lt; b.y);\n                                        });\n\n            // set ij_pairs back to row_indices and col_indices\n\n            auto dst_row_indices = to.row_indices();\n            auto dst_col_indices = to.col_indices();\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(dst_row_indices.size(),\n                       [row_indices = dst_row_indices.viewer().name(\"row_indices\"),\n                        col_indices = dst_col_indices.viewer().name(\"col_indices\"),\n                        ij_pairs = ij_pairs.viewer().name(\"ij_pairs\")] __device__(int i) mutable\n                       {\n                           row_indices(i) = ij_pairs(i).x;\n                           col_indices(i) = ij_pairs(i).y;\n                       });\n        }\n\n        // BCOO -&gt; BSR\n        void convert(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from, DeviceBSRMatrix&lt;T, N&gt;&amp; to)\n        {\n            calculate_block_offsets(from, to);\n\n            to.m_col_indices = from.m_col_indices;\n            to.m_values      = from.m_values;\n        }\n\n        void convert(DeviceBCOOMatrix&lt;T, N&gt;&amp;&amp; from, DeviceBSRMatrix&lt;T, N&gt;&amp; to)\n        {\n            calculate_block_offsets(from, to);\n            to.m_col_indices = std::move(from.m_col_indices);\n            to.m_values      = std::move(from.m_values);\n        }\n\n        void calculate_block_offsets(const DeviceBCOOMatrix&lt;T, N&gt;&amp; from,\n                                     DeviceBSRMatrix&lt;T, N&gt;&amp;        to)\n        {\n            using namespace muda;\n            to.reshape(from.rows(), from.cols());\n\n            auto&amp; dst_row_offsets = to.m_row_offsets;\n\n            // alias the offsets to the col_counts_per_row(reuse)\n            auto&amp; col_counts_per_row = offsets;\n            col_counts_per_row.resize(to.m_row_offsets.size());\n            col_counts_per_row.fill(0);\n\n            unique_indices.resize(from.non_zeros());\n            unique_counts.resize(from.non_zeros());\n\n            // run length encode the row\n            DeviceRunLengthEncode().Encode(from.m_row_indices.data(),\n                                           unique_indices.data(),\n                                           unique_counts.data(),\n                                           count.data(),\n                                           from.non_zeros());\n            int h_count = count;\n\n            unique_indices.resize(h_count);\n            unique_counts.resize(h_count);\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(unique_counts.size(),\n                       [unique_indices = unique_indices.cviewer().name(\"offset\"),\n                        counts = unique_counts.viewer().name(\"counts\"),\n                        col_counts_per_row = col_counts_per_row.viewer().name(\n                            \"col_counts_per_row\")] __device__(int i) mutable\n                       {\n                           auto row                = unique_indices(i);\n                           col_counts_per_row(row) = counts(i);\n                       });\n\n            // calculate the offsets\n            DeviceScan().ExclusiveSum(col_counts_per_row.data(),\n                                      dst_row_offsets.data(),\n                                      col_counts_per_row.size());\n        }\n\n        // Doublet -&gt; BCOO\n        void convert(const DeviceDoubletVector&lt;T, N&gt;&amp; from, DeviceBCOOVector&lt;T, N&gt;&amp; to)\n        {\n            to.reshape(from.count());\n            to.resize_doublets(from.doublet_count());\n            merge_sort_indices_and_segments(from, to);\n            make_unique_indices(from, to);\n            make_unique_segments(from, to);\n        }\n\n        void merge_sort_indices_and_segments(const DeviceDoubletVector&lt;T, N&gt;&amp; from,\n                                             DeviceBCOOVector&lt;T, N&gt;&amp; to)\n        {\n            using namespace muda;\n\n            auto&amp; indices = sort_index;  // alias sort_index to index\n\n            // copy as temp\n            indices       = from.m_indices;\n            temp_segments = from.m_values;\n\n            DeviceMergeSort().SortPairs(indices.data(),\n                                        temp_segments.data(),\n                                        indices.size(),\n                                        [] __device__(const int&amp; a, const int&amp; b)\n                                        { return a &lt; b; });\n        }\n\n        void make_unique_indices(const DeviceDoubletVector&lt;T, N&gt;&amp; from,\n                                 DeviceBCOOVector&lt;T, N&gt;&amp;          to)\n        {\n            using namespace muda;\n\n            auto&amp; indices        = sort_index;  // alias sort_index to index\n            auto&amp; unique_indices = to.m_indices;\n\n            loose_resize(unique_indices, indices.size());\n            loose_resize(unique_counts, indices.size());\n\n            DeviceRunLengthEncode().Encode(indices.data(),\n                                           unique_indices.data(),\n                                           unique_counts.data(),\n                                           count.data(),\n                                           indices.size());\n\n            int h_count = count;\n\n            unique_indices.resize(h_count);\n            unique_counts.resize(h_count);\n\n            loose_resize(offsets, unique_counts.size() + 1);\n\n            DeviceScan().ExclusiveSum(\n                unique_counts.data(), offsets.data(), unique_counts.size());\n\n            // calculate the offset_ends, and set to the unique_counts\n\n            // auto&amp; begin_offset = offsets;\n\n            Launch()\n                .file_line(__FILE__, __LINE__)\n                .apply([offset = offsets.viewer().name(\"offset\"),\n                        count  = unique_counts.cviewer().name(\"counts\"),\n                        last   = unique_counts.size() - 1] __device__() mutable\n                       { offset(last + 1) = offset(last) + count(last); });\n        }\n\n        void make_unique_segments(const DeviceDoubletVector&lt;T, N&gt;&amp; from,\n                                  DeviceBCOOVector&lt;T, N&gt;&amp;          to)\n        {\n            using namespace muda;\n\n            auto&amp; begin_offset = offsets;\n            // auto&amp; end_offset   = unique_counts;\n\n            auto&amp; unique_indices  = to.m_indices;\n            auto&amp; unique_segments = to.m_values;\n\n            unique_segments.resize(unique_indices.size());\n\n            DeviceSegmentedReduce().Reduce(\n                temp_segments.data(),\n                unique_segments.data(),\n                unique_segments.size(),\n                begin_offset.data(),\n                begin_offset.data() + 1,\n                [] __host__ __device__(const VectorValueT&amp; a, const VectorValueT&amp; b) -&gt; VectorValueT\n                { return a + b; },\n                VectorValueTZero());\n        }\n\n\n        // BCOO -&gt; Dense Vector\n        void convert(const DeviceBCOOVector&lt;T, N&gt;&amp; from,\n                     DeviceDenseVector&lt;T&gt;&amp;         to,\n                     bool                          clear_dense_vector = true)\n        {\n            to.resize(N * from.count());\n            set_unique_values_to_dense_vector(from, to, clear_dense_vector);\n        }\n\n        void set_unique_values_to_dense_vector(const DeviceBCOOVector&lt;T, N&gt;&amp; from,\n                                               DeviceDenseVector&lt;T&gt;&amp; to,\n                                               bool clear_dense_vector)\n        {\n            using namespace muda;\n\n            if(clear_dense_vector)\n                to.fill(0);\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(from.non_zeros(),\n                       [unique_values = from.m_values.cviewer().name(\"unique_segments\"),\n                        unique_indices = from.m_indices.cviewer().name(\"unique_indices\"),\n                        dst = to.viewer().name(\"dst_dense_vector\")] __device__(int i) mutable\n                       {\n                           auto index = unique_indices(i);\n\n                           if constexpr(N == 1)\n                           {\n                               dst(index) += unique_values(i);\n                           }\n                           else\n                           {\n                               dst.segment&lt;N&gt;(index * N).as_eigen() += unique_values(i);\n                           }\n                       });\n        }\n\n\n        // Triplet -&gt; Dense Vector\n        void convert(const DeviceDoubletVector&lt;T, N&gt;&amp; from,\n                     DeviceDenseVector&lt;T&gt;&amp;            to,\n                     bool                             clear_dense_vector = true)\n        {\n            using namespace muda;\n\n            to.resize(N * from.count());\n\n            if(clear_dense_vector)\n                to.fill(0);\n\n            ParallelFor()\n                .file_line(__FILE__, __LINE__)\n                .apply(from.doublet_count(),\n                       [src = from.viewer().name(\"src_sparse_vector\"),\n                        dst = to.viewer().name(\"dst_dense_vector\")] __device__(int i) mutable\n                       {\n                           auto&amp;&amp; [index, value] = src(i);\n                           dst.segment&lt;N&gt;(index * N).atomic_add(value);\n                       });\n        }\n\n        void bsr2csr(cusparseHandle_t         handle,\n                     int                      mb,\n                     int                      nb,\n                     int                      blockDim,\n                     cusparseMatDescr_t       descrA,\n                     const T*                 bsrValA,\n                     const int*               bsrRowPtrA,\n                     const int*               bsrColIndA,\n                     int                      nnzb,\n                     DeviceCSRMatrix&lt;T&gt;&amp;      to,\n                     muda::DeviceBuffer&lt;int&gt;&amp; row_offsets,\n                     muda::DeviceBuffer&lt;int&gt;&amp; col_indices,\n                     muda::DeviceBuffer&lt;T&gt;&amp;   values)\n        {\n            using namespace muda;\n            cusparseDirection_t dir = CUSPARSE_DIRECTION_COLUMN;\n            int                 m   = mb * blockDim;\n            int nnz = nnzb * blockDim * blockDim;  // number of elements\n            to.reshape(m, m);\n            col_indices.resize(nnz);\n            values.resize(nnz);\n\n            if constexpr(std::is_same_v&lt;T, float&gt;)\n            {\n                checkCudaErrors(cusparseSbsr2csr(handle,\n                                                 dir,\n                                                 mb,\n                                                 nb,\n                                                 descrA,\n                                                 bsrValA,\n                                                 bsrRowPtrA,\n                                                 bsrColIndA,\n                                                 blockDim,\n                                                 to.legacy_descr(),\n                                                 values.data(),\n                                                 row_offsets.data(),\n                                                 col_indices.data()));\n            }\n\n            else if constexpr(std::is_same_v&lt;T, double&gt;)\n            {\n                checkCudaErrors(cusparseDbsr2csr(handle,\n                                                 dir,\n                                                 mb,\n                                                 nb,\n                                                 descrA,\n                                                 bsrValA,\n                                                 bsrRowPtrA,\n                                                 bsrColIndA,\n                                                 blockDim,\n                                                 to.legacy_descr(),\n                                                 values.data(),\n                                                 row_offsets.data(),\n                                                 col_indices.data()));\n            }\n        }\n\n        // BSR -&gt; CSR\n        void convert(const DeviceBSRMatrix&lt;T, N&gt;&amp; from, DeviceCSRMatrix&lt;T&gt;&amp; to)\n            MUDA_REQUIRES(N &gt; 1)\n        {\n            static_assert(N &gt; 1, \"N must be greater than 1\");\n            using namespace muda;\n\n            bsr2csr(cusparse(),\n                    from.rows(),\n                    from.cols(),\n                    N,\n                    from.legacy_descr(),\n                    (const T*)from.m_values.data(),\n                    from.m_row_offsets.data(),\n                    from.m_col_indices.data(),\n                    from.non_zeros(),\n                    to,\n                    to.m_row_offsets,\n                    to.m_col_indices,\n                    to.m_values);\n        }\n    };\n}  // namespace details\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_409feac54749c96b1f5e03ed3e08c376/","title":"Dir src/muda/ext/linear_system/type_mapper","text":"<p>FileList &gt; ext &gt; linear_system &gt; type_mapper</p>"},{"location":"muda/dir_409feac54749c96b1f5e03ed3e08c376/#files","title":"Files","text":"Type Name file algo_mapper.h file data_type_mapper.h <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/type_mapper/</code></p>"},{"location":"muda/algo__mapper_8h/","title":"File algo_mapper.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; type_mapper &gt; algo_mapper.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cublas_v2.h&gt;</code></li> <li><code>#include &lt;cusparse_v2.h&gt;</code></li> <li><code>#include &lt;muda/type_traits/always.h&gt;</code></li> </ul>"},{"location":"muda/algo__mapper_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/algo__mapper_8h/#classes","title":"Classes","text":"Type Name class LinearSystemAlgorithm <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/type_mapper/algo_mapper.h</code></p>"},{"location":"muda/algo__mapper_8h_source/","title":"File algo_mapper.h","text":"<p>File List &gt; ext &gt; linear_system &gt; type_mapper &gt; algo_mapper.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cublas_v2.h&gt;\n#include &lt;cusparse_v2.h&gt;\n#include &lt;muda/type_traits/always.h&gt;\nnamespace muda\n{\nclass LinearSystemAlgorithm\n{\n  public:\n    // convert for compatibility\n    constexpr static cusparseSpMVAlg_t SPMV_ALG_DEFAULT = (cusparseSpMVAlg_t)0;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/data__type__mapper_8h/","title":"File data_type_mapper.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; type_mapper &gt; data_type_mapper.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cublas_v2.h&gt;</code></li> <li><code>#include &lt;cusparse_v2.h&gt;</code></li> <li><code>#include &lt;muda/type_traits/always.h&gt;</code></li> </ul>"},{"location":"muda/data__type__mapper_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/type_mapper/data_type_mapper.h</code></p>"},{"location":"muda/data__type__mapper_8h_source/","title":"File data_type_mapper.h","text":"<p>File List &gt; ext &gt; linear_system &gt; type_mapper &gt; data_type_mapper.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cublas_v2.h&gt;\n#include &lt;cusparse_v2.h&gt;\n#include &lt;muda/type_traits/always.h&gt;\nnamespace muda\n{\ntemplate &lt;typename T&gt;\ninline constexpr cudaDataType_t cuda_data_type()\n{\n    if constexpr(std::is_same_v&lt;T, float&gt;)\n    {\n        return CUDA_R_32F;\n    }\n    else if constexpr(std::is_same_v&lt;T, double&gt;)\n    {\n        return CUDA_R_64F;\n    }\n    else if constexpr(std::is_same_v&lt;T, cuComplex&gt;)\n    {\n        return CUDA_C_32F;\n    }\n    else if constexpr(std::is_same_v&lt;T, cuDoubleComplex&gt;)\n    {\n        return CUDA_C_64F;\n    }\n    else\n    {\n        static_assert(always_false_v&lt;T&gt;, \"not supported type\");\n    }\n}\n\nconstexpr cublasOperation_t cublas_trans_operation(bool b)\n{\n    return b ? CUBLAS_OP_T : CUBLAS_OP_N;\n}\n\ntemplate &lt;typename T&gt;\nconstexpr cusparseIndexType_t cusparse_index_type()\n{\n    if constexpr(std::is_same_v&lt;T, int&gt;)\n        return cusparseIndexType_t::CUSPARSE_INDEX_32I;\n    else if constexpr(std::is_same_v&lt;T, int64_t&gt;)\n        return cusparseIndexType_t::CUSPARSE_INDEX_64I;\n    else if constexpr(std::is_same_v&lt;T, uint16_t&gt;)\n        return cusparseIndexType_t::CUSPARSE_INDEX_16U;\n    else\n        static_assert(always_false_v&lt;T&gt;, \"Unsupported type\");\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/triplet__matrix__view_8h/","title":"File triplet_matrix_view.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; triplet_matrix_view.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/buffer/buffer_view.h&gt;</code></li> <li><code>#include &lt;muda/ext/linear_system/triplet_matrix_viewer.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> <li><code>#include \"details/triplet_matrix_view.inl\"</code></li> </ul>"},{"location":"muda/triplet__matrix__view_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/triplet__matrix__view_8h/#classes","title":"Classes","text":"Type Name class TripletMatrixViewT &lt;IsConst, typename Ty, N&gt; class TripletMatrixViewT &lt;IsConst, typename Ty, N&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/triplet_matrix_view.h</code></p>"},{"location":"muda/triplet__matrix__view_8h_source/","title":"File triplet_matrix_view.h","text":"<p>File List &gt; ext &gt; linear_system &gt; triplet_matrix_view.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/buffer/buffer_view.h&gt;\n#include &lt;muda/ext/linear_system/triplet_matrix_viewer.h&gt;\n#include &lt;muda/view/view_base.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename Ty, int N&gt;\nclass TripletMatrixViewT : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U, int M&gt;\n    friend class TripletMatrixViewT;\n\n  public:\n    static_assert(!std::is_const_v&lt;Ty&gt;, \"Ty must be non-const\");\n    using ConstView    = TripletMatrixViewT&lt;true, Ty, N&gt;;\n    using NonConstView = TripletMatrixViewT&lt;false, Ty, N&gt;;\n    using ThisView     = TripletMatrixViewT&lt;IsConst, Ty, N&gt;;\n\n  private:\n    using ConstViewer    = CTripletMatrixViewer&lt;Ty, N&gt;;\n    using NonConstViewer = TripletMatrixViewer&lt;Ty, N&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n\n  public:\n    using BlockMatrix = Eigen::Matrix&lt;Ty, N, N&gt;;\n\n  protected:\n    // matrix info\n    int m_total_block_rows = 0;\n    int m_total_block_cols = 0;\n\n    // triplet info\n    int m_triplet_index_offset = 0;\n    int m_triplet_count        = 0;\n    int m_total_triplet_count  = 0;\n\n    // sub matrix info\n    int2 m_submatrix_offset = {0, 0};\n    int2 m_submatrix_extent = {0, 0};\n\n    // data\n    auto_const_t&lt;int&gt;*         m_block_row_indices = nullptr;\n    auto_const_t&lt;int&gt;*         m_block_col_indices = nullptr;\n    auto_const_t&lt;BlockMatrix&gt;* m_block_values      = nullptr;\n\n  public:\n    MUDA_GENERIC TripletMatrixViewT() = default;\n    MUDA_GENERIC TripletMatrixViewT(int total_block_rows,\n                                    int total_block_cols,\n\n                                    int triplet_index_offset,\n                                    int triplet_count,\n                                    int total_triplet_count,\n\n                                    int2 submatrix_offset,\n                                    int2 submatrix_extent,\n\n                                    auto_const_t&lt;int&gt;* block_row_indices,\n                                    auto_const_t&lt;int&gt;* block_col_indices,\n                                    auto_const_t&lt;BlockMatrix&gt;* block_values)\n        : m_total_block_rows(total_block_rows)\n        , m_total_block_cols(total_block_cols)\n        , m_triplet_index_offset(triplet_index_offset)\n        , m_triplet_count(triplet_count)\n        , m_total_triplet_count(total_triplet_count)\n        , m_block_row_indices(block_row_indices)\n        , m_block_col_indices(block_col_indices)\n        , m_block_values(block_values)\n        , m_submatrix_offset(submatrix_offset)\n        , m_submatrix_extent(submatrix_extent)\n    {\n        MUDA_KERNEL_ASSERT(triplet_index_offset + triplet_count &lt;= total_triplet_count,\n                           \"TripletMatrixView: out of range, m_total_triplet_count=%d, \"\n                           \"your triplet_index_offset=%d, triplet_count=%d\",\n                           total_triplet_count,\n                           triplet_index_offset,\n                           triplet_count);\n\n        MUDA_KERNEL_ASSERT(submatrix_offset.x &gt;= 0 &amp;&amp; submatrix_offset.y &gt;= 0,\n                           \"TripletMatrixView: submatrix_offset is out of range, submatrix_offset.x=%d, submatrix_offset.y=%d\",\n                           submatrix_offset.x,\n                           submatrix_offset.y);\n\n        MUDA_KERNEL_ASSERT(submatrix_offset.x + submatrix_extent.x &lt;= total_block_rows,\n                           \"TripletMatrixView: submatrix is out of range, submatrix_offset.x=%d, submatrix_extent.x=%d, total_block_rows=%d\",\n                           submatrix_offset.x,\n                           submatrix_extent.x,\n                           total_block_rows);\n\n        MUDA_KERNEL_ASSERT(submatrix_offset.y + submatrix_extent.y &lt;= total_block_cols,\n                           \"TripletMatrixView: submatrix is out of range, submatrix_offset.y=%d, submatrix_extent.y=%d, total_block_cols=%d\",\n                           submatrix_offset.y,\n                           submatrix_extent.y,\n                           total_block_cols);\n    }\n\n    MUDA_GENERIC TripletMatrixViewT(int                total_block_rows,\n                                    int                total_block_cols,\n                                    int                total_triplet_count,\n                                    auto_const_t&lt;int&gt;* block_row_indices,\n                                    auto_const_t&lt;int&gt;* block_col_indices,\n                                    auto_const_t&lt;BlockMatrix&gt;* block_values)\n        : TripletMatrixViewT(total_block_rows,\n                             total_block_cols,\n                             0,\n                             total_triplet_count,\n                             total_triplet_count,\n                             {0, 0},\n                             {total_block_rows, total_block_cols},\n                             block_row_indices,\n                             block_col_indices,\n                             block_values)\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC TripletMatrixViewT(const TripletMatrixViewT&lt;OtherIsConst, Ty, N&gt;&amp; other) MUDA_NOEXCEPT\n        MUDA_REQUIRES(IsConst)\n        : m_total_block_rows(other.m_total_block_rows)\n        , m_total_block_cols(other.m_total_block_cols)\n        , m_triplet_index_offset(other.m_triplet_index_offset)\n        , m_triplet_count(other.m_triplet_count)\n        , m_total_triplet_count(other.m_total_triplet_count)\n        , m_submatrix_offset(other.m_submatrix_offset)\n        , m_submatrix_extent(other.m_submatrix_extent)\n        , m_block_row_indices(other.m_block_row_indices)\n        , m_block_col_indices(other.m_block_col_indices)\n        , m_block_values(other.m_block_values)\n    {\n        static_assert(IsConst);\n    }\n\n    MUDA_GENERIC ConstView as_const() const\n    {\n        return ConstView{m_total_block_rows,\n                         m_total_block_cols,\n                         m_triplet_index_offset,\n                         m_triplet_count,\n                         m_total_triplet_count,\n                         m_submatrix_offset,\n                         m_submatrix_extent,\n                         m_block_row_indices,\n                         m_block_col_indices,\n                         m_block_values};\n    }\n\n    MUDA_GENERIC auto subview(int offset, int count) const\n    {\n        MUDA_ASSERT(offset + count &lt;= m_triplet_count,\n                    \"TripletMatrixView: offset is out of range, size=%d, your offset=%d, your count=%d\",\n                    m_triplet_count,\n                    offset,\n                    count);\n\n        return ThisView{m_total_block_rows,\n                        m_total_block_cols,\n                        m_triplet_index_offset + offset,\n                        count,\n                        m_total_triplet_count,\n                        m_submatrix_offset,\n                        m_submatrix_extent,\n                        m_block_row_indices,\n                        m_block_col_indices,\n                        m_block_values};\n    }\n\n    MUDA_GENERIC auto subview(int offset) const\n    {\n        return subview(offset, m_triplet_count - offset);\n    }\n\n    MUDA_GENERIC auto cviewer() const\n    {\n        return ConstViewer{m_total_block_rows,\n                           m_total_block_cols,\n                           m_triplet_index_offset,\n                           m_triplet_count,\n                           m_total_triplet_count,\n                           m_submatrix_offset,\n                           m_submatrix_extent,\n                           m_block_row_indices,\n                           m_block_col_indices,\n                           m_block_values};\n    }\n\n    MUDA_GENERIC auto viewer() const\n    {\n        return ThisViewer{m_total_block_rows,\n                          m_total_block_cols,\n                          m_triplet_index_offset,\n                          m_triplet_count,\n                          m_total_triplet_count,\n                          m_submatrix_offset,\n                          m_submatrix_extent,\n                          m_block_row_indices,\n                          m_block_col_indices,\n                          m_block_values};\n    }\n\n    MUDA_GENERIC auto submatrix(int2 offset, int2 extent) const\n    {\n        MUDA_KERNEL_ASSERT(offset.x &gt;= 0 &amp;&amp; offset.y &gt;= 0,\n                           \"TripletMatrixView: submatrix is out of range, offset=(%d, %d)\",\n                           offset.x,\n                           offset.y);\n\n        MUDA_KERNEL_ASSERT(offset.x + extent.x &lt;= m_submatrix_extent.x\n                               &amp;&amp; offset.y + extent.y &lt;= m_submatrix_extent.y,\n                           \"TripletMatrixView: submatrix is out of range, offset=(%d, %d), extent=(%d, %d), origin offset=(%d,%d), extent(%d,%d).\",\n                           offset.x,\n                           offset.y,\n                           extent.x,\n                           extent.y,\n                           m_submatrix_offset.x,\n                           m_submatrix_offset.y,\n                           m_submatrix_extent.x,\n                           m_submatrix_extent.y);\n\n        return ThisView{m_total_block_rows,\n                        m_total_block_cols,\n                        m_triplet_index_offset,\n                        m_triplet_count,\n                        m_total_triplet_count,\n                        m_submatrix_offset + offset,\n                        extent,\n                        m_block_row_indices,\n                        m_block_col_indices,\n                        m_block_values};\n    }\n\n    MUDA_GENERIC auto total_block_rows() const { return m_total_block_rows; }\n    MUDA_GENERIC auto total_block_cols() const { return m_total_block_cols; }\n    MUDA_GENERIC auto total_extent() const\n    {\n        return int2{m_total_block_rows, m_total_block_cols};\n    }\n\n    MUDA_GENERIC auto submatrix_offset() const { return m_submatrix_offset; }\n    MUDA_GENERIC auto extent() const { return m_submatrix_extent; }\n\n    MUDA_GENERIC auto triplet_count() const { return m_triplet_count; }\n    MUDA_GENERIC auto tripet_index_offset() const\n    {\n        return m_triplet_index_offset;\n    }\n    MUDA_GENERIC auto total_triplet_count() const\n    {\n        return m_total_triplet_count;\n    }\n};\n\ntemplate &lt;bool IsConst, typename Ty&gt;\nclass TripletMatrixViewT&lt;IsConst, Ty, 1&gt; : public ViewBase&lt;IsConst&gt;\n{\n    using Base = ViewBase&lt;IsConst&gt;;\n\n  protected:\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U, int M&gt;\n    friend class TripletMatrixViewT;\n\n  public:\n    static_assert(!std::is_const_v&lt;Ty&gt;, \"Ty must be non-const\");\n    using ConstView    = TripletMatrixViewT&lt;true, Ty, 1&gt;;\n    using NonConstView = TripletMatrixViewT&lt;false, Ty, 1&gt;;\n    using ThisView     = TripletMatrixViewT&lt;IsConst, Ty, 1&gt;;\n\n  private:\n    using ConstViewer    = CTripletMatrixViewer&lt;Ty, 1&gt;;\n    using NonConstViewer = TripletMatrixViewer&lt;Ty, 1&gt;;\n    using ThisViewer = std::conditional_t&lt;IsConst, ConstViewer, NonConstViewer&gt;;\n\n  protected:\n    // matrix info\n    int m_total_rows = 0;\n    int m_total_cols = 0;\n\n    // triplet info\n    int m_triplet_index_offset = 0;\n    int m_triplet_count        = 0;\n    int m_total_triplet_count  = 0;\n\n    // sub matrix info\n    int2 m_submatrix_offset = {0, 0};\n    int2 m_submatrix_extent = {0, 0};\n\n    // data\n    auto_const_t&lt;int&gt;* m_row_indices;\n    auto_const_t&lt;int&gt;* m_col_indices;\n    auto_const_t&lt;Ty&gt;*  m_values;\n\n\n  public:\n    MUDA_GENERIC TripletMatrixViewT() = default;\n\n    MUDA_GENERIC TripletMatrixViewT(int total_rows,\n                                    int total_cols,\n                                    int triplet_index_offset,\n                                    int triplet_count,\n                                    int total_triplet_count,\n\n                                    int2 submatrix_offset,\n                                    int2 submatrix_extent,\n\n                                    auto_const_t&lt;int&gt;* row_indices,\n                                    auto_const_t&lt;int&gt;* col_indices,\n                                    auto_const_t&lt;Ty&gt;*  values)\n        : m_total_rows(total_rows)\n        , m_total_cols(total_cols)\n        , m_triplet_index_offset(triplet_index_offset)\n        , m_triplet_count(triplet_count)\n        , m_total_triplet_count(total_triplet_count)\n        , m_submatrix_offset(submatrix_offset)\n        , m_submatrix_extent(submatrix_extent)\n        , m_row_indices(row_indices)\n        , m_col_indices(col_indices)\n        , m_values(values)\n    {\n        MUDA_KERNEL_ASSERT(triplet_index_offset + triplet_count &lt;= total_triplet_count,\n                           \"TripletMatrixView: out of range, m_total_triplet_count=%d, \"\n                           \"your triplet_index_offset=%d, triplet_count=%d\",\n                           total_triplet_count,\n                           triplet_index_offset,\n                           triplet_count);\n\n        MUDA_KERNEL_ASSERT(submatrix_offset.x &gt;= 0 &amp;&amp; submatrix_offset.y &gt;= 0,\n                           \"TripletMatrixView: submatrix_offset is out of range, submatrix_offset.x=%d, submatrix_offset.y=%d\",\n                           submatrix_offset.x,\n                           submatrix_offset.y);\n\n        MUDA_KERNEL_ASSERT(submatrix_offset.x + submatrix_extent.x &lt;= total_rows,\n                           \"TripletMatrixView: submatrix is out of range, submatrix_offset.x=%d, submatrix_extent.x=%d, total_rows=%d\",\n                           submatrix_offset.x,\n                           submatrix_extent.x,\n                           total_rows);\n\n        MUDA_KERNEL_ASSERT(submatrix_offset.y + submatrix_extent.y &lt;= total_cols,\n                           \"TripletMatrixView: submatrix is out of range, submatrix_offset.y=%d, submatrix_extent.y=%d, total_cols=%d\",\n                           submatrix_offset.y,\n                           submatrix_extent.y,\n                           total_cols);\n    }\n\n    MUDA_GENERIC TripletMatrixViewT(int                total_rows,\n                                    int                total_cols,\n                                    int                total_triplet_count,\n                                    auto_const_t&lt;int&gt;* row_indices,\n                                    auto_const_t&lt;int&gt;* col_indices,\n                                    auto_const_t&lt;Ty&gt;*  values)\n        : TripletMatrixViewT(total_rows,\n                             total_cols,\n                             0,\n                             total_triplet_count,\n                             total_triplet_count,\n                             {0, 0},\n                             {total_rows, total_cols},\n                             row_indices,\n                             col_indices,\n                             values)\n    {\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC TripletMatrixViewT(const TripletMatrixViewT&lt;OtherIsConst, Ty, 1&gt;&amp; other) MUDA_NOEXCEPT\n        MUDA_REQUIRES(IsConst)\n        : m_total_rows(other.m_total_rows)\n        , m_total_cols(other.m_total_cols)\n        , m_triplet_index_offset(other.m_triplet_index_offset)\n        , m_triplet_count(other.m_triplet_count)\n        , m_total_triplet_count(other.m_total_triplet_count)\n        , m_submatrix_offset(other.m_submatrix_offset)\n        , m_submatrix_extent(other.m_submatrix_extent)\n        , m_row_indices(other.m_row_indices)\n        , m_col_indices(other.m_col_indices)\n        , m_values(other.m_values)\n    {\n        static_assert(IsConst);\n    }\n\n    MUDA_GENERIC ConstView as_const() const\n    {\n        return ConstView{m_total_rows,\n                         m_total_cols,\n                         m_triplet_index_offset,\n                         m_triplet_count,\n                         m_total_triplet_count,\n                         m_submatrix_offset,\n                         m_submatrix_extent,\n                         m_row_indices,\n                         m_col_indices,\n                         m_values};\n    }\n\n    MUDA_GENERIC auto subview(int offset, int count) const\n    {\n        MUDA_ASSERT(offset + count &lt;= m_triplet_count,\n                    \"TripletMatrixView: offset is out of range, size=%d, your offset=%d, your count=%d\",\n                    m_triplet_count,\n                    offset,\n                    count);\n\n        return ThisView{m_total_rows,\n                        m_total_cols,\n                        m_triplet_index_offset + offset,\n                        count,\n                        m_total_triplet_count,\n                        m_submatrix_offset,\n                        m_submatrix_extent,\n                        m_row_indices,\n                        m_col_indices,\n                        m_values};\n    }\n\n    MUDA_GENERIC auto submatrix(int2 offset, int2 extent) const\n    {\n        MUDA_KERNEL_ASSERT(offset.x &gt;= 0 &amp;&amp; offset.y &gt;= 0,\n                           \"TripletMatrixView: submatrix is out of range, submatrix_offset.x=%d, submatrix_offset.y=%d\",\n                           offset.x,\n                           offset.y);\n\n        MUDA_KERNEL_ASSERT(offset.x + extent.x &lt;= m_submatrix_extent.x\n                               &amp;&amp; offset.y + extent.y &lt;= m_submatrix_extent.y,\n                           \"TripletMatrixView: submatrix is out of range, submatrix_offset.x=%d, submatrix_extent.x=%d, submatrix_offset.y=%d, submatrix_extent.y=%d\",\n                           offset.x,\n                           m_submatrix_extent.x,\n                           offset.y,\n                           m_submatrix_extent.y);\n\n        return ThisView{m_total_rows,\n                        m_total_cols,\n                        m_triplet_index_offset,\n                        m_triplet_count,\n                        m_total_triplet_count,\n                        m_submatrix_offset + offset,\n                        extent,\n                        m_row_indices,\n                        m_col_indices,\n                        m_values};\n    }\n\n    MUDA_GENERIC auto subview(int offset) const\n    {\n        return subview(offset, m_triplet_count - offset);\n    }\n\n    MUDA_GENERIC auto cviewer() const\n    {\n        return ConstViewer{m_total_rows,\n                           m_total_cols,\n                           m_triplet_index_offset,\n                           m_triplet_count,\n                           m_total_triplet_count,\n                           m_submatrix_offset,\n                           m_submatrix_extent,\n                           m_row_indices,\n                           m_col_indices,\n                           m_values};\n    }\n\n    MUDA_GENERIC auto viewer() const\n    {\n        return ThisViewer{m_total_rows,\n                          m_total_cols,\n                          m_triplet_index_offset,\n                          m_triplet_count,\n                          m_total_triplet_count,\n                          m_submatrix_offset,\n                          m_submatrix_extent,\n                          m_row_indices,\n                          m_col_indices,\n                          m_values};\n    }\n\n    MUDA_GENERIC auto values() const { return m_values; }\n    MUDA_GENERIC auto row_indices() const { return m_row_indices; }\n    MUDA_GENERIC auto col_indices() const { return m_col_indices; }\n\n    MUDA_GENERIC auto total_rows() const { return m_total_rows; }\n    MUDA_GENERIC auto total_cols() const { return m_total_cols; }\n\n    MUDA_GENERIC auto triplet_count() const { return m_triplet_count; }\n    MUDA_GENERIC auto tripet_index_offset() const\n    {\n        return m_triplet_index_offset;\n    }\n    MUDA_GENERIC auto total_triplet_count() const\n    {\n        return m_total_triplet_count;\n    }\n\n    MUDA_GENERIC auto submatrix_offset() const { return m_submatrix_offset; }\n    MUDA_GENERIC auto extent() const { return m_submatrix_extent; }\n    MUDA_GENERIC auto total_extent() const\n    {\n        return int2{m_total_rows, m_total_cols};\n    }\n};\n\ntemplate &lt;typename Ty, int N&gt;\nusing TripletMatrixView = TripletMatrixViewT&lt;false, Ty, N&gt;;\ntemplate &lt;typename Ty, int N&gt;\nusing CTripletMatrixView = TripletMatrixViewT&lt;true, Ty, N&gt;;\n}  // namespace muda\n\nnamespace muda\n{\ntemplate &lt;typename Ty, int N&gt;\nstruct read_only_view&lt;TripletMatrixView&lt;Ty, N&gt;&gt;\n{\n    using type = CTripletMatrixView&lt;Ty, N&gt;;\n};\n\ntemplate &lt;typename Ty, int N&gt;\nstruct read_write_view&lt;TripletMatrixView&lt;Ty, N&gt;&gt;\n{\n    using type = TripletMatrixView&lt;Ty, N&gt;;\n};\n}  // namespace muda\n\n\n#include \"details/triplet_matrix_view.inl\"\n</code></pre>"},{"location":"muda/triplet__matrix__viewer_8h/","title":"File triplet_matrix_viewer.h","text":"<p>FileList &gt; ext &gt; linear_system &gt; triplet_matrix_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_buffer.h&gt;</code></li> <li><code>#include &lt;muda/tools/cuda_vec_utils.h&gt;</code></li> <li><code>#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;</code></li> <li><code>#include \"details/triplet_matrix_viewer.inl\"</code></li> </ul>"},{"location":"muda/triplet__matrix__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/triplet__matrix__viewer_8h/#classes","title":"Classes","text":"Type Name class TripletMatrixViewerT &lt;IsConst, typename T, N&gt; struct CTriplet class Proxy <p>The documentation for this class was generated from the following file <code>src/muda/ext/linear_system/triplet_matrix_viewer.h</code></p>"},{"location":"muda/triplet__matrix__viewer_8h_source/","title":"File triplet_matrix_viewer.h","text":"<p>File List &gt; ext &gt; linear_system &gt; triplet_matrix_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;muda/viewer/viewer_base.h&gt;\n#include &lt;muda/buffer/device_buffer.h&gt;\n#include &lt;muda/tools/cuda_vec_utils.h&gt;\n#include &lt;muda/ext/eigen/eigen_core_cxx20.h&gt;\n\n\n/*\n* - 2024/2/23 remove viewer's subview, view's subview is enough\n*/\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T, int N&gt;\nclass TripletMatrixViewerT : public ViewerBase&lt;IsConst&gt;\n{\n    using Base = ViewerBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    template &lt;bool OtherIsConst, typename U, int M&gt;\n    friend class TripletMatrixViewerT;\n\n    MUDA_VIEWER_COMMON_NAME(TripletMatrixViewerT);\n\n  public:\n    using ValueT      = std::conditional_t&lt;N == 1, T, Eigen::Matrix&lt;T, N, N&gt;&gt;;\n    using ConstViewer = TripletMatrixViewerT&lt;true, T, N&gt;;\n    using NonConstViewer = TripletMatrixViewerT&lt;false, T, N&gt;;\n    using ThisViewer     = TripletMatrixViewerT&lt;IsConst, T, N&gt;;\n\n    struct CTriplet\n    {\n        MUDA_GENERIC CTriplet(int row_index, int col_index, const ValueT&amp; block)\n            : row_index(row_index)\n            , col_index(col_index)\n            , value(block)\n        {\n        }\n\n        int           row_index;\n        int           col_index;\n        const ValueT&amp; value;\n    };\n\n    class Proxy\n    {\n        friend class TripletMatrixViewerT;\n        const TripletMatrixViewerT&amp; m_viewer;\n        int                         m_index = 0;\n\n      private:\n        MUDA_GENERIC Proxy(const TripletMatrixViewerT&amp; viewer, int index)\n            : m_viewer(viewer)\n            , m_index(index)\n        {\n        }\n\n      public:\n        MUDA_GENERIC auto read() &amp;&amp; { return m_viewer.at(m_index); }\n\n        MUDA_GENERIC\n        void write(int row_index, int col_index, const ValueT&amp; block) &amp;&amp;\n        {\n            auto index = m_viewer.get_index(m_index);\n\n            m_viewer.check_in_submatrix(row_index, col_index);\n\n            auto global_i = m_viewer.m_submatrix_offset.x + row_index;\n            auto global_j = m_viewer.m_submatrix_offset.y + col_index;\n\n            m_viewer.m_row_indices[index] = global_i;\n            m_viewer.m_col_indices[index] = global_j;\n            m_viewer.m_values[index]      = block;\n        }\n\n        MUDA_GENERIC ~Proxy() = default;\n    };\n\n  protected:\n    // matrix info\n    int m_total_rows = 0;\n    int m_total_cols = 0;\n\n    // triplet info\n    int m_triplet_index_offset = 0;\n    int m_triplet_count        = 0;\n    int m_total_triplet_count  = 0;\n\n    // sub matrix info\n    int2 m_submatrix_offset = {0, 0};\n    int2 m_submatrix_extent = {0, 0};\n\n    // data\n    auto_const_t&lt;int&gt;*    m_row_indices;\n    auto_const_t&lt;int&gt;*    m_col_indices;\n    auto_const_t&lt;ValueT&gt;* m_values;\n\n\n  public:\n    MUDA_GENERIC TripletMatrixViewerT() = default;\n\n    MUDA_GENERIC TripletMatrixViewerT(int total_block_rows,\n                                      int total_block_cols,\n                                      int triplet_index_offset,\n                                      int triplet_count,\n                                      int total_triplet_count,\n\n                                      int2 submatrix_offset,\n                                      int2 submatrix_extent,\n\n                                      auto_const_t&lt;int&gt;*    block_row_indices,\n                                      auto_const_t&lt;int&gt;*    block_col_indices,\n                                      auto_const_t&lt;ValueT&gt;* block_values)\n        : m_total_rows(total_block_rows)\n        , m_total_cols(total_block_cols)\n        , m_triplet_index_offset(triplet_index_offset)\n        , m_triplet_count(triplet_count)\n        , m_total_triplet_count(total_triplet_count)\n        , m_submatrix_offset(submatrix_offset)\n        , m_submatrix_extent(submatrix_extent)\n        , m_row_indices(block_row_indices)\n        , m_col_indices(block_col_indices)\n        , m_values(block_values)\n    {\n        MUDA_ASSERT(triplet_index_offset + triplet_count &lt;= total_triplet_count,\n                    \"TripletMatrixViewer [%s:%s]: out of range, m_total_triplet_count=%d, \"\n                    \"your triplet_index_offset=%d, triplet_count=%d. %s(%d)\",\n                    this-&gt;name(),\n                    this-&gt;kernel_name(),\n                    total_triplet_count,\n                    triplet_index_offset,\n                    triplet_count,\n                    this-&gt;kernel_file(),\n                    this-&gt;kernel_line());\n\n        MUDA_ASSERT(submatrix_offset.x &gt;= 0 &amp;&amp; submatrix_offset.y &gt;= 0,\n                    \"TripletMatrixViewer[%s:%s]: submatrix_offset is out of range, submatrix_offset.x=%d, submatrix_offset.y=%d. %s(%d)\",\n                    this-&gt;name(),\n                    this-&gt;kernel_name(),\n                    submatrix_offset.x,\n                    submatrix_offset.y,\n                    this-&gt;kernel_file(),\n                    this-&gt;kernel_line());\n\n        MUDA_ASSERT(submatrix_offset.x + submatrix_extent.x &lt;= total_block_rows,\n                    \"TripletMatrixViewer[%s:%s]: submatrix is out of range, submatrix_offset.x=%d, submatrix_extent.x=%d, total_block_rows=%d. %s(%d)\",\n                    this-&gt;name(),\n                    this-&gt;kernel_name(),\n                    submatrix_offset.x,\n                    submatrix_extent.x,\n                    total_block_rows,\n                    this-&gt;kernel_file(),\n                    this-&gt;kernel_line());\n\n        MUDA_ASSERT(submatrix_offset.y + submatrix_extent.y &lt;= total_block_cols,\n                    \"TripletMatrixViewer[%s:%s]: submatrix is out of range, submatrix_offset.y=%d, submatrix_extent.y=%d, total_block_cols=%d. %s(%d)\",\n                    this-&gt;name(),\n                    this-&gt;kernel_name(),\n                    submatrix_offset.y,\n                    submatrix_extent.y,\n                    total_block_cols,\n                    this-&gt;kernel_file(),\n                    this-&gt;kernel_line());\n    }\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC TripletMatrixViewerT(const TripletMatrixViewerT&lt;OtherIsConst, T, N&gt;&amp; other)\n        : m_total_rows(other.m_total_rows)\n        , m_total_cols(other.m_total_cols)\n        , m_triplet_index_offset(other.m_triplet_index_offset)\n        , m_triplet_count(other.m_triplet_count)\n        , m_total_triplet_count(other.m_total_triplet_count)\n        , m_submatrix_offset(other.m_submatrix_offset)\n        , m_submatrix_extent(other.m_submatrix_extent)\n        , m_row_indices(other.m_row_indices)\n        , m_col_indices(other.m_col_indices)\n        , m_values(other.m_values)\n    {\n    }\n\n    MUDA_GENERIC ConstViewer as_const() const\n    {\n        return ConstViewer{m_total_rows,\n                           m_total_cols,\n                           m_triplet_index_offset,\n                           m_triplet_count,\n                           m_total_triplet_count,\n                           m_submatrix_offset,\n                           m_submatrix_extent,\n                           m_row_indices,\n                           m_col_indices,\n                           m_values};\n    }\n\n    MUDA_GENERIC auto total_rows() const { return m_total_rows; }\n\n    MUDA_GENERIC auto total_cols() const { return m_total_cols; }\n\n    MUDA_GENERIC auto total_extent() const\n    {\n        return int2{m_total_rows, m_total_cols};\n    }\n\n    MUDA_GENERIC auto submatrix_offset() const { return m_submatrix_offset; }\n\n    MUDA_GENERIC auto extent() const { return m_submatrix_extent; }\n\n    MUDA_GENERIC auto triplet_count() const { return m_triplet_count; }\n\n    MUDA_GENERIC auto tripet_index_offset() const\n    {\n        return m_triplet_index_offset;\n    }\n    MUDA_GENERIC auto total_triplet_count() const\n    {\n        return m_total_triplet_count;\n    }\n\n    MUDA_GENERIC auto operator()(int i) const\n    {\n        if constexpr(IsConst)\n        {\n            return at(i);\n        }\n        else\n        {\n            return Proxy{*this, i};\n        }\n    }\n\n  protected:\n    MUDA_GENERIC MUDA_INLINE CTriplet at(int i) const noexcept\n    {\n        auto index    = get_index(i);\n        auto global_i = m_row_indices[index];\n        auto global_j = m_col_indices[index];\n        auto sub_i    = global_i - m_submatrix_offset.x;\n        auto sub_j    = global_j - m_submatrix_offset.y;\n        check_in_submatrix(sub_i, sub_j);\n        return CTriplet{sub_i, sub_j, m_values[index]};\n    }\n\n    MUDA_INLINE MUDA_GENERIC int get_index(int i) const noexcept\n    {\n\n        MUDA_KERNEL_ASSERT(i &gt;= 0 &amp;&amp; i &lt; m_triplet_count,\n                           \"TripletMatrixViewer [%s:%s]: triplet_index out of range, block_count=%d, your index=%d. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           m_triplet_count,\n                           i,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n        auto index = i + m_triplet_index_offset;\n        return index;\n    }\n\n    MUDA_INLINE MUDA_GENERIC void check_in_submatrix(int i, int j) const noexcept\n    {\n        MUDA_KERNEL_ASSERT(i &gt;= 0 &amp;&amp; i &lt; m_submatrix_extent.x,\n                           \"TripletMatrixViewer [%s:%s]: row index out of submatrix range,  submatrix_extent.x=%d, your i=%d. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           m_submatrix_extent.x,\n                           i,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n\n        MUDA_KERNEL_ASSERT(j &gt;= 0 &amp;&amp; j &lt; m_submatrix_extent.y,\n                           \"TripletMatrixViewer [%s:%s]: col index out of submatrix range,  submatrix_extent.y=%d, your j=%d. %s(%d)\",\n                           this-&gt;name(),\n                           this-&gt;kernel_name(),\n                           m_submatrix_extent.y,\n                           j,\n                           this-&gt;kernel_file(),\n                           this-&gt;kernel_line());\n    }\n};\n\ntemplate &lt;typename T, int N&gt;\nusing TripletMatrixViewer = TripletMatrixViewerT&lt;false, T, N&gt;;\n\ntemplate &lt;typename T, int N&gt;\nusing CTripletMatrixViewer = TripletMatrixViewerT&lt;true, T, N&gt;;\n}  // namespace muda\n\n#include \"details/triplet_matrix_viewer.inl\"\n</code></pre>"},{"location":"muda/dir_946c6946a1291bae853a7ff8b793a277/","title":"Dir src/muda/graph","text":"<p>FileList &gt; graph</p>"},{"location":"muda/dir_946c6946a1291bae853a7ff8b793a277/#files","title":"Files","text":"Type Name file event_node.h file graph.h file graph_base.h file graph_exec.h file graph_graph_viewer.h file graph_instantiate_flag.h file graph_launch.h file graph_viewer.h file host_node.h file kernel_node.h file memory_node.h <p>The documentation for this class was generated from the following file <code>src/muda/graph/</code></p>"},{"location":"muda/event__node_8h/","title":"File event_node.h","text":"<p>FileList &gt; graph &gt; event_node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/graph/graph_base.h&gt;</code></li> </ul>"},{"location":"muda/event__node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/event__node_8h/#classes","title":"Classes","text":"Type Name class EventRecordNode class EventWaitNode <p>The documentation for this class was generated from the following file <code>src/muda/graph/event_node.h</code></p>"},{"location":"muda/event__node_8h_source/","title":"File event_node.h","text":"<p>File List &gt; graph &gt; event_node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/graph/graph_base.h&gt;\n\nnamespace muda\n{\nclass EventRecordNode : public GraphNode\n{\n  public:\n    using this_type = EventRecordNode;\n    friend class Graph;\n};\n\nclass EventWaitNode : public GraphNode\n{\n  public:\n    using this_type = EventWaitNode;\n    friend class Graph;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/graph_2graph_8h/","title":"File graph.h","text":"<p>FileList &gt; graph &gt; graph.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;muda/graph/graph_base.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph_exec.h&gt;</code></li> <li><code>#include &lt;muda/graph/kernel_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/memory_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/host_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/event_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph_instantiate_flag.h&gt;</code></li> <li><code>#include \"details/graph.inl\"</code></li> </ul>"},{"location":"muda/graph_2graph_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph_2graph_8h/#classes","title":"Classes","text":"Type Name class Graph <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph.h</code></p>"},{"location":"muda/graph_2graph_8h_source/","title":"File graph.h","text":"<p>File List &gt; graph &gt; graph.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n\n#include &lt;muda/graph/graph_base.h&gt;\n#include &lt;muda/graph/graph_exec.h&gt;\n\n#include &lt;muda/graph/kernel_node.h&gt;\n#include &lt;muda/graph/memory_node.h&gt;\n#include &lt;muda/graph/host_node.h&gt;\n#include &lt;muda/graph/event_node.h&gt;\n\n#include &lt;muda/graph/graph_instantiate_flag.h&gt;\n\nnamespace muda\n{\nclass Graph\n{\n    template &lt;typename T&gt;\n    using S = std::shared_ptr&lt;T&gt;;\n    template &lt;typename T&gt;\n    using U = std::unique_ptr&lt;T&gt;;\n\n  public:\n    Graph();\n    ~Graph();\n\n    // delete copy\n    Graph(const Graph&amp;)            = delete;\n    Graph&amp; operator=(const Graph&amp;) = delete;\n\n    // move\n    Graph(Graph&amp;&amp;);\n    Graph&amp; operator=(Graph&amp;&amp;);\n\n\n    friend class GraphExec;\n    friend class std::shared_ptr&lt;Graph&gt;;\n\n    MUDA_NODISCARD S&lt;GraphExec&gt; instantiate();\n    MUDA_NODISCARD S&lt;GraphExec&gt; instantiate(Flags&lt;GraphInstantiateFlagBit&gt; flags);\n\n    template &lt;typename T&gt;\n    S&lt;KernelNode&gt; add_kernel_node(const S&lt;KernelNodeParms&lt;T&gt;&gt;&amp;     kernelParms,\n                                  const std::vector&lt;S&lt;GraphNode&gt;&gt;&amp; deps);\n    template &lt;typename T&gt;\n    S&lt;KernelNode&gt; add_kernel_node(const S&lt;KernelNodeParms&lt;T&gt;&gt;&amp; kernelParms);\n\n\n    template &lt;typename T&gt;\n    S&lt;HostNode&gt; add_host_node(const S&lt;HostNodeParms&lt;T&gt;&gt;&amp;       hostParms,\n                              const std::vector&lt;S&lt;GraphNode&gt;&gt;&amp; deps);\n    template &lt;typename T&gt;\n    S&lt;HostNode&gt; add_host_node(const S&lt;HostNodeParms&lt;T&gt;&gt;&amp; hostParms);\n\n\n    S&lt;MemcpyNode&gt; add_memcpy_node(void*                            dst,\n                                  const void*                      src,\n                                  size_t                           size_bytes,\n                                  cudaMemcpyKind                   kind,\n                                  const std::vector&lt;S&lt;GraphNode&gt;&gt;&amp; deps);\n    S&lt;MemcpyNode&gt; add_memcpy_node(void* dst, const void* src, size_t size_bytes, cudaMemcpyKind kind);\n    S&lt;MemcpyNode&gt; add_memcpy_node(const cudaMemcpy3DParms&amp; parms);\n    S&lt;MemcpyNode&gt; add_memcpy_node(const cudaMemcpy3DParms&amp;         parms,\n                                  const std::vector&lt;S&lt;GraphNode&gt;&gt;&amp; deps);\n\n    S&lt;MemsetNode&gt; add_memset_node(const cudaMemsetParams&amp;          parms,\n                                  const std::vector&lt;S&lt;GraphNode&gt;&gt;&amp; deps);\n    S&lt;MemsetNode&gt; add_memset_node(const cudaMemsetParams&amp; parms);\n\n\n    S&lt;EventRecordNode&gt; add_event_record_node(cudaEvent_t e,\n                                             const std::vector&lt;S&lt;GraphNode&gt;&gt;&amp; deps);\n    S&lt;EventRecordNode&gt; add_event_record_node(cudaEvent_t e);\n    S&lt;EventWaitNode&gt;   add_event_wait_node(cudaEvent_t                      e,\n                                           const std::vector&lt;S&lt;GraphNode&gt;&gt;&amp; deps);\n    S&lt;EventWaitNode&gt;   add_event_wait_node(cudaEvent_t e);\n\n\n    void add_dependency(S&lt;GraphNode&gt; from, S&lt;GraphNode&gt; to);\n\n    cudaGraph_t handle() const { return m_handle; }\n    cudaGraph_t handle() { return m_handle; }\n    static auto create() { return std::make_shared&lt;Graph&gt;(); }\n\n  private:\n    cudaGraph_t m_handle;\n    // keep the ref count &gt; 0 for those whose data should be kept alive for the graph life.\n    std::list&lt;S&lt;NodeParms&gt;&gt; m_cached;\n    static std::vector&lt;cudaGraphNode_t&gt; map_dependencies(const std::vector&lt;S&lt;GraphNode&gt;&gt;&amp; deps);\n};\n}  // namespace muda\n\n#include \"details/graph.inl\"\n</code></pre>"},{"location":"muda/graph__base_8h/","title":"File graph_base.h","text":"<p>FileList &gt; graph &gt; graph_base.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/version.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;cuda_device_runtime_api.h&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include \"../check/check_cuda_errors.h\"</code></li> </ul>"},{"location":"muda/graph__base_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph__base_8h/#classes","title":"Classes","text":"Type Name class GraphNode class NodeParms <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_base.h</code></p>"},{"location":"muda/graph__base_8h_source/","title":"File graph_base.h","text":"<p>File List &gt; graph &gt; graph_base.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/version.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;cuda_device_runtime_api.h&gt;\n\n#include &lt;list&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;functional&gt;\n\n#include \"../check/check_cuda_errors.h\"\n\nnamespace muda\n{\nclass Graph;\nclass GraphExec;\n\nclass NodeParms\n{\n  public:\n    NodeParms()          = default;\n    virtual ~NodeParms() = default;\n};\n\nclass GraphNode\n{\n  protected:\n    cudaGraphNode_t m_handle;\n\n  public:\n    friend class GraphExec;\n    GraphNode()\n        : m_handle(nullptr)\n    {\n    }\n    using this_type = GraphNode;\n    friend class Graph;\n    cudaGraphNode_t handle() const { return m_handle; }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/graph__exec_8h/","title":"File graph_exec.h","text":"<p>FileList &gt; graph &gt; graph_exec.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/graph/graph_base.h&gt;</code></li> <li><code>#include &lt;muda/graph/kernel_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/memory_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/event_node.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph_viewer.h&gt;</code></li> <li><code>#include \"details/graph_exec.inl\"</code></li> </ul>"},{"location":"muda/graph__exec_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph__exec_8h/#classes","title":"Classes","text":"Type Name class GraphExec <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_exec.h</code></p>"},{"location":"muda/graph__exec_8h_source/","title":"File graph_exec.h","text":"<p>File List &gt; graph &gt; graph_exec.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/graph/graph_base.h&gt;\n#include &lt;muda/graph/kernel_node.h&gt;\n#include &lt;muda/graph/memory_node.h&gt;\n#include &lt;muda/graph/event_node.h&gt;\n#include &lt;muda/graph/graph_viewer.h&gt;\n\nnamespace muda\n{\nclass GraphExec\n{\n    template &lt;typename T&gt;\n    using S = std::shared_ptr&lt;T&gt;;\n    template &lt;typename T&gt;\n    using U = std::unique_ptr&lt;T&gt;;\n    cudaGraphExec_t                m_handle;\n    Flags&lt;GraphInstantiateFlagBit&gt; m_flags;\n\n  public:\n    friend class Graph;\n\n    GraphExec();\n\n    // delete copy\n    GraphExec(const GraphExec&amp;)            = delete;\n    GraphExec&amp; operator=(const GraphExec&amp;) = delete;\n\n    // move\n    GraphExec(GraphExec&amp;&amp; other);\n    GraphExec&amp; operator=(GraphExec&amp;&amp; other);\n\n    void upload(cudaStream_t stream = nullptr);\n\n    void launch(cudaStream_t stream = nullptr);\n\n    template &lt;typename T&gt;\n    void set_kernel_node_parms(S&lt;KernelNode&gt; node, const S&lt;KernelNodeParms&lt;T&gt;&gt;&amp; new_parms);\n\n\n    void set_memcpy_node_parms(S&lt;MemcpyNode&gt;  node,\n                               void*          dst,\n                               const void*    src,\n                               size_t         size_bytes,\n                               cudaMemcpyKind kind);\n    void set_memcpy_node_parms(S&lt;MemcpyNode&gt; node, const cudaMemcpy3DParms&amp; parms);\n    void set_memset_node_parms(S&lt;MemsetNode&gt; node, const cudaMemsetParams&amp; parms);\n\n\n    void set_event_record_node_parms(S&lt;EventRecordNode&gt; node, cudaEvent_t event);\n    void set_event_wait_node_parms(S&lt;EventWaitNode&gt; node, cudaEvent_t event);\n\n    ~GraphExec();\n\n    cudaGraphExec_t handle() const { return m_handle; }\n\n    GraphViewer viewer() const;\n  private:\n    // keep the ref count &gt; 0 for those whose data should be kept alive for the graph life.\n    std::list&lt;S&lt;NodeParms&gt;&gt; m_cached;\n};\n}  // namespace muda\n\n#include \"details/graph_exec.inl\"\n</code></pre>"},{"location":"muda/graph__graph__viewer_8h/","title":"File graph_graph_viewer.h","text":"<p>FileList &gt; graph &gt; graph_graph_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/graph/graph_viewer.h&gt;</code></li> <li><code>#include &lt;muda/compute_graph/compute_graph_var.h&gt;</code></li> <li><code>#include \"details/graph_graph_viewer.inl\"</code></li> </ul>"},{"location":"muda/graph__graph__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph__graph__viewer_8h/#classes","title":"Classes","text":"Type Name class ComputeGraphVar &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_graph_viewer.h</code></p>"},{"location":"muda/graph__graph__viewer_8h_source/","title":"File graph_graph_viewer.h","text":"<p>File List &gt; graph &gt; graph_graph_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/graph/graph_viewer.h&gt;\n#include &lt;muda/compute_graph/compute_graph_var.h&gt;\n\nnamespace muda\n{\ntemplate &lt;&gt;\nclass ComputeGraphVar&lt;GraphViewer&gt; : public ComputeGraphVarBase\n{\n  public:\n    using ROView = GraphViewer;\n    using RWView = GraphViewer;\n\n  protected:\n    friend class ComputeGraph;\n    friend class ComputeGraphVarManager;\n\n    using ComputeGraphVarBase::ComputeGraphVarBase;\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager, std::string_view name, VarId var_id) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id)\n    {\n    }\n\n    ComputeGraphVar(ComputeGraphVarManager* var_manager,\n                    std::string_view        name,\n                    VarId                   var_id,\n                    const RWView&amp;           init_value) MUDA_NOEXCEPT\n        : ComputeGraphVarBase(var_manager, name, var_id, true),\n          m_value(init_value)\n    {\n    }\n\n    virtual ~ComputeGraphVar() = default;\n\n  public:\n    ROView ceval() const { return _ceval(m_value); }\n    RWView eval() { return _eval(m_value); }\n\n    operator ROView() const { return ceval(); }\n    operator RWView() { return eval(); }\n\n    void                          update(const RWView&amp; view);\n    ComputeGraphVar&lt;GraphViewer&gt;&amp; operator=(const RWView&amp; view);\n\n    virtual void graphviz_def(std::ostream&amp; o,\n                              const ComputeGraphGraphvizOptions&amp; options) const override;\n\n  private:\n    RWView m_value;\n};\n\n}  // namespace muda\n\n#include \"details/graph_graph_viewer.inl\"\n</code></pre>"},{"location":"muda/graph__instantiate__flag_8h/","title":"File graph_instantiate_flag.h","text":"<p>FileList &gt; graph &gt; graph_instantiate_flag.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;muda/tools/version.h&gt;</code></li> </ul>"},{"location":"muda/graph__instantiate__flag_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_instantiate_flag.h</code></p>"},{"location":"muda/graph__instantiate__flag_8h_source/","title":"File graph_instantiate_flag.h","text":"<p>File List &gt; graph &gt; graph_instantiate_flag.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;muda/tools/version.h&gt;\nnamespace muda\n{\nenum class GraphInstantiateFlagBit\n{\n    FreeOnLaunch = CUgraphInstantiate_flags::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH,\n#if MUDA_WITH_DEVICE_STREAM_MODEL\n    Upload = CUgraphInstantiate_flags::CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD,\n    DeviceLaunch = CUgraphInstantiate_flags::CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH,\n    UseNodePriority = CUgraphInstantiate_flags::CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY,\n#else\n    Upload          = 2,\n    DeviceLaunch    = 4,\n    UseNodePriority = 8,\n#endif\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/graph__launch_8h/","title":"File graph_launch.h","text":"<p>FileList &gt; graph &gt; graph_launch.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/launch/launch_base.h&gt;</code></li> <li><code>#include \"details/graph_launch.inl\"</code></li> </ul>"},{"location":"muda/graph__launch_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph__launch_8h/#classes","title":"Classes","text":"Type Name class GraphLaunch <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_launch.h</code></p>"},{"location":"muda/graph__launch_8h_source/","title":"File graph_launch.h","text":"<p>File List &gt; graph &gt; graph_launch.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/launch/launch_base.h&gt;\n\nnamespace muda\n{\nclass GraphViewer;\nclass GraphLaunch : public LaunchBase&lt;GraphLaunch&gt;\n{\n  public:\n    GraphLaunch(cudaStream_t stream = nullptr)\n        : LaunchBase(stream)\n    {\n    }\n    ~GraphLaunch() = default;\n\n    GraphLaunch&amp; launch(const GraphViewer&amp; graph);\n};\n}  // namespace muda\n\n#include \"details/graph_launch.inl\"\n</code></pre>"},{"location":"muda/graph__viewer_8h/","title":"File graph_viewer.h","text":"<p>FileList &gt; graph &gt; graph_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> <li><code>#include &lt;muda/graph/graph_instantiate_flag.h&gt;</code></li> <li><code>#include \"details/graph_viewer.inl\"</code></li> </ul>"},{"location":"muda/graph__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/graph__viewer_8h/#classes","title":"Classes","text":"Type Name class GraphViewer struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/graph/graph_viewer.h</code></p>"},{"location":"muda/graph__viewer_8h_source/","title":"File graph_viewer.h","text":"<p>File List &gt; graph &gt; graph_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;muda/viewer/viewer_base.h&gt;\n#include &lt;muda/graph/graph_instantiate_flag.h&gt;\nnamespace muda\n{\nclass GraphViewer : public ViewerBase&lt;true&gt;\n{\n    MUDA_VIEWER_COMMON_NAME(GraphViewer);\n\n  public:\n    MUDA_GENERIC GraphViewer() = default;\n    MUDA_GENERIC GraphViewer(cudaGraphExec_t graph, Flags&lt;GraphInstantiateFlagBit&gt; flags);\n\n    MUDA_GENERIC void launch(cudaStream_t stream = nullptr) const;\n\n    MUDA_DEVICE void tail_launch() const;\n    MUDA_DEVICE void fire_and_forget() const;\n\n    MUDA_GENERIC auto handle() const { return m_graph; }\n\n  private:\n    friend class ComputeGraph;\n    cudaGraphExec_t                m_graph = nullptr;\n    Flags&lt;GraphInstantiateFlagBit&gt; m_flags;\n};\n\ntemplate &lt;&gt;\nstruct read_only_view&lt;GraphViewer&gt;\n{\n    using type = GraphViewer;\n};\n\ntemplate &lt;&gt;\nstruct read_write_view&lt;GraphViewer&gt;\n{\n    using type = GraphViewer;\n};\n\nstatic_assert(is_uniform_view_v&lt;GraphViewer&gt;);\n}  // namespace muda\n\n#include \"details/graph_viewer.inl\"\n</code></pre>"},{"location":"muda/host__node_8h/","title":"File host_node.h","text":"<p>FileList &gt; graph &gt; host_node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/graph/graph_base.h&gt;</code></li> </ul>"},{"location":"muda/host__node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/host__node_8h/#classes","title":"Classes","text":"Type Name class HostNode class HostNodeParms &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/graph/host_node.h</code></p>"},{"location":"muda/host__node_8h_source/","title":"File host_node.h","text":"<p>File List &gt; graph &gt; host_node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/graph/graph_base.h&gt;\n\nnamespace muda\n{\nclass HostNode : public GraphNode\n{\n  public:\n    using this_type = HostNode;\n    friend class Graph;\n};\n\ntemplate &lt;typename T&gt;\nclass HostNodeParms : public NodeParms\n{\n    cudaHostNodeParams m_parms;\n\n  public:\n    T hostData;\n    using this_type = HostNodeParms;\n    friend class Graph;\n    friend class std::shared_ptr&lt;this_type&gt;;\n    friend class std::unique_ptr&lt;this_type&gt;;\n    friend class std::weak_ptr&lt;this_type&gt;;\n\n    HostNodeParms(const T&amp; f)\n        : hostData(f)\n        , m_parms({})\n    {\n        m_parms.userData = &amp;hostData;\n    }\n    auto fn() const { return m_parms.fn; }\n    void fn(cudaHostFn_t fn) { m_parms.fn = fn; }\n    auto userdata() const { return m_parms.userData; }\n    void userdata(void* userdata) { m_parms.userData = userdata; }\n    const cudaHostNodeParams* handle() const { return &amp;m_parms; }\n    cudaHostNodeParams*       handle() { return &amp;m_parms; }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/kernel__node_8h/","title":"File kernel_node.h","text":"<p>FileList &gt; graph &gt; kernel_node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/graph/graph_base.h&gt;</code></li> </ul>"},{"location":"muda/kernel__node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/kernel__node_8h/#classes","title":"Classes","text":"Type Name class KernelNode class KernelNodeParms &lt;typename U&gt; <p>The documentation for this class was generated from the following file <code>src/muda/graph/kernel_node.h</code></p>"},{"location":"muda/kernel__node_8h_source/","title":"File kernel_node.h","text":"<p>File List &gt; graph &gt; kernel_node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/graph/graph_base.h&gt;\n\nnamespace muda\n{\nclass KernelNode : public GraphNode\n{\n  public:\n    using this_type = KernelNode;\n    friend class Graph;\n};\n\ntemplate &lt;typename U&gt;\nclass KernelNodeParms : public NodeParms\n{\n    std::vector&lt;void*&gt;   m_args;\n    cudaKernelNodeParams m_parms;\n\n  public:\n    using this_type = KernelNodeParms;\n    friend class Graph;\n    friend class std::shared_ptr&lt;this_type&gt;;\n    friend class std::unique_ptr&lt;this_type&gt;;\n    friend class std::weak_ptr&lt;this_type&gt;;\n\n    template &lt;typename... Args&gt;\n    KernelNodeParms(Args&amp;&amp;... args)\n        : kernelParmData(std::forward&lt;Args&gt;(args)...)\n        , m_parms({})\n    {\n    }\n\n    KernelNodeParms() {}\n    U    kernelParmData;\n    auto func() { return m_parms.func; }\n    void func(void* v) { m_parms.func = v; }\n    auto grid_dim() { return m_parms.gridDim; }\n    void grid_dim(const dim3&amp; v) { m_parms.gridDim = v; }\n    auto block_dim() { return m_parms.blockDim; }\n    void block_dim(const dim3&amp; v) { m_parms.blockDim = v; }\n    auto shared_mem_bytes() { return m_parms.sharedMemBytes; }\n    void shared_mem_bytes(unsigned int v) { m_parms.sharedMemBytes = v; }\n    auto kernel_params() { return m_parms.kernelParams; }\n    void kernel_params(const std::vector&lt;void*&gt;&amp; v)\n    {\n        m_args               = v;\n        m_parms.kernelParams = m_args.data();\n    }\n    void parse(std::function&lt;std::vector&lt;void*&gt;(U&amp;)&gt; pred)\n    {\n        m_args               = pred(kernelParmData);\n        m_parms.kernelParams = m_args.data();\n    }\n    auto extra() { return m_parms.extra; }\n    void extra(void** v) { m_parms.extra = v; }\n\n    const cudaKernelNodeParams* handle() const { return &amp;m_parms; }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/memory__node_8h/","title":"File memory_node.h","text":"<p>FileList &gt; graph &gt; memory_node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/graph/graph_base.h&gt;</code></li> </ul>"},{"location":"muda/memory__node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/memory__node_8h/#classes","title":"Classes","text":"Type Name class MemcpyNode class MemsetNode <p>The documentation for this class was generated from the following file <code>src/muda/graph/memory_node.h</code></p>"},{"location":"muda/memory__node_8h_source/","title":"File memory_node.h","text":"<p>File List &gt; graph &gt; memory_node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/graph/graph_base.h&gt;\n\nnamespace muda\n{\n#ifdef MUDA_WITH_GRAPH_MEMORY_ALLOC_FREE\nclass MemAllocNode : public GraphNode\n{\n    void* m_dptr;\n\n  public:\n    using this_type = MemAllocNode;\n    friend class Graph;\n};\n\ntemplate &lt;typename T&gt;\nclass MemAllocNodeParms : public NodeParms\n{\n    cudaMemAllocNodeParams m_parms;\n\n  public:\n    using this_type = MemAllocNodeParms;\n    friend class graph;\n    friend class std::shared_ptr&lt;this_type&gt;;\n    friend class std::unique_ptr&lt;this_type&gt;;\n    friend class std::weak_ptr&lt;this_type&gt;;\n\n    MemAllocNodeParms(size_t size)\n        : m_parms({})\n    {\n        m_parms.poolProps.allocType = cudaMemAllocationTypePinned;\n        cudaGetDevice(&amp;m_parms.poolProps.location.id);\n        m_parms.poolProps.location.type = cudaMemLocationTypeDevice;\n        m_parms.bytesize                = size * sizeof(T);\n    }\n\n    cudaMemAllocNodeParams*       getRaw() { return &amp;m_parms; }\n    const cudaMemAllocNodeParams* getRaw() const { return &amp;m_parms; }\n};\n\nclass MemFreeNode : public GraphNode\n{\n  public:\n    using this_type = MemFreeNode;\n    friend class Graph;\n};\n#endif\n\nclass MemcpyNode : public GraphNode\n{\n  public:\n    using this_type = MemcpyNode;\n    friend class Graph;\n};\n\nclass MemsetNode : public GraphNode\n{\n  public:\n    using this_type = MemsetNode;\n    friend class Graph;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_440d6ef7395341c98b5d944289d06a83/","title":"Dir src/muda/launch","text":"<p>FileList &gt; launch</p>"},{"location":"muda/dir_440d6ef7395341c98b5d944289d06a83/#files","title":"Files","text":"Type Name file event.h file host_call.h file kernel.h file kernel_label.h file kernel_tag.h file launch.h cuda kernel launch in muda style. file launch_base.h file memory.h file parallel_for.h A frequently used parallel for loop, DynamicBlockDim andGridStrideLoop strategy are provided, and can be switched seamlessly to each other. file stream.h file stream_define.h <p>The documentation for this class was generated from the following file <code>src/muda/launch/</code></p>"},{"location":"muda/event_8h/","title":"File event.h","text":"<p>FileList &gt; launch &gt; event.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/flag.h&gt;</code></li> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;device_launch_parameters.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cuda_errors.h&gt;</code></li> <li><code>#include \"details/event.inl\"</code></li> </ul>"},{"location":"muda/event_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/event_8h/#classes","title":"Classes","text":"Type Name class Event RAII wrapper for cudaEvent. <p>The documentation for this class was generated from the following file <code>src/muda/launch/event.h</code></p>"},{"location":"muda/event_8h_source/","title":"File event.h","text":"<p>File List &gt; launch &gt; event.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/flag.h&gt;\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;device_launch_parameters.h&gt;\n#include &lt;muda/check/check_cuda_errors.h&gt;\n\nnamespace muda\n{\nclass Event\n{\n    cudaEvent_t m_handle = nullptr;\n\n  public:\n    enum class Bit : unsigned int\n    {\n        eDefault = cudaEventDefault,           \n        eBlockingSync = cudaEventBlockingSync, \n        eDisableTiming = cudaEventDisableTiming, \n        eInterprocess = cudaEventInterprocess \n    };\n\n    enum class QueryResult\n    {\n        eFinished = cudaSuccess,       \n        eNotReady = cudaErrorNotReady, \n    };\n\n    Event(Flags&lt;Bit&gt; flag = Bit::eDisableTiming);\n    ~Event();\n\n    QueryResult query() const;\n    // elapsed time (in ms) between two events\n    static float elapsed_time(cudaEvent_t start, cudaEvent_t stop);\n\n    operator cudaEvent_t() { return m_handle; }\n    cudaEvent_t viewer() const { return m_handle; }\n\n    // delete copy constructor and assignment operator\n    Event(const Event&amp;)            = delete;\n    Event&amp; operator=(const Event&amp;) = delete;\n\n    // allow move constructor\n    Event(Event&amp;&amp; o) MUDA_NOEXCEPT;\n    // delete move assignment operator\n    Event&amp; operator=(Event&amp;&amp; o) MUDA_NOEXCEPT;\n};\n}  // namespace muda\n\n#include \"details/event.inl\"\n</code></pre>"},{"location":"muda/host__call_8h/","title":"File host_call.h","text":"<p>FileList &gt; launch &gt; host_call.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/launch/launch_base.h&gt;</code></li> </ul>"},{"location":"muda/host__call_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/host__call_8h/#classes","title":"Classes","text":"Type Name class HostCall <p>The documentation for this class was generated from the following file <code>src/muda/launch/host_call.h</code></p>"},{"location":"muda/host__call_8h_source/","title":"File host_call.h","text":"<p>File List &gt; launch &gt; host_call.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/launch/launch_base.h&gt;\n\nnamespace muda\n{\nnamespace details\n{\n    template &lt;typename F, typename UserTag&gt;\n    MUDA_HOST void CUDARTAPI generic_host_call(void* userdata)\n    {\n        auto f = reinterpret_cast&lt;F*&gt;(userdata);\n        (*f)();\n    }\n\n    template &lt;typename F, typename UserTag&gt;\n    MUDA_HOST void CUDARTAPI delete_function_object(void* userdata)\n    {\n        auto f = reinterpret_cast&lt;F*&gt;(userdata);\n        delete f;\n    }\n}  // namespace details\n\n\nclass HostCall : public LaunchBase&lt;HostCall&gt;\n{\n  public:\n    MUDA_HOST HostCall(cudaStream_t stream = nullptr)\n        : LaunchBase(stream)\n    {\n    }\n\n    template &lt;typename F, typename UserTag = DefaultTag&gt;\n    MUDA_HOST HostCall&amp; apply(F&amp;&amp; f, UserTag tag = {})\n    {\n        MUDA_ASSERT(ComputeGraphBuilder::is_phase_none(),\n                    \"HostCall must be can't appear in a compute graph\");\n        using CallableType = raw_type_t&lt;F&gt;;\n        static_assert(std::is_invocable_v&lt;CallableType&gt;, \"f:void (void)\");\n        auto userdata = new CallableType(std::forward&lt;F&gt;(f));\n        checkCudaErrors(cudaLaunchHostFunc(\n            this-&gt;stream(), details::generic_host_call&lt;CallableType, UserTag&gt;, userdata));\n        checkCudaErrors(cudaLaunchHostFunc(\n            this-&gt;stream(), details::delete_function_object&lt;CallableType, UserTag&gt;, userdata));\n        return *this;\n    }\n\n    template &lt;typename F, typename UserTag = DefaultTag&gt;\n    MUDA_NODISCARD MUDA_HOST auto as_node_parms(F&amp;&amp; f, UserTag tag = {})\n    {\n        using CallableType = raw_type_t&lt;F&gt;;\n        auto parms = std::make_shared&lt;HostNodeParms&lt;CallableType&gt;&gt;(std::forward&lt;F&gt;(f));\n        parms-&gt;fn((cudaHostFn_t)details::generic_host_call&lt;CallableType, UserTag&gt;);\n        return parms;\n    }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/kernel_8h/","title":"File kernel.h","text":"<p>FileList &gt; launch &gt; kernel.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/launch/stream_define.h&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"muda/kernel_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/kernel_8h/#classes","title":"Classes","text":"Type Name class Kernel &lt;typename F&gt; <p>The documentation for this class was generated from the following file <code>src/muda/launch/kernel.h</code></p>"},{"location":"muda/kernel_8h_source/","title":"File kernel.h","text":"<p>File List &gt; launch &gt; kernel.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/launch/stream_define.h&gt;\n#include &lt;type_traits&gt;\n\nnamespace muda\n{\ntemplate &lt;typename F&gt;\nclass Kernel\n{\n    dim3         m_grid_dim;\n    dim3         m_block_dim;\n    size_t       m_shared_memory_size;\n    cudaStream_t m_stream;\n    F            m_kernel;\n\n  public:\n    MUDA_GENERIC Kernel(dim3 grid_dim, dim3 m_block_dim, size_t shared_memory_size, cudaStream_t stream, F f)\n        : m_grid_dim(grid_dim)\n        , m_block_dim(m_block_dim)\n        , m_shared_memory_size(shared_memory_size)\n        , m_stream(stream)\n        , m_kernel(f)\n    {\n#ifdef __CUDA_ARCH__\n        MUDA_KERNEL_ASSERT(stream == details::stream::tail_launch()\n                               || stream == details::stream::fire_and_forget(),\n                           \"Kernel Launch on device with invalid stream! \"\n                           \"Only Stream::TailLaunch{} and Stream::FireAndForget{} are allowed\");\n#endif\n    }\n\n    MUDA_GENERIC Kernel(F f)\n        : Kernel{1, 1, 0, 0, f}\n    {\n    }\n\n    MUDA_GENERIC Kernel(dim3 grid_dim, dim3 m_block_dim, F f)\n        : Kernel{grid_dim, m_block_dim, 0, 0, f}\n    {\n    }\n\n    MUDA_GENERIC Kernel(dim3 grid_dim, dim3 m_block_dim, size_t shared_memory_size, F f)\n        : Kernel{grid_dim, m_block_dim, shared_memory_size, 0, f}\n    {\n    }\n\n    MUDA_GENERIC Kernel(dim3 grid_dim, dim3 m_block_dim, cudaStream_t stream, F f)\n        : Kernel{grid_dim, m_block_dim, 0, stream, f}\n    {\n    }\n\n    MUDA_GENERIC Kernel(cudaStream_t stream, F f)\n        : Kernel{1, 1, 0, stream, f}\n    {\n    }\n\n    template &lt;typename... Args&gt;\n    MUDA_GENERIC void operator()(Args&amp;&amp;... args) &amp;&amp;\n    {\n        static_assert(std::is_invocable_v&lt;F, Args...&gt;, \"invalid arguments\");\n#if MUDA_WITH_DEVICE_STREAM_MODEL\n        m_kernel&lt;&lt;&lt;m_grid_dim, m_block_dim, m_shared_memory_size, m_stream&gt;&gt;&gt;(\n            std::forward&lt;Args&gt;(args)...);\n        checkCudaErrors(cudaGetLastError());\n#else\n        cudaStream_t stream = nullptr;\n        if(m_stream == details::stream::tail_launch())\n        {\n            checkCudaErrors(cudaDeviceSynchronize());\n        }\n        else if(m_stream == details::stream::fire_and_forget())\n        {\n            // do nothing\n        }\n        else\n        {\n            stream = m_stream;\n        }\n        m_kernel&lt;&lt;&lt;m_grid_dim, m_block_dim, m_shared_memory_size, stream&gt;&gt;&gt;(\n            std::forward&lt;Args&gt;(args)...);\n        checkCudaErrors(cudaGetLastError());\n#endif\n    }\n\n    // delete copy and move\n    MUDA_GENERIC         Kernel(const Kernel&amp;)    = delete;\n    MUDA_GENERIC Kernel&amp; operator=(const Kernel&amp;) = delete;\n    MUDA_GENERIC         Kernel(Kernel&amp;&amp;)         = delete;\n    MUDA_GENERIC Kernel&amp; operator=(Kernel&amp;&amp;)      = delete;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/kernel__label_8h/","title":"File kernel_label.h","text":"<p>FileList &gt; launch &gt; kernel_label.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/launch_info_cache.h&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> </ul>"},{"location":"muda/kernel__label_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/kernel__label_8h/#classes","title":"Classes","text":"Type Name class KernelLabel <p>The documentation for this class was generated from the following file <code>src/muda/launch/kernel_label.h</code></p>"},{"location":"muda/kernel__label_8h_source/","title":"File kernel_label.h","text":"<p>File List &gt; launch &gt; kernel_label.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/launch_info_cache.h&gt;\n#include &lt;string_view&gt;\nnamespace muda\n{\nclass KernelLabel\n{\n  public:\n    KernelLabel(std::string_view name, std::string_view file = \"\", int line = -1)\n    {\n        if constexpr(muda::RUNTIME_CHECK_ON)\n        {\n            details::LaunchInfoCache::current_kernel_name(name);\n            details::LaunchInfoCache::current_kernel_file(file);\n            details::LaunchInfoCache::current_kernel_line(line);\n        }\n    }\n\n    ~KernelLabel()\n    {\n        if constexpr(muda::RUNTIME_CHECK_ON)\n        {\n            details::LaunchInfoCache::current_kernel_name(\"\");\n            details::LaunchInfoCache::current_kernel_file(\"\");\n            details::LaunchInfoCache::current_kernel_line(-1);\n        }\n    }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/kernel__tag_8h/","title":"File kernel_tag.h","text":"<p>FileList &gt; launch &gt; kernel_tag.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/kernel__tag_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/kernel__tag_8h/#classes","title":"Classes","text":"Type Name struct Default struct Tag &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/launch/kernel_tag.h</code></p>"},{"location":"muda/kernel__tag_8h_source/","title":"File kernel_tag.h","text":"<p>File List &gt; launch &gt; kernel_tag.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nstruct Tag\n{\n};\n\nstruct Default\n{\n};\n\nusing DefaultTag = Tag&lt;Default&gt;;\n}  // namespace muda\n</code></pre>"},{"location":"muda/launch_2launch_8h/","title":"File launch.h","text":"<p>FileList &gt; launch &gt; launch.h</p> <p>Go to the source code of this file</p> <p>cuda kernel launch in muda style. More...</p> <ul> <li><code>#include &lt;muda/launch/launch_base.h&gt;</code></li> <li><code>#include &lt;muda/type_traits/always.h&gt;</code></li> <li><code>#include &lt;muda/launch/kernel_tag.h&gt;</code></li> <li><code>#include \"details/launch.inl\"</code></li> </ul>"},{"location":"muda/launch_2launch_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/launch_2launch_8h/#classes","title":"Classes","text":"Type Name class Launch A wrapper of raw cuda kernel launch in muda style , removing the<code>&lt;&lt;&lt;&gt;&gt;&gt;</code> usage, for better intellisense support. struct LaunchCallable &lt;typename F&gt;"},{"location":"muda/launch_2launch_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>MuGdxy </p> <p>Date:</p> <p>January 2024 </p> <p>The documentation for this class was generated from the following file <code>src/muda/launch/launch.h</code></p>"},{"location":"muda/launch_2launch_8h_source/","title":"File launch.h","text":"<p>File List &gt; launch &gt; launch.h</p> <p>Go to the documentation of this file</p> <pre><code>/*****************************************************************/ \n\n#pragma once\n#include &lt;muda/launch/launch_base.h&gt;\n#include &lt;muda/type_traits/always.h&gt;\n#include &lt;muda/launch/kernel_tag.h&gt;\nnamespace muda\n{\nnamespace details\n{\n    template &lt;typename F&gt;\n    struct LaunchCallable\n    {\n        F    callable;\n        dim3 dim;\n        template &lt;typename U&gt;\n        LaunchCallable(U&amp;&amp; f, const dim3&amp; d)\n            : callable(std::forward&lt;U&gt;(f))\n            , dim(d)\n        {\n        }\n    };\n\n    template &lt;typename F, typename UserTag = DefaultTag&gt;\n    MUDA_GLOBAL void generic_kernel(LaunchCallable&lt;F&gt; f);\n\n    template &lt;typename F, typename UserTag = DefaultTag&gt;\n    MUDA_GLOBAL void generic_kernel_with_range(LaunchCallable&lt;F&gt; f);\n}  // namespace details\n\n// using details::generic_kernel;\n\ndim3 cube(int x) MUDA_NOEXCEPT;\ndim3 square(int x) MUDA_NOEXCEPT;\n\nclass Launch : public LaunchBase&lt;Launch&gt;\n{\n    dim3   m_grid_dim;\n    dim3   m_block_dim;\n    size_t m_shared_mem_size;\n\n  public:\n    template &lt;typename F&gt;\n    using NodeParms = KernelNodeParms&lt;details::LaunchCallable&lt;raw_type_t&lt;F&gt;&gt;&gt;;\n\n    MUDA_HOST Launch(dim3 gridDim, dim3 blockDim, size_t sharedMemSize = 0, cudaStream_t stream = nullptr) MUDA_NOEXCEPT\n        : LaunchBase(stream),\n          m_grid_dim(gridDim),\n          m_block_dim(blockDim),\n          m_shared_mem_size(sharedMemSize)\n    {\n    }\n\n    MUDA_HOST Launch(int          gridDim       = 1,\n                     int          blockDim      = 1,\n                     size_t       sharedMemSize = 0,\n                     cudaStream_t stream        = nullptr) MUDA_NOEXCEPT\n        : LaunchBase(stream),\n          m_grid_dim(gridDim),\n          m_block_dim(blockDim),\n          m_shared_mem_size(sharedMemSize)\n    {\n    }\n\n    MUDA_HOST Launch(dim3 blockDim, size_t sharedMemSize = 0, cudaStream_t stream = nullptr) MUDA_NOEXCEPT\n        : LaunchBase(stream),\n          m_grid_dim(0),\n          m_block_dim(blockDim),\n          m_shared_mem_size(sharedMemSize)\n    {\n    }\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST Launch&amp; apply(F&amp;&amp; f);\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST Launch&amp; apply(F&amp;&amp; f, Tag&lt;UserTag&gt;);\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST Launch&amp; apply(const dim3&amp; active_dim, F&amp;&amp; f);\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST Launch&amp; apply(const dim3&amp; active_dim, F&amp;&amp; f, Tag&lt;UserTag&gt;);\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST MUDA_NODISCARD auto as_node_parms(F&amp;&amp; f) -&gt; S&lt;NodeParms&lt;F&gt;&gt;;\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST MUDA_NODISCARD auto as_node_parms(F&amp;&amp; f, Tag&lt;UserTag&gt;)\n        -&gt; S&lt;NodeParms&lt;F&gt;&gt;;\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST MUDA_NODISCARD auto as_node_parms(const dim3&amp; active_dim, F&amp;&amp; f)\n        -&gt; S&lt;NodeParms&lt;F&gt;&gt;;\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST MUDA_NODISCARD auto as_node_parms(const dim3&amp; active_dim, F&amp;&amp; f, Tag&lt;UserTag&gt;)\n        -&gt; S&lt;NodeParms&lt;F&gt;&gt;;\n\n\n  private:\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST void invoke(F&amp;&amp; f);\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST void invoke(const dim3&amp; active_dim, F&amp;&amp; f);\n\n    MUDA_GENERIC dim3 calculate_grid_dim(const dim3&amp; active_dim) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC void check_input_with_range() const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC void check_input() const MUDA_NOEXCEPT;\n};\n}  // namespace muda\n\n#include \"details/launch.inl\"\n</code></pre>"},{"location":"muda/launch__base_8h/","title":"File launch_base.h","text":"<p>FileList &gt; launch &gt; launch_base.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;device_launch_parameters.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;cooperative_groups.h&gt;</code></li> <li><code>#include &lt;cuda_profiler_api.h&gt;</code></li> <li><code>#include &lt;muda/type_traits/type_modifier.h&gt;</code></li> <li><code>#include &lt;muda/tools/launch_info_cache.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cuda_errors.h&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/launch/event.h&gt;</code></li> <li><code>#include &lt;muda/launch/kernel_tag.h&gt;</code></li> <li><code>#include \"details/launch_base.inl\"</code></li> </ul>"},{"location":"muda/launch__base_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/launch__base_8h/#classes","title":"Classes","text":"Type Name class Empty class LaunchBase &lt;typename T&gt; class LaunchCore <p>The documentation for this class was generated from the following file <code>src/muda/launch/launch_base.h</code></p>"},{"location":"muda/launch__base_8h_source/","title":"File launch_base.h","text":"<p>File List &gt; launch &gt; launch_base.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;device_launch_parameters.h&gt;\n\n#include &lt;string&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;cooperative_groups.h&gt;\n\n#include &lt;cuda_profiler_api.h&gt;\n\n#include &lt;muda/type_traits/type_modifier.h&gt;\n#include &lt;muda/tools/launch_info_cache.h&gt;\n\n#include &lt;muda/check/check_cuda_errors.h&gt;\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/launch/event.h&gt;\n#include &lt;muda/launch/kernel_tag.h&gt;\n\nnamespace muda\n{\nnamespace details\n{\n    inline void stream_error_callback(cudaStream_t stream, cudaError error, void* userdata)\n    {\n        auto callback =\n            reinterpret_cast&lt;std::function&lt;void(cudaStream_t, cudaError)&gt;*&gt;(userdata);\n        (*callback)(stream, error);\n        delete callback;\n    }\n}  // namespace details\n\nclass ComputeGraphVarBase;\n\ntemplate &lt;typename T&gt;\nclass ComputeGraphVar;\n\nclass LaunchCore\n{\n  protected:\n    template &lt;typename T&gt;\n    using S = std::shared_ptr&lt;T&gt;;\n    MUDA_GENERIC ::cudaStream_t stream() const { return m_stream; }\n\n    ::cudaStream_t m_stream;\n    MUDA_HOST void pop_kernel_label();\n\n  public:\n    static void kernel_name(std::string_view name);\n    static void file_line(std::string_view file, int line);\n\n    MUDA_GENERIC LaunchCore(::cudaStream_t stream) MUDA_NOEXCEPT;\n\n    void init_stream(::cudaStream_t s) { m_stream = s; }\n\n    void push_range(const std::string&amp; name);\n    void pop_range();\n\n    void record(cudaEvent_t e, int flag = cudaEventRecordDefault);\n    void record(ComputeGraphVar&lt;cudaEvent_t&gt;&amp;            e,\n                const std::vector&lt;ComputeGraphVarBase*&gt;&amp; vars);\n    template &lt;typename... ViewT&gt;\n    void record(ComputeGraphVar&lt;cudaEvent_t&gt;&amp; e, ComputeGraphVar&lt;ViewT&gt;&amp;... vars);\n    void when(cudaEvent_t e, int flag = cudaEventWaitDefault);\n    // let the host wait for the event\n    void wait(cudaEvent_t e, int flag = cudaEventWaitDefault);\n    void wait(const ComputeGraphVar&lt;cudaEvent_t&gt;&amp;      e,\n              const std::vector&lt;ComputeGraphVarBase*&gt;&amp; vars);\n    template &lt;typename... ViewT&gt;\n    void wait(const ComputeGraphVar&lt;cudaEvent_t&gt;&amp; e, ComputeGraphVar&lt;ViewT&gt;&amp;... vars);\n    void wait();\n    void callback(const std::function&lt;void(::cudaStream_t, ::cudaError)&gt;&amp; callback);\n\n    static void wait_event(cudaEvent_t event);\n    static void wait_stream(::cudaStream_t stream);\n    static void wait_device();\n\n    ~LaunchCore() MUDA_NOEXCEPT;\n};\n\ntemplate &lt;typename T&gt;\nclass LaunchBase : public LaunchCore\n{\n    template &lt;typename Others&gt;\n    friend class LaunchBase;\n    using Base = LaunchCore;\n\n  public:\n    using derived_type = T;\n    MUDA_GENERIC LaunchBase(::cudaStream_t stream) MUDA_NOEXCEPT;\n\n    // create a named scope for better recognization (if you are using some profile tools)\n    // usage:\n    //  on(stream)\n    //      .push_range(\"part1\")\n    //      .next&lt;launch&gt;(1,1).apply(...)\n    //      .pop_range()\n    //      .wait();\n    T&amp; push_range(const std::string&amp; name);\n    T&amp; pop_range();\n\n    // create a name for the following kernel launch\n    // viewers will record this name for the sake of better recognization when debugging\n    T&amp; kernel_name(std::string_view name);\n    T&amp; file_line(std::string_view file, int line);\n\n    // record an event on this point with current stream, you could use .when() to\n    // capture this event for synchronization\n    // flags:\n    //  cudaEventRecordDefault : Default event creation flag.\n    //  cudaEventRecordExternal : Event is captured in the graph as an external\n    //  event node when performing stream capture.\n    T&amp; record(cudaEvent_t e, int flag = cudaEventRecordDefault);\n\n    T&amp; record(ComputeGraphVar&lt;cudaEvent_t&gt;&amp;            e,\n              const std::vector&lt;ComputeGraphVarBase*&gt;&amp; vars);\n\n    template &lt;typename... ViewT&gt;\n    T&amp; record(ComputeGraphVar&lt;cudaEvent_t&gt;&amp; e, ComputeGraphVar&lt;ViewT&gt;&amp;... vars);\n\n    // let the following kernels wait until the event is triggered\n    // (asynchronize with the host)\n    // usage:\n    //  on(stream)\n    //      .when(event)\n    //      .next&lt;launch&gt;(1,1).apply(...)\n    //      .wait();\n    // flags:\n    //  cudaEventRecordDefault : Default event creation flag.\n    //  cudaEventRecordExternal : Event is captured in the graph as an external\n    //  event node when performing stream capture.\n    T&amp; when(cudaEvent_t e, int flag = cudaEventWaitDefault);\n    // let the host wait for the event\n    T&amp; wait(cudaEvent_t e, int flag = cudaEventWaitDefault);\n    T&amp; wait(const ComputeGraphVar&lt;cudaEvent_t&gt;&amp;      e,\n            const std::vector&lt;ComputeGraphVarBase*&gt;&amp; vars);\n    template &lt;typename... ViewT&gt;\n    T&amp; wait(const ComputeGraphVar&lt;cudaEvent_t&gt;&amp; e, ComputeGraphVar&lt;ViewT&gt;&amp;... vars);\n\n\n    // let the host wait for the current stream\n    T&amp; wait();\n\n    // register a host callback function, which will be called when all the jobs before\n    // this point are done.\n    T&amp; callback(const std::function&lt;void(::cudaStream_t, ::cudaError)&gt;&amp; callback);\n\n    template &lt;typename Next&gt;\n    Next next(Next n);\n    template &lt;typename Next, typename... Args&gt;\n    Next next(Args&amp;&amp;... args);\n\n    ~LaunchBase() MUDA_NOEXCEPT;\n\n  protected:\n    T&amp; pop_kernel_label();\n\n  private:\n    T&amp; derived() MUDA_NOEXCEPT { return *(T*)(this); }\n};\n\nclass Empty : public LaunchBase&lt;Empty&gt;\n{\n  public:\n    Empty(::cudaStream_t stream = nullptr)\n        : LaunchBase(stream)\n    {\n    }\n};\n\nEmpty on(::cudaStream_t stream);\n\nEmpty on();\n\nvoid wait_device();\nvoid wait_stream(::cudaStream_t stream);\nvoid wait_event(cudaEvent_t event);\n}  // namespace muda\n\n#include \"details/launch_base.inl\"\n</code></pre>"},{"location":"muda/memory_8h/","title":"File memory.h","text":"<p>FileList &gt; launch &gt; memory.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/launch/launch_base.h&gt;</code></li> <li><code>#include &lt;muda/tools/version.h&gt;</code></li> <li><code>#include \"details/memory.inl\"</code></li> </ul>"},{"location":"muda/memory_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/memory_8h/#classes","title":"Classes","text":"Type Name class Memory <p>The documentation for this class was generated from the following file <code>src/muda/launch/memory.h</code></p>"},{"location":"muda/memory_8h_source/","title":"File memory.h","text":"<p>File List &gt; launch &gt; memory.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/launch/launch_base.h&gt;\n#include &lt;muda/tools/version.h&gt;\n\nnamespace muda\n{\nclass Memory : public LaunchBase&lt;Memory&gt;\n{\n  public:\n    MUDA_HOST Memory(cudaStream_t stream = nullptr)\n        : LaunchBase(stream){};\n\n    // Memory1D\n    template &lt;typename T&gt;\n    MUDA_HOST Memory&amp; alloc_1d(T** ptr, size_t byte_size, bool async = DEFAULT_ASYNC_ALLOC_FREE);\n    template &lt;typename T&gt;\n    MUDA_HOST Memory&amp; alloc(T** ptr, size_t byte_size, bool async = DEFAULT_ASYNC_ALLOC_FREE);\n    MUDA_HOST Memory&amp; free(void* ptr, bool async = DEFAULT_ASYNC_ALLOC_FREE);\n    MUDA_HOST Memory&amp; copy(void* dst, const void* src, size_t byte_size, cudaMemcpyKind kind);\n    MUDA_HOST Memory&amp; transfer(void* dst, const void* src, size_t byte_size);\n    MUDA_HOST Memory&amp; download(void* dst, const void* src, size_t byte_size);\n    MUDA_HOST Memory&amp; upload(void* dst, const void* src, size_t byte_size);\n    MUDA_HOST Memory&amp; set(void* data, size_t byte_size, char value = 0);\n\n    // Memory2D\n    template &lt;typename T&gt;\n    MUDA_HOST Memory&amp; alloc_2d(T**     ptr,\n                               size_t* pitch,\n                               size_t  width_bytes,\n                               size_t  height,\n                               bool    async = DEFAULT_ASYNC_ALLOC_FREE);\n    template &lt;typename T&gt;\n    MUDA_HOST Memory&amp; alloc(T**     ptr,\n                            size_t* pitch,\n                            size_t  width_bytes,\n                            size_t  height,\n                            bool    async = DEFAULT_ASYNC_ALLOC_FREE);\n    MUDA_HOST Memory&amp; copy(void*          dst,\n                           size_t         dst_pitch,\n                           const void*    src,\n                           size_t         src_pitch,\n                           size_t         width_bytes,\n                           size_t         height,\n                           cudaMemcpyKind kind);\n    MUDA_HOST Memory&amp; transfer(void*       dst,\n                               size_t      dst_pitch,\n                               const void* src,\n                               size_t      src_pitch,\n                               size_t      width_bytes,\n                               size_t      height);\n    MUDA_HOST Memory&amp; download(void*       dst,\n                               size_t      dst_pitch,\n                               const void* src,\n                               size_t      src_pitch,\n                               size_t      width_bytes,\n                               size_t      height);\n    MUDA_HOST Memory&amp; upload(void*       dst,\n                             size_t      dst_pitch,\n                             const void* src,\n                             size_t      src_pitch,\n                             size_t      width_bytes,\n                             size_t      height);\n    MUDA_HOST Memory&amp; set(void* data, size_t pitch, size_t width_bytes, size_t height, char value = 0);\n\n    // Memory3D\n    MUDA_HOST Memory&amp; alloc_3d(cudaPitchedPtr*   pitched_ptr,\n                               const cudaExtent&amp; extent,\n                               bool async = DEFAULT_ASYNC_ALLOC_FREE);\n    MUDA_HOST Memory&amp; alloc(cudaPitchedPtr*   pitched_ptr,\n                            const cudaExtent&amp; extent,\n                            bool              async = DEFAULT_ASYNC_ALLOC_FREE);\n    MUDA_HOST Memory&amp; free(cudaPitchedPtr pitched_ptr, bool async = DEFAULT_ASYNC_ALLOC_FREE);\n    MUDA_HOST Memory&amp; copy(const cudaMemcpy3DParms&amp; parms);\n    MUDA_HOST Memory&amp; transfer(cudaMemcpy3DParms parms);\n    MUDA_HOST Memory&amp; download(cudaMemcpy3DParms parms);\n    MUDA_HOST Memory&amp; upload(cudaMemcpy3DParms parms);\n    MUDA_HOST Memory&amp; set(cudaPitchedPtr pitched_ptr, cudaExtent extent, char value = 0);\n};\n\n}  // namespace muda\n\n#include \"details/memory.inl\"\n</code></pre>"},{"location":"muda/parallel__for_8h/","title":"File parallel_for.h","text":"<p>FileList &gt; launch &gt; parallel_for.h</p> <p>Go to the source code of this file</p> <p>A frequently used parallel for loop, DynamicBlockDim andGridStrideLoop strategy are provided, and can be switched seamlessly to each other.More...</p> <ul> <li><code>#include &lt;muda/launch/launch_base.h&gt;</code></li> <li><code>#include &lt;muda/launch/kernel_tag.h&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include \"details/parallel_for.inl\"</code></li> </ul>"},{"location":"muda/parallel__for_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/parallel__for_8h/#classes","title":"Classes","text":"Type Name class ParallelFor a frequently used parallel for loop, DynamicBlockDim andGridStrideLoop strategy are provided, and can be switched seamlessly to each other. class ParallelForDetails class ParallelForCallable &lt;typename F&gt;"},{"location":"muda/parallel__for_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>MuGdxy </p> <p>Date:</p> <p>January 2024 </p> <p>The documentation for this class was generated from the following file <code>src/muda/launch/parallel_for.h</code></p>"},{"location":"muda/parallel__for_8h_source/","title":"File parallel_for.h","text":"<p>File List &gt; launch &gt; parallel_for.h</p> <p>Go to the documentation of this file</p> <pre><code>/*****************************************************************/ \n\n\n#pragma once\n#include &lt;muda/launch/launch_base.h&gt;\n#include &lt;muda/launch/kernel_tag.h&gt;\n#include &lt;stdexcept&gt;\n#include &lt;exception&gt;\n\nnamespace muda\n{\nnamespace details\n{\n    template &lt;typename F&gt;\n    class ParallelForCallable\n    {\n      public:\n        F   callable;\n        int count;\n        template &lt;typename U&gt;\n        MUDA_GENERIC ParallelForCallable(U&amp;&amp; callable, int count) MUDA_NOEXCEPT\n            : callable(std::forward&lt;U&gt;(callable)),\n              count(count)\n        {\n        }\n        // MUDA_GENERIC ~ParallelForCallable() = default;\n    };\n\n    template &lt;typename F, typename UserTag&gt;\n    MUDA_GLOBAL void parallel_for_kernel(ParallelForCallable&lt;F&gt; f);\n\n    template &lt;typename F, typename UserTag&gt;\n    MUDA_GLOBAL void grid_stride_loop_kernel(ParallelForCallable&lt;F&gt; f);\n}  // namespace details\n\nenum class ParallelForType : uint32_t\n{\n    DynamicBlocks,\n    GridStrideLoop\n};\n\nclass ParallelForDetails\n{\n  public:\n    MUDA_NODISCARD MUDA_DEVICE int  active_num_in_block() const MUDA_NOEXCEPT;\n    MUDA_NODISCARD MUDA_DEVICE bool is_final_block() const MUDA_NOEXCEPT;\n    MUDA_NODISCARD MUDA_DEVICE ParallelForType parallel_for_type() const MUDA_NOEXCEPT\n    {\n        return m_type;\n    }\n\n    MUDA_NODISCARD MUDA_DEVICE int total_num() const MUDA_NOEXCEPT\n    {\n        return m_total_num;\n    }\n    MUDA_NODISCARD MUDA_DEVICE operator int() const MUDA_NOEXCEPT\n    {\n        return m_current_i;\n    }\n\n    MUDA_NODISCARD MUDA_DEVICE int i() const MUDA_NOEXCEPT\n    {\n        return m_current_i;\n    }\n\n    MUDA_NODISCARD MUDA_DEVICE int batch_i() const MUDA_NOEXCEPT\n    {\n        return m_batch_i;\n    }\n\n    MUDA_NODISCARD MUDA_DEVICE int total_batch() const MUDA_NOEXCEPT\n    {\n        return m_total_batch;\n    }\n\n  private:\n    template &lt;typename F, typename UserTag&gt;\n    friend MUDA_GLOBAL void details::parallel_for_kernel(ParallelForCallable&lt;F&gt; f);\n\n    template &lt;typename F, typename UserTag&gt;\n    friend MUDA_GLOBAL void details::grid_stride_loop_kernel(ParallelForCallable&lt;F&gt; f);\n\n    MUDA_DEVICE ParallelForDetails(ParallelForType type, int i, int total_num) MUDA_NOEXCEPT\n        : m_type(type),\n          m_total_num(total_num),\n          m_current_i(i)\n    {\n    }\n\n    ParallelForType m_type;\n    int             m_total_num;\n    int             m_total_batch         = 1;\n    int             m_batch_i             = 0;\n    int             m_active_num_in_block = 0;\n    int             m_current_i           = 0;\n};\n\nusing details::grid_stride_loop_kernel;\nusing details::parallel_for_kernel;\n\n\nclass ParallelFor : public LaunchBase&lt;ParallelFor&gt;\n{\n    int    m_grid_dim;\n    int    m_block_dim;\n    size_t m_shared_mem_size;\n\n  public:\n    template &lt;typename F&gt;\n    using NodeParms = KernelNodeParms&lt;details::ParallelForCallable&lt;raw_type_t&lt;F&gt;&gt;&gt;;\n\n    MUDA_HOST ParallelFor(size_t shared_mem_size = 0, cudaStream_t stream = nullptr) MUDA_NOEXCEPT\n        : LaunchBase(stream),\n          m_grid_dim(0),\n          m_block_dim(-1),\n          m_shared_mem_size(shared_mem_size)\n    {\n    }\n\n    MUDA_HOST ParallelFor(int blockDim, size_t shared_mem_size = 0, cudaStream_t stream = nullptr) MUDA_NOEXCEPT\n        : LaunchBase(stream),\n          m_grid_dim(0),\n          m_block_dim(blockDim),\n          m_shared_mem_size(shared_mem_size)\n    {\n    }\n\n\n    MUDA_HOST ParallelFor(int          gridDim,\n                          int          blockDim,\n                          size_t       shared_mem_size = 0,\n                          cudaStream_t stream          = nullptr) MUDA_NOEXCEPT\n        : LaunchBase(stream),\n          m_grid_dim(gridDim),\n          m_block_dim(blockDim),\n          m_shared_mem_size(shared_mem_size)\n    {\n    }\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST ParallelFor&amp; apply(int count, F&amp;&amp; f);\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST ParallelFor&amp; apply(int count, F&amp;&amp; f, Tag&lt;UserTag&gt;);\n\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST MUDA_NODISCARD auto as_node_parms(int count, F&amp;&amp; f) -&gt; S&lt;NodeParms&lt;F&gt;&gt;;\n\n    template &lt;typename F, typename UserTag = Default&gt;\n    MUDA_HOST MUDA_NODISCARD auto as_node_parms(int count, F&amp;&amp; f, Tag&lt;UserTag&gt;)\n        -&gt; S&lt;NodeParms&lt;F&gt;&gt;;\n\n    MUDA_GENERIC MUDA_NODISCARD static int round_up_blocks(int count, int block_dim) MUDA_NOEXCEPT\n    {\n        return (count + block_dim - 1) / block_dim;\n    }\n\n  public:\n    template &lt;typename F, typename UserTag&gt;\n    MUDA_HOST void invoke(int count, F&amp;&amp; f);\n\n    template &lt;typename F, typename UserTag&gt;\n    MUDA_GENERIC int calculate_block_dim(int count) const MUDA_NOEXCEPT;\n\n    MUDA_GENERIC int calculate_grid_dim(int count) const MUDA_NOEXCEPT;\n\n    static MUDA_GENERIC int calculate_grid_dim(int count, int block_dim) MUDA_NOEXCEPT;\n\n    MUDA_GENERIC void check_input(int count) const MUDA_NOEXCEPT;\n};\n}  // namespace muda\n\n#include \"details/parallel_for.inl\"\n</code></pre>"},{"location":"muda/stream_8h/","title":"File stream.h","text":"<p>FileList &gt; launch &gt; stream.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;device_launch_parameters.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cuda_errors.h&gt;</code></li> <li><code>#include &lt;muda/tools/temp_buffer.h&gt;</code></li> <li><code>#include \"details/stream.inl\"</code></li> </ul>"},{"location":"muda/stream_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/stream_8h/#classes","title":"Classes","text":"Type Name class Stream RAII wrapper for cudaStream. class FireAndForget class GraphFireAndForget class GraphTailLaunch class TailLaunch <p>The documentation for this class was generated from the following file <code>src/muda/launch/stream.h</code></p>"},{"location":"muda/stream_8h_source/","title":"File stream.h","text":"<p>File List &gt; launch &gt; stream.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;device_launch_parameters.h&gt;\n#include &lt;muda/check/check_cuda_errors.h&gt;\n#include &lt;muda/tools/temp_buffer.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass DeviceBuffer;\n\nclass Stream\n{\n    cudaStream_t m_handle = nullptr;\n\n  public:\n    enum class Flag : unsigned int\n    {\n        eDefault     = cudaStreamDefault,\n        eNonBlocking = cudaStreamNonBlocking\n    };\n\n    MUDA_NODISCARD Stream(Flag f = Flag::eDefault);\n    ~Stream();\n\n    operator cudaStream_t() const { return m_handle; }\n    cudaStream_t view() const { return m_handle; }\n\n    // delete copy constructor and copy assignment operator\n    Stream(const Stream&amp;)            = delete;\n    Stream&amp; operator=(const Stream&amp;) = delete;\n\n    // allow move constructor and move assignment operator\n    Stream(Stream&amp;&amp; o) MUDA_NOEXCEPT;\n    Stream&amp; operator=(Stream&amp;&amp; o) MUDA_NOEXCEPT;\n\n    void wait() const;\n\n    void begin_capture(cudaStreamCaptureMode mode = cudaStreamCaptureModeThreadLocal) const;\n    void end_capture(cudaGraph_t* graph) const;\n\n    static Stream&amp; Default();\n\n    class TailLaunch\n    {\n      public:\n        MUDA_DEVICE TailLaunch(){};\n        MUDA_DEVICE operator cudaStream_t() const;\n    };\n\n    class FireAndForget\n    {\n      public:\n        MUDA_DEVICE FireAndForget(){};\n        MUDA_DEVICE operator cudaStream_t() const;\n    };\n\n    class GraphTailLaunch\n    {\n      public:\n        MUDA_DEVICE GraphTailLaunch(){};\n        MUDA_DEVICE operator cudaStream_t() const;\n    };\n\n    class GraphFireAndForget\n    {\n      public:\n        MUDA_DEVICE GraphFireAndForget(){};\n        MUDA_DEVICE operator cudaStream_t() const;\n    };\n\n    std::byte* workspace(size_t byte_size);\n\n  private:\n    Stream(nullptr_t)\n        : m_handle(nullptr)\n    {\n    }\n    details::ByteTempBuffer m_workspace;\n};\n\n\n}  // namespace muda\n\n#include \"details/stream.inl\"\n</code></pre>"},{"location":"muda/stream__define_8h/","title":"File stream_define.h","text":"<p>FileList &gt; launch &gt; stream_define.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;muda/tools/version.h&gt;</code></li> <li><code>#include &lt;cuda_device_runtime_api.h&gt;</code></li> </ul>"},{"location":"muda/stream__define_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details namespace stream <p>The documentation for this class was generated from the following file <code>src/muda/launch/stream_define.h</code></p>"},{"location":"muda/stream__define_8h_source/","title":"File stream_define.h","text":"<p>File List &gt; launch &gt; stream_define.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cinttypes&gt;\n#include &lt;muda/tools/version.h&gt;\n#include &lt;cuda_device_runtime_api.h&gt;\nnamespace muda::details::stream\n{\n#if MUDA_GENERIC_STREAM_MODEL\nMUDA_INLINE MUDA_GENERIC cudaStream_t tail_launch()\n{\n    return cudaStreamTailLaunch;\n}\nMUDA_INLINE MUDA_GENERIC cudaStream_t fire_and_forget()\n{\n    return cudaStreamFireAndForget;\n}\nMUDA_INLINE MUDA_GENERIC cudaStream_t graph_tail_launch()\n{\n    return cudaStreamGraphTailLaunch;\n}\nMUDA_INLINE MUDA_GENERIC cudaStream_t graph_fire_and_forget()\n{\n    return cudaStreamGraphFireAndForget;\n}\n#else\nMUDA_INLINE MUDA_GENERIC cudaStream_t graph_tail_launch()\n{\n    return reinterpret_cast&lt;cudaStream_t&gt;(0x0100000000000000);\n}\nMUDA_INLINE MUDA_GENERIC cudaStream_t graph_fire_and_forget()\n{\n    return reinterpret_cast&lt;cudaStream_t&gt;(0x0200000000000000);\n}\nMUDA_INLINE MUDA_GENERIC cudaStream_t tail_launch()\n{\n    return reinterpret_cast&lt;cudaStream_t&gt;(0x3);\n}\nMUDA_INLINE MUDA_GENERIC cudaStream_t fire_and_forget()\n{\n    return reinterpret_cast&lt;cudaStream_t&gt;(0x4);\n}\n#endif\n}  // namespace muda::details::stream\n</code></pre>"},{"location":"muda/dir_b382702c5a05deb664663fe4596d147e/","title":"Dir src/muda/literal","text":"<p>FileList &gt; literal</p>"},{"location":"muda/dir_b382702c5a05deb664663fe4596d147e/#files","title":"Files","text":"Type Name file unit.h <p>The documentation for this class was generated from the following file <code>src/muda/literal/</code></p>"},{"location":"muda/unit_8h/","title":"File unit.h","text":"<p>FileList &gt; literal &gt; unit.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cinttypes&gt;</code></li> </ul>"},{"location":"muda/unit_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/literal/unit.h</code></p>"},{"location":"muda/unit_8h_source/","title":"File unit.h","text":"<p>File List &gt; literal &gt; unit.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cinttypes&gt;\nnamespace muda\n{\n#ifdef _WIN32\nconstexpr size_t operator\"\" _K(size_t value)\n{\n    return value * 1024;\n}\n\nconstexpr size_t operator\"\" _M(size_t value)\n{\n    return value * 1024 * 1024;\n}\n\nconstexpr size_t operator\"\" _G(size_t value)\n{\n    return value * 1024 * 1024 * 1024;\n}\n\nconstexpr size_t operator\"\" _T(size_t value)\n{\n    return value * 1024 * 1024 * 1024 * 1024;\n}\n\nconstexpr size_t operator\"\" _P(size_t value)\n{\n    return value * 1024 * 1024 * 1024 * 1024 * 1024;\n}\n#elif __linux__\n// TOFIX:\n// temporary workaround for linux\nconstexpr size_t operator\"\" _K(unsigned long long value)\n{\n    return value * 1024;\n}\n\nconstexpr size_t operator\"\" _M(unsigned long long value)\n{\n    return value * 1024 * 1024;\n}\n\nconstexpr size_t operator\"\" _G(unsigned long long value)\n{\n    return value * 1024 * 1024 * 1024;\n}\n\nconstexpr size_t operator\"\" _T(unsigned long long value)\n{\n    return value * 1024 * 1024 * 1024 * 1024;\n}\n\nconstexpr size_t operator\"\" _P(unsigned long long value)\n{\n    return value * 1024 * 1024 * 1024 * 1024 * 1024;\n}\n#endif\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_7d83e812141fe1e865a4aab383f85074/","title":"Dir src/muda/logger","text":"<p>FileList &gt; logger</p>"},{"location":"muda/dir_7d83e812141fe1e865a4aab383f85074/#files","title":"Files","text":"Type Name file logger.h file logger_basic_data.h file logger_function.h file logger_viewer.h <p>The documentation for this class was generated from the following file <code>src/muda/logger/</code></p>"},{"location":"muda/logger_2logger_8h/","title":"File logger.h","text":"<p>FileList &gt; logger &gt; logger.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cuda_errors.h&gt;</code></li> <li><code>#include &lt;cinttypes&gt;</code></li> <li><code>#include &lt;muda/literal/unit.h&gt;</code></li> <li><code>#include &lt;muda/logger/logger_viewer.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_var.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;muda/tools/temp_buffer.h&gt;</code></li> <li><code>#include &lt;muda/logger/details/logger.inl&gt;</code></li> </ul>"},{"location":"muda/logger_2logger_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/logger_2logger_8h/#classes","title":"Classes","text":"Type Name class Logger class LoggerDataContainer class LoggerMetaData <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger.h</code></p>"},{"location":"muda/logger_2logger_8h_source/","title":"File logger.h","text":"<p>File List &gt; logger &gt; logger.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/check/check_cuda_errors.h&gt;\n#include &lt;cinttypes&gt;\n#include &lt;muda/literal/unit.h&gt;\n#include &lt;muda/logger/logger_viewer.h&gt;\n#include &lt;muda/buffer/device_var.h&gt;\n#include &lt;vector&gt;\n#include &lt;muda/tools/temp_buffer.h&gt;\n\nnamespace muda\n{\nclass LoggerMetaData\n{\n  public:\n    uint32_t        id;\n    LoggerBasicType type;\n    void*           data;\n    LoggerFmtArg    fmt_arg;\n    template &lt;typename T&gt;\n    const T&amp; as();\n};\n\nclass LoggerDataContainer\n{\n  public:\n    span&lt;LoggerMetaData&gt; meta_data() { return m_meta_data; }\n\n  private:\n    friend class Logger;\n    std::vector&lt;LoggerMetaData&gt; m_meta_data;\n    std::vector&lt;char&gt;           m_buffer;\n};\n\nclass Logger\n{\n    static constexpr size_t DEFAULT_META_SIZE   = 16_M;\n    static constexpr size_t DEFAULT_BUFFER_SIZE = 128_M;\n\n  public:\n    Logger(LoggerViewer* global_viewer,\n           size_t        meta_size   = DEFAULT_META_SIZE,\n           size_t        buffer_size = DEFAULT_BUFFER_SIZE);\n\n    Logger(size_t meta_size = DEFAULT_META_SIZE, size_t buffer_size = DEFAULT_BUFFER_SIZE)\n        : Logger(nullptr, meta_size, buffer_size)\n    {\n    }\n\n    ~Logger();\n\n    // delete copy\n    Logger(const Logger&amp;)            = delete;\n    Logger&amp; operator=(const Logger&amp;) = delete;\n\n    // allow move\n    Logger(Logger&amp;&amp;) noexcept;\n    Logger&amp; operator=(Logger&amp;&amp;) noexcept;\n\n\n    void retrieve(std::ostream&amp; o = std::cout);\n\n    MUDA_NODISCARD LoggerDataContainer retrieve_meta();\n\n    MUDA_NODISCARD bool is_meta_data_full() const\n    {\n        return m_h_offset.exceed_meta_data;\n    }\n\n    MUDA_NODISCARD bool is_buffer_full() const\n    {\n        return m_h_offset.exceed_buffer;\n    }\n\n    MUDA_NODISCARD LoggerViewer viewer() const\n    {\n        return m_log_viewer_ptr ? *m_log_viewer_ptr : m_viewer;\n    }\n\n  private:\n    friend class LaunchCore;\n    friend class Debug;\n    void expand_meta_data();\n    void expand_buffer();\n    void upload();\n    void download();\n    void expand_if_needed();\n\n    //details::LoggerMetaData* m_meta_data;\n    //size_t                   m_meta_data_size;\n\n\n    details::TempBuffer&lt;uint32_t&gt;                m_sorted_meta_data_id;\n    details::TempBuffer&lt;details::LoggerMetaData&gt; m_sorted_meta_data;\n\n    details::TempBuffer&lt;uint32_t&gt;                m_meta_data_id;\n    details::TempBuffer&lt;details::LoggerMetaData&gt; m_meta_data;\n\n    std::vector&lt;details::LoggerMetaData&gt; m_h_meta_data;\n\n    //char*              m_buffer;\n    //size_t             m_buffer_size;\n    details::TempBuffer&lt;char&gt; m_buffer;\n    std::vector&lt;char&gt;         m_h_buffer;\n\n    //details::LoggerOffset*           m_offset;\n    details::TempBuffer&lt;details::LoggerOffset&gt; m_offset;\n    details::LoggerOffset                      m_h_offset;\n\n    LoggerViewer* m_log_viewer_ptr = nullptr;\n    LoggerViewer  m_viewer;\n    template &lt;typename F&gt;\n    void _retrieve(F&amp;&amp;);\n    void put(std::ostream&amp; os, const details::LoggerMetaData&amp; meta_data) const;\n};\n//MUDA_INLINE __device__ LoggerViewer cout;\n}  // namespace muda\n\n#include &lt;muda/logger/details/logger.inl&gt;\n</code></pre>"},{"location":"muda/logger__basic__data_8h/","title":"File logger_basic_data.h","text":"<p>FileList &gt; logger &gt; logger_basic_data.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cinttypes&gt;</code></li> </ul>"},{"location":"muda/logger__basic__data_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/logger__basic__data_8h/#classes","title":"Classes","text":"Type Name class LoggerMetaData class LoggerOffset <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger_basic_data.h</code></p>"},{"location":"muda/logger__basic__data_8h_source/","title":"File logger_basic_data.h","text":"<p>File List &gt; logger &gt; logger_basic_data.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cinttypes&gt;\n\nnamespace muda\n{\nenum class LoggerBasicType : uint16_t\n{\n    None,\n    Int8,\n    Int16,\n    Int,\n    Int32 = Int,\n    Int64,\n    Long,\n    LongLong,\n\n    UInt8,\n    UInt16,\n    UInt,\n    UInt32 = UInt,\n    UInt64,\n    ULong,\n    ULongLong,\n\n    Float,\n    Double,\n    String,\n    FmtString,\n\n\n    Object,  // user defined object\n};\n\nusing LoggerFmtArg = void (*)(void* formatter, const void* obj);\n\nnamespace details\n{\n    class LoggerMetaData\n    {\n      public:\n        LoggerBasicType type     = LoggerBasicType::None;\n        uint16_t        exceeded = 0;  // false\n        uint32_t        id       = ~0;\n        uint32_t        size     = ~0;\n        uint32_t        offset   = ~0;\n        LoggerFmtArg    fmt_arg  = nullptr;\n    };\n\n    class LoggerOffset\n    {\n      public:\n        uint32_t log_id           = 0;\n        uint32_t meta_data_offset = 0;\n        uint32_t exceed_meta_data = 0;  // false\n        uint32_t buffer_offset    = 0;\n        uint32_t exceed_buffer    = 0;  // false\n    };\n}  // namespace details\n}  // namespace muda\n</code></pre>"},{"location":"muda/logger__function_8h/","title":"File logger_function.h","text":"<p>FileList &gt; logger &gt; logger_function.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/logger/logger_viewer.h&gt;</code></li> </ul>"},{"location":"muda/logger__function_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger_function.h</code></p>"},{"location":"muda/logger__function_8h_source/","title":"File logger_function.h","text":"<p>File List &gt; logger &gt; logger_function.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/logger/logger_viewer.h&gt;\n\nnamespace muda\n{\n// signed\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, char1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, char2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, char3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, char4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, short1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, short2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, short3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, short4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, int1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, int2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, int3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, int4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, long1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, long2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, long3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, long4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, longlong1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, longlong2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, longlong3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, longlong4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\n\n// unsigned\n\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, uchar1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, uchar2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, uchar3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, uchar4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, uint1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, uint2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, uint3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, uint4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, ulong1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, ulong2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, ulong3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\"\n                 &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, ulong4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\"\n                 &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, ulonglong1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, ulonglong2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, ulonglong3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, ulonglong4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\n// float\n\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, float1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, float2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, float3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, float4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, double1 val)\n{\n    return proxy &lt;&lt; val.x;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, double2 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, double3 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z;\n}\nMUDA_INLINE MUDA_DEVICE LogProxy operator&lt;&lt;(LogProxy proxy, double4 val)\n{\n    return proxy &lt;&lt; val.x &lt;&lt; \",\" &lt;&lt; val.y &lt;&lt; \",\" &lt;&lt; val.z &lt;&lt; \",\" &lt;&lt; val.w;\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/logger__viewer_8h/","title":"File logger_viewer.h","text":"<p>FileList &gt; logger &gt; logger_viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/logger/logger_basic_data.h&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cuda_errors.h&gt;</code></li> <li><code>#include &lt;muda/literal/unit.h&gt;</code></li> <li><code>#include &lt;muda/viewer/dense.h&gt;</code></li> <li><code>#include &lt;muda/logger/details/logger_viewer.inl&gt;</code></li> </ul>"},{"location":"muda/logger__viewer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/logger__viewer_8h/#classes","title":"Classes","text":"Type Name class LogProxy class LoggerViewer"},{"location":"muda/logger__viewer_8h/#macros","title":"Macros","text":"Type Name define PROXY_OPERATOR (enum_name, T)"},{"location":"muda/logger__viewer_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/logger__viewer_8h/#define-proxy_operator","title":"define PROXY_OPERATOR","text":"<pre><code>#define PROXY_OPERATOR (\n    enum_name,\n    T\n) MUDA_INLINE MUDA_DEVICE friend LogProxy operator&lt;&lt;(LogProxy p, T v)        \\\n    {                                                                          \\\n        details::LoggerMetaData meta;                                          \\\n        meta.type = LoggerBasicType::enum_name;                                \\\n        meta.size = sizeof(T);                                                 \\\n        meta.id   = p.m_log_id;                                                \\\n        p.push_data(meta, &amp;v);                                                 \\\n        return p;                                                              \\\n    }\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/logger/logger_viewer.h</code></p>"},{"location":"muda/logger__viewer_8h_source/","title":"File logger_viewer.h","text":"<p>File List &gt; logger &gt; logger_viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/logger/logger_basic_data.h&gt;\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/check/check_cuda_errors.h&gt;\n#include &lt;muda/literal/unit.h&gt;\n#include &lt;muda/viewer/dense.h&gt;\nnamespace muda\n{\nclass LoggerViewer;\nclass LogProxy\n{\n    LoggerViewer* m_viewer = nullptr;\n    uint32_t      m_log_id;\n\n  public:\n    MUDA_DEVICE LogProxy() = default;\n    MUDA_DEVICE LogProxy(LoggerViewer&amp; viewer);\n\n    MUDA_DEVICE LogProxy(const LogProxy&amp; other)\n        : m_viewer(other.m_viewer)\n        , m_log_id(other.m_log_id)\n    {\n    }\n\n    template &lt;bool IsFmt&gt;\n    MUDA_DEVICE LogProxy&amp; push_string(const char* str);\n\n    MUDA_DEVICE LogProxy&amp; operator&lt;&lt;(const char* str);\n\n#define PROXY_OPERATOR(enum_name, T)                                           \\\n    MUDA_INLINE MUDA_DEVICE friend LogProxy operator&lt;&lt;(LogProxy p, T v)        \\\n    {                                                                          \\\n        details::LoggerMetaData meta;                                          \\\n        meta.type = LoggerBasicType::enum_name;                                \\\n        meta.size = sizeof(T);                                                 \\\n        meta.id   = p.m_log_id;                                                \\\n        p.push_data(meta, &amp;v);                                                 \\\n        return p;                                                              \\\n    }\n\n    PROXY_OPERATOR(Int8, int8_t);\n    PROXY_OPERATOR(Int16, int16_t);\n    PROXY_OPERATOR(Int32, int32_t);\n    PROXY_OPERATOR(Int64, int64_t);\n\n\n    PROXY_OPERATOR(UInt8, uint8_t);\n    PROXY_OPERATOR(UInt16, uint16_t);\n    PROXY_OPERATOR(UInt32, uint32_t);\n    PROXY_OPERATOR(UInt64, uint64_t);\n\n    PROXY_OPERATOR(Float, float);\n    PROXY_OPERATOR(Double, double);\n\n#ifdef _WIN32\n    PROXY_OPERATOR(Long, long);\n    PROXY_OPERATOR(ULong, unsigned long);\n#elif __linux__\n    PROXY_OPERATOR(LongLong, long long);\n    PROXY_OPERATOR(ULongLong, unsigned long long);\n#endif\n\n#undef PROXY_OPERATOR\n\n    template &lt;typename T&gt;\n    MUDA_DEVICE void push_fmt_arg(const T&amp; obj, LoggerFmtArg fmt_arg_func);\n\n    MUDA_DEVICE bool push_data(const details::LoggerMetaData&amp; meta, const void* data);\n};\nclass LoggerViewer\n{\n  public:\n    friend class Logger;\n    friend class LogProxy;\n\n    template &lt;typename T&gt;\n    MUDA_DEVICE LogProxy operator&lt;&lt;(const T&amp; t);\n    MUDA_DEVICE LogProxy operator&lt;&lt;(const char* s);\n    template &lt;bool IsFmt&gt;\n    MUDA_DEVICE LogProxy push_string(const char* str);\n    MUDA_DEVICE LogProxy proxy() { return LogProxy(*this); }\n\n    MUDA_GENERIC operator bool() const\n    {\n        return m_meta_data &amp;&amp; m_buffer &amp;&amp; m_offset;\n    }\n\n  private:\n    // Don't use viewer, cuda don't allow to use constructor in __device__ global variable\n    // However, LoggerViewer should be able to use as a global variable for debugging\n    uint32_t*                m_meta_data_id      = nullptr;\n    int                      m_meta_data_id_size = 0;\n    details::LoggerMetaData* m_meta_data         = nullptr;\n    int                      m_meta_data_size    = 0;\n    char*                    m_buffer            = nullptr;\n    int                      m_buffer_size       = 0;\n    details::LoggerOffset*   m_offset            = nullptr;\n\n    MUDA_DEVICE uint32_t next_meta_data_idx() const;\n    MUDA_DEVICE uint32_t next_buffer_idx(uint32_t size) const;\n    MUDA_DEVICE bool push_data(details::LoggerMetaData meta, const void* data);\n};\n}  // namespace muda\n\n#include &lt;muda/logger/details/logger_viewer.inl&gt;\n</code></pre>"},{"location":"muda/dir_76b30f276e6a3b8973955140272e7c63/","title":"Dir src/muda/mstl","text":"<p>FileList &gt; mstl</p>"},{"location":"muda/dir_76b30f276e6a3b8973955140272e7c63/#files","title":"Files","text":"Type Name file span.h"},{"location":"muda/dir_76b30f276e6a3b8973955140272e7c63/#directories","title":"Directories","text":"Type Name dir tcb <p>The documentation for this class was generated from the following file <code>src/muda/mstl/</code></p>"},{"location":"muda/span_8h/","title":"File span.h","text":"<p>FileList &gt; mstl &gt; span.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/platform.h&gt;</code></li> <li><code>#include &lt;muda/mstl/tcb/span.hpp&gt;</code></li> </ul>"},{"location":"muda/span_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/mstl/span.h</code></p>"},{"location":"muda/span_8h_source/","title":"File span.h","text":"<p>File List &gt; mstl &gt; span.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/platform.h&gt;\n#include &lt;muda/mstl/tcb/span.hpp&gt;\n#if MUDA_HAS_CXX20\n#include &lt;span&gt;\n#endif\n\nnamespace muda\n{\n#if MUDA_HAS_CXX20\nusing std::span;\n#else\ntemplate &lt;typename T&gt;\nusing span = tcb::span&lt;T&gt;;\n#endif\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_98b3ad4083edbdd3c811d05568c94a59/","title":"Dir src/muda/mstl/tcb","text":"<p>FileList &gt; mstl &gt; tcb</p>"},{"location":"muda/dir_98b3ad4083edbdd3c811d05568c94a59/#files","title":"Files","text":"Type Name file span.hpp <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/</code></p>"},{"location":"muda/span_8hpp/","title":"File span.hpp","text":"<p>FileList &gt; mstl &gt; tcb &gt; span.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"muda/span_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace TCB_SPAN_NAMESPACE_NAME namespace detail namespace std"},{"location":"muda/span_8hpp/#classes","title":"Classes","text":"Type Name struct has_size_and_data &lt;typename, typename&gt; struct has_size_and_data &lt;typename, typename&gt; struct is_complete &lt;typename, typename&gt; struct is_complete &lt;typename, typename&gt; struct is_container &lt;typename C, typename U&gt; struct is_container_element_type_compatible &lt;typename, typename, typename&gt; struct is_container_element_type_compatible &lt;typename, typename, typename&gt; struct is_span &lt;typename&gt; struct is_span &lt;typename&gt; struct is_std_array &lt;typename&gt; struct is_std_array &lt;typename&gt; struct span_storage &lt;typename E, S&gt; struct span_storage &lt;typename E, S&gt; class span &lt;typename ElementType, Extent&gt; class tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; &lt;I, typename ElementType, Extent&gt; class tuple_size&lt; TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; &lt;typename ElementType, Extent&gt;"},{"location":"muda/span_8hpp/#macros","title":"Macros","text":"Type Name define TCB_SPAN_ARRAY_CONSTEXPR define TCB_SPAN_CONSTEXPR11  constexpr define TCB_SPAN_CONSTEXPR14 define TCB_SPAN_CONSTEXPR_ASSIGN define TCB_SPAN_EXPECT (cond)  define TCB_SPAN_INLINE_VAR define TCB_SPAN_NAMESPACE_NAME  tcb define TCB_SPAN_NODISCARD define TCB_SPAN_NO_CONTRACT_CHECKING define TCB_SPAN_NO_EXCEPTIONS"},{"location":"muda/span_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/span_8hpp/#define-tcb_span_array_constexpr","title":"define TCB_SPAN_ARRAY_CONSTEXPR","text":"<pre><code>#define TCB_SPAN_ARRAY_CONSTEXPR \n</code></pre>"},{"location":"muda/span_8hpp/#define-tcb_span_constexpr11","title":"define TCB_SPAN_CONSTEXPR11","text":"<pre><code>#define TCB_SPAN_CONSTEXPR11 constexpr\n</code></pre>"},{"location":"muda/span_8hpp/#define-tcb_span_constexpr14","title":"define TCB_SPAN_CONSTEXPR14","text":"<pre><code>#define TCB_SPAN_CONSTEXPR14 \n</code></pre>"},{"location":"muda/span_8hpp/#define-tcb_span_constexpr_assign","title":"define TCB_SPAN_CONSTEXPR_ASSIGN","text":"<pre><code>#define TCB_SPAN_CONSTEXPR_ASSIGN \n</code></pre>"},{"location":"muda/span_8hpp/#define-tcb_span_expect","title":"define TCB_SPAN_EXPECT","text":"<pre><code>#define TCB_SPAN_EXPECT (\n    cond\n) \n</code></pre>"},{"location":"muda/span_8hpp/#define-tcb_span_inline_var","title":"define TCB_SPAN_INLINE_VAR","text":"<pre><code>#define TCB_SPAN_INLINE_VAR \n</code></pre>"},{"location":"muda/span_8hpp/#define-tcb_span_namespace_name","title":"define TCB_SPAN_NAMESPACE_NAME","text":"<pre><code>#define TCB_SPAN_NAMESPACE_NAME tcb\n</code></pre>"},{"location":"muda/span_8hpp/#define-tcb_span_nodiscard","title":"define TCB_SPAN_NODISCARD","text":"<pre><code>#define TCB_SPAN_NODISCARD \n</code></pre>"},{"location":"muda/span_8hpp/#define-tcb_span_no_contract_checking","title":"define TCB_SPAN_NO_CONTRACT_CHECKING","text":"<pre><code>#define TCB_SPAN_NO_CONTRACT_CHECKING \n</code></pre>"},{"location":"muda/span_8hpp/#define-tcb_span_no_exceptions","title":"define TCB_SPAN_NO_EXCEPTIONS","text":"<pre><code>#define TCB_SPAN_NO_EXCEPTIONS \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/mstl/tcb/span.hpp</code></p>"},{"location":"muda/span_8hpp_source/","title":"File span.hpp","text":"<p>File List &gt; mstl &gt; tcb &gt; span.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\nThis is an implementation of C++20's std::span\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4820.pdf\n*/\n\n//          Copyright Tristan Brindle 2018.\n// Distributed under the Boost Software License, Version 1.0.\n//    (See accompanying file ../../LICENSE_1_0.txt or copy at\n//          https://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef TCB_SPAN_HPP_INCLUDED\n#define TCB_SPAN_HPP_INCLUDED\n\n#include &lt;array&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;type_traits&gt;\n\n#ifndef TCB_SPAN_NO_EXCEPTIONS\n// Attempt to discover whether we're being compiled with exception support\n#if !(defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND))\n#define TCB_SPAN_NO_EXCEPTIONS\n#endif\n#endif\n\n#ifndef TCB_SPAN_NO_EXCEPTIONS\n#include &lt;cstdio&gt;\n#include &lt;stdexcept&gt;\n#endif\n\n// Various feature test macros\n\n#ifndef TCB_SPAN_NAMESPACE_NAME\n#define TCB_SPAN_NAMESPACE_NAME tcb\n#endif\n\n#if __cplusplus &gt;= 201703L || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201703L)\n#define TCB_SPAN_HAVE_CPP17\n#endif\n\n#if __cplusplus &gt;= 201402L || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201402L)\n#define TCB_SPAN_HAVE_CPP14\n#endif\n\nnamespace TCB_SPAN_NAMESPACE_NAME {\n\n// Establish default contract checking behavior\n#if !defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION) &amp;&amp;                          \\\n    !defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION) &amp;&amp;                      \\\n    !defined(TCB_SPAN_NO_CONTRACT_CHECKING)\n#if defined(NDEBUG) || !defined(TCB_SPAN_HAVE_CPP14)\n#define TCB_SPAN_NO_CONTRACT_CHECKING\n#else\n#define TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION\n#endif\n#endif\n\n#if defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION)\nstruct contract_violation_error : std::logic_error {\n    explicit contract_violation_error(const char* msg) : std::logic_error(msg)\n    {}\n};\n\ninline void contract_violation(const char* msg)\n{\n    throw contract_violation_error(msg);\n}\n\n#elif defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION)\n[[noreturn]] inline void contract_violation(const char* /*unused*/)\n{\n    std::terminate();\n}\n#endif\n\n#if !defined(TCB_SPAN_NO_CONTRACT_CHECKING)\n#define TCB_SPAN_STRINGIFY(cond) #cond\n#define TCB_SPAN_EXPECT(cond)                                                  \\\n    cond ? (void) 0 : contract_violation(\"Expected \" TCB_SPAN_STRINGIFY(cond))\n#else\n#define TCB_SPAN_EXPECT(cond)\n#endif\n\n#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_inline_variables)\n#define TCB_SPAN_INLINE_VAR inline\n#else\n#define TCB_SPAN_INLINE_VAR\n#endif\n\n#if defined(TCB_SPAN_HAVE_CPP14) ||                                            \\\n    (defined(__cpp_constexpr) &amp;&amp; __cpp_constexpr &gt;= 201304)\n#define TCB_SPAN_HAVE_CPP14_CONSTEXPR\n#endif\n\n#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR)\n#define TCB_SPAN_CONSTEXPR14 constexpr\n#else\n#define TCB_SPAN_CONSTEXPR14\n#endif\n\n#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR) &amp;&amp;                                  \\\n    (!defined(_MSC_VER) || _MSC_VER &gt; 1900)\n#define TCB_SPAN_CONSTEXPR_ASSIGN constexpr\n#else\n#define TCB_SPAN_CONSTEXPR_ASSIGN\n#endif\n\n#if defined(TCB_SPAN_NO_CONTRACT_CHECKING)\n#define TCB_SPAN_CONSTEXPR11 constexpr\n#else\n#define TCB_SPAN_CONSTEXPR11 TCB_SPAN_CONSTEXPR14\n#endif\n\n#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_deduction_guides)\n#define TCB_SPAN_HAVE_DEDUCTION_GUIDES\n#endif\n\n#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_byte)\n#define TCB_SPAN_HAVE_STD_BYTE\n#endif\n\n#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_array_constexpr)\n#define TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC\n#endif\n\n#if defined(TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC)\n#define TCB_SPAN_ARRAY_CONSTEXPR constexpr\n#else\n#define TCB_SPAN_ARRAY_CONSTEXPR\n#endif\n\n#ifdef TCB_SPAN_HAVE_STD_BYTE\nusing byte = std::byte;\n#else\nusing byte = unsigned char;\n#endif\n\n#if defined(TCB_SPAN_HAVE_CPP17)\n#define TCB_SPAN_NODISCARD [[nodiscard]]\n#else\n#define TCB_SPAN_NODISCARD\n#endif\n\nTCB_SPAN_INLINE_VAR constexpr std::size_t dynamic_extent = SIZE_MAX;\n\ntemplate &lt;typename ElementType, std::size_t Extent = dynamic_extent&gt;\nclass span;\n\nnamespace detail {\n\ntemplate &lt;typename E, std::size_t S&gt;\nstruct span_storage {\n    constexpr span_storage() noexcept = default;\n\n    constexpr span_storage(E* p_ptr, std::size_t /*unused*/) noexcept\n       : ptr(p_ptr)\n    {}\n\n    E* ptr = nullptr;\n    static constexpr std::size_t size = S;\n};\n\ntemplate &lt;typename E&gt;\nstruct span_storage&lt;E, dynamic_extent&gt; {\n    constexpr span_storage() noexcept = default;\n\n    constexpr span_storage(E* p_ptr, std::size_t p_size) noexcept\n        : ptr(p_ptr), size(p_size)\n    {}\n\n    E* ptr = nullptr;\n    std::size_t size = 0;\n};\n\n// Reimplementation of C++17 std::size() and std::data()\n#if defined(TCB_SPAN_HAVE_CPP17) ||                                            \\\n    defined(__cpp_lib_nonmember_container_access)\nusing std::data;\nusing std::size;\n#else\ntemplate &lt;class C&gt;\nconstexpr auto size(const C&amp; c) -&gt; decltype(c.size())\n{\n    return c.size();\n}\n\ntemplate &lt;class T, std::size_t N&gt;\nconstexpr std::size_t size(const T (&amp;)[N]) noexcept\n{\n    return N;\n}\n\ntemplate &lt;class C&gt;\nconstexpr auto data(C&amp; c) -&gt; decltype(c.data())\n{\n    return c.data();\n}\n\ntemplate &lt;class C&gt;\nconstexpr auto data(const C&amp; c) -&gt; decltype(c.data())\n{\n    return c.data();\n}\n\ntemplate &lt;class T, std::size_t N&gt;\nconstexpr T* data(T (&amp;array)[N]) noexcept\n{\n    return array;\n}\n\ntemplate &lt;class E&gt;\nconstexpr const E* data(std::initializer_list&lt;E&gt; il) noexcept\n{\n    return il.begin();\n}\n#endif // TCB_SPAN_HAVE_CPP17\n\n#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_void_t)\nusing std::void_t;\n#else\ntemplate &lt;typename...&gt;\nusing void_t = void;\n#endif\n\ntemplate &lt;typename T&gt;\nusing uncvref_t =\n    typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type;\n\ntemplate &lt;typename&gt;\nstruct is_span : std::false_type {};\n\ntemplate &lt;typename T, std::size_t S&gt;\nstruct is_span&lt;span&lt;T, S&gt;&gt; : std::true_type {};\n\ntemplate &lt;typename&gt;\nstruct is_std_array : std::false_type {};\n\ntemplate &lt;typename T, std::size_t N&gt;\nstruct is_std_array&lt;std::array&lt;T, N&gt;&gt; : std::true_type {};\n\ntemplate &lt;typename, typename = void&gt;\nstruct has_size_and_data : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_size_and_data&lt;T, void_t&lt;decltype(detail::size(std::declval&lt;T&gt;())),\n                                   decltype(detail::data(std::declval&lt;T&gt;()))&gt;&gt;\n    : std::true_type {};\n\ntemplate &lt;typename C, typename U = uncvref_t&lt;C&gt;&gt;\nstruct is_container {\n    static constexpr bool value =\n        !is_span&lt;U&gt;::value &amp;&amp; !is_std_array&lt;U&gt;::value &amp;&amp;\n        !std::is_array&lt;U&gt;::value &amp;&amp; has_size_and_data&lt;C&gt;::value;\n};\n\ntemplate &lt;typename T&gt;\nusing remove_pointer_t = typename std::remove_pointer&lt;T&gt;::type;\n\ntemplate &lt;typename, typename, typename = void&gt;\nstruct is_container_element_type_compatible : std::false_type {};\n\ntemplate &lt;typename T, typename E&gt;\nstruct is_container_element_type_compatible&lt;\n    T, E,\n    typename std::enable_if&lt;\n        !std::is_same&lt;\n            typename std::remove_cv&lt;decltype(detail::data(std::declval&lt;T&gt;()))&gt;::type,\n            void&gt;::value &amp;&amp;\n        std::is_convertible&lt;\n            remove_pointer_t&lt;decltype(detail::data(std::declval&lt;T&gt;()))&gt; (*)[],\n            E (*)[]&gt;::value\n        &gt;::type&gt;\n    : std::true_type {};\n\ntemplate &lt;typename, typename = size_t&gt;\nstruct is_complete : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct is_complete&lt;T, decltype(sizeof(T))&gt; : std::true_type {};\n\n} // namespace detail\n\ntemplate &lt;typename ElementType, std::size_t Extent&gt;\nclass span {\n    static_assert(std::is_object&lt;ElementType&gt;::value,\n                  \"A span's ElementType must be an object type (not a \"\n                  \"reference type or void)\");\n    static_assert(detail::is_complete&lt;ElementType&gt;::value,\n                  \"A span's ElementType must be a complete type (not a forward \"\n                  \"declaration)\");\n    static_assert(!std::is_abstract&lt;ElementType&gt;::value,\n                  \"A span's ElementType cannot be an abstract class type\");\n\n    using storage_type = detail::span_storage&lt;ElementType, Extent&gt;;\n\npublic:\n    // constants and types\n    using element_type = ElementType;\n    using value_type = typename std::remove_cv&lt;ElementType&gt;::type;\n    using size_type = std::size_t;\n    using difference_type = std::ptrdiff_t;\n    using pointer = element_type*;\n    using const_pointer = const element_type*;\n    using reference = element_type&amp;;\n    using const_reference = const element_type&amp;;\n    using iterator = pointer;\n    using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;\n\n    static constexpr size_type extent = Extent;\n\n    // [span.cons], span constructors, copy, assignment, and destructor\n    template &lt;\n        std::size_t E = Extent,\n        typename std::enable_if&lt;(E == dynamic_extent || E &lt;= 0), int&gt;::type = 0&gt;\n    constexpr span() noexcept\n    {}\n\n    TCB_SPAN_CONSTEXPR11 span(pointer ptr, size_type count)\n        : storage_(ptr, count)\n    {\n        TCB_SPAN_EXPECT(extent == dynamic_extent || count == extent);\n    }\n\n    TCB_SPAN_CONSTEXPR11 span(pointer first_elem, pointer last_elem)\n        : storage_(first_elem, last_elem - first_elem)\n    {\n        TCB_SPAN_EXPECT(extent == dynamic_extent ||\n                        last_elem - first_elem ==\n                            static_cast&lt;std::ptrdiff_t&gt;(extent));\n    }\n\n    template &lt;std::size_t N, std::size_t E = Extent,\n              typename std::enable_if&lt;\n                  (E == dynamic_extent || N == E) &amp;&amp;\n                      detail::is_container_element_type_compatible&lt;\n                          element_type (&amp;)[N], ElementType&gt;::value,\n                  int&gt;::type = 0&gt;\n    constexpr span(element_type (&amp;arr)[N]) noexcept : storage_(arr, N)\n    {}\n\n    template &lt;typename T, std::size_t N, std::size_t E = Extent,\n              typename std::enable_if&lt;\n                  (E == dynamic_extent || N == E) &amp;&amp;\n                      detail::is_container_element_type_compatible&lt;\n                          std::array&lt;T, N&gt;&amp;, ElementType&gt;::value,\n                  int&gt;::type = 0&gt;\n    TCB_SPAN_ARRAY_CONSTEXPR span(std::array&lt;T, N&gt;&amp; arr) noexcept\n        : storage_(arr.data(), N)\n    {}\n\n    template &lt;typename T, std::size_t N, std::size_t E = Extent,\n              typename std::enable_if&lt;\n                  (E == dynamic_extent || N == E) &amp;&amp;\n                      detail::is_container_element_type_compatible&lt;\n                          const std::array&lt;T, N&gt;&amp;, ElementType&gt;::value,\n                  int&gt;::type = 0&gt;\n    TCB_SPAN_ARRAY_CONSTEXPR span(const std::array&lt;T, N&gt;&amp; arr) noexcept\n        : storage_(arr.data(), N)\n    {}\n\n    template &lt;\n        typename Container, std::size_t E = Extent,\n        typename std::enable_if&lt;\n            E == dynamic_extent &amp;&amp; detail::is_container&lt;Container&gt;::value &amp;&amp;\n                detail::is_container_element_type_compatible&lt;\n                    Container&amp;, ElementType&gt;::value,\n            int&gt;::type = 0&gt;\n    constexpr span(Container&amp; cont)\n        : storage_(detail::data(cont), detail::size(cont))\n    {}\n\n    template &lt;\n        typename Container, std::size_t E = Extent,\n        typename std::enable_if&lt;\n            E == dynamic_extent &amp;&amp; detail::is_container&lt;Container&gt;::value &amp;&amp;\n                detail::is_container_element_type_compatible&lt;\n                    const Container&amp;, ElementType&gt;::value,\n            int&gt;::type = 0&gt;\n    constexpr span(const Container&amp; cont)\n        : storage_(detail::data(cont), detail::size(cont))\n    {}\n\n    constexpr span(const span&amp; other) noexcept = default;\n\n    template &lt;typename OtherElementType, std::size_t OtherExtent,\n              typename std::enable_if&lt;\n                  (Extent == dynamic_extent || OtherExtent == dynamic_extent ||\n                   Extent == OtherExtent) &amp;&amp;\n                      std::is_convertible&lt;OtherElementType (*)[],\n                                          ElementType (*)[]&gt;::value,\n                  int&gt;::type = 0&gt;\n    constexpr span(const span&lt;OtherElementType, OtherExtent&gt;&amp; other) noexcept\n        : storage_(other.data(), other.size())\n    {}\n\n    ~span() noexcept = default;\n\n    TCB_SPAN_CONSTEXPR_ASSIGN span&amp;\n    operator=(const span&amp; other) noexcept = default;\n\n    // [span.sub], span subviews\n    template &lt;std::size_t Count&gt;\n    TCB_SPAN_CONSTEXPR11 span&lt;element_type, Count&gt; first() const\n    {\n        TCB_SPAN_EXPECT(Count &lt;= size());\n        return {data(), Count};\n    }\n\n    template &lt;std::size_t Count&gt;\n    TCB_SPAN_CONSTEXPR11 span&lt;element_type, Count&gt; last() const\n    {\n        TCB_SPAN_EXPECT(Count &lt;= size());\n        return {data() + (size() - Count), Count};\n    }\n\n    template &lt;std::size_t Offset, std::size_t Count = dynamic_extent&gt;\n    using subspan_return_t =\n        span&lt;ElementType, Count != dynamic_extent\n                              ? Count\n                              : (Extent != dynamic_extent ? Extent - Offset\n                                                          : dynamic_extent)&gt;;\n\n    template &lt;std::size_t Offset, std::size_t Count = dynamic_extent&gt;\n    TCB_SPAN_CONSTEXPR11 subspan_return_t&lt;Offset, Count&gt; subspan() const\n    {\n        TCB_SPAN_EXPECT(Offset &lt;= size() &amp;&amp;\n                        (Count == dynamic_extent || Offset + Count &lt;= size()));\n        return {data() + Offset,\n                Count != dynamic_extent ? Count : size() - Offset};\n    }\n\n    TCB_SPAN_CONSTEXPR11 span&lt;element_type, dynamic_extent&gt;\n    first(size_type count) const\n    {\n        TCB_SPAN_EXPECT(count &lt;= size());\n        return {data(), count};\n    }\n\n    TCB_SPAN_CONSTEXPR11 span&lt;element_type, dynamic_extent&gt;\n    last(size_type count) const\n    {\n        TCB_SPAN_EXPECT(count &lt;= size());\n        return {data() + (size() - count), count};\n    }\n\n    TCB_SPAN_CONSTEXPR11 span&lt;element_type, dynamic_extent&gt;\n    subspan(size_type offset, size_type count = dynamic_extent) const\n    {\n        TCB_SPAN_EXPECT(offset &lt;= size() &amp;&amp;\n                        (count == dynamic_extent || offset + count &lt;= size()));\n        return {data() + offset,\n                count == dynamic_extent ? size() - offset : count};\n    }\n\n    // [span.obs], span observers\n    constexpr size_type size() const noexcept { return storage_.size; }\n\n    constexpr size_type size_bytes() const noexcept\n    {\n        return size() * sizeof(element_type);\n    }\n\n    TCB_SPAN_NODISCARD constexpr bool empty() const noexcept\n    {\n        return size() == 0;\n    }\n\n    // [span.elem], span element access\n    TCB_SPAN_CONSTEXPR11 reference operator[](size_type idx) const\n    {\n        TCB_SPAN_EXPECT(idx &lt; size());\n        return *(data() + idx);\n    }\n\n    TCB_SPAN_CONSTEXPR11 reference front() const\n    {\n        TCB_SPAN_EXPECT(!empty());\n        return *data();\n    }\n\n    TCB_SPAN_CONSTEXPR11 reference back() const\n    {\n        TCB_SPAN_EXPECT(!empty());\n        return *(data() + (size() - 1));\n    }\n\n    constexpr pointer data() const noexcept { return storage_.ptr; }\n\n    // [span.iterators], span iterator support\n    constexpr iterator begin() const noexcept { return data(); }\n\n    constexpr iterator end() const noexcept { return data() + size(); }\n\n    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rbegin() const noexcept\n    {\n        return reverse_iterator(end());\n    }\n\n    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rend() const noexcept\n    {\n        return reverse_iterator(begin());\n    }\n\nprivate:\n    storage_type storage_{};\n};\n\n#ifdef TCB_SPAN_HAVE_DEDUCTION_GUIDES\n\n/* Deduction Guides */\ntemplate &lt;class T, size_t N&gt;\nspan(T (&amp;)[N])-&gt;span&lt;T, N&gt;;\n\ntemplate &lt;class T, size_t N&gt;\nspan(std::array&lt;T, N&gt;&amp;)-&gt;span&lt;T, N&gt;;\n\ntemplate &lt;class T, size_t N&gt;\nspan(const std::array&lt;T, N&gt;&amp;)-&gt;span&lt;const T, N&gt;;\n\ntemplate &lt;class Container&gt;\nspan(Container&amp;)-&gt;span&lt;typename std::remove_reference&lt;\n    decltype(*detail::data(std::declval&lt;Container&amp;&gt;()))&gt;::type&gt;;\n\ntemplate &lt;class Container&gt;\nspan(const Container&amp;)-&gt;span&lt;const typename Container::value_type&gt;;\n\n#endif // TCB_HAVE_DEDUCTION_GUIDES\n\ntemplate &lt;typename ElementType, std::size_t Extent&gt;\nconstexpr span&lt;ElementType, Extent&gt;\nmake_span(span&lt;ElementType, Extent&gt; s) noexcept\n{\n    return s;\n}\n\ntemplate &lt;typename T, std::size_t N&gt;\nconstexpr span&lt;T, N&gt; make_span(T (&amp;arr)[N]) noexcept\n{\n    return {arr};\n}\n\ntemplate &lt;typename T, std::size_t N&gt;\nTCB_SPAN_ARRAY_CONSTEXPR span&lt;T, N&gt; make_span(std::array&lt;T, N&gt;&amp; arr) noexcept\n{\n    return {arr};\n}\n\ntemplate &lt;typename T, std::size_t N&gt;\nTCB_SPAN_ARRAY_CONSTEXPR span&lt;const T, N&gt;\nmake_span(const std::array&lt;T, N&gt;&amp; arr) noexcept\n{\n    return {arr};\n}\n\ntemplate &lt;typename Container&gt;\nconstexpr span&lt;typename std::remove_reference&lt;\n    decltype(*detail::data(std::declval&lt;Container&amp;&gt;()))&gt;::type&gt;\nmake_span(Container&amp; cont)\n{\n    return {cont};\n}\n\ntemplate &lt;typename Container&gt;\nconstexpr span&lt;const typename Container::value_type&gt;\nmake_span(const Container&amp; cont)\n{\n    return {cont};\n}\n\ntemplate &lt;typename ElementType, std::size_t Extent&gt;\nspan&lt;const byte, ((Extent == dynamic_extent) ? dynamic_extent\n                                             : sizeof(ElementType) * Extent)&gt;\nas_bytes(span&lt;ElementType, Extent&gt; s) noexcept\n{\n    return {reinterpret_cast&lt;const byte*&gt;(s.data()), s.size_bytes()};\n}\n\ntemplate &lt;\n    class ElementType, size_t Extent,\n    typename std::enable_if&lt;!std::is_const&lt;ElementType&gt;::value, int&gt;::type = 0&gt;\nspan&lt;byte, ((Extent == dynamic_extent) ? dynamic_extent\n                                       : sizeof(ElementType) * Extent)&gt;\nas_writable_bytes(span&lt;ElementType, Extent&gt; s) noexcept\n{\n    return {reinterpret_cast&lt;byte*&gt;(s.data()), s.size_bytes()};\n}\n\ntemplate &lt;std::size_t N, typename E, std::size_t S&gt;\nconstexpr auto get(span&lt;E, S&gt; s) -&gt; decltype(s[N])\n{\n    return s[N];\n}\n\n} // namespace TCB_SPAN_NAMESPACE_NAME\n\nnamespace std {\n\ntemplate &lt;typename ElementType, size_t Extent&gt;\nclass tuple_size&lt;TCB_SPAN_NAMESPACE_NAME::span&lt;ElementType, Extent&gt;&gt;\n    : public integral_constant&lt;size_t, Extent&gt; {};\n\ntemplate &lt;typename ElementType&gt;\nclass tuple_size&lt;TCB_SPAN_NAMESPACE_NAME::span&lt;\n    ElementType, TCB_SPAN_NAMESPACE_NAME::dynamic_extent&gt;&gt;; // not defined\n\ntemplate &lt;size_t I, typename ElementType, size_t Extent&gt;\nclass tuple_element&lt;I, TCB_SPAN_NAMESPACE_NAME::span&lt;ElementType, Extent&gt;&gt; {\npublic:\n    static_assert(Extent != TCB_SPAN_NAMESPACE_NAME::dynamic_extent &amp;&amp;\n                      I &lt; Extent,\n                  \"\");\n    using type = ElementType;\n};\n\n} // end namespace std\n\n#endif // TCB_SPAN_HPP_INCLUDED\n</code></pre>"},{"location":"muda/dir_4d62fb1c1e2c9fb3fa1c4847a09b7b77/","title":"Dir src/muda/tools","text":"<p>FileList &gt; muda &gt; tools</p>"},{"location":"muda/dir_4d62fb1c1e2c9fb3fa1c4847a09b7b77/#files","title":"Files","text":"Type Name file cuda_vec_utils.h file debug_break.h file debug_log.h file extent.h file filesystem.h file flag.h file fuzzy.h file host_device_config.h file host_device_string_cache.h file id_with_type.h file launch_info_cache.h file platform.h file string_pointer.h file temp_buffer.h file version.h <p>The documentation for this class was generated from the following file <code>src/muda/tools/</code></p>"},{"location":"muda/cuda__vec__utils_8h/","title":"File cuda_vec_utils.h","text":"<p>FileList &gt; muda &gt; tools &gt; cuda_vec_utils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;vector_types.h&gt;</code></li> </ul>"},{"location":"muda/cuda__vec__utils_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/tools/cuda_vec_utils.h</code></p>"},{"location":"muda/cuda__vec__utils_8h_source/","title":"File cuda_vec_utils.h","text":"<p>File List &gt; muda &gt; tools &gt; cuda_vec_utils.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n#include &lt;vector_types.h&gt;\n\nnamespace muda\n{\nMUDA_INLINE MUDA_GENERIC int2 operator+(const int2&amp; a, const int2&amp; b)\n{\n    return make_int2(a.x + b.x, a.y + b.y);\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/debug__break_8h/","title":"File debug_break.h","text":"<p>FileList &gt; muda &gt; tools &gt; debug_break.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;signal.h&gt;</code></li> </ul>"},{"location":"muda/debug__break_8h/#public-functions","title":"Public Functions","text":"Type Name __attribute__ ((always_inline))"},{"location":"muda/debug__break_8h/#macros","title":"Macros","text":"Type Name define DEBUG_BREAK_IMPL  DEBUG_BREAK_USE_SIGTRAP define DEBUG_BREAK_USE_BULTIN_TRAP  2 define DEBUG_BREAK_USE_SIGTRAP  3 define DEBUG_BREAK_USE_TRAP_INSTRUCTION  1"},{"location":"muda/debug__break_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"muda/debug__break_8h/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (always_inline)\n) \n</code></pre>"},{"location":"muda/debug__break_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/debug__break_8h/#define-debug_break_impl","title":"define DEBUG_BREAK_IMPL","text":"<pre><code>#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_SIGTRAP\n</code></pre>"},{"location":"muda/debug__break_8h/#define-debug_break_use_bultin_trap","title":"define DEBUG_BREAK_USE_BULTIN_TRAP","text":"<pre><code>#define DEBUG_BREAK_USE_BULTIN_TRAP 2\n</code></pre>"},{"location":"muda/debug__break_8h/#define-debug_break_use_sigtrap","title":"define DEBUG_BREAK_USE_SIGTRAP","text":"<pre><code>#define DEBUG_BREAK_USE_SIGTRAP 3\n</code></pre>"},{"location":"muda/debug__break_8h/#define-debug_break_use_trap_instruction","title":"define DEBUG_BREAK_USE_TRAP_INSTRUCTION","text":"<pre><code>#define DEBUG_BREAK_USE_TRAP_INSTRUCTION 1\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/debug_break.h</code></p>"},{"location":"muda/debug__break_8h_source/","title":"File debug_break.h","text":"<p>File List &gt; muda &gt; tools &gt; debug_break.h</p> <p>Go to the documentation of this file</p> <pre><code>/* Copyright (c) 2011-2021, Scott Tsai\n * \n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#ifndef DEBUG_BREAK_H\n#define DEBUG_BREAK_H\n\n#ifdef _MSC_VER\ninline static void debug_break(void) \n{\n    __debugbreak();\n}\n#else\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define DEBUG_BREAK_USE_TRAP_INSTRUCTION 1\n#define DEBUG_BREAK_USE_BULTIN_TRAP 2\n#define DEBUG_BREAK_USE_SIGTRAP 3\n\n#if defined(__i386__) || defined(__x86_64__)\n#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION\n__inline__ static void trap_instruction(void)\n{\n    __asm__ volatile(\"int $0x03\");\n}\n#elif defined(__thumb__)\n#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION\n/* FIXME: handle __THUMB_INTERWORK__ */\n__attribute__((always_inline)) __inline__ static void trap_instruction(void)\n{\n    /* See 'arm-linux-tdep.c' in GDB source.\n     * Both instruction sequences below work. */\n#if 1\n    /* 'eabi_linux_thumb_le_breakpoint' */\n    __asm__ volatile(\".inst 0xde01\");\n#else\n    /* 'eabi_linux_thumb2_le_breakpoint' */\n    __asm__ volatile(\".inst.w 0xf7f0a000\");\n#endif\n\n    /* Known problem:\n     * After a breakpoint hit, can't 'stepi', 'step', or 'continue' in GDB.\n     * 'step' would keep getting stuck on the same instruction.\n     *\n     * Workaround: use the new GDB commands 'debugbreak-step' and\n     * 'debugbreak-continue' that become available\n     * after you source the script from GDB:\n     *\n     * $ gdb -x debugbreak-gdb.py &lt;... USUAL ARGUMENTS ...&gt;\n     *\n     * 'debugbreak-step' would jump over the breakpoint instruction with\n     * roughly equivalent of:\n     * (gdb) set $instruction_len = 2\n     * (gdb) tbreak *($pc + $instruction_len)\n     * (gdb) jump   *($pc + $instruction_len)\n     */\n}\n#elif defined(__arm__) &amp;&amp; !defined(__thumb__)\n#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION\n__attribute__((always_inline)) __inline__ static void trap_instruction(void)\n{\n    /* See 'arm-linux-tdep.c' in GDB source,\n     * 'eabi_linux_arm_le_breakpoint' */\n    __asm__ volatile(\".inst 0xe7f001f0\");\n    /* Known problem:\n     * Same problem and workaround as Thumb mode */\n}\n#elif defined(__aarch64__) &amp;&amp; defined(__APPLE__)\n#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_BULTIN_DEBUGTRAP\n#elif defined(__aarch64__)\n#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION\n__attribute__((always_inline)) __inline__ static void trap_instruction(void)\n{\n    /* See 'aarch64-tdep.c' in GDB source,\n     * 'aarch64_default_breakpoint' */\n    __asm__ volatile(\".inst 0xd4200000\");\n}\n#elif defined(__powerpc__)\n/* PPC 32 or 64-bit, big or little endian */\n#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION\n__attribute__((always_inline)) __inline__ static void trap_instruction(void)\n{\n    /* See 'rs6000-tdep.c' in GDB source,\n     * 'rs6000_breakpoint' */\n    __asm__ volatile(\".4byte 0x7d821008\");\n\n    /* Known problem:\n     * After a breakpoint hit, can't 'stepi', 'step', or 'continue' in GDB.\n     * 'step' stuck on the same instruction (\"twge r2,r2\").\n     *\n     * The workaround is the same as ARM Thumb mode: use debugbreak-gdb.py\n     * or manually jump over the instruction. */\n}\n#elif defined(__riscv)\n/* RISC-V 32 or 64-bit, whether the \"C\" extension\n     * for compressed, 16-bit instructions are supported or not */\n#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_TRAP_INSTRUCTION\n__attribute__((always_inline)) __inline__ static void trap_instruction(void)\n{\n    /* See 'riscv-tdep.c' in GDB source,\n     * 'riscv_sw_breakpoint_from_kind' */\n    __asm__ volatile(\".4byte 0x00100073\");\n}\n#else\n#define DEBUG_BREAK_IMPL DEBUG_BREAK_USE_SIGTRAP\n#endif\n\n\n#ifndef DEBUG_BREAK_IMPL\n#error \"debugbreak.h is not supported on this target\"\n#elif DEBUG_BREAK_IMPL == DEBUG_BREAK_USE_TRAP_INSTRUCTION\n__attribute__((always_inline)) __inline__ static void debug_break(void)\n{\n    trap_instruction();\n}\n#elif DEBUG_BREAK_IMPL == DEBUG_BREAK_USE_BULTIN_DEBUGTRAP\n__attribute__((always_inline)) __inline__ static void debug_break(void)\n{\n    __builtin_debugtrap();\n}\n#elif DEBUG_BREAK_IMPL == DEBUG_BREAK_USE_BULTIN_TRAP\n__attribute__((always_inline)) __inline__ static void debug_break(void)\n{\n    __builtin_trap();\n}\n#elif DEBUG_BREAK_IMPL == DEBUG_BREAK_USE_SIGTRAP\n#include &lt;signal.h&gt;\n__attribute__((always_inline)) __inline__ static void debug_break(void)\n{\n    raise(SIGTRAP);\n}\n#else\n#error \"invalid DEBUG_BREAK_IMPL value\"\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ifdef _MSC_VER */\n\n#endif /* ifndef DEBUG_BREAK_H */\n</code></pre>"},{"location":"muda/debug__log_8h/","title":"File debug_log.h","text":"<p>FileList &gt; muda &gt; tools &gt; debug_log.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;muda/tools/fuzzy.h&gt;</code></li> <li><code>#include &lt;muda/assert.h&gt;</code></li> <li><code>#include &lt;muda/print.h&gt;</code></li> <li><code>#include &lt;muda/muda_config.h&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> </ul>"},{"location":"muda/debug__log_8h/#macros","title":"Macros","text":"Type Name define MUDA_ASSERT (res, fmt, ...) MUDA_KERNEL_ASSERT(res, fmt, ##__VA_ARGS__) define MUDA_DEBUG_TRAP ()  define MUDA_ERROR (fmt, ...) MUDA_KERNEL_ERROR(fmt, ##__VA_ARGS__) define MUDA_ERROR_WITH_LOCATION (fmt, ...) MUDA_KERNEL_ERROR_WITH_LOCATION(fmt, ##__VA_ARGS__) define MUDA_KERNEL_ASSERT (res, fmt, ...)  define MUDA_KERNEL_CHECK (res, fmt, ...)  define MUDA_KERNEL_ERROR (fmt, ...)  define MUDA_KERNEL_ERROR_WITH_LOCATION (fmt, ...)  define MUDA_KERNEL_PRINT (fmt, ...)  define MUDA_KERNEL_WARN (fmt, ...)  define MUDA_KERNEL_WARN_WITH_LOCATION (fmt, ...)"},{"location":"muda/debug__log_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/debug__log_8h/#define-muda_assert","title":"define MUDA_ASSERT","text":"<pre><code>#define MUDA_ASSERT (\n    res,\n    fmt,\n    ...\n) MUDA_KERNEL_ASSERT(res, fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_debug_trap","title":"define MUDA_DEBUG_TRAP","text":"<pre><code>#define MUDA_DEBUG_TRAP (\n\n) {                                                                          \\\n        if constexpr(::muda::TRAP_ON_ERROR)                                    \\\n            ::muda::trap();                                                    \\\n    }\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_error","title":"define MUDA_ERROR","text":"<pre><code>#define MUDA_ERROR (\n    fmt,\n    ...\n) MUDA_KERNEL_ERROR(fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_error_with_location","title":"define MUDA_ERROR_WITH_LOCATION","text":"<pre><code>#define MUDA_ERROR_WITH_LOCATION (\n    fmt,\n    ...\n) MUDA_KERNEL_ERROR_WITH_LOCATION(fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_kernel_assert","title":"define MUDA_KERNEL_ASSERT","text":"<pre><code>#define MUDA_KERNEL_ASSERT (\n    res,\n    fmt,\n    ...\n) {                                                                             \\\n        if constexpr(::muda::RUNTIME_CHECK_ON)                                    \\\n        {                                                                         \\\n            if(!(res))                                                            \\\n            {                                                                     \\\n                MUDA_KERNEL_PRINT(\"%s(%d): %s:\\n &lt;assert&gt; \" #res \" failed. \" fmt, \\\n                                  __FILE__,                                       \\\n                                  __LINE__,                                       \\\n                                  MUDA_FUNCTION_SIG,                              \\\n                                  ##__VA_ARGS__);                                 \\\n                MUDA_DEBUG_TRAP();                                                \\\n            }                                                                     \\\n        }                                                                         \\\n    }\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_kernel_check","title":"define MUDA_KERNEL_CHECK","text":"<pre><code>#define MUDA_KERNEL_CHECK (\n    res,\n    fmt,\n    ...\n) {                                                                            \\\n        if constexpr(::muda::RUNTIME_CHECK_ON)                                   \\\n        {                                                                        \\\n            if(!(res))                                                           \\\n            {                                                                    \\\n                MUDA_KERNEL_PRINT(\"%s(%d): %s:\\n &lt;check&gt; \" #res \" failed. \" fmt, \\\n                                  __FILE__,                                      \\\n                                  __LINE__,                                      \\\n                                  MUDA_FUNCTION_SIG,                             \\\n                                  ##__VA_ARGS__);                                \\\n            }                                                                    \\\n        }                                                                        \\\n    }\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_kernel_error","title":"define MUDA_KERNEL_ERROR","text":"<pre><code>#define MUDA_KERNEL_ERROR (\n    fmt,\n    ...\n) {                                                                          \\\n        MUDA_KERNEL_PRINT(\"&lt;error&gt; \" fmt, ##__VA_ARGS__);                      \\\n        MUDA_DEBUG_TRAP();                                                     \\\n    }\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_kernel_error_with_location","title":"define MUDA_KERNEL_ERROR_WITH_LOCATION","text":"<pre><code>#define MUDA_KERNEL_ERROR_WITH_LOCATION (\n    fmt,\n    ...\n) {                                                                                                          \\\n        MUDA_KERNEL_PRINT(\"%s(%d): %s:\\n &lt;error&gt; \" fmt, __FILE__, __LINE__, MUDA_FUNCTION_SIG, ##__VA_ARGS__); \\\n        MUDA_DEBUG_TRAP();                                                                                     \\\n    }\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_kernel_print","title":"define MUDA_KERNEL_PRINT","text":"<pre><code>#define MUDA_KERNEL_PRINT (\n    fmt,\n    ...\n) {                                                                          \\\n        ::muda::print(\"(host):\" fmt \"\\n\", ##__VA_ARGS__);                      \\\n    }\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_kernel_warn","title":"define MUDA_KERNEL_WARN","text":"<pre><code>#define MUDA_KERNEL_WARN (\n    fmt,\n    ...\n) {                                                                          \\\n        MUDA_KERNEL_PRINT(\"&lt;warn&gt;\" fmt, ##__VA_ARGS__);                        \\\n    }\n</code></pre>"},{"location":"muda/debug__log_8h/#define-muda_kernel_warn_with_location","title":"define MUDA_KERNEL_WARN_WITH_LOCATION","text":"<pre><code>#define MUDA_KERNEL_WARN_WITH_LOCATION (\n    fmt,\n    ...\n) {                                                                                                        \\\n        MUDA_KERNEL_PRINT(\"%s(%d): %s:\\n &lt;warn&gt;\" fmt, __FILE__, __LINE__, MUDA_FUNCTION_SIG, ##__VA_ARGS__); \\\n    }\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/debug_log.h</code></p>"},{"location":"muda/debug__log_8h_source/","title":"File debug_log.h","text":"<p>File List &gt; muda &gt; tools &gt; debug_log.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdlib&gt;\n#include &lt;cassert&gt;\n#include &lt;muda/tools/fuzzy.h&gt;\n#include &lt;muda/assert.h&gt;\n#include &lt;muda/print.h&gt;\n#include &lt;muda/muda_config.h&gt;\n#include &lt;muda/muda_def.h&gt;\n\n#ifdef __CUDA_ARCH__\n#define MUDA_KERNEL_PRINT(fmt, ...)                                            \\\n    {                                                                          \\\n        if(muda::block_dim().y == 1 &amp;&amp; muda::block_dim().z == 1)               \\\n        {                                                                      \\\n            ::muda::print(\"(%d|%d)-(%d|%d):\" fmt \"\\n\",                         \\\n                          muda::block_idx().x,                                 \\\n                          muda::grid_dim().x,                                  \\\n                          muda::thread_idx().x,                                \\\n                          muda::block_dim().x,                                 \\\n                          ##__VA_ARGS__);                                      \\\n        }                                                                      \\\n        else if(muda::block_dim().z == 1)                                      \\\n        {                                                                      \\\n            ::muda::print(\"(%d|%d,%d|%d)-(%d|%d,%d|%d):\" fmt \"\\n\",             \\\n                          muda::block_idx().x,                                 \\\n                          muda::grid_dim().x,                                  \\\n                          muda::block_idx().y,                                 \\\n                          muda::grid_dim().y,                                  \\\n                          muda::thread_idx().x,                                \\\n                          muda::block_dim().x,                                 \\\n                          muda::thread_idx().y,                                \\\n                          muda::block_dim().y,                                 \\\n                          ##__VA_ARGS__);                                      \\\n        }                                                                      \\\n        else                                                                   \\\n        {                                                                      \\\n            ::muda::print(\"(%d|%d,%d|%d,%d|%d)-(%d|%d,%d|%d,%d|%d):\" fmt \"\\n\", \\\n                          muda::block_idx().x,                                 \\\n                          muda::grid_dim().x,                                  \\\n                          muda::block_idx().y,                                 \\\n                          muda::grid_dim().y,                                  \\\n                          muda::block_idx().z,                                 \\\n                          muda::grid_dim().z,                                  \\\n                          muda::thread_idx().x,                                \\\n                          muda::block_dim().x,                                 \\\n                          muda::thread_idx().y,                                \\\n                          muda::block_dim().y,                                 \\\n                          muda::thread_idx().z,                                \\\n                          muda::block_dim().z,                                 \\\n                          ##__VA_ARGS__);                                      \\\n        }                                                                      \\\n    }\n#else\n#define MUDA_KERNEL_PRINT(fmt, ...)                                            \\\n    {                                                                          \\\n        ::muda::print(\"(host):\" fmt \"\\n\", ##__VA_ARGS__);                      \\\n    }\n#endif\n\n//when muda::TRAP_ON_ERROR == true trap the device\n#define MUDA_DEBUG_TRAP()                                                      \\\n    {                                                                          \\\n        if constexpr(::muda::TRAP_ON_ERROR)                                    \\\n            ::muda::trap();                                                    \\\n    }\n\n// check whether (res == true), if not, print the error info (when muda::TRAP_ON_ERROR == true\n// trap the device)\n#define MUDA_KERNEL_ASSERT(res, fmt, ...)                                         \\\n    {                                                                             \\\n        if constexpr(::muda::RUNTIME_CHECK_ON)                                    \\\n        {                                                                         \\\n            if(!(res))                                                            \\\n            {                                                                     \\\n                MUDA_KERNEL_PRINT(\"%s(%d): %s:\\n &lt;assert&gt; \" #res \" failed. \" fmt, \\\n                                  __FILE__,                                       \\\n                                  __LINE__,                                       \\\n                                  MUDA_FUNCTION_SIG,                              \\\n                                  ##__VA_ARGS__);                                 \\\n                MUDA_DEBUG_TRAP();                                                \\\n            }                                                                     \\\n        }                                                                         \\\n    }\n\n// check whether (res == true), if not, print the error info(never trap the device)\n#define MUDA_KERNEL_CHECK(res, fmt, ...)                                         \\\n    {                                                                            \\\n        if constexpr(::muda::RUNTIME_CHECK_ON)                                   \\\n        {                                                                        \\\n            if(!(res))                                                           \\\n            {                                                                    \\\n                MUDA_KERNEL_PRINT(\"%s(%d): %s:\\n &lt;check&gt; \" #res \" failed. \" fmt, \\\n                                  __FILE__,                                      \\\n                                  __LINE__,                                      \\\n                                  MUDA_FUNCTION_SIG,                             \\\n                                  ##__VA_ARGS__);                                \\\n            }                                                                    \\\n        }                                                                        \\\n    }\n\n// print error info, and call muda_debug_trap()\n#define MUDA_KERNEL_ERROR(fmt, ...)                                            \\\n    {                                                                          \\\n        MUDA_KERNEL_PRINT(\"&lt;error&gt; \" fmt, ##__VA_ARGS__);                      \\\n        MUDA_DEBUG_TRAP();                                                     \\\n    }\n\n#define MUDA_KERNEL_ERROR_WITH_LOCATION(fmt, ...)                                                              \\\n    {                                                                                                          \\\n        MUDA_KERNEL_PRINT(\"%s(%d): %s:\\n &lt;error&gt; \" fmt, __FILE__, __LINE__, MUDA_FUNCTION_SIG, ##__VA_ARGS__); \\\n        MUDA_DEBUG_TRAP();                                                                                     \\\n    }\n\n// print warn info\n#define MUDA_KERNEL_WARN(fmt, ...)                                             \\\n    {                                                                          \\\n        MUDA_KERNEL_PRINT(\"&lt;warn&gt;\" fmt, ##__VA_ARGS__);                        \\\n    }\n\n#define MUDA_KERNEL_WARN_WITH_LOCATION(fmt, ...)                                                             \\\n    {                                                                                                        \\\n        MUDA_KERNEL_PRINT(\"%s(%d): %s:\\n &lt;warn&gt;\" fmt, __FILE__, __LINE__, MUDA_FUNCTION_SIG, ##__VA_ARGS__); \\\n    }\n\n\n#define MUDA_ASSERT(res, fmt, ...) MUDA_KERNEL_ASSERT(res, fmt, ##__VA_ARGS__)\n\n#define MUDA_ERROR(fmt, ...) MUDA_KERNEL_ERROR(fmt, ##__VA_ARGS__)\n\n#define MUDA_ERROR_WITH_LOCATION(fmt, ...) MUDA_KERNEL_ERROR_WITH_LOCATION(fmt, ##__VA_ARGS__)\n</code></pre>"},{"location":"muda/extent_8h/","title":"File extent.h","text":"<p>FileList &gt; muda &gt; tools &gt; extent.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;cinttypes&gt;</code></li> </ul>"},{"location":"muda/extent_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/extent_8h/#classes","title":"Classes","text":"Type Name class Extent2D class Extent3D class Offset2D class Offset3D"},{"location":"muda/extent_8h/#macros","title":"Macros","text":"Type Name define MUDA_DEFINE_ARITHMATIC_OPERATOR (op)  define MUDA_DEFINE_COMPARISON_OPERATOR (op)"},{"location":"muda/extent_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/extent_8h/#define-muda_define_arithmatic_operator","title":"define MUDA_DEFINE_ARITHMATIC_OPERATOR","text":"<pre><code>#define MUDA_DEFINE_ARITHMATIC_OPERATOR (\n    op\n) MUDA_INLINE MUDA_GENERIC Extent2D operator op(const Extent2D&amp; lhs,               \\\n                                                  const Extent2D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                \\\n        return Extent2D{lhs.height() op rhs.height(), lhs.width() op rhs.width()};   \\\n    }                                                                                \\\n    MUDA_INLINE MUDA_GENERIC Extent3D operator op(const Extent3D&amp; lhs,               \\\n                                                  const Extent3D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                \\\n        return Extent3D{lhs.depth() op  rhs.depth(),                                 \\\n                        lhs.height() op rhs.height(),                                \\\n                        lhs.width() op  rhs.width()};                                 \\\n    }                                                                                \\\n    MUDA_INLINE MUDA_GENERIC Offset2D operator op(const Offset2D&amp; lhs,               \\\n                                                  const Offset2D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                \\\n        return Offset2D{lhs.offset_in_height() op rhs.offset_in_height(),            \\\n                        lhs.offset_in_width() op  rhs.offset_in_width()};             \\\n    }                                                                                \\\n    MUDA_INLINE MUDA_GENERIC Offset3D operator op(const Offset3D&amp; lhs,               \\\n                                                  const Offset3D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                \\\n        return Offset3D{lhs.offset_in_depth() op  rhs.offset_in_depth(),             \\\n                        lhs.offset_in_height() op rhs.offset_in_height(),            \\\n                        lhs.offset_in_width() op  rhs.offset_in_width()};             \\\n    }\n</code></pre>"},{"location":"muda/extent_8h/#define-muda_define_comparison_operator","title":"define MUDA_DEFINE_COMPARISON_OPERATOR","text":"<pre><code>#define MUDA_DEFINE_COMPARISON_OPERATOR (\n    op\n) MUDA_INLINE MUDA_GENERIC bool operator op(const Extent2D&amp; lhs, const Extent2D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                                 \\\n        return (lhs.height() op rhs.height()) &amp;&amp; (lhs.width() op rhs.width());                        \\\n    }                                                                                                 \\\n    MUDA_INLINE MUDA_GENERIC bool operator op(const Extent3D&amp; lhs, const Extent3D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                                 \\\n        return (lhs.depth() op rhs.depth()) &amp;&amp; (lhs.height() op rhs.height())                         \\\n               &amp;&amp; (lhs.width() op rhs.width());                                                       \\\n    }\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/extent.h</code></p>"},{"location":"muda/extent_8h_source/","title":"File extent.h","text":"<p>File List &gt; muda &gt; tools &gt; extent.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;muda/muda_def.h&gt;\n#include &lt;cinttypes&gt;\n#undef min\n#undef max\nnamespace muda\n{\nclass Extent2D\n{\n    size_t m_extent[2];\n\n  public:\n    MUDA_GENERIC Extent2D() MUDA_NOEXCEPT : m_extent{~0ull, ~0ull} {}\n\n    MUDA_GENERIC Extent2D(size_t height, size_t width) MUDA_NOEXCEPT\n        : m_extent{height, width}\n    {\n    }\n\n    MUDA_GENERIC size_t height() const MUDA_NOEXCEPT { return m_extent[0]; }\n    MUDA_GENERIC size_t width() const MUDA_NOEXCEPT { return m_extent[1]; }\n\n    template &lt;typename T&gt;\n    MUDA_GENERIC cudaExtent cuda_extent() const MUDA_NOEXCEPT\n    {\n        return cudaExtent{width() * sizeof(T), height(), 1};\n    }\n\n    MUDA_GENERIC bool valid() const\n    {\n        return m_extent[0] != ~0ull &amp;&amp; m_extent[1] != ~0ull;\n    }\n\n    static MUDA_GENERIC Extent2D Zero() MUDA_NOEXCEPT { return Extent2D{0, 0}; }\n};\n\n\nclass Extent3D\n{\n    size_t m_extent[3];\n\n  public:\n    MUDA_GENERIC Extent3D() MUDA_NOEXCEPT : m_extent{~0ull, ~0ull, ~0ull} {}\n    MUDA_GENERIC Extent3D(size_t depth, size_t height, size_t width) MUDA_NOEXCEPT\n        : m_extent{depth, height, width}\n    {\n    }\n\n    MUDA_GENERIC size_t depth() const MUDA_NOEXCEPT { return m_extent[0]; }\n    MUDA_GENERIC size_t height() const MUDA_NOEXCEPT { return m_extent[1]; }\n    MUDA_GENERIC size_t width() const MUDA_NOEXCEPT { return m_extent[2]; }\n\n    template &lt;typename T&gt;\n    MUDA_GENERIC cudaExtent cuda_extent() const MUDA_NOEXCEPT\n    {\n        return cudaExtent{width() * sizeof(T), height(), depth()};\n    }\n\n    MUDA_GENERIC bool valid() const\n    {\n        return m_extent[0] != ~0ull &amp;&amp; m_extent[1] != ~0ull &amp;&amp; m_extent[2] != ~0ull;\n    }\n\n    static MUDA_GENERIC Extent3D Zero() MUDA_NOEXCEPT\n    {\n        return Extent3D{0, 0, 0};\n    }\n};\n\nclass Offset2D\n{\n    size_t m_offset[2];\n\n  public:\n    MUDA_GENERIC Offset2D() MUDA_NOEXCEPT : m_offset{~0ull, ~0ull} {}\n\n    static MUDA_GENERIC Offset2D Zero() MUDA_NOEXCEPT { return Offset2D{0, 0}; }\n\n    MUDA_GENERIC Offset2D(size_t offset_in_height, size_t offset_in_width) MUDA_NOEXCEPT\n        : m_offset{offset_in_height, offset_in_width}\n    {\n    }\n\n    MUDA_GENERIC size_t offset_in_height() const MUDA_NOEXCEPT\n    {\n        return m_offset[0];\n    }\n\n    MUDA_GENERIC size_t offset_in_width() const MUDA_NOEXCEPT\n    {\n        return m_offset[1];\n    }\n\n    template &lt;typename T&gt;\n    MUDA_GENERIC cudaPos cuda_pos() const MUDA_NOEXCEPT\n    {\n        return cudaPos{offset_in_width() * sizeof(T), offset_in_height(), 0};\n    }\n};\n\nclass Offset3D\n{\n    size_t m_offset[3];\n\n  public:\n    MUDA_GENERIC Offset3D() MUDA_NOEXCEPT : m_offset{~0ull, ~0ull, ~0ull} {}\n\n    static MUDA_GENERIC Offset3D Zero() MUDA_NOEXCEPT\n    {\n        return Offset3D{0, 0, 0};\n    }\n\n    MUDA_GENERIC Offset3D(size_t offset_in_depth, size_t offset_in_height, size_t offset_in_width) MUDA_NOEXCEPT\n        : m_offset{offset_in_depth, offset_in_height, offset_in_width}\n    {\n    }\n\n    MUDA_GENERIC size_t offset_in_depth() const MUDA_NOEXCEPT\n    {\n        return m_offset[0];\n    }\n\n    MUDA_GENERIC size_t offset_in_height() const MUDA_NOEXCEPT\n    {\n        return m_offset[1];\n    }\n\n    MUDA_GENERIC size_t offset_in_width() const MUDA_NOEXCEPT\n    {\n        return m_offset[2];\n    }\n\n    template &lt;typename T&gt;\n    MUDA_GENERIC cudaPos cuda_pos() const MUDA_NOEXCEPT\n    {\n        return cudaPos{offset_in_width() * sizeof(T), offset_in_height(), offset_in_depth()};\n    }\n};\n\nMUDA_INLINE MUDA_GENERIC Extent2D as_extent(const Offset2D&amp; offset) MUDA_NOEXCEPT\n{\n    return Extent2D{offset.offset_in_height(), offset.offset_in_width()};\n}\n\nMUDA_INLINE MUDA_GENERIC Extent3D as_extent(const Offset3D&amp; offset) MUDA_NOEXCEPT\n{\n    return Extent3D{offset.offset_in_depth(), offset.offset_in_height(), offset.offset_in_width()};\n}\n\nMUDA_INLINE MUDA_GENERIC Offset2D as_offset(const Extent2D&amp; extent) MUDA_NOEXCEPT\n{\n    return Offset2D{extent.height(), extent.width()};\n}\n\nMUDA_INLINE MUDA_GENERIC Offset3D as_offset(const Extent3D&amp; extent) MUDA_NOEXCEPT\n{\n    return Offset3D{extent.depth(), extent.height(), extent.width()};\n}\n\nMUDA_INLINE MUDA_GENERIC Offset2D min(const Offset2D&amp; lhs, const Offset2D&amp; rhs)\n{\n    return Offset2D{std::min(lhs.offset_in_height(), rhs.offset_in_height()),\n                    std::min(lhs.offset_in_width(), rhs.offset_in_width())};\n}\n\nMUDA_INLINE MUDA_GENERIC Offset3D min(const Offset3D&amp; lhs, const Offset3D&amp; rhs)\n{\n    return Offset3D{std::min(lhs.offset_in_depth(), rhs.offset_in_depth()),\n                    std::min(lhs.offset_in_height(), rhs.offset_in_height()),\n                    std::min(lhs.offset_in_width(), rhs.offset_in_width())};\n}\n\nMUDA_INLINE MUDA_GENERIC Extent2D max(const Extent2D&amp; lhs, const Extent2D&amp; rhs)\n{\n    return Extent2D{std::max(lhs.height(), rhs.height()),\n                    std::max(lhs.width(), rhs.width())};\n}\n\nMUDA_INLINE MUDA_GENERIC Extent3D max(const Extent3D&amp; lhs, const Extent3D&amp; rhs)\n{\n    return Extent3D{std::max(lhs.depth(), rhs.depth()),\n                    std::max(lhs.height(), rhs.height()),\n                    std::max(lhs.width(), rhs.width())};\n}\n\n#define MUDA_DEFINE_COMPARISON_OPERATOR(op)                                                           \\\n    MUDA_INLINE MUDA_GENERIC bool operator op(const Extent2D&amp; lhs, const Extent2D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                                 \\\n        return (lhs.height() op rhs.height()) &amp;&amp; (lhs.width() op rhs.width());                        \\\n    }                                                                                                 \\\n    MUDA_INLINE MUDA_GENERIC bool operator op(const Extent3D&amp; lhs, const Extent3D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                                 \\\n        return (lhs.depth() op rhs.depth()) &amp;&amp; (lhs.height() op rhs.height())                         \\\n               &amp;&amp; (lhs.width() op rhs.width());                                                       \\\n    }\n\nMUDA_DEFINE_COMPARISON_OPERATOR(&lt;=);\nMUDA_DEFINE_COMPARISON_OPERATOR(&lt;);\nMUDA_DEFINE_COMPARISON_OPERATOR(==);\n\n#undef MUDA_DEFINE_COMPARISON_OPERATOR\n\n\n#define MUDA_DEFINE_ARITHMATIC_OPERATOR(op)                                          \\\n    MUDA_INLINE MUDA_GENERIC Extent2D operator op(const Extent2D&amp; lhs,               \\\n                                                  const Extent2D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                \\\n        return Extent2D{lhs.height() op rhs.height(), lhs.width() op rhs.width()};   \\\n    }                                                                                \\\n    MUDA_INLINE MUDA_GENERIC Extent3D operator op(const Extent3D&amp; lhs,               \\\n                                                  const Extent3D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                \\\n        return Extent3D{lhs.depth() op  rhs.depth(),                                 \\\n                        lhs.height() op rhs.height(),                                \\\n                        lhs.width() op  rhs.width()};                                 \\\n    }                                                                                \\\n    MUDA_INLINE MUDA_GENERIC Offset2D operator op(const Offset2D&amp; lhs,               \\\n                                                  const Offset2D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                \\\n        return Offset2D{lhs.offset_in_height() op rhs.offset_in_height(),            \\\n                        lhs.offset_in_width() op  rhs.offset_in_width()};             \\\n    }                                                                                \\\n    MUDA_INLINE MUDA_GENERIC Offset3D operator op(const Offset3D&amp; lhs,               \\\n                                                  const Offset3D&amp; rhs) MUDA_NOEXCEPT \\\n    {                                                                                \\\n        return Offset3D{lhs.offset_in_depth() op  rhs.offset_in_depth(),             \\\n                        lhs.offset_in_height() op rhs.offset_in_height(),            \\\n                        lhs.offset_in_width() op  rhs.offset_in_width()};             \\\n    }\n\nMUDA_DEFINE_ARITHMATIC_OPERATOR(+);\nMUDA_DEFINE_ARITHMATIC_OPERATOR(-);\n#undef MUDA_DEFINE_ARITHMATIC_OPERATOR\n\n\n}  // namespace muda\n</code></pre>"},{"location":"muda/filesystem_8h/","title":"File filesystem.h","text":"<p>FileList &gt; muda &gt; tools &gt; filesystem.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/platform.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/tools/filesystem.h</code></p>"},{"location":"muda/filesystem_8h_source/","title":"File filesystem.h","text":"<p>File List &gt; muda &gt; tools &gt; filesystem.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/platform.h&gt;\n\n#ifdef MUDA_PLATFORM_LINUX\n#if __GNUC__ &gt;= 8\n#include &lt;filesystem&gt;\nnamespace muda\n{\n    namespace filesystem = std::filesystem;\n}\n#else\n#include &lt;experimental/filesystem&gt;\nnamespace muda\n{\n    namespace filesystem = std::experimental::filesystem;\n}\n#endif\n#endif\n\n#ifdef MUDA_PLATFORM_WINDOWS\n#include &lt;filesystem&gt;\nnamespace muda\n{\n    namespace filesystem = std::filesystem;\n}\n#endif\n</code></pre>"},{"location":"muda/flag_8h/","title":"File flag.h","text":"<p>FileList &gt; muda &gt; tools &gt; flag.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> </ul>"},{"location":"muda/flag_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/flag_8h/#classes","title":"Classes","text":"Type Name class Flags &lt;typename BitType&gt; <p>The documentation for this class was generated from the following file <code>src/muda/tools/flag.h</code></p>"},{"location":"muda/flag_8h_source/","title":"File flag.h","text":"<p>File List &gt; muda &gt; tools &gt; flag.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;type_traits&gt;\n#include &lt;muda/muda_def.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename BitType&gt;\nclass Flags\n{\n  public:\n    using bit_type  = BitType;\n    using mask_type = typename ::std::underlying_type&lt;bit_type&gt;::type;\n\n    // constructors\n    MUDA_GENERIC MUDA_CONSTEXPR Flags() MUDA_NOEXCEPT : m_mask(0) {}\n\n    MUDA_GENERIC MUDA_CONSTEXPR Flags(BitType bit) MUDA_NOEXCEPT\n        : m_mask(static_cast&lt;mask_type&gt;(bit))\n    {\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR Flags(Flags&lt;BitType&gt; const&amp; rhs) MUDA_NOEXCEPT = default;\n\n    MUDA_GENERIC MUDA_CONSTEXPR explicit Flags(mask_type flags) MUDA_NOEXCEPT : m_mask(flags)\n    {\n    }\n\n    // relational operators\n    // auto operator&lt;=&gt;(Flags&lt;BitType&gt; const&amp;) const = default;\n\n    MUDA_GENERIC MUDA_CONSTEXPR bool operator&lt;(Flags&lt;BitType&gt; const&amp; rhs) const MUDA_NOEXCEPT\n    {\n        return m_mask &lt; rhs.m_mask;\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR bool operator&lt;=(Flags&lt;BitType&gt; const&amp; rhs) const MUDA_NOEXCEPT\n    {\n        return m_mask &lt;= rhs.m_mask;\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR bool operator&gt;(Flags&lt;BitType&gt; const&amp; rhs) const MUDA_NOEXCEPT\n    {\n        return m_mask &gt; rhs.m_mask;\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR bool operator&gt;=(Flags&lt;BitType&gt; const&amp; rhs) const MUDA_NOEXCEPT\n    {\n        return m_mask &gt;= rhs.m_mask;\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR bool operator==(Flags&lt;BitType&gt; const&amp; rhs) const MUDA_NOEXCEPT\n    {\n        return m_mask == rhs.m_mask;\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR bool operator!=(Flags&lt;BitType&gt; const&amp; rhs) const MUDA_NOEXCEPT\n    {\n        return m_mask != rhs.m_mask;\n    }\n\n\n    // logical operator\n    MUDA_GENERIC MUDA_CONSTEXPR bool operator!() const MUDA_NOEXCEPT\n    {\n        return !m_mask;\n    }\n\n    // bitwise operators\n    MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator&amp;(Flags&lt;BitType&gt; const&amp; rhs) const MUDA_NOEXCEPT\n    {\n        return Flags&lt;BitType&gt;(m_mask &amp; rhs.m_mask);\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator|(Flags&lt;BitType&gt; const&amp; rhs) const MUDA_NOEXCEPT\n    {\n        return Flags&lt;BitType&gt;(m_mask | rhs.m_mask);\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator^(Flags&lt;BitType&gt; const&amp; rhs) const MUDA_NOEXCEPT\n    {\n        return Flags&lt;BitType&gt;(m_mask ^ rhs.m_mask);\n    }\n\n    // assignment operators\n    MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt;&amp; operator=(Flags&lt;BitType&gt; const&amp; rhs) MUDA_NOEXCEPT = default;\n\n    MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt;&amp; operator|=(Flags&lt;BitType&gt; const&amp; rhs) MUDA_NOEXCEPT\n    {\n        m_mask |= rhs.m_mask;\n        return *this;\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt;&amp; operator&amp;=(Flags&lt;BitType&gt; const&amp; rhs) MUDA_NOEXCEPT\n    {\n        m_mask &amp;= rhs.m_mask;\n        return *this;\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt;&amp; operator^=(Flags&lt;BitType&gt; const&amp; rhs) MUDA_NOEXCEPT\n    {\n        m_mask ^= rhs.m_mask;\n        return *this;\n    }\n\n    // cast operators\n    explicit MUDA_GENERIC MUDA_CONSTEXPR operator bool() const MUDA_NOEXCEPT\n    {\n        return !!m_mask;\n    }\n\n    explicit MUDA_GENERIC MUDA_CONSTEXPR operator mask_type() const MUDA_NOEXCEPT\n    {\n        return m_mask;\n    }\n\n    MUDA_GENERIC MUDA_CONSTEXPR bool has(BitType bit) const MUDA_NOEXCEPT\n    {\n        return (m_mask &amp; static_cast&lt;mask_type&gt;(bit)) == static_cast&lt;mask_type&gt;(bit);\n    }\n\n  private:\n    mask_type m_mask;\n};\n\n//template &lt;typename BitType&gt;\n//MUDA_GENERIC MUDA_CONSTEXPR bool operator&lt;(BitType bit, Flags&lt;BitType&gt; const&amp; flags) MUDA_NOEXCEPT\n//{\n//    return flags.operator&gt;(bit);\n//}\n//\n//template &lt;typename BitType&gt;\n//MUDA_GENERIC MUDA_CONSTEXPR bool operator&lt;=(BitType bit, Flags&lt;BitType&gt; const&amp; flags) MUDA_NOEXCEPT\n//{\n//    return flags.operator&gt;=(bit);\n//}\n//\n//template &lt;typename BitType&gt;\n//MUDA_GENERIC MUDA_CONSTEXPR bool operator&gt;(BitType bit, Flags&lt;BitType&gt; const&amp; flags) MUDA_NOEXCEPT\n//{\n//    return flags.operator&lt;(bit);\n//}\n//\n//template &lt;typename BitType&gt;\n//MUDA_GENERIC MUDA_CONSTEXPR bool operator&gt;=(BitType bit, Flags&lt;BitType&gt; const&amp; flags) MUDA_NOEXCEPT\n//{\n//    return flags.operator&lt;=(bit);\n//}\n//\n//template &lt;typename BitType&gt;\n//MUDA_GENERIC MUDA_CONSTEXPR bool operator==(BitType bit, Flags&lt;BitType&gt; const&amp; flags) MUDA_NOEXCEPT\n//{\n//    return flags.operator==(bit);\n//}\n//\n//template &lt;typename BitType&gt;\n//MUDA_GENERIC MUDA_CONSTEXPR bool operator!=(BitType bit, Flags&lt;BitType&gt; const&amp; flags) MUDA_NOEXCEPT\n//{\n//    return flags.operator!=(bit);\n//}\n\n\n// bitwise operators\ntemplate &lt;typename BitType&gt;\nMUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator&amp;(BitType bit,\n                                                                 Flags&lt;BitType&gt; const&amp; flags) MUDA_NOEXCEPT\n{\n    return flags.operator&amp;(bit);\n}\n\ntemplate &lt;typename BitType&gt;\nMUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator|(BitType bit,\n                                                                 Flags&lt;BitType&gt; const&amp; flags) MUDA_NOEXCEPT\n{\n    return flags.operator|(bit);\n}\n\ntemplate &lt;typename BitType&gt;\nMUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator^(BitType bit,\n                                                                 Flags&lt;BitType&gt; const&amp; flags) MUDA_NOEXCEPT\n{\n    return flags.operator^(bit);\n}\n\n//template &lt;typename BitType, typename ::std::enable_if&lt;is_flag_type&lt;BitType&gt;::isBitmask, bool&gt;::type = true&gt;\n//MUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator&amp;(BitType lhs, BitType rhs) MUDA_NOEXCEPT\n//{\n//    return Flags&lt;BitType&gt;(lhs) &amp; rhs;\n//}\n//\n//template &lt;typename BitType, typename ::std::enable_if&lt;is_flag_type&lt;BitType&gt;::isBitmask, bool&gt;::type = true&gt;\n//MUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator|(BitType lhs, BitType rhs) MUDA_NOEXCEPT\n//{\n//    return Flags&lt;BitType&gt;(lhs) | rhs;\n//}\n//\n//template &lt;typename BitType, typename ::std::enable_if&lt;is_flag_type&lt;BitType&gt;::isBitmask, bool&gt;::type = true&gt;\n//MUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator^(BitType lhs, BitType rhs) MUDA_NOEXCEPT\n//{\n//    return Flags&lt;BitType&gt;(lhs) ^ rhs;\n//}\n//\n//template &lt;typename BitType, typename ::std::enable_if&lt;is_flag_type&lt;BitType&gt;::isBitmask, bool&gt;::type = true&gt;\n//MUDA_INLINE MUDA_GENERIC MUDA_CONSTEXPR Flags&lt;BitType&gt; operator~(BitType bit) MUDA_NOEXCEPT\n//{\n//    return ~(Flags&lt;BitType&gt;(bit));\n//}\n}  // namespace muda\n</code></pre>"},{"location":"muda/fuzzy_8h/","title":"File fuzzy.h","text":"<p>FileList &gt; muda &gt; tools &gt; fuzzy.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> </ul>"},{"location":"muda/fuzzy_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda <p>The documentation for this class was generated from the following file <code>src/muda/tools/fuzzy.h</code></p>"},{"location":"muda/fuzzy_8h_source/","title":"File fuzzy.h","text":"<p>File List &gt; muda &gt; tools &gt; fuzzy.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;muda/muda_def.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename FHost, typename FDevice&gt;\nMUDA_INLINE MUDA_GENERIC decltype(auto) invoke(FHost&amp;&amp; host, FDevice&amp;&amp; device) MUDA_NOEXCEPT\n{\n    if constexpr(std::is_same_v&lt;std::invoke_result_t&lt;FHost&gt;, void&gt;\n                 &amp;&amp; std::is_same_v&lt;std::invoke_result_t&lt;FDevice&gt;, void&gt;)\n    {\n#ifdef __CUDA_ARCH__\n        device();\n#else\n        host();\n#endif\n    }\n    else\n    {\n#ifdef __CUDA_ARCH__\n        return device();\n#else\n        return host();\n#endif\n    }\n}\n\nMUDA_INLINE MUDA_GENERIC dim3 grid_dim()\n{\n#ifdef __CUDA_ARCH__\n    return gridDim;\n#else\n    return dim3(0, 0, 0);\n#endif\n}\n\nMUDA_INLINE MUDA_GENERIC dim3 block_idx()\n{\n#ifdef __CUDA_ARCH__\n    return blockIdx;\n#else\n    return dim3(0, 0, 0);\n#endif\n}\n\nMUDA_INLINE MUDA_GENERIC dim3 block_dim()\n{\n#ifdef __CUDA_ARCH__\n    return blockDim;\n#else\n    return dim3(0, 0, 0);\n#endif\n}\n\nMUDA_INLINE MUDA_GENERIC dim3 thread_idx()\n{\n#ifdef __CUDA_ARCH__\n    return threadIdx;\n#else\n    return dim3(0, 0, 0);\n#endif\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/host__device__config_8h/","title":"File host_device_config.h","text":"<p>FileList &gt; muda &gt; tools &gt; host_device_config.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;muda/buffer/device_var.h&gt;</code></li> <li><code>#include &lt;muda/view/view_base.h&gt;</code></li> </ul>"},{"location":"muda/host__device__config_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/host__device__config_8h/#classes","title":"Classes","text":"Type Name class HostDeviceConfig &lt;typename T&gt; class HostDeviceConfigView &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/tools/host_device_config.h</code></p>"},{"location":"muda/host__device__config_8h_source/","title":"File host_device_config.h","text":"<p>File List &gt; muda &gt; tools &gt; host_device_config.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n#include &lt;muda/buffer/device_var.h&gt;\n#include &lt;muda/view/view_base.h&gt;\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nclass HostDeviceConfigView : public ViewBase&lt;true&gt;\n{\n    using Base = ViewBase&lt;true&gt;;\n    const T* m_host_data;\n    const T* m_device_data;\n\n  public:\n    using value_type = T;\n\n    MUDA_GENERIC HostDeviceConfigView(const T* host_data, const T* device_data)\n        : m_host_data{host_data}\n        , m_device_data{device_data}\n    {\n    }\n\n    MUDA_GENERIC const T* host_data() const MUDA_NOEXCEPT\n    {\n        return m_host_data;\n    }\n    MUDA_GENERIC const T* device_data() const MUDA_NOEXCEPT\n    {\n        return m_device_data;\n    }\n\n    MUDA_GENERIC const T* data() const MUDA_NOEXCEPT\n    {\n#ifdef __CUDA_ARCH__\n        return device_data();\n#else\n        return host_data();\n#endif\n    }\n\n    MUDA_GENERIC const T* operator-&gt;() const MUDA_NOEXCEPT { return data(); }\n    MUDA_GENERIC const T&amp; operator*() const MUDA_NOEXCEPT { return *data(); }\n};\n\ntemplate &lt;typename T&gt;\nclass HostDeviceConfig\n{\n  private:\n    friend class BufferLaunch;\n    T            m_host_data;\n    DeviceVar&lt;T&gt; m_device_data;\n\n  public:\n    using value_type = T;\n\n    HostDeviceConfig() = default;\n    HostDeviceConfig(const T&amp; value)\n        : m_host_data{value}\n        , m_device_data{value}\n    {\n    }\n\n    HostDeviceConfig(const HostDeviceConfig&amp;)               = default;\n    HostDeviceConfig(HostDeviceConfig&amp;&amp;) MUDA_NOEXCEPT      = default;\n    HostDeviceConfig&amp; operator=(const HostDeviceConfig&lt;T&gt;&amp;) = default;\n    HostDeviceConfig&amp; operator=(HostDeviceConfig&lt;T&gt;&amp;&amp;)      = default;\n\n    HostDeviceConfig&amp; operator=(const T&amp; val)\n    {\n        m_host_data   = val;\n        m_device_data = val;\n        return *this;\n    }\n\n    const T* host_data() const MUDA_NOEXCEPT { return &amp;m_host_data; }\n\n    T* host_data() MUDA_NOEXCEPT { return &amp;m_host_data; }\n\n    const T* device_data() const MUDA_NOEXCEPT { return m_device_data.data(); }\n    auto     buffer_view() MUDA_NOEXCEPT { return m_device_data.view(); }\n\n    auto buffer_view() const MUDA_NOEXCEPT { return m_device_data.view(); }\n\n    auto view() const MUDA_NOEXCEPT\n    {\n        return HostDeviceConfigView&lt;T&gt;{host_data(), device_data()};\n    }\n};\n\n}  // namespace muda\n</code></pre>"},{"location":"muda/host__device__string__cache_8h/","title":"File host_device_string_cache.h","text":"<p>FileList &gt; muda &gt; tools &gt; host_device_string_cache.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;muda/literal/unit.h&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/check/check_cuda_errors.h&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;muda/tools/string_pointer.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> </ul>"},{"location":"muda/host__device__string__cache_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/host__device__string__cache_8h/#classes","title":"Classes","text":"Type Name class HostDeviceStringCache <p>The documentation for this class was generated from the following file <code>src/muda/tools/host_device_string_cache.h</code></p>"},{"location":"muda/host__device__string__cache_8h_source/","title":"File host_device_string_cache.h","text":"<p>File List &gt; muda &gt; tools &gt; host_device_string_cache.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda_runtime.h&gt;\n#include &lt;muda/literal/unit.h&gt;\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/check/check_cuda_errors.h&gt;\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;muda/tools/string_pointer.h&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n\nnamespace muda::details\n{\nclass HostDeviceStringCache\n{\n    class StringLocation\n    {\n      public:\n        size_t buffer_index = ~0;\n        size_t offset       = ~0;\n        size_t size         = ~0;\n    };\n\n    std::unordered_map&lt;std::string, StringLocation&gt; m_string_map;\n\n    std::vector&lt;char*&gt; m_device_string_buffers;\n    std::vector&lt;char*&gt; m_host_string_buffers;\n\n    size_t m_current_buffer_offset;\n    size_t m_buffer_size;\n\n    StringPointer m_empty_string_pointer{};\n\n  public:\n    HostDeviceStringCache(size_t buffer_size = 4_M)\n        : m_buffer_size(buffer_size)\n        , m_current_buffer_offset(0)\n    {\n        m_device_string_buffers.reserve(32);\n        m_host_string_buffers.reserve(32);\n\n        char* s;\n        checkCudaErrors(cudaMalloc(&amp;s, m_buffer_size * sizeof(char)));\n        m_device_string_buffers.emplace_back(s);\n        m_host_string_buffers.emplace_back(new char[m_buffer_size]);\n\n        m_empty_string_pointer = get_string_pointer(\"\");  // insert empty string\n    }\n    ~HostDeviceStringCache()\n    {\n        for(auto s : m_device_string_buffers)\n            cudaFree(s);\n        for(auto s : m_host_string_buffers)\n            delete[] s;\n    }\n    // delete copy\n    HostDeviceStringCache(const HostDeviceStringCache&amp;)            = delete;\n    HostDeviceStringCache&amp; operator=(const HostDeviceStringCache&amp;) = delete;\n    // move\n    HostDeviceStringCache(HostDeviceStringCache&amp;&amp;)            = default;\n    HostDeviceStringCache&amp; operator=(HostDeviceStringCache&amp;&amp;) = default;\n\n    StringPointer operator[](std::string_view s)\n    {\n        if(s.empty() || s == \"\")\n        {\n            return m_empty_string_pointer;\n        }\n        return get_string_pointer(s);\n    }\n\n  private:\n    StringPointer get_string_pointer(std::string_view s)\n    {\n        auto         str           = std::string{s};\n        auto         it            = m_string_map.find(str);\n        char*        device_string = nullptr;\n        char*        host_string   = nullptr;\n        unsigned int str_length    = 0;\n\n        if(it != m_string_map.end())  // cached\n        {\n            auto&amp; loc = it-&gt;second;\n            device_string = m_device_string_buffers[loc.buffer_index] + loc.offset;\n            host_string = m_host_string_buffers[loc.buffer_index] + loc.offset;\n            str_length  = static_cast&lt;unsigned int&gt;(loc.size - 1);\n        }\n        else  // need insert\n        {\n            auto  zero_end_length = str.size() + 1;\n            auto&amp; loc             = m_string_map[str];  // insert\n\n            if(m_current_buffer_offset + zero_end_length &gt; m_buffer_size)  // need new buffer\n            {\n                char* s;\n                checkCudaErrors(cudaMalloc(&amp;s, m_buffer_size * sizeof(char)));\n                m_device_string_buffers.emplace_back(s);\n                m_host_string_buffers.emplace_back(new char[m_buffer_size]);\n                m_current_buffer_offset = 0;\n            }\n\n            auto device_buffer = m_device_string_buffers.back();\n            auto host_buffer   = m_host_string_buffers.back();\n\n            // copy string to host buffer (with '\\0' end)\n            host_buffer[m_current_buffer_offset + str.size()] = '\\0';\n            std::memcpy(host_buffer + m_current_buffer_offset, str.data(), str.size());\n\n            // copy string from host buffer to device buffer\n            checkCudaErrors(cudaMemcpy(device_buffer + m_current_buffer_offset,\n                                       host_buffer + m_current_buffer_offset,\n                                       str.size() + 1,\n                                       cudaMemcpyHostToDevice));\n\n            loc.buffer_index = m_host_string_buffers.size() - 1;\n            loc.offset       = m_current_buffer_offset;\n            loc.size         = zero_end_length;  // include '\\0'\n\n            m_current_buffer_offset += zero_end_length;\n\n            device_string = device_buffer + loc.offset;\n            host_string   = host_buffer + loc.offset;\n            str_length    = static_cast&lt;unsigned int&gt;(loc.size - 1);\n        }\n        return StringPointer{device_string, host_string, str_length};\n    }\n};\n}  // namespace muda::details\n</code></pre>"},{"location":"muda/id__with__type_8h/","title":"File id_with_type.h","text":"<p>FileList &gt; muda &gt; tools &gt; id_with_type.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> </ul>"},{"location":"muda/id__with__type_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace std"},{"location":"muda/id__with__type_8h/#classes","title":"Classes","text":"Type Name class IdWithType &lt;typename T&gt; struct hash&lt; muda::IdWithType&lt; T &gt; &gt; &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/tools/id_with_type.h</code></p>"},{"location":"muda/id__with__type_8h_source/","title":"File id_with_type.h","text":"<p>File List &gt; muda &gt; tools &gt; id_with_type.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;ostream&gt;\n#include &lt;muda/muda_def.h&gt;\n#undef max\nnamespace muda\n{\ntemplate &lt;typename T = uint64_t&gt;\nclass IdWithType\n{\n  public:\n    using value_type                 = T;\n    static constexpr auto invalid_id = std::numeric_limits&lt;value_type&gt;::max();\n    MUDA_GENERIC explicit IdWithType(value_type value) noexcept\n        : m_value{value}\n    {\n    }\n    MUDA_GENERIC explicit IdWithType() noexcept\n        : m_value{invalid_id}\n    {\n    }\n    MUDA_GENERIC value_type value() const noexcept { return m_value; }\n    friend std::ostream&amp;    operator&lt;&lt;(std::ostream&amp; os, const IdWithType&amp; id)\n    {\n        os &lt;&lt; id.m_value;\n        return os;\n    }\n    MUDA_GENERIC friend bool operator==(const IdWithType&amp; lhs, const IdWithType&amp; rhs) noexcept\n    {\n        return lhs.m_value == rhs.m_value;\n    }\n    MUDA_GENERIC friend bool operator!=(const IdWithType&amp; lhs, const IdWithType&amp; rhs) noexcept\n    {\n        return lhs.m_value != rhs.m_value;\n    }\n    MUDA_GENERIC friend bool operator&lt;(const IdWithType&amp; lhs, const IdWithType&amp; rhs) noexcept\n    {\n        return lhs.m_value &lt; rhs.m_value;\n    }\n    MUDA_GENERIC friend bool operator&gt;(const IdWithType&amp; lhs, const IdWithType&amp; rhs) noexcept\n    {\n        return lhs.m_value &gt; rhs.m_value;\n    }\n    MUDA_GENERIC bool is_valid() const noexcept\n    {\n        return m_value != invalid_id;\n    }\n\n  protected:\n    value_type m_value{invalid_id};\n};\n\nusing U64IdWithType = IdWithType&lt;uint64_t&gt;;\nusing U32IdWithType = IdWithType&lt;uint32_t&gt;;\nusing I64IdWithType = IdWithType&lt;int64_t&gt;;\nusing I32IdWithType = IdWithType&lt;int32_t&gt;;\n}  // namespace muda\n\nnamespace std\n{\ntemplate &lt;typename T&gt;\nstruct hash&lt;muda::IdWithType&lt;T&gt;&gt;\n{\n    size_t operator()(const muda::IdWithType&lt;T&gt;&amp; s) const noexcept\n    {\n        return std::hash&lt;T&gt;{}(s.value());\n    }\n};\n}  // namespace std\n</code></pre>"},{"location":"muda/launch__info__cache_8h/","title":"File launch_info_cache.h","text":"<p>FileList &gt; muda &gt; tools &gt; launch_info_cache.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/tools/host_device_string_cache.h&gt;</code></li> </ul>"},{"location":"muda/launch__info__cache_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/launch__info__cache_8h/#classes","title":"Classes","text":"Type Name class LaunchInfoCache <p>The documentation for this class was generated from the following file <code>src/muda/tools/launch_info_cache.h</code></p>"},{"location":"muda/launch__info__cache_8h_source/","title":"File launch_info_cache.h","text":"<p>File List &gt; muda &gt; tools &gt; launch_info_cache.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/tools/host_device_string_cache.h&gt;\nnamespace muda::details\n{\nclass LaunchInfoCache\n{\n  private:\n    HostDeviceStringCache m_view_name_string_cache;\n    HostDeviceStringCache m_kernel_name_string_cache;\n    HostDeviceStringCache m_kernel_file_string_cache;\n    HostDeviceStringCache m_capture_name_string_cache;\n\n    StringPointer m_current_kernel_name;\n    StringPointer m_current_capture_name;\n    StringPointer m_current_kernel_file;\n    int           m_current_kernel_line;\n\n\n    LaunchInfoCache() MUDA_NOEXCEPT\n    {\n        m_current_kernel_name = m_kernel_name_string_cache[std::string_view{\"\"}];\n        m_current_kernel_file = m_kernel_file_string_cache[std::string_view{\"\"}];\n        m_current_capture_name = m_capture_name_string_cache[std::string_view{\"\"}];\n        m_current_kernel_line = -1;\n    }\n\n  public:\n    static auto view_name(std::string_view name) MUDA_NOEXCEPT\n    {\n        return instance().m_view_name_string_cache[name];\n    }\n\n    static auto current_kernel_name(std::string_view name) MUDA_NOEXCEPT\n    {\n        auto&amp; ins                 = instance();\n        ins.m_current_kernel_name = ins.m_kernel_name_string_cache[name];\n        return ins.m_current_kernel_name;\n    }\n\n    static auto current_kernel_name() MUDA_NOEXCEPT\n    {\n        return instance().m_current_kernel_name;\n    }\n\n    static auto current_capture_name(std::string_view name) MUDA_NOEXCEPT\n    {\n        auto&amp; ins                  = instance();\n        ins.m_current_capture_name = ins.m_capture_name_string_cache[name];\n        return ins.m_current_capture_name;\n    }\n\n    static auto current_capture_name() MUDA_NOEXCEPT\n    {\n        return instance().m_current_capture_name;\n    }\n\n    static auto current_kernel_file(std::string_view name) MUDA_NOEXCEPT\n    {\n        auto&amp; ins                 = instance();\n        ins.m_current_kernel_file = ins.m_kernel_file_string_cache[name];\n        return ins.m_current_kernel_file;\n    }\n\n    static auto current_kernel_file() MUDA_NOEXCEPT\n    {\n        return instance().m_current_kernel_file;\n    }\n\n    static auto current_kernel_line(int line) MUDA_NOEXCEPT\n    {\n        instance().m_current_kernel_line = line;\n        return line;\n    }\n\n    static auto current_kernel_line() MUDA_NOEXCEPT\n    {\n        return instance().m_current_kernel_line;\n    }\n\n    static LaunchInfoCache&amp; instance() MUDA_NOEXCEPT\n    {\n        thread_local static LaunchInfoCache instance;\n        return instance;\n    }\n};\n}  // namespace muda::details\n</code></pre>"},{"location":"muda/platform_8h/","title":"File platform.h","text":"<p>FileList &gt; muda &gt; tools &gt; platform.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/platform_8h/#macros","title":"Macros","text":"Type Name define MUDA_HAS_CXX20  __cplusplus &gt;= 202002L"},{"location":"muda/platform_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/platform_8h/#define-muda_has_cxx20","title":"define MUDA_HAS_CXX20","text":"<pre><code>#define MUDA_HAS_CXX20 __cplusplus &gt;= 202002L\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/platform.h</code></p>"},{"location":"muda/platform_8h_source/","title":"File platform.h","text":"<p>File List &gt; muda &gt; tools &gt; platform.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n// Cross Platform Macros\n#if defined(WIN64) || defined(_WIN64) || defined(__WIN64__)\n#define MUDA_PLATFORM_WIN64\n#elif defined(WIN32) || defined(_WIN32) || defined(__WIN32__)\n#define MUDA_PLATFORM_WIN32\n#elif defined(__linux__)\n#define MUDA_PLATFORM_LINUX\n#elif defined(__APPLE__)\n#define MUDA_PLATFORM_APPLE\n#endif\n\n// Windows 64 or 32\n#if defined(MUDA_PLATFORM_WIN64) || defined(MUDA_PLATFORM_WIN32)\n#define MUDA_PLATFORM_WINDOWS\n#endif\n\n// Function Attributes\n#if defined(MUDA_PLATFORM_WINDOWS)\n#define MUDA_STDCALL __stdcall\n#define MUDA_CDECL __cdecl\n#define MUDA_FASTCALL __fastcall\n#define MUDA_FUNCTION_SIG __FUNCSIG__\n#elif defined(MUDA_PLATFORM_LINUX)\n#define MUDA_STDCALL __attribute__((__stdcall__))\n#define MUDA_CDECL __attribute__((__cdecl__))\n#define MUDA_FASTCALL __attribute__((__fastcall__))\n#define MUDA_FUNCTION_SIG __PRETTY_FUNCTION__\n#endif\n\n#if defined(_MSVC_LANG)\n#define MUDA_HAS_CXX20 _HAS_CXX20\n#else\n#define MUDA_HAS_CXX20 __cplusplus &gt;= 202002L\n#endif\n</code></pre>"},{"location":"muda/string__pointer_8h/","title":"File string_pointer.h","text":"<p>FileList &gt; muda &gt; tools &gt; string_pointer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> </ul>"},{"location":"muda/string__pointer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/string__pointer_8h/#classes","title":"Classes","text":"Type Name class StringPointer <p>The documentation for this class was generated from the following file <code>src/muda/tools/string_pointer.h</code></p>"},{"location":"muda/string__pointer_8h_source/","title":"File string_pointer.h","text":"<p>File List &gt; muda &gt; tools &gt; string_pointer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/muda_def.h&gt;\n\nnamespace muda::details\n{\nclass StringPointer\n{\n  public:\n    char*        device_string = nullptr;\n    char*        host_string   = nullptr;\n    unsigned int length        = 0;\n\n    MUDA_INLINE MUDA_GENERIC const char* auto_select() const MUDA_NOEXCEPT\n    {\n#ifdef __CUDA_ARCH__\n        return device_string;\n#else\n        return host_string;\n#endif  // __CUDA_ARCH__\n    }\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/temp__buffer_8h/","title":"File temp_buffer.h","text":"<p>FileList &gt; muda &gt; tools &gt; temp_buffer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;muda/check/check.h&gt;</code></li> </ul>"},{"location":"muda/temp__buffer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda namespace details"},{"location":"muda/temp__buffer_8h/#classes","title":"Classes","text":"Type Name class TempBuffer &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/tools/temp_buffer.h</code></p>"},{"location":"muda/temp__buffer_8h_source/","title":"File temp_buffer.h","text":"<p>File List &gt; muda &gt; tools &gt; temp_buffer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda_runtime.h&gt;\n#include &lt;muda/check/check.h&gt;\nnamespace muda::details\n{\ntemplate &lt;typename T&gt;\nclass TempBuffer\n{\n  public:\n    TempBuffer() {}\n\n    TempBuffer(size_t size) { resize(size); }\n\n    ~TempBuffer()\n    {\n        if(m_data)\n        {\n            // we don't check the error here to prevent exception when app is shutting down\n            cudaFree(m_data);\n        }\n    }\n\n    TempBuffer(TempBuffer&amp;&amp; other) noexcept\n    {\n        m_size           = other.m_size;\n        m_capacity       = other.m_capacity;\n        m_data           = other.m_data;\n        other.m_size     = 0;\n        other.m_capacity = 0;\n        other.m_data     = nullptr;\n    }\n\n    TempBuffer&amp; operator=(TempBuffer&amp;&amp; other) noexcept\n    {\n        if(this == &amp;other)\n        {\n            return *this;\n        }\n        m_size           = other.m_size;\n        m_capacity       = other.m_capacity;\n        m_data           = other.m_data;\n        other.m_size     = 0;\n        other.m_capacity = 0;\n        other.m_data     = nullptr;\n        return *this;\n    }\n\n    // no change on copy\n    TempBuffer(const TempBuffer&amp;) noexcept {}\n    // no change on copy\n    TempBuffer&amp; operator=(const TempBuffer&amp;) noexcept { return *this; }\n\n    void copy_to(std::vector&lt;T&gt;&amp; vec, cudaStream_t stream = nullptr) const\n    {\n        vec.resize(m_size);\n        checkCudaErrors(cudaMemcpyAsync(\n            vec.data(), m_data, m_size * sizeof(T), cudaMemcpyDeviceToHost, stream));\n    }\n\n    void copy_from(TempBuffer&lt;T&gt;&amp; other, cudaStream_t stream = nullptr)\n    {\n        resize(other.size());\n        checkCudaErrors(cudaMemcpyAsync(\n            m_data, other.data(), other.size() * sizeof(T), cudaMemcpyDeviceToDevice, stream));\n    }\n\n    void copy_from(const std::vector&lt;T&gt;&amp; vec, cudaStream_t stream = nullptr)\n    {\n        resize(vec.size());\n        checkCudaErrors(cudaMemcpyAsync(\n            m_data, vec.data(), vec.size() * sizeof(T), cudaMemcpyHostToDevice, stream));\n    }\n\n    TempBuffer(const std::vector&lt;T&gt;&amp; vec) { copy_from(vec); }\n\n    TempBuffer&amp; operator=(const std::vector&lt;T&gt;&amp; vec)\n    {\n        copy_from(vec);\n        return *this;\n    }\n\n    void reserve(size_t new_cap, cudaStream_t stream = nullptr)\n    {\n        if(new_cap &lt;= m_capacity)\n        {\n            return;\n        }\n        T* new_data = nullptr;\n        checkCudaErrors(cudaMalloc(&amp;new_data, new_cap * sizeof(T)));\n        if(m_data)\n        {\n            checkCudaErrors(cudaFree(m_data));\n        }\n        m_data     = new_data;\n        m_capacity = new_cap;\n    }\n\n    void resize(size_t size, cudaStream_t stream = nullptr)\n    {\n        if(size &lt;= m_capacity)\n        {\n            m_size = size;\n            return;\n        }\n        reserve(size, stream);\n        m_size = size;\n    }\n\n    void free() noexcept\n    {\n        m_size     = 0;\n        m_capacity = 0;\n        if(m_data)\n        {\n            checkCudaErrors(cudaFree(m_data));\n            m_data = nullptr;\n        }\n    }\n\n    auto size() const noexcept { return m_size; }\n    auto data() const noexcept { return m_data; }\n    auto capacity() const noexcept { return m_capacity; }\n\n  private:\n    size_t m_size     = 0;\n    size_t m_capacity = 0;\n    T*     m_data     = nullptr;\n};\n\nusing ByteTempBuffer = TempBuffer&lt;std::byte&gt;;\n}  // namespace muda::details\n</code></pre>"},{"location":"muda/version_8h/","title":"File version.h","text":"<p>FileList &gt; muda &gt; tools &gt; version.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/version_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/version_8h/#macros","title":"Macros","text":"Type Name define MUDA_BASELINE_CUDACC_VER_MAJOR  11 define MUDA_BASELINE_CUDACC_VER_MINOR  6 define MUDA_WITH_DEVICE_STREAM_MODEL  0"},{"location":"muda/version_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/version_8h/#define-muda_baseline_cudacc_ver_major","title":"define MUDA_BASELINE_CUDACC_VER_MAJOR","text":"<pre><code>#define MUDA_BASELINE_CUDACC_VER_MAJOR 11\n</code></pre>"},{"location":"muda/version_8h/#define-muda_baseline_cudacc_ver_minor","title":"define MUDA_BASELINE_CUDACC_VER_MINOR","text":"<pre><code>#define MUDA_BASELINE_CUDACC_VER_MINOR 6\n</code></pre>"},{"location":"muda/version_8h/#define-muda_with_device_stream_model","title":"define MUDA_WITH_DEVICE_STREAM_MODEL","text":"<pre><code>#define MUDA_WITH_DEVICE_STREAM_MODEL 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/tools/version.h</code></p>"},{"location":"muda/version_8h_source/","title":"File version.h","text":"<p>File List &gt; muda &gt; tools &gt; version.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n// muda's baseline cuda version  is 11.6\n#define MUDA_BASELINE_CUDACC_VER_MAJOR 11\n#define MUDA_BASELINE_CUDACC_VER_MINOR 6\n\n#if(__CUDACC_VER_MAJOR__ &gt;= MUDA_BASELINE_CUDACC_VER_MAJOR)                    \\\n    &amp;&amp; (__CUDACC_VER_MINOR__ &gt;= MUDA_BASELINE_CUDACC_VER_MINOR)\n\n#define MUDA_BASELINE_CUDACC_VER_SATISFIED\n#define MUDA_WITH_THRUST_UNIVERSAL\n#define MUDA_WITH_GRAPH_MEMORY_ALLOC_FREE\n\n#endif\n\n\n#if(__CUDACC_VER_MAJOR__ &gt;= 11) &amp;&amp; (__CUDACC_VER_MINOR__ &gt;= 2)\n\n#define MUDA_WITH_ASYNC_MEMORY_ALLOC_FREE\nnamespace muda\n{\nconstexpr bool DEFAULT_ASYNC_ALLOC_FREE = true;\n}\n#else\nnamespace muda\n{\nconstexpr bool DEFAULT_ASYNC_ALLOC_FREE = false;\n}\n#endif\n\n#if(__CUDACC_VER_MAJOR__ &gt;= 12) &amp;&amp; (__CUDACC_VER_MINOR__ &gt;= 0)\n#define MUDA_WITH_DEVICE_STREAM_MODEL 1\n#else\n#define MUDA_WITH_DEVICE_STREAM_MODEL 0\n#endif\n</code></pre>"},{"location":"muda/dir_604bea9d06d02462c18f7966e507987c/","title":"Dir src/muda/type_traits","text":"<p>FileList &gt; muda &gt; type_traits</p>"},{"location":"muda/dir_604bea9d06d02462c18f7966e507987c/#files","title":"Files","text":"Type Name file always.h file cuda_arch.h file type_label.h file type_modifier.h <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/</code></p>"},{"location":"muda/always_8h/","title":"File always.h","text":"<p>FileList &gt; muda &gt; type_traits &gt; always.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/always_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/always_8h/#classes","title":"Classes","text":"Type Name struct always_false &lt;typename T&gt; struct always_true &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/always.h</code></p>"},{"location":"muda/always_8h_source/","title":"File always.h","text":"<p>File List &gt; muda &gt; type_traits &gt; always.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace muda\n{\ntemplate &lt;typename T&gt;\nstruct always_false\n{\n    static constexpr bool value = false;\n};\n\ntemplate &lt;typename T&gt;\nconstexpr bool always_false_v = always_false&lt;T&gt;::value;\n\ntemplate &lt;typename T&gt;\nstruct always_true\n{\n    static constexpr bool value = true;\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/cuda__arch_8h/","title":"File cuda_arch.h","text":"<p>FileList &gt; muda &gt; type_traits &gt; cuda_arch.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> </ul>"},{"location":"muda/cuda__arch_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/cuda__arch_8h/#classes","title":"Classes","text":"Type Name struct is_cuda_arch <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/cuda_arch.h</code></p>"},{"location":"muda/cuda__arch_8h_source/","title":"File cuda_arch.h","text":"<p>File List &gt; muda &gt; type_traits &gt; cuda_arch.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\nnamespace muda\n{\nstruct is_cuda_arch\n{\n#ifdef __CUDA_ARCH__\n    constexpr static bool value = true;\n#else\n    constexpr static bool value = false;\n#endif\n};\n\nconstexpr bool is_cuda_arch_v = is_cuda_arch::value;\n}  // namespace muda\n</code></pre>"},{"location":"muda/type__label_8h/","title":"File type_label.h","text":"<p>FileList &gt; muda &gt; type_traits &gt; type_label.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"muda/type__label_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/type__label_8h/#classes","title":"Classes","text":"Type Name struct force_trivial &lt;typename T&gt; struct force_trivially_constructible &lt;typename T&gt; struct force_trivially_copy_assignable &lt;typename T&gt; struct force_trivially_copy_constructible &lt;typename T&gt; struct force_trivially_destructible &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/type_label.h</code></p>"},{"location":"muda/type__label_8h_source/","title":"File type_label.h","text":"<p>File List &gt; muda &gt; type_traits &gt; type_label.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;type_traits&gt;\n\nnamespace muda\n{\n/*************************************************************************\n* \n*                               Type Labels\n* \n*************************************************************************/\n\n// force a type to be trivial (only in muda memory-related API)\ntemplate &lt;typename T&gt;\nstruct force_trivial\n{\n    constexpr static bool value = false;\n};\ntemplate &lt;typename T&gt;\nconstexpr bool force_trivial_v = force_trivial&lt;T&gt;::value;\ntemplate &lt;typename T&gt;\nconstexpr bool is_trivial_v = std::is_trivial_v&lt;T&gt; || force_trivial_v&lt;T&gt;;\n\n// force a type to be trivially destructible (only in muda memory-related API)\ntemplate &lt;typename T&gt;\nstruct force_trivially_destructible\n{\n    constexpr static bool value = false;\n};\ntemplate &lt;typename T&gt;\nconstexpr bool force_trivially_destructible_v = force_trivially_destructible&lt;T&gt;::value;\ntemplate &lt;typename T&gt;\nconstexpr bool is_trivially_destructible_v =\n    std::is_trivially_destructible_v&lt;T&gt; || force_trivially_destructible_v&lt;T&gt;;\n\n// force a type to be trivially constructible (only in muda memory-related API)\ntemplate &lt;typename T&gt;\nstruct force_trivially_constructible\n{\n    constexpr static bool value = false;\n};\ntemplate &lt;typename T&gt;\nconstexpr bool force_trivially_constructible_v = force_trivially_constructible&lt;T&gt;::value;\ntemplate &lt;typename T&gt;\nconstexpr bool is_trivially_constructible_v =\n    std::is_trivially_constructible_v&lt;T&gt; || force_trivially_constructible_v&lt;T&gt;;\n\n// force a type to be trivially copy constructible (only in muda memory-related API)\ntemplate &lt;typename T&gt;\nstruct force_trivially_copy_constructible\n{\n    constexpr static bool value = false;\n};\ntemplate &lt;typename T&gt;\nconstexpr bool force_trivially_copy_constructible_v =\n    force_trivially_copy_constructible&lt;T&gt;::value;\ntemplate &lt;typename T&gt;\nconstexpr bool is_trivially_copy_constructible_v =\n    std::is_trivially_copy_constructible_v&lt;T&gt; || force_trivially_copy_constructible_v&lt;T&gt;;\n\n// force a type to be trivially copy assignable (only in muda memory-related API)\ntemplate &lt;typename T&gt;\nstruct force_trivially_copy_assignable\n{\n    constexpr static bool value = false;\n};\ntemplate &lt;typename T&gt;\nconstexpr bool force_trivially_copy_assignable_v =\n    force_trivially_copy_assignable&lt;T&gt;::value;\ntemplate &lt;typename T&gt;\nconstexpr bool is_trivially_copy_assignable_v =\n    std::is_trivially_copy_assignable_v&lt;T&gt; || force_trivially_copy_assignable_v&lt;T&gt;;\n}  // namespace muda\n</code></pre>"},{"location":"muda/type__modifier_8h/","title":"File type_modifier.h","text":"<p>FileList &gt; muda &gt; type_traits &gt; type_modifier.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> </ul>"},{"location":"muda/type__modifier_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/type__modifier_8h/#classes","title":"Classes","text":"Type Name struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/type_traits/type_modifier.h</code></p>"},{"location":"muda/type__modifier_8h_source/","title":"File type_modifier.h","text":"<p>File List &gt; muda &gt; type_traits &gt; type_modifier.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;type_traits&gt;\n#include &lt;muda/muda_def.h&gt;\n\nnamespace muda\n{\n/*************************************************************************\n* \n*                               Raw Type\n* \n*************************************************************************/\ntemplate &lt;typename T&gt;\nusing raw_type_t = std::remove_all_extents_t&lt;std::remove_reference_t&lt;T&gt;&gt;;\n\n/*************************************************************************\n* \n*                               View Type\n* \n*************************************************************************/\ntemplate &lt;typename T&gt;\nstruct read_only_view\n{\n    using type = T;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view\n{\n    using type = T;\n};\n\ntemplate &lt;typename T&gt;\nusing read_only_view_t = typename read_only_view&lt;T&gt;::type;\n\ntemplate &lt;typename T&gt;\nconstexpr bool is_read_only_view_v = std::is_same_v&lt;T, read_only_view_t&lt;T&gt;&gt;;\n\ntemplate &lt;typename T&gt;\nusing read_write_view_t = typename read_write_view&lt;T&gt;::type;\n\ntemplate &lt;typename T&gt;\nconstexpr bool is_read_write_view_v = std::is_same_v&lt;T, read_write_view_t&lt;T&gt;&gt;;\n\ntemplate &lt;typename T&gt;\nconstexpr bool is_uniform_view_v = is_read_only_view_v&lt;T&gt; &amp;&amp; is_read_write_view_v&lt;T&gt;;\n\n/*************************************************************************\n* \n*                           Remove Const\n* \n*************************************************************************/\ntemplate &lt;typename T&gt;\nMUDA_GENERIC MUDA_INLINE constexpr T* remove_const(const T* ptr) noexcept\n{\n    return const_cast&lt;T*&gt;(ptr);\n}\n\ntemplate &lt;typename T&gt;\nMUDA_GENERIC MUDA_INLINE constexpr T&amp; remove_const(const T&amp; ref) noexcept\n{\n    return const_cast&lt;T&amp;&gt;(ref);\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_db2dafed41077e2be62453d93935ca4c/","title":"Dir src/muda/view","text":"<p>FileList &gt; muda &gt; view</p>"},{"location":"muda/dir_db2dafed41077e2be62453d93935ca4c/#files","title":"Files","text":"Type Name file view_base.h <p>The documentation for this class was generated from the following file <code>src/muda/view/</code></p>"},{"location":"muda/view__base_8h/","title":"File view_base.h","text":"<p>FileList &gt; muda &gt; view &gt; view_base.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/type_traits/type_modifier.h&gt;</code></li> </ul>"},{"location":"muda/view__base_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/view__base_8h/#classes","title":"Classes","text":"Type Name class ViewBase &lt;IsConst_&gt; <p>The documentation for this class was generated from the following file <code>src/muda/view/view_base.h</code></p>"},{"location":"muda/view__base_8h_source/","title":"File view_base.h","text":"<p>File List &gt; muda &gt; view &gt; view_base.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/type_traits/type_modifier.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst_&gt;\nclass ViewBase\n{\n  public:\n    constexpr static bool IsConst    = IsConst_;\n    constexpr static bool IsNonConst = !IsConst_;\n    template &lt;typename T&gt;\n    using auto_const_t = std::conditional_t&lt;IsConst, const T, T&gt;;\n    template &lt;typename T&gt;\n    using non_const_enable_t = std::enable_if_t&lt;IsNonConst, T&gt;;\n\n  private:\n    std::byte _dummy; // a workaround to avoid NVCC EBO bug.\n};\n}  // namespace muda\n</code></pre>"},{"location":"muda/dir_b8d9e5dede9d3b62139c9f3b116c88e0/","title":"Dir src/muda/viewer","text":"<p>FileList &gt; muda &gt; viewer</p>"},{"location":"muda/dir_b8d9e5dede9d3b62139c9f3b116c88e0/#files","title":"Files","text":"Type Name file dense.h file viewer_base.h"},{"location":"muda/dir_b8d9e5dede9d3b62139c9f3b116c88e0/#directories","title":"Directories","text":"Type Name dir dense <p>The documentation for this class was generated from the following file <code>src/muda/viewer/</code></p>"},{"location":"muda/dense_8h/","title":"File dense.h","text":"<p>FileList &gt; muda &gt; viewer &gt; dense.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/viewer/dense/dense_0d.h&gt;</code></li> <li><code>#include &lt;muda/viewer/dense/dense_1d.h&gt;</code></li> <li><code>#include &lt;muda/viewer/dense/dense_2d.h&gt;</code></li> <li><code>#include &lt;muda/viewer/dense/dense_3d.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense.h</code></p>"},{"location":"muda/dense_8h_source/","title":"File dense.h","text":"<p>File List &gt; muda &gt; viewer &gt; dense.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/viewer/dense/dense_0d.h&gt;\n#include &lt;muda/viewer/dense/dense_1d.h&gt;\n#include &lt;muda/viewer/dense/dense_2d.h&gt;\n#include &lt;muda/viewer/dense/dense_3d.h&gt;\n</code></pre>"},{"location":"muda/dir_23ef7a0035d05de8c06b1bf3400c653b/","title":"Dir src/muda/viewer/dense","text":"<p>FileList &gt; dense</p>"},{"location":"muda/dir_23ef7a0035d05de8c06b1bf3400c653b/#files","title":"Files","text":"Type Name file dense_0d.h file dense_1d.h A C/C++ array like viewer for kernel access, with safe checking on any input. You can index the element in <code>Dense1D&lt;T&gt;</code> by<code>operator ()</code> . file dense_2d.h file dense_3d.h <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense/</code></p>"},{"location":"muda/dense__0d_8h/","title":"File dense_0d.h","text":"<p>FileList &gt; dense &gt; dense_0d.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> </ul>"},{"location":"muda/dense__0d_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/dense__0d_8h/#classes","title":"Classes","text":"Type Name class DenseViewerT &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense/dense_0d.h</code></p>"},{"location":"muda/dense__0d_8h_source/","title":"File dense_0d.h","text":"<p>File List &gt; dense &gt; dense_0d.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/viewer/viewer_base.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst, typename T&gt;\nclass DenseViewerT : public ViewerBase&lt;IsConst&gt;\n{\n    using Base = ViewerBase&lt;IsConst&gt;;\n\n    template &lt;bool OtherIsConst, typename U&gt;\n    friend class DenseViewerT;\n\n    MUDA_VIEWER_COMMON_NAME(DenseViewerT);\n\n  public:\n    using ConstViewer    = DenseViewerT&lt;true, T&gt;;\n    using NonConstViewer = DenseViewerT&lt;false, T&gt;;\n    using ThisViewer     = DenseViewerT&lt;IsConst, T&gt;;\n\n  protected:\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    auto_const_t&lt;T&gt;* m_data = nullptr;\n\n  public:\n    using value_type = T;\n\n    MUDA_GENERIC DenseViewerT() MUDA_NOEXCEPT = default;\n\n    MUDA_GENERIC explicit DenseViewerT(auto_const_t&lt;T&gt;* p) MUDA_NOEXCEPT : m_data(p)\n    {\n    }\n\n    MUDA_GENERIC DenseViewerT(const DenseViewerT&amp;) MUDA_NOEXCEPT = default;\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC DenseViewerT(const DenseViewerT&lt;OtherIsConst, T&gt;&amp; other) MUDA_NOEXCEPT\n        : m_data(other.m_data)\n    {\n    }\n\n    MUDA_GENERIC ThisViewer&amp; operator=(const T&amp; v) MUDA_NOEXCEPT MUDA_REQUIRES(!IsConst)\n    {\n        static_assert(!IsConst, \"Cannot assign to a const viewer\");\n        check();\n        *m_data = v;\n        return *this;\n    }\n\n    MUDA_GENERIC auto as_const() const MUDA_NOEXCEPT\n    {\n        return ConstViewer{m_data};\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator*() const MUDA_NOEXCEPT\n    {\n        check();\n        return *m_data;\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* operator-&gt;() const MUDA_NOEXCEPT\n    {\n        check();\n        return m_data;\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data() const MUDA_NOEXCEPT { return m_data; }\n\n    MUDA_GENERIC operator auto_const_t&lt;T&gt;&amp;() const MUDA_NOEXCEPT\n    {\n        check();\n        return *m_data;\n    }\n\n  protected:\n    MUDA_INLINE MUDA_GENERIC void check() const MUDA_NOEXCEPT\n    {\n        if constexpr(DEBUG_VIEWER)\n        {\n            MUDA_KERNEL_ASSERT(m_data,\n                               \"Dense[%s:%s]: m_data is null. %s(%d)\",\n                               this-&gt;name(),\n                               this-&gt;kernel_name(),\n                               this-&gt;kernel_file(),\n                               this-&gt;kernel_line());\n        }\n    }\n};\n\ntemplate &lt;typename T&gt;\nusing Dense = DenseViewerT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CDense = DenseViewerT&lt;true, T&gt;;\n\n// viewer traits\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;Dense&lt;T&gt;&gt;\n{\n    using type = CDense&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CDense&lt;T&gt;&gt;\n{\n    using type = Dense&lt;T&gt;;\n};\n\n// make functions\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_cdense(const T* data) MUDA_NOEXCEPT\n{\n    return CDense&lt;T&gt;{data};\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_dense(T* data) MUDA_NOEXCEPT\n{\n    return Dense&lt;T&gt;{data};\n}\n\n//print convert\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC const T&amp; print_convert(const Dense&lt;T&gt;&amp; v) MUDA_NOEXCEPT\n{\n    return v.operator T&amp;();\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC const T&amp; print_convert(const CDense&lt;T&gt;&amp; v) MUDA_NOEXCEPT\n{\n    return v.operator const T&amp;();\n}\n\n}  // namespace muda\n</code></pre>"},{"location":"muda/dense__1d_8h/","title":"File dense_1d.h","text":"<p>FileList &gt; dense &gt; dense_1d.h</p> <p>Go to the source code of this file</p> <p>A C/C++ array like viewer for kernel access, with safe checking on any input. You can index the element in <code>Dense1D&lt;T&gt;</code> by<code>operator ()</code> .More...</p> <ul> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> </ul>"},{"location":"muda/dense__1d_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/dense__1d_8h/#classes","title":"Classes","text":"Type Name class Dense1DT &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt;"},{"location":"muda/dense__1d_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>MuGdxy </p> <p>Date:</p> <p>January 2024 </p> <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense/dense_1d.h</code></p>"},{"location":"muda/dense__1d_8h_source/","title":"File dense_1d.h","text":"<p>File List &gt; dense &gt; dense_1d.h</p> <p>Go to the documentation of this file</p> <pre><code>/*****************************************************************/ \n\n#pragma once\n#include &lt;muda/viewer/viewer_base.h&gt;\n\nnamespace muda\n{\n\n/*****************************************************************************\n *\n * Dense1D (1D array)\n * indexing (x)\n * \n * A C/C++ array like viewer.\n * \n *****************************************************************************/\n\ntemplate &lt;bool IsConst, typename T&gt;\nclass Dense1DT : public ViewerBase&lt;IsConst&gt;\n{\n    using Base = ViewerBase&lt;IsConst&gt;;\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    MUDA_VIEWER_COMMON_NAME(Dense1DT);\n\n  public:\n    using ConstViewer    = Dense1DT&lt;true, T&gt;;\n    using NonConstViewer = Dense1DT&lt;false, T&gt;;\n    using ThisViewer     = Dense1DT&lt;IsConst, T&gt;;\n\n  protected:\n    auto_const_t&lt;T&gt;* m_data = nullptr;\n    int              m_dim  = 0;\n\n  public:\n    using value_type = T;\n\n    MUDA_GENERIC Dense1DT() MUDA_NOEXCEPT = default;\n\n    MUDA_GENERIC Dense1DT(auto_const_t&lt;T&gt;* p, int dim) MUDA_NOEXCEPT : m_data(p),\n                                                                       m_dim(dim)\n    {\n    }\n\n    MUDA_GENERIC Dense1DT(const Dense1DT&amp; other) = default;\n\n    template &lt;bool OtherIsConst&gt;\n    MUDA_GENERIC Dense1DT(const Dense1DT&lt;OtherIsConst, T&gt;&amp; other) MUDA_NOEXCEPT\n        MUDA_REQUIRES(!OtherIsConst)\n        : m_data(other.data())\n        , m_dim(other.dim())\n    {\n        static_assert(OtherIsConst, \"Only non-const viewer can be convert to const viewer\");\n    }\n\n    MUDA_GENERIC auto as_const() const MUDA_NOEXCEPT\n    {\n        return ConstViewer{*this};\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator()(int x) const MUDA_NOEXCEPT\n    {\n        check();\n        return m_data[map(x)];\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data() const MUDA_NOEXCEPT { return m_data; }\n\n    MUDA_GENERIC int total_size() const MUDA_NOEXCEPT { return m_dim; }\n\n    MUDA_GENERIC int dim() const MUDA_NOEXCEPT { return m_dim; }\n\n    MUDA_GENERIC ThisViewer subview(int offset) const MUDA_NOEXCEPT\n    {\n        auto size = this-&gt;m_dim - offset;\n        if constexpr(DEBUG_VIEWER)\n        {\n            if(offset &lt; 0)\n                MUDA_KERNEL_ERROR(\"Dense1D[%s:%s]: subview out of range, offset=%d size=%d m_dim=(%d). %s(%d)\",\n                                  this-&gt;name(),\n                                  this-&gt;kernel_name(),\n                                  offset,\n                                  size,\n                                  this-&gt;m_dim,\n                                  this-&gt;kernel_file(),\n                                  this-&gt;kernel_line());\n        }\n        return ThisViewer{this-&gt;m_data + offset, size};\n    }\n\n    MUDA_GENERIC ThisViewer subview(int offset, int size) const MUDA_NOEXCEPT\n    {\n        if constexpr(DEBUG_VIEWER)\n        {\n            if(offset &lt; 0 || offset + size &gt; m_dim)\n                MUDA_KERNEL_ERROR(\"Dense1D[%s:%s]: subview out of range, offset=%d size=%d m_dim=(%d). %s(%d)\",\n                                  this-&gt;name(),\n                                  this-&gt;kernel_name(),\n                                  offset,\n                                  size,\n                                  this-&gt;m_dim,\n                                  this-&gt;kernel_file(),\n                                  this-&gt;kernel_line());\n        }\n        return ThisViewer{this-&gt;m_data + offset, size};\n    }\n\n  protected:\n    MUDA_INLINE MUDA_GENERIC void check() const MUDA_NOEXCEPT\n    {\n        if constexpr(DEBUG_VIEWER)\n            if(m_data == nullptr)\n                MUDA_KERNEL_ERROR(\"Dense1D[%s:%s]: m_data is null. %s(%d)\",\n                                  this-&gt;name(),\n                                  this-&gt;kernel_name(),\n                                  this-&gt;kernel_file(),\n                                  this-&gt;kernel_line());\n    }\n\n    MUDA_GENERIC int map(int x) const MUDA_NOEXCEPT\n    {\n        if constexpr(DEBUG_VIEWER)\n            if(!(x &gt;= 0 &amp;&amp; x &lt; m_dim))\n                MUDA_KERNEL_ERROR(\"Dense1D[%s:%s]: out of range, index=(%d) m_dim=(%d). %s(%d)\",\n                                  this-&gt;name(),\n                                  this-&gt;kernel_name(),\n                                  x,\n                                  m_dim,\n                                  this-&gt;kernel_file(),\n                                  this-&gt;kernel_line());\n        return x;\n    }\n};\n\ntemplate &lt;typename T&gt;\nusing Dense1D = Dense1DT&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CDense1D = Dense1DT&lt;true, T&gt;;\n\n// viewer traits\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;Dense1D&lt;T&gt;&gt;\n{\n    using type = CDense1D&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CDense1D&lt;T&gt;&gt;\n{\n    using type = Dense1D&lt;T&gt;;\n};\n\n// make functions\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_cdense_1d(const T* data, int dimx) MUDA_NOEXCEPT\n{\n    return CDense1D&lt;T&gt;(data, dimx);\n}\n\ntemplate &lt;typename T, int N&gt;\nMUDA_INLINE MUDA_GENERIC auto make_cdense_1d(const T (&amp;data)[N]) MUDA_NOEXCEPT\n{\n    return CDense1D&lt;T&gt;(data, N);\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_dense_1d(T* data, int dimx) MUDA_NOEXCEPT\n{\n    return Dense1D&lt;T&gt;(data, dimx);\n}\n\ntemplate &lt;typename T, int N&gt;\nMUDA_INLINE MUDA_GENERIC auto make_dense_1d(T (&amp;data)[N]) MUDA_NOEXCEPT\n{\n    return Dense1D&lt;T&gt;(data, N);\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/dense__2d_8h/","title":"File dense_2d.h","text":"<p>FileList &gt; dense &gt; dense_2d.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> </ul>"},{"location":"muda/dense__2d_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/dense__2d_8h/#classes","title":"Classes","text":"Type Name class Dense2DBase &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense/dense_2d.h</code></p>"},{"location":"muda/dense__2d_8h_source/","title":"File dense_2d.h","text":"<p>File List &gt; dense &gt; dense_2d.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/viewer/viewer_base.h&gt;\n\nnamespace muda\n{\n/*****************************************************************************\n *\n * Dense2D (2D array)\n * indexing (x,y)\n *  1) non-pitched:  x * dim_y + y \n *  2) pitched:      x * pitch + y\n *\n * Note:\n *  1) y moves faster than x, which is the same as C/C++ 2d array\n *  2) as for CUDA Memory2D, x index into height, y index into width.\n *****************************************************************************/\n\ntemplate &lt;bool IsConst, typename T&gt;\nclass Dense2DBase : public ViewerBase&lt;IsConst&gt;  // TODO\n{\n    using Base = ViewerBase&lt;IsConst&gt;;\n\n    MUDA_VIEWER_COMMON_NAME(Dense2DBase);\n\n\n  protected:\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    auto_const_t&lt;T&gt;* m_data;\n    int2             m_offset;\n    int2             m_dim;\n    int              m_pitch_bytes;\n\n  public:\n    using value_type     = T;\n    using ConstViewer    = Dense2DBase&lt;true, T&gt;;\n    using NonConstViewer = Dense2DBase&lt;false, T&gt;;\n    using ThisViewer     = Dense2DBase&lt;IsConst, T&gt;;\n\n\n    MUDA_GENERIC Dense2DBase() MUDA_NOEXCEPT : m_data(nullptr) {}\n\n    MUDA_GENERIC Dense2DBase(auto_const_t&lt;T&gt;* p, const int2&amp; offset, const int2&amp; dim, int pitch_bytes) MUDA_NOEXCEPT\n        : m_data(p),\n          m_offset(offset),\n          m_dim(dim),\n          m_pitch_bytes(pitch_bytes)\n    {\n    }\n\n    MUDA_GENERIC auto as_const() const MUDA_NOEXCEPT\n    {\n        return ConstViewer{m_data, m_offset, m_dim, m_pitch_bytes};\n    }\n\n    MUDA_GENERIC operator ConstViewer() const MUDA_NOEXCEPT\n    {\n        return as_const();\n    }\n\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator()(int x, int y) MUDA_NOEXCEPT\n    {\n        check();\n        check_range(x, y);\n\n        x += m_offset.x;\n        y += m_offset.y;\n        auto height_begin =\n            reinterpret_cast&lt;auto_const_t&lt;std::byte&gt;*&gt;(m_data) + x * m_pitch_bytes;\n        return *((auto_const_t&lt;T&gt;*)(height_begin) + y);\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator()(const int2&amp; xy) MUDA_NOEXCEPT\n    {\n        return operator()(xy.x, xy.y);\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; flatten(int i)\n    {\n        if constexpr(DEBUG_VIEWER)\n        {\n            MUDA_KERNEL_ASSERT(i &gt;= 0 &amp;&amp; i &lt; total_size(),\n                               \"Dense2D[%s:%s]: out of range, index=%d, total_size=%d. %s(%d)\",\n                               this-&gt;name(),\n                               this-&gt;kernel_name(),\n                               i,\n                               total_size(),\n                               this-&gt;kernel_file(),\n                               this-&gt;kernel_line());\n        }\n        auto x = i / m_dim.y;\n        auto y = i % m_dim.y;\n        return operator()(x, y);\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data() MUDA_NOEXCEPT { return m_data; }\n\n\n    MUDA_GENERIC const T&amp; operator()(const int2&amp; xy) const MUDA_NOEXCEPT\n    {\n        return remove_const(*this)(xy);\n    }\n\n\n    MUDA_GENERIC const T&amp; operator()(int x, int y) const MUDA_NOEXCEPT\n    {\n        return remove_const(*this)(x, y);\n    }\n\n    MUDA_GENERIC const T&amp; flatten(int i) const\n    {\n        return remove_const(*this).flatten(i);\n    }\n\n    MUDA_GENERIC const T* data() const MUDA_NOEXCEPT { return m_data; }\n\n    MUDA_GENERIC auto total_size() const MUDA_NOEXCEPT\n    {\n        return m_dim.x * m_dim.y;\n    }\n\n    MUDA_GENERIC auto area() const MUDA_NOEXCEPT { return total_size(); }\n\n    MUDA_GENERIC auto dim() const MUDA_NOEXCEPT { return m_dim; }\n\n    MUDA_GENERIC auto pitch_bytes() const MUDA_NOEXCEPT\n    {\n        return m_pitch_bytes;\n    }\n\n  protected:\n    MUDA_INLINE MUDA_GENERIC void check_range(int x, int y) const MUDA_NOEXCEPT\n    {\n        if constexpr(DEBUG_VIEWER)\n            if(!(x &gt;= 0 &amp;&amp; x &lt; m_dim.x &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m_dim.y))\n            {\n                MUDA_KERNEL_ERROR(\"Dense2D[%s:%s]: out of range, index=(%d,%d) dim=(%d,%d). %s(%d)\",\n                                  this-&gt;name(),\n                                  this-&gt;kernel_name(),\n                                  x,\n                                  y,\n                                  m_dim.x,\n                                  m_dim.y,\n                                  this-&gt;kernel_file(),\n                                  this-&gt;kernel_line());\n            }\n    }\n\n    MUDA_INLINE MUDA_GENERIC void check() const MUDA_NOEXCEPT\n    {\n        if constexpr(DEBUG_VIEWER)\n        {\n            MUDA_KERNEL_ASSERT(m_data,\n                               \"Dense2D[%s:%s]: m_data is null. %s(%d)\",\n                               this-&gt;name(),\n                               this-&gt;kernel_name(),\n                               this-&gt;kernel_file(),\n                               this-&gt;kernel_line());\n        }\n    }\n};\n\ntemplate &lt;typename T&gt;\nusing Dense2D = Dense2DBase&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CDense2D = Dense2DBase&lt;true, T&gt;;\n\n\n// viewer traits\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;Dense2D&lt;T&gt;&gt;\n{\n    using type = CDense2D&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CDense2D&lt;T&gt;&gt;\n{\n    using type = Dense2D&lt;T&gt;;\n};\n\n// make functions\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_cdense_2d(const T* data, const int2&amp; dim) MUDA_NOEXCEPT\n{\n    return CDense2D&lt;T&gt;{data, make_int2(0, 0), dim, static_cast&lt;int&gt;(dim.y * sizeof(T))};\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_dense_2d(T* data, const int2&amp; dim) MUDA_NOEXCEPT\n{\n    return Dense2D&lt;T&gt;{data, make_int2(0, 0), dim, static_cast&lt;int&gt;(dim.y * sizeof(T))};\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_cdense_2d(const T* data, int dimx, int dimy) MUDA_NOEXCEPT\n{\n    return make_cdense_2d(data, make_int2(dimx, dimy));\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_dense_2d(T* data, int dimx, int dimy) MUDA_NOEXCEPT\n{\n    return make_dense_2d(data, make_int2(dimx, dimy));\n}\n\n\n}  // namespace muda\n</code></pre>"},{"location":"muda/dense__3d_8h/","title":"File dense_3d.h","text":"<p>FileList &gt; dense &gt; dense_3d.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/viewer/viewer_base.h&gt;</code></li> </ul>"},{"location":"muda/dense__3d_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/dense__3d_8h/#classes","title":"Classes","text":"Type Name class Dense3DBase &lt;IsConst, typename T&gt; struct read_only_view &lt;typename T&gt; struct read_write_view &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>src/muda/viewer/dense/dense_3d.h</code></p>"},{"location":"muda/dense__3d_8h_source/","title":"File dense_3d.h","text":"<p>File List &gt; dense &gt; dense_3d.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/viewer/viewer_base.h&gt;\n\nnamespace muda\n{\n/*****************************************************************************************\n *\n * Dense2D (3D array)\n * indexing (x,y,z)\n *  1) non-pitched:  x * dim_y * dimz + y * dim_z + z \n *  2) pitched:      x * dim_y * pitch + y * pitch + z \n *\n * Note:\n *  1) z moves faster than y, y moves faster than x, which is the same as C/C++ 2d array\n *  2) as for CUDA Memory3D, x index into depth, y index into height, z index into width\n ****************************************************************************************/\n\ntemplate &lt;bool IsConst, typename T&gt;\nclass Dense3DBase : public ViewerBase&lt;IsConst&gt;\n{\n    using Base = ViewerBase&lt;IsConst&gt;;\n    MUDA_VIEWER_COMMON_NAME(Dense3DBase);\n\n  protected:\n    template &lt;typename U&gt;\n    using auto_const_t = typename Base::template auto_const_t&lt;U&gt;;\n\n    auto_const_t&lt;T&gt;* m_data;\n    int3             m_offset;\n    int3             m_dim;\n    int              m_pitch_bytes;\n    int              m_pitch_bytes_area;\n\n  public:\n    using value_type     = T;\n    using ConstViewer    = Dense3DBase&lt;true, T&gt;;\n    using NonConstViewer = Dense3DBase&lt;false, T&gt;;\n    using ThisViewer     = Dense3DBase&lt;IsConst, T&gt;;\n\n    MUDA_GENERIC Dense3DBase() MUDA_NOEXCEPT : m_data(nullptr){};\n\n    MUDA_GENERIC Dense3DBase(auto_const_t&lt;T&gt;* p,\n                             const int3&amp;      offset,\n                             const int3&amp;      dim,\n                             int              pitch_bytes,\n                             int              pitch_bytes_area) MUDA_NOEXCEPT\n        : m_data(p),\n          m_offset(offset),\n          m_dim(dim),\n          m_pitch_bytes(pitch_bytes),\n          m_pitch_bytes_area(pitch_bytes_area)\n    {\n    }\n\n    MUDA_GENERIC auto as_const() const MUDA_NOEXCEPT\n    {\n        return ConstViewer{m_data, m_offset, m_dim, m_pitch_bytes, m_pitch_bytes_area};\n    }\n\n    MUDA_GENERIC operator ConstViewer() const MUDA_NOEXCEPT\n    {\n        return as_const();\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator()(int x, int y, int z) MUDA_NOEXCEPT\n    {\n        check();\n        check_range(x, y, z);\n        auto depth_begin = reinterpret_cast&lt;std::byte*&gt;(m_data) + x * m_pitch_bytes_area;\n        auto height_begin = depth_begin + y * m_pitch_bytes;\n        return *(reinterpret_cast&lt;T*&gt;(height_begin) + z);\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; operator()(const int3&amp; xyz) MUDA_NOEXCEPT\n    {\n        return operator()(xyz.x, xyz.y, xyz.z);\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;* data() MUDA_NOEXCEPT { return m_data; }\n\n\n    MUDA_GENERIC const T&amp; operator()(int x, int y, int z) const MUDA_NOEXCEPT\n    {\n        return remove_const(*this)(x, y, z);\n    }\n\n\n    MUDA_GENERIC const T&amp; operator()(const int3&amp; xyz) const MUDA_NOEXCEPT\n    {\n        return remove_const(*this)(xyz.x, xyz.y, xyz.z);\n    }\n\n    MUDA_GENERIC auto_const_t&lt;T&gt;&amp; flatten(int i) MUDA_NOEXCEPT\n    {\n        if constexpr(DEBUG_VIEWER)\n        {\n            MUDA_KERNEL_ASSERT(i &gt;= 0 &amp;&amp; i &lt; total_size(),\n                               \"Dense3D[%s:%s]: out of range, index=%d, total_size=%d. %s(%d)\",\n                               this-&gt;name(),\n                               this-&gt;kernel_name(),\n                               i,\n                               total_size(),\n                               this-&gt;kernel_file(),\n                               this-&gt;kernel_line());\n        }\n        auto area       = m_dim.y * m_dim.z;\n        auto x          = i / area;\n        auto i_in_area  = i % area;\n        auto y          = i_in_area / m_dim.z;\n        auto i_in_width = i_in_area % m_dim.z;\n        auto z          = i_in_width;\n        return operator()(x, y, z);\n    }\n\n\n    MUDA_GENERIC const T&amp; flatten(int i) const MUDA_NOEXCEPT\n    {\n        return remove_const(*this).flatten(i);\n    }\n\n    MUDA_GENERIC const T* data() const MUDA_NOEXCEPT { return m_data; }\n\n\n    MUDA_GENERIC auto dim() const MUDA_NOEXCEPT { return m_dim; }\n    MUDA_GENERIC int  area() const MUDA_NOEXCEPT { return m_dim.y * m_dim.z; }\n    MUDA_GENERIC int  volume() const MUDA_NOEXCEPT { return total_size(); }\n    MUDA_GENERIC int  total_size() const MUDA_NOEXCEPT\n    {\n        return m_dim.x * area();\n    }\n    MUDA_GENERIC int pitch_bytes() const MUDA_NOEXCEPT { return m_pitch_bytes; }\n    MUDA_GENERIC int pitch_bytes_area() const MUDA_NOEXCEPT\n    {\n        return m_pitch_bytes_area;\n    }\n    MUDA_GENERIC int total_bytes() const MUDA_NOEXCEPT\n    {\n        return m_pitch_bytes_area * m_dim.x;\n    }\n\n  protected:\n    MUDA_INLINE MUDA_GENERIC void check_range(int x, int y, int z) const MUDA_NOEXCEPT\n    {\n        if constexpr(DEBUG_VIEWER)\n        {\n            if(!(x &gt;= 0 &amp;&amp; x &lt; m_dim.x &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m_dim.y &amp;&amp; z &gt;= 0\n                 &amp;&amp; z &lt; m_dim.z))\n                MUDA_KERNEL_ERROR(\"Dense3D[%s:%s]: out of range, index=(%d,%d,%d) dim=(%d,%d,%d). %s(%d)\",\n                                  this-&gt;name(),\n                                  this-&gt;kernel_name(),\n                                  x,\n                                  y,\n                                  z,\n                                  m_dim.x,\n                                  m_dim.y,\n                                  m_dim.z,\n                                  this-&gt;kernel_file(),\n                                  this-&gt;kernel_line());\n        }\n    }\n\n    MUDA_INLINE MUDA_GENERIC void check() const MUDA_NOEXCEPT\n    {\n        if constexpr(DEBUG_VIEWER)\n            if(m_data == nullptr)\n                MUDA_KERNEL_ERROR(\"Dense3D[%s:%s]: data is null. %s(%d)\",\n                                  this-&gt;name(),\n                                  this-&gt;kernel_name(),\n                                  this-&gt;kernel_file(),\n                                  this-&gt;kernel_line());\n    }\n};\n\ntemplate &lt;typename T&gt;\nusing Dense3D = Dense3DBase&lt;false, T&gt;;\n\ntemplate &lt;typename T&gt;\nusing CDense3D = Dense3DBase&lt;true, T&gt;;\n\n// viewer traits\ntemplate &lt;typename T&gt;\nstruct read_only_view&lt;Dense3D&lt;T&gt;&gt;\n{\n    using type = CDense3D&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct read_write_view&lt;CDense3D&lt;T&gt;&gt;\n{\n    using type = Dense3D&lt;T&gt;;\n};\n\n// make functions\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_cdense_3d(const T* data, const int3&amp; dim) MUDA_NOEXCEPT\n{\n    auto pitch_bytes = dim.z * sizeof(T);\n    return CDense3D&lt;T&gt;{data,\n                       make_int3(0, 0, 0),\n                       dim,\n                       static_cast&lt;int&gt;(pitch_bytes),\n                       static_cast&lt;int&gt;(dim.y * pitch_bytes)};\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_dense_3d(T* data, const int3&amp; dim) MUDA_NOEXCEPT\n{\n    auto pitch_bytes = dim.z * sizeof(T);\n    return Dense3D&lt;T&gt;{data,\n                      make_int3(0, 0, 0),\n                      dim,\n                      static_cast&lt;int&gt;(pitch_bytes),\n                      static_cast&lt;int&gt;(dim.y * pitch_bytes)};\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_cdense_3d(const T* data, int dimx, int dimy, int dimz) MUDA_NOEXCEPT\n{\n    return make_cdense_3d(data, make_int3(dimx, dimy, dimz));\n}\n\ntemplate &lt;typename T&gt;\nMUDA_INLINE MUDA_GENERIC auto make_dense_3d(T* data, int dimx, int dimy, int dimz) MUDA_NOEXCEPT\n{\n    return make_dense_3d(data, make_int3(dimx, dimy, dimz));\n}\n}  // namespace muda\n</code></pre>"},{"location":"muda/viewer__base_8h/","title":"File viewer_base.h","text":"<p>FileList &gt; muda &gt; viewer &gt; viewer_base.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cuda.h&gt;</code></li> <li><code>#include &lt;cuda_runtime.h&gt;</code></li> <li><code>#include &lt;cuda_runtime_api.h&gt;</code></li> <li><code>#include &lt;muda/muda_def.h&gt;</code></li> <li><code>#include &lt;muda/tools/debug_log.h&gt;</code></li> <li><code>#include &lt;muda/muda_config.h&gt;</code></li> <li><code>#include &lt;muda/assert.h&gt;</code></li> <li><code>#include &lt;muda/tools/launch_info_cache.h&gt;</code></li> <li><code>#include &lt;muda/tools/fuzzy.h&gt;</code></li> <li><code>#include &lt;muda/type_traits/type_modifier.h&gt;</code></li> </ul>"},{"location":"muda/viewer__base_8h/#namespaces","title":"Namespaces","text":"Type Name namespace muda"},{"location":"muda/viewer__base_8h/#classes","title":"Classes","text":"Type Name class ViewerBase &lt;IsConst_&gt;"},{"location":"muda/viewer__base_8h/#macros","title":"Macros","text":"Type Name define MUDA_VIEWER_COMMON_NAME (viewer_name)"},{"location":"muda/viewer__base_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/viewer__base_8h/#define-muda_viewer_common_name","title":"define MUDA_VIEWER_COMMON_NAME","text":"<pre><code>#define MUDA_VIEWER_COMMON_NAME (\n    viewer_name\n) public:                                                                      \\\n    using this_type = viewer_name;                                             \\\n                                                                               \\\n    MUDA_INLINE MUDA_HOST this_type&amp; name(const char* n) noexcept              \\\n    {                                                                          \\ ::muda::ViewerBase &lt;viewer_name::IsConst&gt;::name(n);                     \\\n        return *this;                                                          \\\n    }                                                                          \\\n                                                                               \\\n    MUDA_INLINE MUDA_GENERIC const char* name() const noexcept                 \\\n    {                                                                          \\\n        return ::muda::ViewerBase &lt;viewer_name::IsConst&gt;::name();               \\\n    }                                                                          \\\n                                                                               \\\n  private:\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/viewer/viewer_base.h</code></p>"},{"location":"muda/viewer__base_8h_source/","title":"File viewer_base.h","text":"<p>File List &gt; muda &gt; viewer &gt; viewer_base.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cuda.h&gt;\n#include &lt;cuda_runtime.h&gt;\n#include &lt;cuda_runtime_api.h&gt;\n\n#include &lt;muda/muda_def.h&gt;\n#include &lt;muda/tools/debug_log.h&gt;\n#include &lt;muda/muda_config.h&gt;\n#include &lt;muda/assert.h&gt;\n#include &lt;muda/tools/launch_info_cache.h&gt;\n#include &lt;muda/tools/fuzzy.h&gt;\n#include &lt;muda/type_traits/type_modifier.h&gt;\n\nnamespace muda\n{\ntemplate &lt;bool IsConst_ = false&gt;\nclass ViewerBase\n{\n  public:\n    constexpr static bool IsConst    = IsConst_;\n    constexpr static bool IsNonConst = !IsConst_;\n\n  protected:\n    template &lt;typename T&gt;\n    using auto_const_t = std::conditional_t&lt;IsConst, const T, T&gt;;\n    template &lt;typename T&gt;\n    using non_const_enable_t = std::enable_if_t&lt;IsNonConst, T&gt;;\n\n  private:\n    // friend class details::ViewerBaseAccessor;\n\n#if MUDA_CHECK_ON\n    details::StringPointer m_viewer_name;\n    details::StringPointer m_kernel_name;\n    details::StringPointer m_kernel_file;\n    int                    m_kernel_line = -1;\n#else\n    int m_dummy = 0;  // a dummy member to avoid empty class\n#endif\n  public:\n    MUDA_GENERIC ViewerBase() MUDA_NOEXCEPT\n    {\n#if MUDA_CHECK_ON\n#ifndef __CUDA_ARCH__\n            m_kernel_name = details::LaunchInfoCache::current_kernel_name();\n            m_kernel_file = details::LaunchInfoCache::current_kernel_file();\n            m_kernel_line = details::LaunchInfoCache::current_kernel_line();\n#endif\n#endif\n    }\n\n    MUDA_GENERIC const char* name() const MUDA_NOEXCEPT\n    {\n#if MUDA_CHECK_ON\n        auto n = m_viewer_name.auto_select();\n        if(n &amp;&amp; *n != '\\0')\n            return n;\n#endif\n        return \"~\";\n    }\n\n    MUDA_GENERIC const char* kernel_name() const MUDA_NOEXCEPT\n    {\n#if MUDA_CHECK_ON\n        auto n = m_kernel_name.auto_select();\n        if(n &amp;&amp; *n != '\\0')\n            return n;\n#endif\n        return \"~\";\n    }\n\n    MUDA_GENERIC const char* kernel_file() const MUDA_NOEXCEPT\n    {\n#if MUDA_CHECK_ON\n        auto n = m_kernel_file.auto_select();\n        if(n &amp;&amp; *n != '\\0')\n            return n;\n#endif\n        return \"~\";\n    }\n\n    MUDA_GENERIC int kernel_line() const MUDA_NOEXCEPT\n    {\n#if MUDA_CHECK_ON\n        return m_kernel_line;\n#endif\n        return -1;\n    }\n\n    MUDA_INLINE MUDA_GENERIC void copy_label(const ViewerBase&amp; other) MUDA_NOEXCEPT\n    {\n#if MUDA_CHECK_ON\n        m_viewer_name = other.m_viewer_name;\n        m_kernel_name = other.m_kernel_name;\n        m_kernel_file = other.m_kernel_file;\n        m_kernel_line = other.m_kernel_line;\n#endif\n    }\n\n    // default copy / move\n    ViewerBase(const ViewerBase&amp;)            = default;\n    ViewerBase(ViewerBase&amp;&amp;)                 = default;\n    ViewerBase&amp; operator=(const ViewerBase&amp;) = default;\n    ViewerBase&amp; operator=(ViewerBase&amp;&amp;)      = default;\n\n  protected:\n    MUDA_INLINE MUDA_HOST void name(const char* n) MUDA_NOEXCEPT\n    {\n#if MUDA_CHECK_ON\n        m_viewer_name = details::LaunchInfoCache::view_name(n);\n#endif\n    }\n\n    MUDA_INLINE MUDA_GENERIC void name(details::StringPointer pointer) MUDA_NOEXCEPT\n    {\n#if MUDA_CHECK_ON\n        m_viewer_name = pointer;\n#endif\n    }\n};\n\n#define MUDA_VIEWER_COMMON_NAME(viewer_name)                                   \\\n  public:                                                                      \\\n    using this_type = viewer_name;                                             \\\n                                                                               \\\n    MUDA_INLINE MUDA_HOST this_type&amp; name(const char* n) noexcept              \\\n    {                                                                          \\\n        ::muda::ViewerBase&lt;viewer_name::IsConst&gt;::name(n);                     \\\n        return *this;                                                          \\\n    }                                                                          \\\n                                                                               \\\n    MUDA_INLINE MUDA_GENERIC const char* name() const noexcept                 \\\n    {                                                                          \\\n        return ::muda::ViewerBase&lt;viewer_name::IsConst&gt;::name();               \\\n    }                                                                          \\\n                                                                               \\\n  private:\n}  // namespace muda\n</code></pre>"},{"location":"muda/syntax__sugar_8h/","title":"File syntax_sugar.h","text":"<p>FileList &gt; muda &gt; syntax_sugar.h</p> <p>Go to the source code of this file</p>"},{"location":"muda/syntax__sugar_8h/#macros","title":"Macros","text":"Type Name define MUDA_DEVICE (__VA_ARGS__) mutable define def (viewer, from) viewer = (from).name(#viewer) define kernel_name () kernel_name(__FUNCTION__) define node (name) create_node(name) &lt;&lt; [&amp;]"},{"location":"muda/syntax__sugar_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"muda/syntax__sugar_8h/#define-muda_device","title":"define MUDA_DEVICE","text":"<pre><code>#define MUDA_DEVICE (\n    __VA_ARGS__\n) mutable\n</code></pre>"},{"location":"muda/syntax__sugar_8h/#define-def","title":"define def","text":"<pre><code>#define def (\n    viewer,\n    from\n) viewer = (from).name(#viewer)\n</code></pre>"},{"location":"muda/syntax__sugar_8h/#define-kernel_name","title":"define kernel_name","text":"<pre><code>#define kernel_name (\n\n) kernel_name(__FUNCTION__)\n</code></pre>"},{"location":"muda/syntax__sugar_8h/#define-node","title":"define node","text":"<pre><code>#define node (\n    name\n) create_node(name) &lt;&lt; [&amp;]\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/muda/syntax_sugar.h</code></p>"},{"location":"muda/syntax__sugar_8h_source/","title":"File syntax_sugar.h","text":"<p>File List &gt; muda &gt; syntax_sugar.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n// usage:\n// Launch().apply(\n// [] $()\n// {\n//\n// });\n//\n// you don't need to write mutable and __device__\n#define $(...) MUDA_DEVICE(__VA_ARGS__) mutable\n\n// usage:\n// Launch().apply(\n// [$def(viewer, buffer)] $()\n// {\n//\n// });\n#define $def(viewer, from) viewer = (from).name(#viewer)\n\n// usage:\n// ComputeGraph g;\n// g.$node(name)\n// {\n\n// };\n//\n// you don't need to write g.create_node(name) &lt;&lt; [&amp;]\n// {\n//\n// }\n#define $node(name) create_node(name) &lt;&lt; [&amp;]\n\n#define $kernel_name() kernel_name(__FUNCTION__)\n</code></pre>"},{"location":"muda/type__define_8h/","title":"File type_define.h","text":"<p>FileList &gt; muda &gt; type_define.h</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>src/muda/type_define.h</code></p>"},{"location":"muda/type__define_8h_source/","title":"File type_define.h","text":"<p>File List &gt; muda &gt; type_define.h</p> <p>Go to the documentation of this file</p>"},{"location":"muda/viewer_8h/","title":"File viewer.h","text":"<p>FileList &gt; muda &gt; viewer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;muda/viewer/dense.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/muda/viewer.h</code></p>"},{"location":"muda/viewer_8h_source/","title":"File viewer.h","text":"<p>File List &gt; muda &gt; viewer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;muda/viewer/dense.h&gt;\n</code></pre>"},{"location":"muda/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace TCB_SPAN_NAMESPACE_NAME <ul> <li>namespace detail </li> </ul> </li> <li>namespace muda <ul> <li>namespace config </li> <li>namespace details <ul> <li>namespace buffer </li> <li>namespace eigen </li> <li>namespace field </li> <li>namespace stream </li> </ul> </li> <li>namespace distance </li> <li>namespace eigen </li> <li>namespace lbvh <ul> <li>namespace details </li> </ul> </li> <li>namespace spatial_hash <ul> <li>namespace details </li> </ul> </li> </ul> </li> <li>namespace std </li> <li>namespace thrust </li> </ul>"},{"location":"muda/classes/","title":"Class Index","text":""},{"location":"muda/classes/#a","title":"a","text":"<ul> <li>AABB (muda::spatial_hash)</li> <li>AABB (muda::lbvh)</li> <li>AddNodeProxy (muda::ComputeGraph)</li> <li>always_false (muda)</li> <li>always_true (muda)</li> <li>AnalyticalInverse (muda::eigen)</li> <li>AsIterator (muda::FieldEntryViewCore)</li> </ul>"},{"location":"muda/classes/#b","title":"b","text":"<ul> <li>BoundingSphere (muda::spatial_hash)</li> <li>BSRMatrixViewT (muda)</li> <li>Buffer2DViewT (muda)</li> <li>Buffer3DViewT (muda)</li> <li>BufferInfoAccessor (muda::details::buffer)</li> <li>BufferLaunch (muda)</li> <li>BufferViewT (muda)</li> <li>BVH (muda::lbvh)</li> <li>BVHViewerBase (muda::lbvh::details)</li> </ul>"},{"location":"muda/classes/#c","title":"c","text":"<ul> <li>CDoublet (muda::DoubletVectorViewerT)</li> <li>CFieldEntryView (muda)</li> <li>CFieldEntryViewer (muda)</li> <li>ClosureId (muda)</li> <li>CMatrixMapInfo (muda)</li> <li>CollisionPair (muda::spatial_hash)</li> <li>ComputeGraph (muda)</li> <li>ComputeGraphAccessor (muda::details)</li> <li>ComputeGraphBuilder (muda)</li> <li>ComputeGraphCaptureNode (muda)</li> <li>ComputeGraphClosure (muda)</li> <li>ComputeGraphDependency (muda)</li> <li>ComputeGraphGraphvizOptions (muda)</li> <li>ComputeGraphNode (muda)</li> <li>ComputeGraphNodeBase (muda)</li> <li>ComputeGraphVar (muda)</li> <li>ComputeGraphVar (muda)</li> <li>ComputeGraphVar (muda)</li> <li>ComputeGraphVar (muda)</li> <li>ComputeGraphVar (muda)</li> <li>ComputeGraphVar (muda)</li> <li>ComputeGraphVarBase (muda)</li> <li>ComputeGraphVarManager (muda)</li> <li>COOMatrixViewT (muda)</li> <li>COOVectorViewBase (muda)</li> <li>CTriplet (muda::TripletMatrixViewerT)</li> <li>CubWrapper (muda)</li> <li>cuda_error (muda)</li> </ul>"},{"location":"muda/classes/#d","title":"d","text":"<ul> <li>Debug (muda)</li> <li>Default (muda)</li> <li>DefaultMortonCodeCalculator (muda::lbvh)</li> <li>DefaultPredication (muda::spatial_hash)</li> <li>DefaultQueryCallback (muda::lbvh::details::BVHViewerBase)</li> <li>Dense1DT (muda)</li> <li>Dense2DBase (muda)</li> <li>Dense3DBase (muda)</li> <li>DenseMatrixViewerT (muda)</li> <li>DenseMatrixViewT (muda)</li> <li>DenseVectorViewerT (muda)</li> <li>DenseVectorViewT (muda)</li> <li>DenseViewerT (muda)</li> <li>DeviceBCOOMatrix (muda)</li> <li>DeviceBCOOMatrix (muda)</li> <li>DeviceBCOOVector (muda)</li> <li>DeviceBCOOVector (muda)</li> <li>DeviceBSRMatrix (muda)</li> <li>DeviceBuffer (muda)</li> <li>DeviceBuffer2D (muda)</li> <li>DeviceBuffer3D (muda)</li> <li>DeviceDenseMatrix (muda)</li> <li>DeviceDenseVector (muda)</li> <li>DeviceDoubletVector (muda)</li> <li>DeviceHistogram (muda)</li> <li>DeviceMergeSort (muda)</li> <li>DevicePartition (muda)</li> <li>DeviceRadixSort (muda)</li> <li>DeviceReduce (muda)</li> <li>DeviceRunLengthEncode (muda)</li> <li>DeviceScan (muda)</li> <li>DeviceSegmentedRadixSort (muda)</li> <li>DeviceSegmentedReduce (muda)</li> <li>DeviceSegmentedSort (muda)</li> <li>DeviceSelect (muda)</li> <li>DeviceSpmv (muda)</li> <li>DeviceTripletMatrix (muda)</li> <li>DeviceVar (muda)</li> <li>DeviceVector (muda)</li> <li>DoubletVectorViewerT (muda)</li> <li>DoubletVectorViewT (muda)</li> <li>DoubletVectorViewT (muda)</li> </ul>"},{"location":"muda/classes/#e","title":"e","text":"<ul> <li>Empty (muda)</li> <li>EntryProxy (muda::FieldBuilder)</li> <li>Event (muda)</li> <li>EventRecordNode (muda)</li> <li>EventWaitNode (muda)</li> <li>exception (muda)</li> <li>Extent2D (muda)</li> <li>Extent3D (muda)</li> </ul>"},{"location":"muda/classes/#f","title":"f","text":"<ul> <li>Field (muda)</li> <li>FieldBuilder (muda)</li> <li>FieldBuildOptions (muda)</li> <li>FieldEntry (muda)</li> <li>FieldEntryBase (muda)</li> <li>FieldEntryBaseData (muda)</li> <li>FieldEntryCore (muda)</li> <li>FieldEntryLaunch (muda)</li> <li>FieldEntryLayoutInfo (muda)</li> <li>FieldEntryView (muda)</li> <li>FieldEntryViewBase (muda)</li> <li>FieldEntryViewCore (muda)</li> <li>FieldEntryViewer (muda)</li> <li>FieldEntryViewerBase (muda)</li> <li>FieldEntryViewerCore (muda)</li> <li>FireAndForget (muda::Stream)</li> <li>Flags (muda)</li> <li>force_trivial (muda)</li> <li>force_trivially_constructible (muda)</li> <li>force_trivially_copy_assignable (muda)</li> <li>force_trivially_copy_constructible (muda)</li> <li>force_trivially_destructible (muda)</li> </ul>"},{"location":"muda/classes/#g","title":"g","text":"<ul> <li>GaussEliminationInverse (muda::eigen)</li> <li>Graph (muda)</li> <li>GraphExec (muda)</li> <li>GraphFireAndForget (muda::Stream)</li> <li>GraphLaunch (muda)</li> <li>GraphNode (muda)</li> <li>GraphPhaseGuard (muda::ComputeGraph)</li> <li>GraphTailLaunch (muda::Stream)</li> <li>GraphViewer (muda)</li> </ul>"},{"location":"muda/classes/#h","title":"h","text":"<ul> <li>has_size_and_data (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>has_size_and_data (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>hash&lt; muda::ClosureId &gt; (std)</li> <li>hash&lt; muda::details::MatrixFormatConverterType &gt; (std)</li> <li>hash&lt; muda::IdWithType&lt; T &gt; &gt; (std)</li> <li>HostCall (muda)</li> <li>HostDeviceConfig (muda)</li> <li>HostDeviceConfigView (muda)</li> <li>HostDeviceStringCache (muda::details)</li> <li>HostNode (muda)</li> <li>HostNodeParms (muda)</li> <li>HostVector (muda)</li> </ul>"},{"location":"muda/classes/#i","title":"i","text":"<ul> <li>IdWithType (muda)</li> <li>invalid_argument (muda)</li> <li>is_complete (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>is_complete (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>is_container (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>is_container_element_type_compatible (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>is_container_element_type_compatible (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>is_cuda_arch (muda)</li> <li>is_span (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>is_span (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>is_std_array (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>is_std_array (TCB_SPAN_NAMESPACE_NAME::detail)</li> </ul>"},{"location":"muda/classes/#k","title":"k","text":"<ul> <li>Kernel (muda)</li> <li>KernelLabel (muda)</li> <li>KernelNode (muda)</li> <li>KernelNodeParms (muda)</li> </ul>"},{"location":"muda/classes/#l","title":"l","text":"<ul> <li>Launch (muda)</li> <li>LaunchBase (muda)</li> <li>LaunchCallable (muda::details)</li> <li>LaunchCore (muda)</li> <li>LaunchInfoCache (muda::details)</li> <li>LinearSystemAlgorithm (muda)</li> <li>LinearSystemContext (muda)</li> <li>LinearSystemContextCreateInfo (muda)</li> <li>LinearSystemHandles (muda)</li> <li>LinearSystemSolveReorder (muda)</li> <li>LinearSystemSolveTolerance (muda)</li> <li>LocalVarId (muda::details)</li> <li>LocalVarInfo (muda::details)</li> <li>Logger (muda)</li> <li>LoggerDataContainer (muda)</li> <li>LoggerMetaData (muda)</li> <li>LoggerMetaData (muda::details)</li> <li>LoggerOffset (muda::details)</li> <li>LoggerViewer (muda)</li> <li>logic_error (muda)</li> <li>LogProxy (muda)</li> </ul>"},{"location":"muda/classes/#m","title":"m","text":"<ul> <li>MatrixFormatConverter (muda)</li> <li>MatrixFormatConverter (muda::details)</li> <li>MatrixFormatConverterBase (muda::details)</li> <li>MatrixFormatConverterType (muda::details)</li> <li>MatrixMapInfo (muda)</li> <li>MemcpyNode (muda)</li> <li>Memory (muda)</li> <li>MemsetNode (muda)</li> <li>Morton (muda::spatial_hash)</li> <li>Morton (muda::spatial_hash)</li> <li>Morton (muda::spatial_hash)</li> </ul>"},{"location":"muda/classes/#n","title":"n","text":"<ul> <li>NDReshaper (muda)</li> <li>Node (muda::lbvh::details)</li> <li>NodeId (muda)</li> <li>NodeParms (muda)</li> <li>not_implemented (muda)</li> </ul>"},{"location":"muda/classes/#o","title":"o","text":"<ul> <li>Offset2D (muda)</li> <li>Offset3D (muda)</li> <li>out_of_range (muda)</li> </ul>"},{"location":"muda/classes/#p","title":"p","text":"<ul> <li>ParallelFor (muda)</li> <li>ParallelForCallable (muda::details)</li> <li>ParallelForDetails (muda)</li> <li>Profile (muda)</li> <li>Proxy (muda::DoubletVectorViewerT)</li> <li>Proxy (muda::TripletMatrixViewerT)</li> </ul>"},{"location":"muda/classes/#q","title":"q","text":"<ul> <li>query_nearest (muda::lbvh)</li> <li>query_overlap (muda::lbvh)</li> </ul>"},{"location":"muda/classes/#r","title":"r","text":"<ul> <li>RangeName (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_only_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>read_write_view (muda)</li> <li>RelatedClosureInfo</li> <li>runtime_error (muda)</li> </ul>"},{"location":"muda/classes/#s","title":"s","text":"<ul> <li>SoACopyMap (muda::details)</li> <li>span (TCB_SPAN_NAMESPACE_NAME)</li> <li>span_storage (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>span_storage (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>SparseSpatialHash (muda::spatial_hash)</li> <li>SparseSpatialHashImpl (muda::spatial_hash::details)</li> <li>SpatialHashTableInfo (muda::spatial_hash)</li> <li>SpatialPartitionCell (muda::spatial_hash)</li> <li>Stream (muda)</li> <li>StringLocation</li> <li>StringPointer (muda::details)</li> <li>SubField (muda)</li> <li>SubFieldImpl (muda)</li> <li>SubFieldImpl (muda)</li> <li>SubFieldImpl (muda)</li> <li>SubFieldImpl (muda)</li> <li>SubFieldInterface (muda)</li> </ul>"},{"location":"muda/classes/#t","title":"t","text":"<ul> <li>Tag (muda)</li> <li>TailLaunch (muda::Stream)</li> <li>TempBuffer (muda::details)</li> <li>TripletMatrixViewerT (muda)</li> <li>TripletMatrixViewT (muda)</li> <li>TripletMatrixViewT (muda)</li> <li>tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; (std)</li> <li>tuple_size&lt; TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; (std)</li> </ul>"},{"location":"muda/classes/#v","title":"v","text":"<ul> <li>VarId (muda)</li> <li>VarViewT (muda)</li> <li>vector_of (muda::lbvh)</li> <li>vector_of (muda::lbvh)</li> <li>vector_of (muda::lbvh)</li> <li>ViewBase (muda)</li> <li>ViewerBase (muda)</li> </ul>"},{"location":"muda/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class TCB_SPAN_NAMESPACE_NAME::span </li> <li>class muda::ViewBase </li> <li>class muda::LaunchCore <ul> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> <li>class muda::LaunchBase <ul> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> <li>class muda::CubWrapper </li> </ul> </li> </ul> </li> <li>class muda::CFieldEntryView </li> <li>class muda::CFieldEntryViewer </li> <li>class muda::CMatrixMapInfo </li> <li>class muda::IdWithType </li> <li>class muda::ComputeGraph </li> <li>class muda::ComputeGraph::AddNodeProxy </li> <li>class muda::ComputeGraph::GraphPhaseGuard </li> <li>class muda::ComputeGraphBuilder </li> <li>class muda::ComputeGraphNodeBase <ul> <li>class muda::ComputeGraphNode </li> <li>class muda::ComputeGraphNode </li> <li>class muda::ComputeGraphNode </li> <li>class muda::ComputeGraphNode </li> <li>class muda::ComputeGraphNode </li> <li>class muda::ComputeGraphCaptureNode </li> <li>class muda::ComputeGraphNode </li> </ul> </li> <li>class muda::ComputeGraphClosure </li> <li>class muda::ComputeGraphDependency </li> <li>class muda::ComputeGraphGraphvizOptions </li> <li>class muda::ComputeGraphVarBase <ul> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> <li>class muda::ComputeGraphVar </li> </ul> </li> <li>class muda::ComputeGraphVarManager </li> <li>class muda::Debug </li> <li>class muda::ViewerBase </li> <li>class muda::DeviceTripletMatrix <ul> <li>class muda::DeviceBCOOMatrix </li> <li>class muda::DeviceBCOOMatrix </li> <li>class muda::DeviceBCOOMatrix </li> </ul> </li> <li>class muda::DeviceDoubletVector <ul> <li>class muda::DeviceBCOOVector </li> <li>class muda::DeviceBCOOVector </li> </ul> </li> <li>class muda::DeviceBSRMatrix </li> <li>class muda::DeviceBuffer A <code>std::vector</code> like wrapper of cuda device memory, allows user to:</li> <li>class muda::DeviceBuffer2D </li> <li>class muda::DeviceBuffer3D </li> <li>class muda::DeviceDenseMatrix </li> <li>class muda::DeviceDenseVector </li> <li>class muda::DeviceVar </li> <li>class muda::DoubletVectorViewerT::Proxy </li> <li>class muda::Event RAII wrapper for cudaEvent. </li> <li>class muda::GraphNode <ul> <li>class muda::EventRecordNode </li> <li>class muda::EventWaitNode </li> <li>class muda::HostNode </li> <li>class muda::KernelNode </li> <li>class muda::MemcpyNode </li> <li>class muda::MemsetNode </li> </ul> </li> <li>class muda::Extent2D </li> <li>class muda::Extent3D </li> <li>class muda::Field </li> <li>class muda::FieldBuildOptions </li> <li>class muda::FieldBuilder </li> <li>class muda::FieldBuilder::EntryProxy </li> <li>class muda::FieldEntryBase <ul> <li>class muda::FieldEntry </li> </ul> </li> <li>class muda::FieldEntryBaseData </li> <li>class muda::FieldEntryCore </li> <li>class muda::FieldEntryLayoutInfo </li> <li>class muda::FieldEntryView </li> <li>class muda::FieldEntryViewBase </li> <li>class muda::FieldEntryViewer </li> <li>class muda::FieldEntryViewerBase </li> <li>class muda::Flags </li> <li>class muda::Graph </li> <li>class muda::GraphExec </li> <li>class muda::HostDeviceConfig </li> <li>class muda::NodeParms <ul> <li>class muda::KernelNodeParms </li> <li>class muda::KernelNodeParms </li> <li>class muda::HostNodeParms </li> <li>class muda::KernelNodeParms </li> </ul> </li> <li>class muda::Kernel </li> <li>class muda::KernelLabel </li> <li>class muda::LinearSystemAlgorithm </li> <li>class muda::LinearSystemContext </li> <li>class muda::LinearSystemContextCreateInfo </li> <li>class muda::LinearSystemHandles </li> <li>class muda::LinearSystemSolveReorder </li> <li>class muda::LinearSystemSolveTolerance </li> <li>class muda::LogProxy </li> <li>class muda::Logger </li> <li>class muda::LoggerDataContainer </li> <li>class muda::LoggerMetaData </li> <li>class muda::LoggerViewer </li> <li>class muda::MatrixFormatConverter </li> <li>class muda::MatrixMapInfo For MapMatrix e.g. Eigen::Map&lt; ... &gt; </li> <li>class muda::NDReshaper </li> <li>class muda::Offset2D </li> <li>class muda::Offset3D </li> <li>class muda::ParallelForDetails </li> <li>class muda::Profile </li> <li>class muda::RangeName </li> <li>class muda::Stream RAII wrapper for cudaStream. </li> <li>class muda::Stream::FireAndForget </li> <li>class muda::Stream::GraphFireAndForget </li> <li>class muda::Stream::GraphTailLaunch </li> <li>class muda::Stream::TailLaunch </li> <li>class muda::SubField </li> <li>class muda::SubFieldImpl </li> <li>class muda::SubFieldInterface <ul> <li>class muda::SubFieldImpl </li> <li>class muda::SubFieldImpl </li> <li>class muda::SubFieldImpl </li> </ul> </li> <li>class muda::TripletMatrixViewerT::Proxy </li> <li>class muda::details::ComputeGraphAccessor </li> <li>class muda::details::HostDeviceStringCache </li> <li>class muda::details::LaunchInfoCache </li> <li>class muda::details::LocalVarInfo </li> <li>class muda::details::LoggerMetaData </li> <li>class muda::details::LoggerOffset </li> <li>class muda::details::MatrixFormatConverterBase <ul> <li>class muda::details::MatrixFormatConverter </li> </ul> </li> <li>class muda::details::MatrixFormatConverterType </li> <li>class muda::details::ParallelForCallable </li> <li>class muda::details::StringPointer </li> <li>class muda::details::TempBuffer </li> <li>class muda::details::buffer::BufferInfoAccessor </li> <li>class muda::lbvh::BVH </li> <li>class muda::spatial_hash::AABB </li> <li>class muda::spatial_hash::BoundingSphere </li> <li>class muda::spatial_hash::CollisionPair </li> <li>class muda::spatial_hash::DefaultPredication </li> <li>class muda::spatial_hash::Morton </li> <li>class muda::spatial_hash::SparseSpatialHash </li> <li>class muda::spatial_hash::SpatialHashTableInfo </li> <li>class muda::spatial_hash::SpatialPartitionCell To represent a cell-object pair in the spatial hash 3D grid e.g. (cell_id,object_id) = (1024, 32) for the meaning: the 32th object overlap with the 1024th cell. </li> <li>class muda::spatial_hash::details::SparseSpatialHashImpl </li> <li>class muda::ComputeGraphVarBase::RelatedClosureInfo </li> <li>class muda::details::HostDeviceStringCache::StringLocation </li> <li>class std::tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::is_container </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::span_storage </li> <li>struct muda::Default </li> <li>struct muda::DoubletVectorViewerT::CDoublet </li> <li>struct muda::FieldEntryViewCore::AsIterator </li> <li>struct muda::Tag </li> <li>struct muda::TripletMatrixViewerT::CTriplet </li> <li>struct muda::always_false </li> <li>struct muda::always_true </li> <li>struct muda::details::LaunchCallable </li> <li>struct muda::details::SoACopyMap </li> <li>struct muda::eigen::AnalyticalInverse </li> <li>struct muda::eigen::GaussEliminationInverse </li> <li>struct muda::force_trivial </li> <li>struct muda::force_trivially_constructible </li> <li>struct muda::force_trivially_copy_assignable </li> <li>struct muda::force_trivially_copy_constructible </li> <li>struct muda::force_trivially_destructible </li> <li>struct muda::is_cuda_arch </li> <li>struct muda::lbvh::AABB </li> <li>struct muda::lbvh::DefaultMortonCodeCalculator </li> <li>struct muda::lbvh::details::BVHViewerBase::DefaultQueryCallback </li> <li>struct muda::lbvh::details::Node </li> <li>struct muda::lbvh::query_nearest </li> <li>struct muda::lbvh::query_overlap </li> <li>struct muda::lbvh::vector_of </li> <li>struct muda::read_only_view </li> <li>struct muda::read_write_view </li> <li>struct std::hash&lt; muda::ClosureId &gt; </li> <li>struct std::hash&lt; muda::IdWithType&lt; T &gt; &gt; </li> <li>struct std::hash&lt; muda::details::MatrixFormatConverterType &gt; </li> <li>class thrust::device_vector&lt; T, thrust::device_allocator&lt; T &gt; &gt; <ul> <li>class muda::DeviceVector </li> </ul> </li> <li>class thrust::host_vector&lt; T, std::allocator&lt; T &gt; &gt; <ul> <li>class muda::HostVector </li> </ul> </li> <li>class std::exception <ul> <li>class muda::exception <ul> <li>class muda::cuda_error </li> <li>class muda::invalid_argument </li> <li>class muda::logic_error </li> <li>class muda::not_implemented </li> <li>class muda::out_of_range </li> <li>class muda::runtime_error </li> </ul> </li> <li>class muda::exception <ul> <li>class muda::cuda_error </li> <li>class muda::invalid_argument </li> <li>class muda::logic_error </li> <li>class muda::not_implemented </li> <li>class muda::out_of_range </li> <li>class muda::runtime_error </li> </ul> </li> <li>class muda::exception <ul> <li>class muda::cuda_error </li> <li>class muda::invalid_argument </li> <li>class muda::logic_error </li> <li>class muda::not_implemented </li> <li>class muda::out_of_range </li> <li>class muda::runtime_error </li> </ul> </li> <li>class muda::exception <ul> <li>class muda::cuda_error </li> <li>class muda::invalid_argument </li> <li>class muda::logic_error </li> <li>class muda::not_implemented </li> <li>class muda::out_of_range </li> <li>class muda::runtime_error </li> </ul> </li> <li>class muda::exception <ul> <li>class muda::cuda_error </li> <li>class muda::invalid_argument </li> <li>class muda::logic_error </li> <li>class muda::not_implemented </li> <li>class muda::out_of_range </li> <li>class muda::runtime_error </li> </ul> </li> <li>class muda::exception <ul> <li>class muda::cuda_error </li> <li>class muda::invalid_argument </li> <li>class muda::logic_error </li> <li>class muda::not_implemented </li> <li>class muda::out_of_range </li> <li>class muda::runtime_error </li> </ul> </li> <li>class muda::exception <ul> <li>class muda::cuda_error </li> <li>class muda::invalid_argument </li> <li>class muda::logic_error </li> <li>class muda::not_implemented </li> <li>class muda::out_of_range </li> <li>class muda::runtime_error </li> </ul> </li> </ul> </li> <li>class integral_constant&lt; size_t, Extent &gt; <ul> <li>class std::tuple_size&lt; TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt; </li> </ul> </li> <li>class std::false_type <ul> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::has_size_and_data </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::has_size_and_data </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::is_complete </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::is_complete </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::is_container_element_type_compatible </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::is_container_element_type_compatible </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::is_span </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::is_span </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::is_std_array </li> <li>struct TCB_SPAN_NAMESPACE_NAME::detail::is_std_array </li> </ul> </li> </ul>"},{"location":"muda/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"muda/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"muda/class_members/","title":"Class Members","text":""},{"location":"muda/class_members/#a","title":"a","text":"<ul> <li>as_const (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>auto_const_t (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::ViewBase, muda::ViewerBase, muda::lbvh::details::BVHViewerBase)</li> <li>alloc (muda::BufferLaunch, muda::Memory)</li> <li>add_node (muda::ComputeGraph)</li> <li>AddNodeProxy (muda::ComputeGraph::AddNodeProxy)</li> <li>all_nodes_closure_style (muda::ComputeGraphGraphvizOptions)</li> <li>arc_style (muda::ComputeGraphGraphvizOptions)</li> <li>as_subgraph (muda::ComputeGraphGraphvizOptions)</li> <li>access_index (muda::ComputeGraphNodeBase)</li> <li>area (muda::Dense2DBase, muda::Dense3DBase)</li> <li>as_eigen (muda::DenseMatrixViewerT, muda::DenseVectorViewerT)</li> <li>atomic_add (muda::DenseMatrixViewerT, muda::DenseVectorViewerT)</li> <li>ArgMax (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>ArgMin (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>at (muda::DoubletVectorViewerT, muda::TripletMatrixViewerT)</li> <li>async_copy_to_new_place (muda::FieldEntry, muda::FieldEntryBase)</li> <li>aos_elem_addr (muda::FieldEntryCore)</li> <li>aos_struct_begin (muda::FieldEntryCore)</li> <li>aosoa_elem_addr (muda::FieldEntryCore)</li> <li>aosoa_inner_index (muda::FieldEntryCore)</li> <li>aosoa_struct_begin (muda::FieldEntryCore)</li> <li>add_dependency (muda::Graph)</li> <li>add_event_record_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>add_event_wait_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>add_host_node (muda::Graph)</li> <li>add_kernel_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>add_memcpy_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>add_memset_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>apply (muda::HostCall, muda::Launch, muda::ParallelFor)</li> <li>as_node_parms (muda::HostCall, muda::Launch, muda::ParallelFor)</li> <li>add_sync_callback (muda::LinearSystemContext)</li> <li>axpby (muda::LinearSystemContext)</li> <li>as (muda::LoggerMetaData)</li> <li>alloc_1d (muda::Memory)</li> <li>alloc_2d (muda::Memory)</li> <li>alloc_3d (muda::Memory)</li> <li>active_num_in_block (muda::ParallelForDetails)</li> <li>AoS (muda::SubField)</li> <li>AoSoA (muda::SubField)</li> <li>allow_inplace_shrink (muda::SubField, muda::SubFieldInterface)</li> <li>align (muda::SubFieldInterface)</li> <li>async_upload_temp_cores (muda::SubFieldInterface)</li> <li>aync_upload_cores (muda::SubFieldInterface)</li> <li>access_graph (muda::details::ComputeGraphAccessor)</li> <li>access_graph_exec (muda::details::ComputeGraphAccessor)</li> <li>add_capture_node (muda::details::ComputeGraphAccessor)</li> <li>auto_select (muda::details::StringPointer)</li> <li>AABB (muda::lbvh::AABB, muda::spatial_hash::AABB)</li> <li>aabb_getter_type (muda::lbvh::BVH)</li> <li>aabb_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>aabbs (muda::lbvh::BVH)</li> <li>allow_ignore (muda::spatial_hash::SpatialPartitionCell)</li> <li>allCoords (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>allRadius (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>alloc_collision_pair_list (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#b","title":"b","text":"<ul> <li>back (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>begin (TCB_SPAN_NAMESPACE_NAME::span, muda::CMatrixMapInfo, muda::MatrixMapInfo)</li> <li>BSRMatrixViewT (muda::BSRMatrixViewT)</li> <li>Base (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DeviceHistogram, muda::DeviceMergeSort, muda::DevicePartition, muda::DeviceRadixSort, muda::DeviceReduce, muda::DeviceRunLengthEncode, muda::DeviceScan, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedReduce, muda::DeviceSegmentedSort, muda::DeviceSelect, muda::DeviceSpmv, muda::DeviceVector, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::HostDeviceConfigView, muda::LaunchBase, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>Buffer2DViewT (muda::Buffer2DViewT)</li> <li>Buffer3DViewT (muda::Buffer3DViewT)</li> <li>BufferLaunch (muda::BufferLaunch)</li> <li>BufferViewT (muda::BufferViewT)</li> <li>build (muda::ComputeGraph, muda::FieldBuilder, muda::SubField, muda::SubFieldInterface, muda::lbvh::BVH)</li> <li>build_deps (muda::ComputeGraph)</li> <li>base_building_ceval (muda::ComputeGraphVarBase)</li> <li>base_building_eval (muda::ComputeGraphVarBase)</li> <li>base_update (muda::ComputeGraphVarBase)</li> <li>Buffer2DView (muda::DenseMatrixViewT, muda::DenseMatrixViewerT)</li> <li>buffer_view (muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::HostDeviceConfig)</li> <li>block (muda::DenseMatrixViewerT)</li> <li>BufferView (muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>block_size (muda::DeviceBSRMatrix)</li> <li>block_dim (muda::DeviceTripletMatrix, muda::KernelNodeParms)</li> <li>Bit (muda::Event)</li> <li>bit_type (muda::Flags)</li> <li>buffer_byte_size_base (muda::LinearSystemContextCreateInfo)</li> <li>batch_i (muda::ParallelForDetails)</li> <li>begin_capture (muda::Stream)</li> <li>builder (muda::SubField)</li> <li>build_impl (muda::SubFieldInterface)</li> <li>build_options (muda::SubFieldInterface)</li> <li>BlockMatrix (muda::TripletMatrixViewT)</li> <li>buffer_offset (muda::details::LoggerOffset)</li> <li>blocks_sorted (muda::details::MatrixFormatConverter)</li> <li>bsr2csr (muda::details::MatrixFormatConverter)</li> <li>BVH (muda::lbvh::BVH)</li> <li>BVHViewerBase (muda::lbvh::details::BVHViewerBase)</li> <li>BoundingSphere (muda::spatial_hash::BoundingSphere)</li> <li>balanced_setup_collision_pairs (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>buffer_index (muda::details::HostDeviceStringCache::StringLocation)</li> </ul>"},{"location":"muda/class_members/#c","title":"c","text":"<ul> <li>const_pointer (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>const_reference (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>ConstView (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DoubletVectorViewT, muda::TripletMatrixViewT, muda::VarViewT)</li> <li>col_indices (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceTripletMatrix)</li> <li>cols (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceTripletMatrix)</li> <li>CViewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT)</li> <li>copy_from (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceVar, muda::FieldEntry, muda::VarViewT, muda::details::TempBuffer)</li> <li>copy_to (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceVector, muda::FieldEntry, muda::VarViewT, muda::details::TempBuffer)</li> <li>cuda_pitched_ptr (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::details::buffer::BufferInfoAccessor)</li> <li>cviewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::DeviceVar, muda::DeviceVector, muda::DoubletVectorViewT, muda::FieldEntry, muda::FieldEntryViewCore, muda::TripletMatrixViewT, muda::VarViewT, muda::lbvh::BVH)</li> <li>clear (muda::BufferLaunch, muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::lbvh::BVH)</li> <li>copy (muda::BufferLaunch, muda::FieldEntryLaunch, muda::Memory)</li> <li>COOMatrixViewT (muda::COOMatrixViewT)</li> <li>COOVectorViewBase (muda::COOVectorViewBase)</li> <li>ComputeGraph (muda::ComputeGraph)</li> <li>capture (muda::ComputeGraph, muda::ComputeGraphBuilder)</li> <li>check_vars_valid (muda::ComputeGraph)</li> <li>clear_current_graph (muda::ComputeGraph)</li> <li>create_node (muda::ComputeGraph)</li> <li>cuda_graph_add_deps (muda::ComputeGraph)</li> <li>current_access_index (muda::ComputeGraph)</li> <li>current_closure_id (muda::ComputeGraph)</li> <li>current_graph_phase (muda::ComputeGraph)</li> <li>current_node_id (muda::ComputeGraph)</li> <li>CaptureAction (muda::ComputeGraphBuilder)</li> <li>ComputeGraphBuilder (muda::ComputeGraphBuilder)</li> <li>current_graph (muda::ComputeGraphBuilder)</li> <li>current_phase (muda::ComputeGraphBuilder)</li> <li>ComputeGraphCaptureNode (muda::ComputeGraphCaptureNode)</li> <li>ComputeGraphClosure (muda::ComputeGraphClosure)</li> <li>clousure_id (muda::ComputeGraphClosure)</li> <li>cluster_style (muda::ComputeGraphGraphvizOptions)</li> <li>cluster_var_style (muda::ComputeGraphGraphvizOptions)</li> <li>ComputeGraphNode (muda::ComputeGraphNode)</li> <li>ComputeGraphNodeBase (muda::ComputeGraphNodeBase)</li> <li>ComputeGraphVar (muda::ComputeGraphVar)</li> <li>ComputeGraphVarBase (muda::ComputeGraphVar, muda::ComputeGraphVarBase)</li> <li>ceval (muda::ComputeGraphVar)</li> <li>ComputeGraphVarManager (muda::ComputeGraphVarManager)</li> <li>create_graph (muda::ComputeGraphVarManager)</li> <li>create_var (muda::ComputeGraphVarManager)</li> <li>CubWrapper (muda::CubWrapper)</li> <li>call_sync_callback (muda::Debug)</li> <li>ConstViewer (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>check (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseViewerT)</li> <li>check_range (muda::Dense2DBase, muda::Dense3DBase)</li> <li>CBuffer2DView (muda::DenseMatrixViewT, muda::DenseMatrixViewerT)</li> <li>col (muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DeviceDenseMatrix)</li> <li>CMapMatrix (muda::DenseMatrixViewerT)</li> <li>check_size_matching (muda::DenseMatrixViewerT, muda::DenseVectorViewerT)</li> <li>col_offset (muda::DenseMatrixViewerT)</li> <li>CBufferView (muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>CMapVector (muda::DenseVectorViewerT)</li> <li>check_data (muda::DenseVectorViewerT)</li> <li>check_segment (muda::DenseVectorViewerT)</li> <li>cview (muda::DeviceBSRMatrix, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceDoubletVector, muda::DeviceTripletMatrix)</li> <li>capacity (muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseVector, muda::details::TempBuffer)</li> <li>count (muda::DeviceDoubletVector, muda::FieldEntryBase, muda::FieldEntryCore, muda::details::MatrixFormatConverter, muda::details::ParallelForCallable)</li> <li>CsrMV (muda::DeviceSpmv)</li> <li>check_in_subvector (muda::DoubletVectorViewerT)</li> <li>CDoublet (muda::DoubletVectorViewerT::CDoublet)</li> <li>cuda_extent (muda::Extent2D, muda::Extent3D)</li> <li>create_entry (muda::FieldBuilder, muda::SubField)</li> <li>core (muda::FieldEntryBase)</li> <li>cast (muda::FieldEntryCore)</li> <li>ConstMatMap (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>check_index (muda::FieldEntryViewerCore, muda::lbvh::details::BVHViewerBase)</li> <li>create (muda::Graph)</li> <li>calculate_grid_dim (muda::Launch, muda::ParallelFor)</li> <li>check_input (muda::Launch, muda::ParallelFor)</li> <li>check_input_with_range (muda::Launch)</li> <li>callback (muda::LaunchBase, muda::LaunchCore)</li> <li>convert (muda::LinearSystemContext, muda::MatrixFormatConverter, muda::details::MatrixFormatConverter)</li> <li>cublas (muda::LinearSystemContext, muda::LinearSystemHandles, muda::details::MatrixFormatConverterBase)</li> <li>cusolver_dn (muda::LinearSystemContext, muda::LinearSystemHandles, muda::details::MatrixFormatConverterBase)</li> <li>cusolver_sp (muda::LinearSystemContext, muda::LinearSystemHandles, muda::details::MatrixFormatConverterBase)</li> <li>cusparse (muda::LinearSystemContext, muda::LinearSystemHandles, muda::details::MatrixFormatConverterBase)</li> <li>current (muda::MatrixFormatConverter)</li> <li>cuda_pos (muda::Offset2D, muda::Offset3D)</li> <li>calculate_block_dim (muda::ParallelFor)</li> <li>calculate_new_cores (muda::SubFieldInterface)</li> <li>check_in_submatrix (muda::TripletMatrixViewerT)</li> <li>CTriplet (muda::TripletMatrixViewerT::CTriplet)</li> <li>col_index (muda::TripletMatrixViewerT::CTriplet)</li> <li>copy_label (muda::ViewerBase)</li> <li>cuda_error (muda::cuda_error)</li> <li>ComputeGraphAccessor (muda::details::ComputeGraphAccessor)</li> <li>capture_stream (muda::details::ComputeGraphAccessor)</li> <li>check_allow_node_adding (muda::details::ComputeGraphAccessor)</li> <li>check_allow_var_eval (muda::details::ComputeGraphAccessor)</li> <li>current_closure (muda::details::ComputeGraphAccessor)</li> <li>current_node (muda::details::ComputeGraphAccessor)</li> <li>current_stream (muda::details::ComputeGraphAccessor)</li> <li>callable (muda::details::LaunchCallable, muda::details::ParallelForCallable)</li> <li>current_capture_name (muda::details::LaunchInfoCache)</li> <li>current_kernel_file (muda::details::LaunchInfoCache)</li> <li>current_kernel_line (muda::details::LaunchInfoCache)</li> <li>current_kernel_name (muda::details::LaunchInfoCache)</li> <li>calculate_block_offsets (muda::details::MatrixFormatConverter)</li> <li>col_tmp (muda::details::MatrixFormatConverter)</li> <li>center (muda::spatial_hash::AABB)</li> <li>CollisionPair (muda::spatial_hash::CollisionPair)</li> <li>cell (muda::spatial_hash::SpatialHashTableInfo)</li> <li>cell_center_coord (muda::spatial_hash::SpatialHashTableInfo)</li> <li>cell_size (muda::spatial_hash::SpatialHashTableInfo)</li> <li>coord (muda::spatial_hash::SpatialHashTableInfo)</li> <li>coord_min (muda::spatial_hash::SpatialHashTableInfo)</li> <li>cid (muda::spatial_hash::SpatialPartitionCell)</li> <li>ctlbit (muda::spatial_hash::SpatialPartitionCell)</li> <li>Cell (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>calculate_hash_table_basic_info (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellArrayKey (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellArrayKeySorted (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellArrayValue (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellArrayValueSorted (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellToCollisionPairUpperBound (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellToCollisionPairUpperBoundPrefixSum (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>collisionPairBuffer (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>collisionPairCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>collisionPairPrefixSum (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>count_object_per_cell (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>closure_ids (muda::ComputeGraphVarBase::RelatedClosureInfo)</li> </ul>"},{"location":"muda/class_members/#d","title":"d","text":"<ul> <li>data (TCB_SPAN_NAMESPACE_NAME::span, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DenseViewerT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceVar, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::HostDeviceConfigView, muda::LoggerMetaData, muda::VarViewT, muda::details::TempBuffer)</li> <li>difference_type (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::VarViewT)</li> <li>descr (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseVectorViewT, muda::DeviceBSRMatrix, muda::DeviceDenseVector)</li> <li>doublet_count (muda::COOVectorViewBase, muda::DeviceDoubletVector, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>doublet_index_offset (muda::COOVectorViewBase)</li> <li>Dependency (muda::ComputeGraph)</li> <li>dep_span (muda::ComputeGraph)</li> <li>deps (muda::ComputeGraphClosure)</li> <li>debug_sync_all (muda::Debug)</li> <li>Dense1DT (muda::Dense1DT)</li> <li>dim (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::details::LaunchCallable, muda::details::MatrixFormatConverterBase)</li> <li>Dense2DBase (muda::Dense2DBase)</li> <li>Dense3DBase (muda::Dense3DBase)</li> <li>DenseMatrixViewT (muda::DenseMatrixViewT)</li> <li>DenseMatrixViewerT (muda::DenseMatrixViewerT)</li> <li>DenseVectorViewT (muda::DenseVectorViewT)</li> <li>DenseVectorViewerT (muda::DenseVectorViewerT)</li> <li>DenseViewerT (muda::DenseViewerT)</li> <li>DeviceBCOOMatrix (muda::DeviceBCOOMatrix)</li> <li>DeviceBCOOVector (muda::DeviceBCOOVector)</li> <li>DeviceBSRMatrix (muda::DeviceBSRMatrix)</li> <li>destroy_all_descr (muda::DeviceBSRMatrix)</li> <li>DeviceBuffer (muda::DeviceBuffer)</li> <li>DeviceBuffer2D (muda::DeviceBuffer2D)</li> <li>DeviceBuffer3D (muda::DeviceBuffer3D)</li> <li>DeviceDenseMatrix (muda::DeviceDenseMatrix)</li> <li>DeviceDenseVector (muda::DeviceDenseVector)</li> <li>DeviceDoubletVector (muda::DeviceDoubletVector)</li> <li>doublet_capacity (muda::DeviceDoubletVector)</li> <li>DeviceTripletMatrix (muda::DeviceTripletMatrix)</li> <li>DeviceVar (muda::DeviceVar)</li> <li>DoubletVectorViewT (muda::DoubletVectorViewT)</li> <li>DoubletVectorViewerT (muda::DoubletVectorViewerT)</li> <li>depth (muda::Extent3D)</li> <li>device_data (muda::HostDeviceConfig, muda::HostDeviceConfigView)</li> <li>derived (muda::LaunchBase)</li> <li>derived_type (muda::LaunchBase)</li> <li>dot (muda::LinearSystemContext)</li> <li>DEFAULT_BUFFER_SIZE (muda::Logger)</li> <li>DEFAULT_META_SIZE (muda::Logger)</li> <li>download (muda::Logger, muda::Memory)</li> <li>Default (muda::Stream)</li> <li>data_buffer (muda::SubField)</li> <li>data_type (muda::details::MatrixFormatConverterBase, muda::details::MatrixFormatConverterType)</li> <li>device_string (muda::details::StringPointer)</li> <li>download_if_dirty (muda::lbvh::BVH)</li> <li>DefaultMortonCodeCalculator (muda::lbvh::DefaultMortonCodeCalculator)</li> <li>detect (muda::spatial_hash::SparseSpatialHash, muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#e","title":"e","text":"<ul> <li>element_type (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>empty (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>end (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>extent (TCB_SPAN_NAMESPACE_NAME::span, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DoubletVectorViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>emplace_related_var (muda::ComputeGraph)</li> <li>event_style (muda::ComputeGraphGraphvizOptions)</li> <li>eval (muda::ComputeGraphVar)</li> <li>Encode (muda::DeviceRunLengthEncode)</li> <li>ExclusiveScan (muda::DeviceScan)</li> <li>ExclusiveScanByKey (muda::DeviceScan)</li> <li>ExclusiveSum (muda::DeviceScan)</li> <li>ExclusiveSumByKey (muda::DeviceScan)</li> <li>Empty (muda::Empty)</li> <li>Event (muda::Event)</li> <li>elapsed_time (muda::Event)</li> <li>Extent2D (muda::Extent2D)</li> <li>Extent3D (muda::Extent3D)</li> <li>entry (muda::FieldBuilder)</li> <li>EntryProxy (muda::FieldBuilder::EntryProxy)</li> <li>ElementType (muda::FieldEntry)</li> <li>elem_byte_size (muda::FieldEntryBase, muda::FieldEntryBaseData, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::details::SoACopyMap)</li> <li>elem_count (muda::FieldEntryBaseData)</li> <li>elem_count_based_stride (muda::FieldEntryBaseData)</li> <li>elem_addr (muda::FieldEntryCore)</li> <li>entry_name (muda::FieldEntryViewerCore)</li> <li>extra (muda::KernelNodeParms)</li> <li>expand_buffer (muda::Logger)</li> <li>expand_if_needed (muda::Logger)</li> <li>expand_meta_data (muda::Logger)</li> <li>end_capture (muda::Stream)</li> <li>error (muda::cuda_error)</li> <li>error_string (muda::cuda_error)</li> <li>exceeded (muda::details::LoggerMetaData)</li> <li>exceed_buffer (muda::details::LoggerOffset)</li> <li>exceed_meta_data (muda::details::LoggerOffset)</li> <li>expand_blocks (muda::details::MatrixFormatConverter)</li> <li>exception (muda::exception)</li> <li>empty_level (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#f","title":"f","text":"<ul> <li>first (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>front (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>fill (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferLaunch, muda::BufferViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::FieldEntry, muda::FieldEntryLaunch, muda::VarViewT)</li> <li>free (muda::BufferLaunch, muda::Memory, muda::details::TempBuffer)</li> <li>from (muda::ComputeGraphDependency)</li> <li>find_var (muda::ComputeGraphVarManager)</li> <li>flatten (muda::Dense2DBase, muda::Dense3DBase)</li> <li>Flagged (muda::DevicePartition, muda::DeviceSelect)</li> <li>Field (muda::Field)</li> <li>FieldBuilder (muda::FieldBuilder)</li> <li>FieldEntry (muda::FieldEntry)</li> <li>FieldEntryBase (muda::FieldEntryBase)</li> <li>FieldEntryBaseData (muda::FieldEntryBaseData)</li> <li>FieldEntryCore (muda::FieldEntryCore)</li> <li>FieldEntryLaunch (muda::FieldEntryLaunch)</li> <li>FieldEntryLayoutInfo (muda::FieldEntryLayoutInfo)</li> <li>FieldEntryViewCore (muda::FieldEntryViewCore)</li> <li>FieldEntryViewerCore (muda::FieldEntryViewerCore)</li> <li>Flags (muda::Flags)</li> <li>fire_and_forget (muda::GraphViewer)</li> <li>fn (muda::HostNodeParms)</li> <li>func (muda::KernelNodeParms, muda::cuda_error)</li> <li>file_line (muda::LaunchBase, muda::LaunchCore)</li> <li>fmt_arg (muda::LoggerMetaData, muda::details::LoggerMetaData)</li> <li>Flag (muda::Stream)</li> <li>FireAndForget (muda::Stream::FireAndForget)</li> <li>find_entry (muda::SubField)</li> <li>file (muda::cuda_error)</li> <li>Float (muda::spatial_hash::SpatialHashTableInfo)</li> <li>fill_hash_cells (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#g","title":"g","text":"<ul> <li>graphviz (muda::ComputeGraph, muda::ComputeGraphVarManager)</li> <li>GraphPhaseGuard (muda::ComputeGraph::GraphPhaseGuard)</li> <li>graphviz_def (muda::ComputeGraphClosure, muda::ComputeGraphVar, muda::ComputeGraphVarBase)</li> <li>graphviz_id (muda::ComputeGraphClosure, muda::ComputeGraphVarBase)</li> <li>graphviz_var_usages (muda::ComputeGraphClosure)</li> <li>graph_font (muda::ComputeGraphGraphvizOptions)</li> <li>graph_id (muda::ComputeGraphGraphvizOptions)</li> <li>graph_viewer_style (muda::ComputeGraphGraphvizOptions)</li> <li>graphs (muda::ComputeGraphVarManager)</li> <li>get_index (muda::DoubletVectorViewerT, muda::TripletMatrixViewerT)</li> <li>Graph (muda::Graph)</li> <li>GraphExec (muda::GraphExec)</li> <li>GraphLaunch (muda::GraphLaunch)</li> <li>GraphNode (muda::GraphNode)</li> <li>GraphViewer (muda::GraphViewer)</li> <li>grid_dim (muda::KernelNodeParms)</li> <li>generic_spmv (muda::LinearSystemContext)</li> <li>gesv (muda::LinearSystemContext)</li> <li>GraphFireAndForget (muda::Stream::GraphFireAndForget)</li> <li>GraphTailLaunch (muda::Stream::GraphTailLaunch)</li> <li>get_or_create_node (muda::details::ComputeGraphAccessor)</li> <li>get_string_pointer (muda::details::HostDeviceStringCache)</li> <li>graph (muda::ComputeGraphVarBase::RelatedClosureInfo)</li> </ul>"},{"location":"muda/class_members/#h","title":"h","text":"<ul> <li>handle (muda::ComputeGraphNodeBase, muda::Graph, muda::GraphExec, muda::GraphNode, muda::GraphViewer, muda::HostNodeParms, muda::KernelNodeParms)</li> <li>HistogramEven (muda::DeviceHistogram)</li> <li>HistogramRange (muda::DeviceHistogram)</li> <li>height (muda::Extent2D, muda::Extent3D)</li> <li>has (muda::Flags)</li> <li>HostCall (muda::HostCall)</li> <li>HostDeviceConfig (muda::HostDeviceConfig)</li> <li>host_data (muda::HostDeviceConfig, muda::HostDeviceConfigView)</li> <li>HostDeviceConfigView (muda::HostDeviceConfigView)</li> <li>HostNodeParms (muda::HostNodeParms)</li> <li>hostData (muda::HostNodeParms)</li> <li>HostDeviceStringCache (muda::details::HostDeviceStringCache)</li> <li>host_string (muda::details::StringPointer)</li> <li>host_aabbs (muda::lbvh::BVH)</li> <li>host_nodes (muda::lbvh::BVH)</li> <li>host_objects (muda::lbvh::BVH)</li> <li>hash_cell (muda::spatial_hash::SpatialHashTableInfo)</li> <li>home (muda::spatial_hash::SpatialPartitionCell)</li> <li>h_spatialHashConfig (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#i","title":"i","text":"<ul> <li>iterator (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>is_trans (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DenseMatrixViewT)</li> <li>iterator_category (muda::BufferViewT, muda::VarViewT)</li> <li>inner_stride (muda::CMatrixMapInfo, muda::MatrixMapInfo)</li> <li>instance (muda::ComputeGraphBuilder, muda::details::LaunchInfoCache)</li> <li>invoke_phase_actions (muda::ComputeGraphBuilder)</li> <li>is_building (muda::ComputeGraphBuilder)</li> <li>is_caturing (muda::ComputeGraphBuilder)</li> <li>is_direct_launching (muda::ComputeGraphBuilder)</li> <li>is_phase_none (muda::ComputeGraphBuilder)</li> <li>is_phase_serial_launching (muda::ComputeGraphBuilder)</li> <li>is_topo_building (muda::ComputeGraphBuilder)</li> <li>is_valid (muda::ComputeGraphNodeBase, muda::ComputeGraphVarBase, muda::IdWithType, muda::spatial_hash::CollisionPair)</li> <li>is_using (muda::ComputeGraphVarBase, muda::ComputeGraphVarManager)</li> <li>is_debug_sync_all (muda::Debug)</li> <li>is_sym (muda::DenseMatrixViewT)</li> <li>inc (muda::DenseVectorViewT)</li> <li>index (muda::DenseVectorViewerT, muda::DoubletVectorViewerT::CDoublet)</li> <li>IsBlockMatrix (muda::DeviceBSRMatrix, muda::DeviceTripletMatrix)</li> <li>IsSegmentVector (muda::DeviceDoubletVector)</li> <li>indices (muda::DeviceDoubletVector)</li> <li>If (muda::DevicePartition, muda::DeviceSelect)</li> <li>InclusiveScan (muda::DeviceScan)</li> <li>InclusiveScanByKey (muda::DeviceScan)</li> <li>InclusiveSum (muda::DeviceScan)</li> <li>InclusiveSumByKey (muda::DeviceScan)</li> <li>innermost_array_size (muda::FieldEntryLayoutInfo)</li> <li>instantiate (muda::Graph)</li> <li>IdWithType (muda::IdWithType)</li> <li>invalid_id (muda::IdWithType)</li> <li>invoke (muda::Launch, muda::ParallelFor)</li> <li>init_stream (muda::LaunchCore)</li> <li>is_buffer_full (muda::Logger)</li> <li>is_meta_data_full (muda::Logger)</li> <li>id (muda::LoggerMetaData, muda::details::LocalVarInfo, muda::details::LoggerMetaData, muda::spatial_hash::CollisionPair)</li> <li>impl (muda::MatrixFormatConverter)</li> <li>i (muda::ParallelForDetails)</li> <li>is_final_block (muda::ParallelForDetails)</li> <li>IsConst (muda::ViewBase, muda::ViewerBase)</li> <li>IsNonConst (muda::ViewBase, muda::ViewerBase)</li> <li>is_topo_built (muda::details::ComputeGraphAccessor)</li> <li>ij_hash (muda::details::MatrixFormatConverter)</li> <li>ij_hash_input (muda::details::MatrixFormatConverter)</li> <li>ij_pairs (muda::details::MatrixFormatConverter)</li> <li>invert2x2 (muda::eigen::AnalyticalInverse)</li> <li>invert3x3 (muda::eigen::AnalyticalInverse)</li> <li>invert4x4 (muda::eigen::AnalyticalInverse)</li> <li>invalid_argument (muda::invalid_argument)</li> <li>index_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>IDs (muda::spatial_hash::CollisionPair)</li> <li>invalid (muda::spatial_hash::CollisionPair)</li> <li>Impl (muda::spatial_hash::SparseSpatialHash)</li> <li>is_home (muda::spatial_hash::SpatialPartitionCell)</li> <li>is_phantom (muda::spatial_hash::SpatialPartitionCell)</li> <li>I32 (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#k","title":"k","text":"<ul> <li>kernel_name (muda::CubWrapper, muda::LaunchBase, muda::LaunchCore, muda::ViewerBase)</li> <li>Kernel (muda::Kernel)</li> <li>KernelLabel (muda::KernelLabel)</li> <li>KernelNodeParms (muda::KernelNodeParms)</li> <li>kernelParmData (muda::KernelNodeParms)</li> <li>kernel_params (muda::KernelNodeParms)</li> <li>kernel_file (muda::ViewerBase)</li> <li>kernel_line (muda::ViewerBase)</li> </ul>"},{"location":"muda/class_members/#l","title":"l","text":"<ul> <li>last (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>legacy_descr (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix)</li> <li>launch (muda::ComputeGraph, muda::GraphExec, muda::GraphLaunch, muda::GraphViewer)</li> <li>lda (muda::DenseMatrixViewT)</li> <li>Layout (muda::Field, muda::FieldEntryLayoutInfo)</li> <li>layout (muda::FieldEntryBase, muda::FieldEntryCore, muda::FieldEntryLayoutInfo, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>layout_info (muda::FieldEntryBase, muda::FieldEntryBaseData, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::SubFieldInterface)</li> <li>Launch (muda::Launch)</li> <li>LaunchBase (muda::LaunchBase)</li> <li>LaunchCore (muda::LaunchCore)</li> <li>LinearSystemContext (muda::LinearSystemContext)</li> <li>label (muda::LinearSystemContext)</li> <li>LinearSystemHandles (muda::LinearSystemHandles)</li> <li>LogProxy (muda::LogProxy)</li> <li>Logger (muda::Logger)</li> <li>line (muda::cuda_error)</li> <li>LaunchCallable (muda::details::LaunchCallable)</li> <li>LaunchInfoCache (muda::details::LaunchInfoCache)</li> <li>log_id (muda::details::LoggerOffset)</li> <li>loose_resize (muda::details::MatrixFormatConverterBase)</li> <li>length (muda::details::StringPointer)</li> <li>lower (muda::lbvh::AABB)</li> <li>left_idx (muda::lbvh::details::Node)</li> <li>logic_error (muda::logic_error)</li> <li>level (muda::spatial_hash::BoundingSphere, muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#m","title":"m","text":"<ul> <li>m_col (muda::BSRMatrixViewT, muda::DenseMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDenseMatrix)</li> <li>m_col_indices (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceTripletMatrix, muda::TripletMatrixViewerT)</li> <li>m_descr (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseVectorViewT, muda::DeviceBSRMatrix, muda::DeviceDenseVector)</li> <li>m_legacy_descr (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix)</li> <li>m_non_zeros (muda::BSRMatrixViewT)</li> <li>m_row (muda::BSRMatrixViewT, muda::DenseMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDenseMatrix)</li> <li>m_row_offsets (muda::BSRMatrixViewT, muda::DeviceBSRMatrix)</li> <li>m_trans (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DenseMatrixViewT)</li> <li>m_values (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DeviceBSRMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::TripletMatrixViewerT)</li> <li>m_data (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceVar, muda::VarViewT, muda::details::TempBuffer)</li> <li>m_extent (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::Extent2D, muda::Extent3D)</li> <li>m_offset (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::Logger, muda::LoggerViewer, muda::Offset2D, muda::Offset3D)</li> <li>m_origin_height (muda::Buffer2DViewT, muda::Buffer3DViewT)</li> <li>m_origin_width (muda::Buffer2DViewT, muda::Buffer3DViewT)</li> <li>m_pitch_bytes (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::Dense2DBase, muda::Dense3DBase, muda::DeviceBuffer2D, muda::DeviceBuffer3D)</li> <li>m_pitch_bytes_area (muda::Buffer3DViewT, muda::Dense3DBase, muda::DeviceBuffer3D)</li> <li>m_block_dim (muda::BufferLaunch, muda::Kernel, muda::Launch, muda::ParallelFor)</li> <li>m_grid_dim (muda::BufferLaunch, muda::Kernel, muda::Launch, muda::ParallelFor)</li> <li>m_size (muda::BufferViewT, muda::COOVectorViewBase, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DeviceBuffer, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::details::TempBuffer)</li> <li>m_cols (muda::COOMatrixViewT, muda::DeviceTripletMatrix)</li> <li>m_row_indices (muda::COOMatrixViewT, muda::DeviceTripletMatrix, muda::TripletMatrixViewerT)</li> <li>m_rows (muda::COOMatrixViewT, muda::DeviceTripletMatrix)</li> <li>m_submatrix_extent (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_submatrix_offset (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_total_triplet_count (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_triplet_count (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_triplet_index_offset (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_doublet_count (muda::COOVectorViewBase, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_doublet_index_offset (muda::COOVectorViewBase, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_indices (muda::COOVectorViewBase, muda::DeviceDoubletVector, muda::lbvh::BVH)</li> <li>m_total_doublet_count (muda::COOVectorViewBase, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_access_graph_index (muda::ComputeGraph, muda::ComputeGraphClosure)</li> <li>m_allow_access_graph (muda::ComputeGraph)</li> <li>m_allow_node_adding (muda::ComputeGraph)</li> <li>m_closure_need_update (muda::ComputeGraph)</li> <li>m_closures (muda::ComputeGraph)</li> <li>m_current_closure_id (muda::ComputeGraph)</li> <li>m_current_graph_phase (muda::ComputeGraph)</li> <li>m_current_node_id (muda::ComputeGraph)</li> <li>m_current_single_stream (muda::ComputeGraph)</li> <li>m_deps (muda::ComputeGraph)</li> <li>m_event (muda::ComputeGraph)</li> <li>m_event_result (muda::ComputeGraph)</li> <li>m_flags (muda::ComputeGraph, muda::GraphExec, muda::GraphViewer)</li> <li>m_global_to_local_var_id (muda::ComputeGraph)</li> <li>m_graph (muda::ComputeGraph, muda::ComputeGraphClosure, muda::GraphViewer)</li> <li>m_graph_exec (muda::ComputeGraph)</li> <li>m_graph_nodes (muda::ComputeGraph, muda::ComputeGraphClosure)</li> <li>m_is_capturing (muda::ComputeGraph)</li> <li>m_is_in_capture_func (muda::ComputeGraph)</li> <li>m_is_topo_built (muda::ComputeGraph)</li> <li>m_name (muda::ComputeGraph, muda::ComputeGraphClosure, muda::ComputeGraphNodeBase, muda::ComputeGraphVarBase, muda::FieldBuilder::EntryProxy, muda::FieldEntryBase, muda::FieldEntryCore, muda::SubField)</li> <li>m_need_update (muda::ComputeGraph)</li> <li>m_nodes (muda::ComputeGraph, muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>m_related_vars (muda::ComputeGraph)</li> <li>m_sub_graphs (muda::ComputeGraph)</li> <li>m_var_manager (muda::ComputeGraph, muda::ComputeGraphVarBase)</li> <li>m_cg (muda::ComputeGraph::AddNodeProxy, muda::ComputeGraph::GraphPhaseGuard, muda::details::ComputeGraphAccessor)</li> <li>m_node_name (muda::ComputeGraph::AddNodeProxy)</li> <li>m_current_graph (muda::ComputeGraphBuilder)</li> <li>m_sub_graph (muda::ComputeGraphCaptureNode)</li> <li>m_closure (muda::ComputeGraphClosure)</li> <li>m_clousure_id (muda::ComputeGraphClosure)</li> <li>m_deps_begin (muda::ComputeGraphClosure)</li> <li>m_deps_count (muda::ComputeGraphClosure)</li> <li>m_type (muda::ComputeGraphClosure, muda::ComputeGraphNodeBase, muda::ParallelForDetails)</li> <li>m_var_usages (muda::ComputeGraphClosure)</li> <li>m_node (muda::ComputeGraphNode)</li> <li>m_access_index (muda::ComputeGraphNodeBase)</li> <li>m_cuda_node (muda::ComputeGraphNodeBase)</li> <li>m_node_id (muda::ComputeGraphNodeBase)</li> <li>m_value (muda::ComputeGraphVar, muda::IdWithType)</li> <li>m_closure_ids (muda::ComputeGraphVarBase)</li> <li>m_is_valid (muda::ComputeGraphVarBase)</li> <li>m_related_closure_infos (muda::ComputeGraphVarBase)</li> <li>m_var_id (muda::ComputeGraphVarBase)</li> <li>m_graphs (muda::ComputeGraphVarManager)</li> <li>m_vars (muda::ComputeGraphVarManager)</li> <li>m_vars_map (muda::ComputeGraphVarManager)</li> <li>m_muda_stream (muda::CubWrapper)</li> <li>MUDA_VIEWER_COMMON_NAME (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewerT, muda::GraphViewer, muda::TripletMatrixViewerT, muda::lbvh::details::BVHViewerBase)</li> <li>m_dim (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase)</li> <li>map (muda::Dense1DT)</li> <li>m_sym (muda::DenseMatrixViewT, muda::DeviceDenseMatrix)</li> <li>m_view (muda::DenseMatrixViewT, muda::DenseMatrixViewerT)</li> <li>MapMatrix (muda::DenseMatrixViewerT)</li> <li>MapMatrixT (muda::DenseMatrixViewerT)</li> <li>MatrixType (muda::DenseMatrixViewerT)</li> <li>m_col_offset (muda::DenseMatrixViewerT)</li> <li>m_col_size (muda::DenseMatrixViewerT)</li> <li>m_row_offset (muda::DenseMatrixViewerT)</li> <li>m_row_size (muda::DenseMatrixViewerT)</li> <li>m_inc (muda::DenseVectorViewT)</li> <li>m_origin_size (muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>MapVector (muda::DenseVectorViewerT)</li> <li>MapVectorT (muda::DenseVectorViewerT)</li> <li>m_capacity (muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::details::TempBuffer)</li> <li>m_count (muda::DeviceDoubletVector)</li> <li>MultiHistogramEven (muda::DeviceHistogram)</li> <li>MultiHistogramRange (muda::DeviceHistogram)</li> <li>Max (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>Min (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>m_segment_indices (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_segment_values (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_subvector_extent (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_subvector_offset (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_total_segment_count (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_index (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>m_viewer (muda::DoubletVectorViewerT::Proxy, muda::LogProxy, muda::Logger, muda::TripletMatrixViewerT::Proxy)</li> <li>m_handle (muda::Event, muda::Graph, muda::GraphExec, muda::GraphNode, muda::Stream)</li> <li>m_name_to_index (muda::Field, muda::SubFieldInterface)</li> <li>m_string_cache (muda::Field)</li> <li>m_sub_fields (muda::Field)</li> <li>max_alignment (muda::FieldBuildOptions)</li> <li>min_alignment (muda::FieldBuildOptions)</li> <li>m_is_built (muda::FieldBuilder, muda::SubField)</li> <li>m_layout (muda::FieldBuilder, muda::FieldEntryLayoutInfo)</li> <li>m_options (muda::FieldBuilder)</li> <li>m_single_entry (muda::FieldBuilder)</li> <li>m_subfield (muda::FieldBuilder)</li> <li>m_builder (muda::FieldBuilder::EntryProxy)</li> <li>matrix (muda::FieldBuilder::EntryProxy)</li> <li>matrix2x2 (muda::FieldBuilder::EntryProxy)</li> <li>matrix3x3 (muda::FieldBuilder::EntryProxy)</li> <li>matrix4x4 (muda::FieldBuilder::EntryProxy)</li> <li>m_workpace (muda::FieldEntry)</li> <li>m_core (muda::FieldEntryBase, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>m_field (muda::FieldEntryBase, muda::SubField, muda::SubFieldInterface)</li> <li>m_host_device_core (muda::FieldEntryBase)</li> <li>m_buffer (muda::FieldEntryCore, muda::Logger, muda::LoggerDataContainer, muda::LoggerViewer)</li> <li>m_info (muda::FieldEntryCore)</li> <li>m_innermost_array_size (muda::FieldEntryLayoutInfo)</li> <li>MatStride (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>m_stride (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>m_mask (muda::Flags)</li> <li>mask_type (muda::Flags)</li> <li>m_cached (muda::Graph, muda::GraphExec)</li> <li>map_dependencies (muda::Graph)</li> <li>m_device_data (muda::HostDeviceConfig, muda::HostDeviceConfigView)</li> <li>m_host_data (muda::HostDeviceConfig, muda::HostDeviceConfigView)</li> <li>m_parms (muda::HostNodeParms, muda::KernelNodeParms)</li> <li>m_kernel (muda::Kernel)</li> <li>m_shared_memory_size (muda::Kernel)</li> <li>m_stream (muda::Kernel, muda::LaunchCore, muda::LinearSystemHandles, muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>m_args (muda::KernelNodeParms)</li> <li>m_shared_mem_size (muda::Launch, muda::ParallelFor)</li> <li>m_buffers (muda::LinearSystemContext)</li> <li>m_converter (muda::LinearSystemContext)</li> <li>m_create_info (muda::LinearSystemContext)</li> <li>m_current_label (muda::LinearSystemContext)</li> <li>m_handles (muda::LinearSystemContext, muda::MatrixFormatConverter, muda::details::MatrixFormatConverterBase)</li> <li>m_host_buffers (muda::LinearSystemContext)</li> <li>m_reorder (muda::LinearSystemContext)</li> <li>m_scalar_buffer (muda::LinearSystemContext)</li> <li>m_sync_callbacks (muda::LinearSystemContext)</li> <li>m_tolerance (muda::LinearSystemContext)</li> <li>mv (muda::LinearSystemContext)</li> <li>m_cublas (muda::LinearSystemHandles)</li> <li>m_cusolver_dn (muda::LinearSystemHandles)</li> <li>m_cusolver_sp (muda::LinearSystemHandles)</li> <li>m_cusparse (muda::LinearSystemHandles)</li> <li>m_pointer_mode_device (muda::LinearSystemHandles)</li> <li>m_reserve_ratio (muda::LinearSystemHandles)</li> <li>m_reorder_method (muda::LinearSystemSolveReorder)</li> <li>m_solve_sparse_error_threshold (muda::LinearSystemSolveTolerance)</li> <li>m_log_id (muda::LogProxy)</li> <li>m_h_buffer (muda::Logger)</li> <li>m_h_meta_data (muda::Logger)</li> <li>m_h_offset (muda::Logger)</li> <li>m_log_viewer_ptr (muda::Logger)</li> <li>m_meta_data (muda::Logger, muda::LoggerDataContainer, muda::LoggerViewer)</li> <li>m_meta_data_id (muda::Logger, muda::LoggerViewer)</li> <li>m_sorted_meta_data (muda::Logger)</li> <li>m_sorted_meta_data_id (muda::Logger)</li> <li>meta_data (muda::LoggerDataContainer)</li> <li>m_buffer_size (muda::LoggerViewer, muda::details::HostDeviceStringCache)</li> <li>m_meta_data_id_size (muda::LoggerViewer)</li> <li>m_meta_data_size (muda::LoggerViewer)</li> <li>MatrixFormatConverter (muda::MatrixFormatConverter, muda::details::MatrixFormatConverter)</li> <li>m_impls (muda::MatrixFormatConverter)</li> <li>Memory (muda::Memory)</li> <li>m_active_num_in_block (muda::ParallelForDetails)</li> <li>m_batch_i (muda::ParallelForDetails)</li> <li>m_current_i (muda::ParallelForDetails)</li> <li>m_total_batch (muda::ParallelForDetails)</li> <li>m_total_num (muda::ParallelForDetails)</li> <li>m_workspace (muda::Stream)</li> <li>m_interface (muda::SubField)</li> <li>m_build_options (muda::SubFieldInterface)</li> <li>m_data_buffer (muda::SubFieldInterface)</li> <li>m_data_buffer_size (muda::SubFieldInterface)</li> <li>m_entries (muda::SubFieldInterface)</li> <li>m_host_device_new_cores (muda::SubFieldInterface)</li> <li>m_layout_info (muda::SubFieldInterface)</li> <li>m_new_cores (muda::SubFieldInterface)</li> <li>m_num_elements (muda::SubFieldInterface)</li> <li>m_struct_stride (muda::SubFieldInterface)</li> <li>m_block_col_indices (muda::TripletMatrixViewT)</li> <li>m_block_row_indices (muda::TripletMatrixViewT)</li> <li>m_block_values (muda::TripletMatrixViewT)</li> <li>m_total_block_cols (muda::TripletMatrixViewT)</li> <li>m_total_block_rows (muda::TripletMatrixViewT)</li> <li>m_total_cols (muda::TripletMatrixViewerT)</li> <li>m_total_rows (muda::TripletMatrixViewerT)</li> <li>m_dummy (muda::ViewerBase)</li> <li>m_error (muda::cuda_error)</li> <li>m_error_string (muda::cuda_error)</li> <li>m_file (muda::cuda_error)</li> <li>m_func (muda::cuda_error)</li> <li>m_line (muda::cuda_error)</li> <li>m_current_buffer_offset (muda::details::HostDeviceStringCache)</li> <li>m_device_string_buffers (muda::details::HostDeviceStringCache)</li> <li>m_empty_string_pointer (muda::details::HostDeviceStringCache)</li> <li>m_host_string_buffers (muda::details::HostDeviceStringCache)</li> <li>m_string_map (muda::details::HostDeviceStringCache)</li> <li>m_capture_name_string_cache (muda::details::LaunchInfoCache)</li> <li>m_current_capture_name (muda::details::LaunchInfoCache)</li> <li>m_current_kernel_file (muda::details::LaunchInfoCache)</li> <li>m_current_kernel_line (muda::details::LaunchInfoCache)</li> <li>m_current_kernel_name (muda::details::LaunchInfoCache)</li> <li>m_kernel_file_string_cache (muda::details::LaunchInfoCache)</li> <li>m_kernel_name_string_cache (muda::details::LaunchInfoCache)</li> <li>m_view_name_string_cache (muda::details::LaunchInfoCache)</li> <li>meta_data_offset (muda::details::LoggerOffset)</li> <li>MatrixValueT (muda::details::MatrixFormatConverter)</li> <li>MatrixValueTZero (muda::details::MatrixFormatConverter)</li> <li>make_unique_blocks (muda::details::MatrixFormatConverter)</li> <li>make_unique_indices (muda::details::MatrixFormatConverter)</li> <li>make_unique_indices_and_blocks (muda::details::MatrixFormatConverter)</li> <li>make_unique_segments (muda::details::MatrixFormatConverter)</li> <li>merge_sort_indices_and_blocks (muda::details::MatrixFormatConverter)</li> <li>merge_sort_indices_and_segments (muda::details::MatrixFormatConverter)</li> <li>MatrixFormatConverterBase (muda::details::MatrixFormatConverterBase)</li> <li>m_N (muda::details::MatrixFormatConverterBase)</li> <li>m_data_type (muda::details::MatrixFormatConverterBase)</li> <li>m_what (muda::exception)</li> <li>m_aabbs (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>m_flag_container (muda::lbvh::BVH)</li> <li>m_h_aabbs (muda::lbvh::BVH)</li> <li>m_h_nodes (muda::lbvh::BVH)</li> <li>m_h_objects (muda::lbvh::BVH)</li> <li>m_host_dirty (muda::lbvh::BVH)</li> <li>m_morton (muda::lbvh::BVH)</li> <li>m_morton64 (muda::lbvh::BVH)</li> <li>m_objects (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>morton_code_calculator_type (muda::lbvh::BVH)</li> <li>m_num_nodes (muda::lbvh::details::BVHViewerBase)</li> <li>m_num_objects (muda::lbvh::details::BVHViewerBase)</li> <li>max (muda::spatial_hash::AABB)</li> <li>min (muda::spatial_hash::AABB)</li> <li>m_impl (muda::spatial_hash::SparseSpatialHash)</li> <li>maxRadius (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>minCoord (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#n","title":"n","text":"<ul> <li>NonConstView (muda::BSRMatrixViewT, muda::Buffer3DViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DoubletVectorViewT, muda::TripletMatrixViewT)</li> <li>non_zeros (muda::BSRMatrixViewT, muda::DeviceBCOOMatrix, muda::DeviceBCOOVector, muda::DeviceBSRMatrix)</li> <li>name (muda::ComputeGraph, muda::ComputeGraphClosure, muda::ComputeGraphNodeBase, muda::ComputeGraphVarBase, muda::FieldEntryBase, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::SubField, muda::ViewerBase)</li> <li>node_style (muda::ComputeGraphGraphvizOptions)</li> <li>node_id (muda::ComputeGraphNodeBase)</li> <li>NonConstViewer (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>NonTrivialRuns (muda::DeviceRunLengthEncode)</li> <li>num_sub_fields (muda::Field)</li> <li>name_string_pointer (muda::FieldEntryCore)</li> <li>NonConstMatMap (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>NodeParms (muda::Launch, muda::NodeParms, muda::ParallelFor)</li> <li>next (muda::LaunchBase)</li> <li>norm (muda::LinearSystemContext)</li> <li>next_buffer_idx (muda::LoggerViewer)</li> <li>next_meta_data_idx (muda::LoggerViewer)</li> <li>need_pop (muda::Profile)</li> <li>num_entries (muda::SubField)</li> <li>num_elements (muda::SubFieldInterface)</li> <li>non_const_enable_t (muda::ViewBase, muda::ViewerBase)</li> <li>N (muda::details::MatrixFormatConverterType)</li> <li>node_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>nodes (muda::lbvh::BVH)</li> <li>num_nodes (muda::lbvh::details::BVHViewerBase)</li> <li>num_objects (muda::lbvh::details::BVHViewerBase)</li> <li>not_implemented (muda::not_implemented)</li> </ul>"},{"location":"muda/class_members/#o","title":"o","text":"<ul> <li>operator= (TCB_SPAN_NAMESPACE_NAME::span, muda::ComputeGraph, muda::ComputeGraphVar, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DeviceBCOOMatrix, muda::DeviceBCOOVector, muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceTripletMatrix, muda::DeviceVar, muda::DeviceVector, muda::Event, muda::FieldEntryBase, muda::Flags, muda::Graph, muda::GraphExec, muda::HostDeviceConfig, muda::Kernel, muda::LinearSystemContext, muda::Logger, muda::Stream, muda::SubField, muda::SubFieldInterface, muda::ViewerBase, muda::details::HostDeviceStringCache, muda::details::TempBuffer, muda::lbvh::AABB, muda::lbvh::BVH, muda::lbvh::DefaultMortonCodeCalculator, muda::lbvh::query_nearest, muda::lbvh::query_overlap)</li> <li>operator[] (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::Field, muda::VarViewT, muda::details::HostDeviceStringCache)</li> <li>offset (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::details::LoggerMetaData, muda::details::HostDeviceStringCache::StringLocation)</li> <li>origin_data (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>OtherView (muda::Buffer3DViewT)</li> <li>operator* (muda::BufferViewT, muda::DenseViewerT, muda::HostDeviceConfigView, muda::VarViewT)</li> <li>operator+ (muda::BufferViewT)</li> <li>outer_stride (muda::CMatrixMapInfo, muda::MatrixMapInfo)</li> <li>operator ConstView (muda::COOVectorViewBase)</li> <li>operator&lt;&lt; (muda::ComputeGraph::AddNodeProxy, muda::LogProxy, muda::LoggerViewer)</li> <li>operator GraphViewer (muda::ComputeGraph)</li> <li>operator() (muda::ComputeGraphClosure, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DoubletVectorViewerT, muda::Kernel, muda::TripletMatrixViewerT, muda::eigen::AnalyticalInverse, muda::eigen::GaussEliminationInverse, muda::lbvh::DefaultMortonCodeCalculator, muda::lbvh::details::BVHViewerBase::DefaultQueryCallback, muda::lbvh::query_overlap, muda::spatial_hash::DefaultPredication, std::hash&lt; muda::ClosureId &gt;, std::hash&lt; muda::IdWithType&lt; T &gt; &gt;, std::hash&lt; muda::details::MatrixFormatConverterType &gt;)</li> <li>operator ROViewer (muda::ComputeGraphVar)</li> <li>operator RWViewer (muda::ComputeGraphVar)</li> <li>operator ConstViewer (muda::Dense2DBase, muda::Dense3DBase, muda::lbvh::details::BVHViewerBase)</li> <li>origin_col (muda::DenseMatrixViewerT)</li> <li>origin_row (muda::DenseMatrixViewerT)</li> <li>origin_size (muda::DenseVectorViewerT)</li> <li>operator auto_const_t&lt; T &gt; &amp; (muda::DenseViewerT)</li> <li>operator-&gt; (muda::DenseViewerT, muda::HostDeviceConfigView)</li> <li>operator BSRMatrixView&lt; Ty, N &gt; (muda::DeviceBSRMatrix)</li> <li>operator CBSRMatrixView&lt; Ty, N &gt; (muda::DeviceBSRMatrix)</li> <li>operator BufferView&lt; T &gt; (muda::DeviceBuffer, muda::DeviceVector)</li> <li>operator CBufferView&lt; T &gt; (muda::DeviceBuffer, muda::DeviceVector)</li> <li>operator Buffer2DView&lt; T &gt; (muda::DeviceBuffer2D)</li> <li>operator CBuffer2DView&lt; T &gt; (muda::DeviceBuffer2D)</li> <li>operator Buffer3DView&lt; T &gt; (muda::DeviceBuffer3D)</li> <li>operator CBuffer3DView&lt; T &gt; (muda::DeviceBuffer3D)</li> <li>operator CDenseMatrixView&lt; Ty &gt; (muda::DeviceDenseMatrix)</li> <li>operator DenseMatrixView&lt; Ty &gt; (muda::DeviceDenseMatrix)</li> <li>operator CDenseVectorView&lt; T &gt; (muda::DeviceDenseVector)</li> <li>operator DenseVectorView&lt; T &gt; (muda::DeviceDenseVector)</li> <li>operator CTripletMatrixView&lt; T, N &gt; (muda::DeviceTripletMatrix)</li> <li>operator TripletMatrixView&lt; T, N &gt; (muda::DeviceTripletMatrix)</li> <li>operator CVarView&lt; T &gt; (muda::DeviceVar)</li> <li>operator T (muda::DeviceVar)</li> <li>operator VarView&lt; T &gt; (muda::DeviceVar)</li> <li>operator cudaEvent_t (muda::Event)</li> <li>offset_in_base_struct (muda::FieldEntryBaseData, muda::details::SoACopyMap)</li> <li>offset_in_struct (muda::FieldEntryBaseData)</li> <li>operator bool (muda::Flags, muda::LoggerViewer)</li> <li>operator mask_type (muda::Flags)</li> <li>operator! (muda::Flags)</li> <li>operator!= (muda::Flags)</li> <li>operator&amp; (muda::Flags)</li> <li>operator&amp;= (muda::Flags)</li> <li>operator&lt; (muda::Flags)</li> <li>operator&lt;= (muda::Flags)</li> <li>operator== (muda::Flags, muda::details::MatrixFormatConverterType)</li> <li>operator&gt; (muda::Flags)</li> <li>operator&gt;= (muda::Flags)</li> <li>operator^ (muda::Flags)</li> <li>operator^= (muda::Flags)</li> <li>operator| (muda::Flags)</li> <li>operator|= (muda::Flags)</li> <li>Offset2D (muda::Offset2D)</li> <li>offset_in_height (muda::Offset2D, muda::Offset3D)</li> <li>offset_in_width (muda::Offset2D, muda::Offset3D)</li> <li>Offset3D (muda::Offset3D)</li> <li>offset_in_depth (muda::Offset3D)</li> <li>operator int (muda::ParallelForDetails)</li> <li>operator cudaStream_t (muda::Stream::FireAndForget, muda::Stream::GraphFireAndForget, muda::Stream::GraphTailLaunch, muda::Stream::TailLaunch, muda::Stream)</li> <li>offsets (muda::details::MatrixFormatConverter)</li> <li>object_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>objects (muda::lbvh::BVH)</li> <li>object (muda::lbvh::details::BVHViewerBase)</li> <li>object_idx (muda::lbvh::details::Node)</li> <li>out_of_range (muda::out_of_range)</li> <li>o (muda::spatial_hash::BoundingSphere)</li> <li>oid (muda::spatial_hash::SpatialPartitionCell)</li> <li>overlap (muda::spatial_hash::SpatialPartitionCell)</li> <li>objCountInCell (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>objCountInCellPrefixSum (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#p","title":"p","text":"<ul> <li>ptr (TCB_SPAN_NAMESPACE_NAME::detail::span_storage)</li> <li>pointer (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::VarViewT)</li> <li>pitch_bytes (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::Dense2DBase, muda::Dense3DBase, muda::DeviceBuffer2D, muda::DeviceBuffer3D)</li> <li>pitch_bytes_area (muda::Buffer3DViewT, muda::Dense3DBase, muda::DeviceBuffer3D)</li> <li>Phase (muda::ComputeGraphBuilder)</li> <li>PhaseAction (muda::ComputeGraphBuilder)</li> <li>prepare_buffer (muda::CubWrapper)</li> <li>Proxy (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>parse (muda::KernelNodeParms)</li> <li>pop_kernel_label (muda::LaunchBase, muda::LaunchCore)</li> <li>pop_range (muda::LaunchBase, muda::LaunchCore)</li> <li>push_range (muda::LaunchBase, muda::LaunchCore)</li> <li>plus (muda::LinearSystemContext)</li> <li>PROXY_OPERATOR (muda::LogProxy)</li> <li>push_data (muda::LogProxy, muda::LoggerViewer)</li> <li>push_fmt_arg (muda::LogProxy)</li> <li>push_string (muda::LogProxy, muda::LoggerViewer)</li> <li>put (muda::Logger)</li> <li>proxy (muda::LoggerViewer)</li> <li>ParallelFor (muda::ParallelFor)</li> <li>ParallelForDetails (muda::ParallelForDetails)</li> <li>parallel_for_type (muda::ParallelForDetails)</li> <li>Profile (muda::Profile)</li> <li>ParallelForCallable (muda::details::ParallelForCallable)</li> <li>parent_idx (muda::lbvh::details::Node)</li> <li>pass (muda::spatial_hash::SpatialPartitionCell)</li> <li>pass_type (muda::spatial_hash::SpatialPartitionCell)</li> <li>pairCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>pairListOffset (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>potentialCollisionPairIdToCellIndex (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>potentialCollisionPairIdToCellIndexBuffer (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#q","title":"q","text":"<ul> <li>query (muda::ComputeGraph, muda::ComputeGraphVarBase, muda::Event, muda::lbvh::details::BVHViewerBase)</li> <li>QueryResult (muda::Event)</li> <li>query_nearest (muda::lbvh::query_nearest)</li> <li>query_overlap (muda::lbvh::query_overlap)</li> </ul>"},{"location":"muda/class_members/#r","title":"r","text":"<ul> <li>rbegin (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>reference (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::VarViewT)</li> <li>rend (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>reverse_iterator (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>row_offsets (muda::BSRMatrixViewT, muda::DeviceBSRMatrix)</li> <li>rows (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceTripletMatrix)</li> <li>reserve (muda::BufferLaunch, muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseVector, muda::NDReshaper, muda::details::TempBuffer)</li> <li>resize (muda::BufferLaunch, muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseVector, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::NDReshaper, muda::SubField, muda::SubFieldInterface, muda::details::TempBuffer)</li> <li>row_indices (muda::COOMatrixViewT, muda::DeviceTripletMatrix)</li> <li>read_style (muda::ComputeGraphGraphvizOptions)</li> <li>read_write_style (muda::ComputeGraphGraphvizOptions)</li> <li>ROViewer (muda::ComputeGraphVar)</li> <li>RWViewer (muda::ComputeGraphVar)</li> <li>remove_related_closure_infos (muda::ComputeGraphVarBase)</li> <li>row (muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DeviceDenseMatrix)</li> <li>row_offset (muda::DenseMatrixViewerT)</li> <li>reserve_offsets (muda::DeviceBSRMatrix)</li> <li>reshape (muda::DeviceBSRMatrix, muda::DeviceDenseMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix)</li> <li>reserve_doublets (muda::DeviceDoubletVector)</li> <li>resize_doublets (muda::DeviceDoubletVector)</li> <li>Reduce (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>ReduceByKey (muda::DeviceReduce)</li> <li>reserve_triplets (muda::DeviceTripletMatrix)</li> <li>resize_triplets (muda::DeviceTripletMatrix)</li> <li>raw_ptr (muda::DeviceVector)</li> <li>read (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>record (muda::LaunchBase, muda::LaunchCore)</li> <li>reorder (muda::LinearSystemContext)</li> <li>reserve_ratio (muda::LinearSystemContext, muda::LinearSystemHandles)</li> <li>reoder_method (muda::LinearSystemSolveReorder)</li> <li>reorder_method (muda::LinearSystemSolveReorder)</li> <li>reorder_method_int (muda::LinearSystemSolveReorder)</li> <li>retrieve (muda::Logger)</li> <li>retrieve_meta (muda::Logger)</li> <li>round_up_blocks (muda::ParallelFor)</li> <li>RangeName (muda::RangeName)</li> <li>require_total_buffer_byte_size (muda::SubFieldInterface)</li> <li>resize_data_buffer (muda::SubFieldInterface)</li> <li>round_up (muda::SubFieldInterface)</li> <li>row_index (muda::TripletMatrixViewerT::CTriplet)</li> <li>radix_sort_indices_and_blocks (muda::details::MatrixFormatConverter)</li> <li>row_tmp (muda::details::MatrixFormatConverter)</li> <li>real_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>right_idx (muda::lbvh::details::Node)</li> <li>runtime_error (muda::runtime_error)</li> <li>radius (muda::spatial_hash::AABB)</li> <li>r (muda::spatial_hash::BoundingSphere)</li> </ul>"},{"location":"muda/class_members/#s","title":"s","text":"<ul> <li>size (TCB_SPAN_NAMESPACE_NAME::detail::span_storage, TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DeviceBuffer, muda::DeviceDenseVector, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::SubField, muda::details::LoggerMetaData, muda::details::TempBuffer, muda::details::HostDeviceStringCache::StringLocation)</li> <li>span_storage (TCB_SPAN_NAMESPACE_NAME::detail::span_storage)</li> <li>size_bytes (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>size_type (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>span (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>storage_ (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>storage_type (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>subspan (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>subspan_return_t (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>subview (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::DenseVectorViewT, muda::DoubletVectorViewT, muda::TripletMatrixViewT)</li> <li>shrink_to_fit (muda::BufferLaunch, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::NDReshaper)</li> <li>S (muda::ComputeGraph, muda::ComputeGraphClosure, muda::ComputeGraphNodeBase, muda::ComputeGraphVarManager, muda::Graph, muda::GraphExec, muda::LaunchCore, muda::details::ComputeGraphAccessor)</li> <li>serial_launch (muda::ComputeGraph)</li> <li>set_current_graph_as_this (muda::ComputeGraph)</li> <li>shared_capture_stream (muda::ComputeGraph)</li> <li>set_node (muda::ComputeGraphCaptureNode, muda::ComputeGraphNode)</li> <li>set_deps_range (muda::ComputeGraphClosure)</li> <li>show_all_graph_nodes_in_a_closure (muda::ComputeGraphGraphvizOptions)</li> <li>show_nodes (muda::ComputeGraphGraphvizOptions)</li> <li>show_vars (muda::ComputeGraphGraphvizOptions)</li> <li>set_handle (muda::ComputeGraphNodeBase)</li> <li>sync (muda::ComputeGraphVarBase, muda::ComputeGraphVarManager, muda::LinearSystemContext)</li> <li>sync_on (muda::ComputeGraphVarManager)</li> <li>set_sync_callback (muda::Debug)</li> <li>segment (muda::DenseVectorViewerT)</li> <li>SegmentVector (muda::DeviceBCOOVector, muda::DoubletVectorViewT)</li> <li>sym (muda::DeviceDenseMatrix)</li> <li>SortKeys (muda::DeviceMergeSort, muda::DeviceRadixSort, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedSort)</li> <li>SortKeysCopy (muda::DeviceMergeSort)</li> <li>SortPairs (muda::DeviceMergeSort, muda::DeviceRadixSort, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedSort)</li> <li>SortPairsCopy (muda::DeviceMergeSort)</li> <li>StableSortKeys (muda::DeviceMergeSort, muda::DeviceSegmentedSort)</li> <li>StableSortPairs (muda::DeviceMergeSort, muda::DeviceSegmentedSort)</li> <li>SortKeysDescending (muda::DeviceRadixSort, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedSort)</li> <li>SortPairsDescending (muda::DeviceRadixSort, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedSort)</li> <li>Sum (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>StableSortKeysDescending (muda::DeviceSegmentedSort)</li> <li>StableSortPairsDescending (muda::DeviceSegmentedSort)</li> <li>subvector (muda::DoubletVectorViewT)</li> <li>subvector_offset (muda::DoubletVectorViewT)</li> <li>scalar (muda::FieldBuilder::EntryProxy)</li> <li>shape (muda::FieldEntryBase, muda::FieldEntryBaseData, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>struct_stride (muda::FieldEntryBase, muda::FieldEntryBaseData, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>soa_elem_addr (muda::FieldEntryCore)</li> <li>set_event_record_node_parms (muda::GraphExec)</li> <li>set_event_wait_node_parms (muda::GraphExec)</li> <li>set_kernel_node_parms (muda::GraphExec)</li> <li>set_memcpy_node_parms (muda::GraphExec)</li> <li>set_memset_node_parms (muda::GraphExec)</li> <li>shared_mem_bytes (muda::KernelNodeParms)</li> <li>stream (muda::LaunchCore, muda::LinearSystemContext, muda::LinearSystemContextCreateInfo, muda::LinearSystemHandles)</li> <li>SPMV_ALG_DEFAULT (muda::LinearSystemAlgorithm)</li> <li>set_pointer_mode_device (muda::LinearSystemContext, muda::LinearSystemHandles)</li> <li>set_pointer_mode_host (muda::LinearSystemContext, muda::LinearSystemHandles)</li> <li>shrink_temp_buffers (muda::LinearSystemContext)</li> <li>solve (muda::LinearSystemContext)</li> <li>spmv (muda::LinearSystemContext)</li> <li>sysv (muda::LinearSystemContext)</li> <li>solve_sparse_error_threshold (muda::LinearSystemSolveTolerance)</li> <li>set (muda::Memory)</li> <li>Stream (muda::Stream)</li> <li>SoA (muda::SubField)</li> <li>SubField (muda::SubField)</li> <li>SubFieldInterface (muda::SubFieldInterface)</li> <li>submatrix (muda::TripletMatrixViewT)</li> <li>submatrix_offset (muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>set_capture_node (muda::details::ComputeGraphAccessor)</li> <li>set_event_record_node (muda::details::ComputeGraphAccessor)</li> <li>set_event_wait_node (muda::details::ComputeGraphAccessor)</li> <li>set_kernel_node (muda::details::ComputeGraphAccessor)</li> <li>set_memcpy_node (muda::details::ComputeGraphAccessor)</li> <li>set_memset_node (muda::details::ComputeGraphAccessor)</li> <li>set_var_usage (muda::details::ComputeGraphAccessor)</li> <li>set_unique_values_to_dense_vector (muda::details::MatrixFormatConverter)</li> <li>sort_index (muda::details::MatrixFormatConverter)</li> <li>sort_index_input (muda::details::MatrixFormatConverter)</li> <li>sort_index_tmp (muda::details::MatrixFormatConverter)</li> <li>sort_indices_and_values (muda::details::MatrixFormatConverter)</li> <li>SparseSpatialHash (muda::spatial_hash::SparseSpatialHash)</li> <li>SpatialHashTableInfo (muda::spatial_hash::SpatialHashTableInfo)</li> <li>SpatialPartitionCell (muda::spatial_hash::SpatialPartitionCell)</li> <li>set_as_home (muda::spatial_hash::SpatialPartitionCell)</li> <li>set_as_phantom (muda::spatial_hash::SpatialPartitionCell)</li> <li>set_overlap (muda::spatial_hash::SpatialPartitionCell)</li> <li>SparseSpatialHashImpl (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>setup_hash_table (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>simple_count_collision_pairs (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>simple_fill_collision_pair_list (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>simple_setup_collision_pairs (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>spatialHashConfig (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>spheres (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>sum (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#t","title":"t","text":"<ul> <li>T (muda::BSRMatrixViewT, muda::DenseMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDenseMatrix)</li> <li>ThisView (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DoubletVectorViewT, muda::TripletMatrixViewT, muda::VarViewT)</li> <li>ThisViewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>total_size (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DeviceBuffer2D, muda::DeviceBuffer3D)</li> <li>total_triplet_count (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>tripet_index_offset (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>triplet_count (muda::COOMatrixViewT, muda::DeviceTripletMatrix, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>total_doublet_count (muda::COOVectorViewBase, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>topo_build (muda::ComputeGraph)</li> <li>type (muda::ComputeGraphClosure, muda::ComputeGraphNodeBase, muda::FieldEntryBaseData, muda::LoggerMetaData, muda::details::LoggerMetaData, muda::read_only_view, muda::read_write_view, std::tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt;)</li> <li>to (muda::ComputeGraphDependency)</li> <li>total_bytes (muda::Dense3DBase)</li> <li>ThisBuffer2DView (muda::DenseMatrixViewT, muda::DenseMatrixViewerT)</li> <li>ThisMapMatrix (muda::DenseMatrixViewerT)</li> <li>ThisBufferView (muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>ThisMapVector (muda::DenseVectorViewerT)</li> <li>triplet_capacity (muda::DeviceTripletMatrix)</li> <li>total_extent (muda::DoubletVectorViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>this_type (muda::EventRecordNode, muda::EventWaitNode, muda::GraphNode, muda::HostNode, muda::HostNodeParms, muda::KernelNode, muda::KernelNodeParms, muda::MemcpyNode, muda::MemsetNode)</li> <li>ThisMatMap (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>total_count (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>tail_launch (muda::GraphViewer)</li> <li>temp_buffer (muda::LinearSystemContext)</li> <li>temp_buffers (muda::LinearSystemContext)</li> <li>temp_host_buffer (muda::LinearSystemContext)</li> <li>temp_host_buffers (muda::LinearSystemContext)</li> <li>tolerance (muda::LinearSystemContext)</li> <li>TypeN (muda::MatrixFormatConverter)</li> <li>transfer (muda::Memory)</li> <li>total_batch (muda::ParallelForDetails)</li> <li>total_num (muda::ParallelForDetails)</li> <li>TailLaunch (muda::Stream::TailLaunch)</li> <li>TripletMatrixViewT (muda::TripletMatrixViewT)</li> <li>total_block_cols (muda::TripletMatrixViewT)</li> <li>total_block_rows (muda::TripletMatrixViewT)</li> <li>TripletMatrixViewerT (muda::TripletMatrixViewerT)</li> <li>total_cols (muda::TripletMatrixViewerT)</li> <li>total_rows (muda::TripletMatrixViewerT)</li> <li>temp_bcoo_matrix (muda::details::MatrixFormatConverter)</li> <li>temp_bcoo_vector (muda::details::MatrixFormatConverter)</li> <li>temp_segments (muda::details::MatrixFormatConverter)</li> <li>TempBuffer (muda::details::TempBuffer)</li> <li>target (muda::lbvh::query_nearest, muda::lbvh::query_overlap)</li> </ul>"},{"location":"muda/class_members/#u","title":"u","text":"<ul> <li>U (muda::ComputeGraph, muda::Field, muda::Graph, muda::GraphExec, muda::MatrixFormatConverter, muda::SubField, muda::SubFieldInterface)</li> <li>update (muda::ComputeGraph, muda::ComputeGraphVar, muda::ComputeGraphVarBase)</li> <li>update_sub_graph (muda::ComputeGraphCaptureNode)</li> <li>unique_graphs (muda::ComputeGraphVarManager)</li> <li>Unique (muda::DeviceSelect)</li> <li>upload (muda::GraphExec, muda::Logger, muda::Memory)</li> <li>userdata (muda::HostNodeParms)</li> <li>update_capture_node (muda::details::ComputeGraphAccessor)</li> <li>update_event_record_node (muda::details::ComputeGraphAccessor)</li> <li>update_event_wait_node (muda::details::ComputeGraphAccessor)</li> <li>update_kernel_node (muda::details::ComputeGraphAccessor)</li> <li>update_memcpy_node (muda::details::ComputeGraphAccessor)</li> <li>update_memset_node (muda::details::ComputeGraphAccessor)</li> <li>unique_blocks (muda::details::MatrixFormatConverter)</li> <li>unique_counts (muda::details::MatrixFormatConverter)</li> <li>unique_ij_pairs (muda::details::MatrixFormatConverter)</li> <li>unique_indices (muda::details::MatrixFormatConverter)</li> <li>unique_segments (muda::details::MatrixFormatConverter)</li> <li>unique_values (muda::details::MatrixFormatConverter)</li> <li>upper (muda::lbvh::AABB)</li> <li>U32 (muda::spatial_hash::SpatialHashTableInfo, muda::spatial_hash::SpatialPartitionCell, muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>uniqueKey (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>uniqueKeyCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#v","title":"v","text":"<ul> <li>value (TCB_SPAN_NAMESPACE_NAME::detail::is_container, muda::DoubletVectorViewerT::CDoublet, muda::IdWithType, muda::TripletMatrixViewerT::CTriplet, muda::always_false, muda::always_true, muda::force_trivial, muda::force_trivially_constructible, muda::force_trivially_copy_assignable, muda::force_trivially_copy_constructible, muda::force_trivially_destructible, muda::is_cuda_arch)</li> <li>value_type (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseViewerT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceVar, muda::HostDeviceConfig, muda::HostDeviceConfigView, muda::IdWithType, muda::VarViewT)</li> <li>ValueT (muda::BSRMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::DoubletVectorViewerT, muda::TripletMatrixViewerT)</li> <li>values (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix)</li> <li>Viewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT)</li> <li>viewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::ComputeGraph, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::DeviceVar, muda::DeviceVector, muda::DoubletVectorViewT, muda::Event, muda::FieldEntry, muda::FieldEntryViewCore, muda::GraphExec, muda::Logger, muda::TripletMatrixViewT, muda::VarViewT, muda::lbvh::BVH)</li> <li>vector_size (muda::COOVectorViewBase)</li> <li>var_usages (muda::ComputeGraphClosure)</li> <li>var_style (muda::ComputeGraphGraphvizOptions)</li> <li>var_id (muda::ComputeGraphVarBase)</li> <li>var_span (muda::ComputeGraphVarManager)</li> <li>volume (muda::Dense3DBase)</li> <li>VectorType (muda::DenseVectorViewerT)</li> <li>VectorBlock&lt; ThisMapVector &gt; (muda::DenseVectorViewerT)</li> <li>view (muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::DeviceVar, muda::DeviceVector, muda::FieldEntry, muda::HostDeviceConfig, muda::Stream)</li> <li>valid (muda::Extent2D, muda::Extent3D)</li> <li>vector (muda::FieldBuilder::EntryProxy)</li> <li>vector2 (muda::FieldBuilder::EntryProxy)</li> <li>vector3 (muda::FieldBuilder::EntryProxy)</li> <li>vector4 (muda::FieldBuilder::EntryProxy)</li> <li>ViewerCore (muda::FieldEntryViewCore)</li> <li>VarViewT (muda::VarViewT)</li> <li>ViewerBase (muda::ViewerBase)</li> <li>view_name (muda::details::LaunchInfoCache)</li> <li>var (muda::details::LocalVarInfo)</li> <li>VectorValueT (muda::details::MatrixFormatConverter)</li> <li>VectorValueTZero (muda::details::MatrixFormatConverter)</li> <li>vector_type (muda::lbvh::query_nearest)</li> <li>Vector3 (muda::spatial_hash::AABB, muda::spatial_hash::BoundingSphere, muda::spatial_hash::SpatialHashTableInfo, muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>Vector3i (muda::spatial_hash::SpatialHashTableInfo, muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>Vector3u (muda::spatial_hash::SpatialHashTableInfo, muda::spatial_hash::SpatialPartitionCell, muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>validCellCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>validCollisionPairCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_members/#w","title":"w","text":"<ul> <li>write (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>width (muda::Extent2D, muda::Extent3D)</li> <li>wait (muda::LaunchBase, muda::LaunchCore, muda::Stream)</li> <li>when (muda::LaunchBase, muda::LaunchCore)</li> <li>wait_device (muda::LaunchCore)</li> <li>wait_event (muda::LaunchCore)</li> <li>wait_stream (muda::LaunchCore)</li> <li>workspace (muda::Stream)</li> <li>what (muda::exception)</li> <li>whole (muda::lbvh::DefaultMortonCodeCalculator)</li> </ul>"},{"location":"muda/class_members/#z","title":"z","text":"<ul> <li>Zero (muda::Extent2D, muda::Extent3D, muda::Offset2D, muda::Offset3D)</li> </ul>"},{"location":"muda/class_members/#_1","title":"~","text":"<ul> <li>~span (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>~GraphPhaseGuard (muda::ComputeGraph::GraphPhaseGuard)</li> <li>~ComputeGraph (muda::ComputeGraph)</li> <li>~ComputeGraphBuilder (muda::ComputeGraphBuilder)</li> <li>~ComputeGraphCaptureNode (muda::ComputeGraphCaptureNode)</li> <li>~ComputeGraphClosure (muda::ComputeGraphClosure)</li> <li>~ComputeGraphNode (muda::ComputeGraphNode)</li> <li>~ComputeGraphNodeBase (muda::ComputeGraphNodeBase)</li> <li>~ComputeGraphVar (muda::ComputeGraphVar)</li> <li>~ComputeGraphVarBase (muda::ComputeGraphVarBase)</li> <li>~ComputeGraphVarManager (muda::ComputeGraphVarManager)</li> <li>~DeviceBCOOMatrix (muda::DeviceBCOOMatrix)</li> <li>~DeviceBCOOVector (muda::DeviceBCOOVector)</li> <li>~DeviceBSRMatrix (muda::DeviceBSRMatrix)</li> <li>~DeviceBuffer (muda::DeviceBuffer)</li> <li>~DeviceBuffer2D (muda::DeviceBuffer2D)</li> <li>~DeviceBuffer3D (muda::DeviceBuffer3D)</li> <li>~DeviceDenseVector (muda::DeviceDenseVector)</li> <li>~DeviceDoubletVector (muda::DeviceDoubletVector)</li> <li>~DeviceTripletMatrix (muda::DeviceTripletMatrix)</li> <li>~DeviceVar (muda::DeviceVar)</li> <li>~Proxy (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>~Event (muda::Event)</li> <li>~Field (muda::Field)</li> <li>~FieldBuilder (muda::FieldBuilder)</li> <li>~FieldEntryBase (muda::FieldEntryBase)</li> <li>~Graph (muda::Graph)</li> <li>~GraphExec (muda::GraphExec)</li> <li>~GraphLaunch (muda::GraphLaunch)</li> <li>~KernelLabel (muda::KernelLabel)</li> <li>~LaunchBase (muda::LaunchBase)</li> <li>~LaunchCore (muda::LaunchCore)</li> <li>~LinearSystemContext (muda::LinearSystemContext)</li> <li>~LinearSystemHandles (muda::LinearSystemHandles)</li> <li>~Logger (muda::Logger)</li> <li>~MatrixFormatConverter (muda::MatrixFormatConverter, muda::details::MatrixFormatConverter)</li> <li>~NodeParms (muda::NodeParms)</li> <li>~Profile (muda::Profile)</li> <li>~RangeName (muda::RangeName)</li> <li>~Stream (muda::Stream)</li> <li>~SubField (muda::SubField)</li> <li>~SubFieldInterface (muda::SubFieldInterface)</li> <li>~HostDeviceStringCache (muda::details::HostDeviceStringCache)</li> <li>~MatrixFormatConverterBase (muda::details::MatrixFormatConverterBase)</li> <li>~TempBuffer (muda::details::TempBuffer)</li> <li>~BVH (muda::lbvh::BVH)</li> <li>~DefaultMortonCodeCalculator (muda::lbvh::DefaultMortonCodeCalculator)</li> <li>~query_nearest (muda::lbvh::query_nearest)</li> <li>~query_overlap (muda::lbvh::query_overlap)</li> </ul>"},{"location":"muda/class_members/#_","title":"_","text":"<ul> <li>_update (muda::ComputeGraph)</li> <li>_building_eval (muda::ComputeGraphVarBase)</li> <li>_ceval (muda::ComputeGraphVarBase)</li> <li>_eval (muda::ComputeGraphVarBase)</li> <li>_is_debug_sync_all (muda::Debug)</li> <li>_mutex (muda::Debug)</li> <li>_sync_callback (muda::Debug)</li> <li>_retrieve (muda::Logger)</li> <li>_dummy (muda::ViewBase)</li> </ul>"},{"location":"muda/class_member_functions/","title":"Class Member Functions","text":""},{"location":"muda/class_member_functions/#a","title":"a","text":"<ul> <li>as_const (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>alloc (muda::BufferLaunch, muda::Memory)</li> <li>add_node (muda::ComputeGraph)</li> <li>AddNodeProxy (muda::ComputeGraph::AddNodeProxy)</li> <li>access_index (muda::ComputeGraphNodeBase)</li> <li>area (muda::Dense2DBase, muda::Dense3DBase)</li> <li>as_eigen (muda::DenseMatrixViewerT, muda::DenseVectorViewerT)</li> <li>atomic_add (muda::DenseMatrixViewerT, muda::DenseVectorViewerT)</li> <li>ArgMax (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>ArgMin (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>at (muda::DoubletVectorViewerT, muda::TripletMatrixViewerT)</li> <li>async_copy_to_new_place (muda::FieldEntry, muda::FieldEntryBase)</li> <li>aos_elem_addr (muda::FieldEntryCore)</li> <li>aos_struct_begin (muda::FieldEntryCore)</li> <li>aosoa_elem_addr (muda::FieldEntryCore)</li> <li>aosoa_inner_index (muda::FieldEntryCore)</li> <li>aosoa_struct_begin (muda::FieldEntryCore)</li> <li>add_dependency (muda::Graph)</li> <li>add_event_record_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>add_event_wait_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>add_host_node (muda::Graph)</li> <li>add_kernel_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>add_memcpy_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>add_memset_node (muda::Graph, muda::details::ComputeGraphAccessor)</li> <li>apply (muda::HostCall, muda::Launch, muda::ParallelFor)</li> <li>as_node_parms (muda::HostCall, muda::Launch, muda::ParallelFor)</li> <li>add_sync_callback (muda::LinearSystemContext)</li> <li>axpby (muda::LinearSystemContext)</li> <li>as (muda::LoggerMetaData)</li> <li>alloc_1d (muda::Memory)</li> <li>alloc_2d (muda::Memory)</li> <li>alloc_3d (muda::Memory)</li> <li>active_num_in_block (muda::ParallelForDetails)</li> <li>AoS (muda::SubField)</li> <li>AoSoA (muda::SubField)</li> <li>allow_inplace_shrink (muda::SubField, muda::SubFieldInterface)</li> <li>align (muda::SubFieldInterface)</li> <li>async_upload_temp_cores (muda::SubFieldInterface)</li> <li>aync_upload_cores (muda::SubFieldInterface)</li> <li>access_graph (muda::details::ComputeGraphAccessor)</li> <li>access_graph_exec (muda::details::ComputeGraphAccessor)</li> <li>add_capture_node (muda::details::ComputeGraphAccessor)</li> <li>auto_select (muda::details::StringPointer)</li> <li>AABB (muda::lbvh::AABB, muda::spatial_hash::AABB)</li> <li>aabbs (muda::lbvh::BVH)</li> <li>allow_ignore (muda::spatial_hash::SpatialPartitionCell)</li> <li>alloc_collision_pair_list (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_functions/#b","title":"b","text":"<ul> <li>back (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>begin (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>BSRMatrixViewT (muda::BSRMatrixViewT)</li> <li>Buffer2DViewT (muda::Buffer2DViewT)</li> <li>Buffer3DViewT (muda::Buffer3DViewT)</li> <li>BufferLaunch (muda::BufferLaunch)</li> <li>BufferViewT (muda::BufferViewT)</li> <li>build (muda::ComputeGraph, muda::FieldBuilder, muda::SubField, muda::SubFieldInterface, muda::lbvh::BVH)</li> <li>build_deps (muda::ComputeGraph)</li> <li>base_building_ceval (muda::ComputeGraphVarBase)</li> <li>base_building_eval (muda::ComputeGraphVarBase)</li> <li>base_update (muda::ComputeGraphVarBase)</li> <li>buffer_view (muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::HostDeviceConfig)</li> <li>block (muda::DenseMatrixViewerT)</li> <li>block_size (muda::DeviceBSRMatrix)</li> <li>block_dim (muda::DeviceTripletMatrix, muda::KernelNodeParms)</li> <li>batch_i (muda::ParallelForDetails)</li> <li>begin_capture (muda::Stream)</li> <li>builder (muda::SubField)</li> <li>build_impl (muda::SubFieldInterface)</li> <li>build_options (muda::SubFieldInterface)</li> <li>bsr2csr (muda::details::MatrixFormatConverter)</li> <li>BVH (muda::lbvh::BVH)</li> <li>BVHViewerBase (muda::lbvh::details::BVHViewerBase)</li> <li>BoundingSphere (muda::spatial_hash::BoundingSphere)</li> <li>balanced_setup_collision_pairs (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_functions/#c","title":"c","text":"<ul> <li>col_indices (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceTripletMatrix)</li> <li>cols (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceTripletMatrix)</li> <li>copy_from (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceVar, muda::FieldEntry, muda::VarViewT, muda::details::TempBuffer)</li> <li>copy_to (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceVector, muda::FieldEntry, muda::VarViewT, muda::details::TempBuffer)</li> <li>cuda_pitched_ptr (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::details::buffer::BufferInfoAccessor)</li> <li>cviewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::DeviceVar, muda::DeviceVector, muda::DoubletVectorViewT, muda::FieldEntry, muda::FieldEntryViewCore, muda::TripletMatrixViewT, muda::VarViewT, muda::lbvh::BVH)</li> <li>clear (muda::BufferLaunch, muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::lbvh::BVH)</li> <li>copy (muda::BufferLaunch, muda::FieldEntryLaunch, muda::Memory)</li> <li>COOMatrixViewT (muda::COOMatrixViewT)</li> <li>COOVectorViewBase (muda::COOVectorViewBase)</li> <li>ComputeGraph (muda::ComputeGraph)</li> <li>capture (muda::ComputeGraph, muda::ComputeGraphBuilder)</li> <li>check_vars_valid (muda::ComputeGraph)</li> <li>clear_current_graph (muda::ComputeGraph)</li> <li>create_node (muda::ComputeGraph)</li> <li>cuda_graph_add_deps (muda::ComputeGraph)</li> <li>current_access_index (muda::ComputeGraph)</li> <li>current_closure_id (muda::ComputeGraph)</li> <li>current_graph_phase (muda::ComputeGraph)</li> <li>current_node_id (muda::ComputeGraph)</li> <li>ComputeGraphBuilder (muda::ComputeGraphBuilder)</li> <li>current_graph (muda::ComputeGraphBuilder)</li> <li>current_phase (muda::ComputeGraphBuilder)</li> <li>ComputeGraphCaptureNode (muda::ComputeGraphCaptureNode)</li> <li>ComputeGraphClosure (muda::ComputeGraphClosure)</li> <li>clousure_id (muda::ComputeGraphClosure)</li> <li>ComputeGraphNode (muda::ComputeGraphNode)</li> <li>ComputeGraphNodeBase (muda::ComputeGraphNodeBase)</li> <li>ComputeGraphVar (muda::ComputeGraphVar)</li> <li>ComputeGraphVarBase (muda::ComputeGraphVar, muda::ComputeGraphVarBase)</li> <li>ceval (muda::ComputeGraphVar)</li> <li>ComputeGraphVarManager (muda::ComputeGraphVarManager)</li> <li>create_graph (muda::ComputeGraphVarManager)</li> <li>create_var (muda::ComputeGraphVarManager)</li> <li>CubWrapper (muda::CubWrapper)</li> <li>call_sync_callback (muda::Debug)</li> <li>check (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseViewerT)</li> <li>check_range (muda::Dense2DBase, muda::Dense3DBase)</li> <li>col (muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DeviceDenseMatrix)</li> <li>check_size_matching (muda::DenseMatrixViewerT, muda::DenseVectorViewerT)</li> <li>col_offset (muda::DenseMatrixViewerT)</li> <li>check_data (muda::DenseVectorViewerT)</li> <li>check_segment (muda::DenseVectorViewerT)</li> <li>cview (muda::DeviceBSRMatrix, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceDoubletVector, muda::DeviceTripletMatrix)</li> <li>capacity (muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseVector, muda::details::TempBuffer)</li> <li>count (muda::DeviceDoubletVector, muda::FieldEntryBase, muda::FieldEntryCore)</li> <li>CsrMV (muda::DeviceSpmv)</li> <li>check_in_subvector (muda::DoubletVectorViewerT)</li> <li>CDoublet (muda::DoubletVectorViewerT::CDoublet)</li> <li>cuda_extent (muda::Extent2D, muda::Extent3D)</li> <li>create_entry (muda::FieldBuilder, muda::SubField)</li> <li>core (muda::FieldEntryBase)</li> <li>cast (muda::FieldEntryCore)</li> <li>check_index (muda::FieldEntryViewerCore, muda::lbvh::details::BVHViewerBase)</li> <li>create (muda::Graph)</li> <li>calculate_grid_dim (muda::Launch, muda::ParallelFor)</li> <li>check_input (muda::Launch, muda::ParallelFor)</li> <li>check_input_with_range (muda::Launch)</li> <li>callback (muda::LaunchBase, muda::LaunchCore)</li> <li>convert (muda::LinearSystemContext, muda::MatrixFormatConverter, muda::details::MatrixFormatConverter)</li> <li>cublas (muda::LinearSystemContext, muda::LinearSystemHandles, muda::details::MatrixFormatConverterBase)</li> <li>cusolver_dn (muda::LinearSystemContext, muda::LinearSystemHandles, muda::details::MatrixFormatConverterBase)</li> <li>cusolver_sp (muda::LinearSystemContext, muda::LinearSystemHandles, muda::details::MatrixFormatConverterBase)</li> <li>cusparse (muda::LinearSystemContext, muda::LinearSystemHandles, muda::details::MatrixFormatConverterBase)</li> <li>cuda_pos (muda::Offset2D, muda::Offset3D)</li> <li>calculate_block_dim (muda::ParallelFor)</li> <li>calculate_new_cores (muda::SubFieldInterface)</li> <li>check_in_submatrix (muda::TripletMatrixViewerT)</li> <li>CTriplet (muda::TripletMatrixViewerT::CTriplet)</li> <li>copy_label (muda::ViewerBase)</li> <li>cuda_error (muda::cuda_error)</li> <li>ComputeGraphAccessor (muda::details::ComputeGraphAccessor)</li> <li>capture_stream (muda::details::ComputeGraphAccessor)</li> <li>check_allow_node_adding (muda::details::ComputeGraphAccessor)</li> <li>check_allow_var_eval (muda::details::ComputeGraphAccessor)</li> <li>current_closure (muda::details::ComputeGraphAccessor)</li> <li>current_node (muda::details::ComputeGraphAccessor)</li> <li>current_stream (muda::details::ComputeGraphAccessor)</li> <li>current_capture_name (muda::details::LaunchInfoCache)</li> <li>current_kernel_file (muda::details::LaunchInfoCache)</li> <li>current_kernel_line (muda::details::LaunchInfoCache)</li> <li>current_kernel_name (muda::details::LaunchInfoCache)</li> <li>calculate_block_offsets (muda::details::MatrixFormatConverter)</li> <li>center (muda::spatial_hash::AABB)</li> <li>CollisionPair (muda::spatial_hash::CollisionPair)</li> <li>cell (muda::spatial_hash::SpatialHashTableInfo)</li> <li>cell_center_coord (muda::spatial_hash::SpatialHashTableInfo)</li> <li>coord (muda::spatial_hash::SpatialHashTableInfo)</li> <li>calculate_hash_table_basic_info (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>count_object_per_cell (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_functions/#d","title":"d","text":"<ul> <li>data (TCB_SPAN_NAMESPACE_NAME::span, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DenseViewerT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceVar, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::HostDeviceConfigView, muda::VarViewT, muda::details::TempBuffer)</li> <li>descr (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseVectorViewT, muda::DeviceBSRMatrix, muda::DeviceDenseVector)</li> <li>doublet_count (muda::COOVectorViewBase, muda::DeviceDoubletVector, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>doublet_index_offset (muda::COOVectorViewBase)</li> <li>dep_span (muda::ComputeGraph)</li> <li>deps (muda::ComputeGraphClosure)</li> <li>debug_sync_all (muda::Debug)</li> <li>Dense1DT (muda::Dense1DT)</li> <li>dim (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::details::MatrixFormatConverterBase)</li> <li>Dense2DBase (muda::Dense2DBase)</li> <li>Dense3DBase (muda::Dense3DBase)</li> <li>DenseMatrixViewT (muda::DenseMatrixViewT)</li> <li>DenseMatrixViewerT (muda::DenseMatrixViewerT)</li> <li>DenseVectorViewT (muda::DenseVectorViewT)</li> <li>DenseVectorViewerT (muda::DenseVectorViewerT)</li> <li>DenseViewerT (muda::DenseViewerT)</li> <li>DeviceBCOOMatrix (muda::DeviceBCOOMatrix)</li> <li>DeviceBCOOVector (muda::DeviceBCOOVector)</li> <li>DeviceBSRMatrix (muda::DeviceBSRMatrix)</li> <li>destroy_all_descr (muda::DeviceBSRMatrix)</li> <li>DeviceBuffer (muda::DeviceBuffer)</li> <li>DeviceBuffer2D (muda::DeviceBuffer2D)</li> <li>DeviceBuffer3D (muda::DeviceBuffer3D)</li> <li>DeviceDenseMatrix (muda::DeviceDenseMatrix)</li> <li>DeviceDenseVector (muda::DeviceDenseVector)</li> <li>DeviceDoubletVector (muda::DeviceDoubletVector)</li> <li>doublet_capacity (muda::DeviceDoubletVector)</li> <li>DeviceTripletMatrix (muda::DeviceTripletMatrix)</li> <li>DeviceVar (muda::DeviceVar)</li> <li>DoubletVectorViewT (muda::DoubletVectorViewT)</li> <li>DoubletVectorViewerT (muda::DoubletVectorViewerT)</li> <li>depth (muda::Extent3D)</li> <li>device_data (muda::HostDeviceConfig, muda::HostDeviceConfigView)</li> <li>derived (muda::LaunchBase)</li> <li>dot (muda::LinearSystemContext)</li> <li>download (muda::Logger, muda::Memory)</li> <li>Default (muda::Stream)</li> <li>data_buffer (muda::SubField)</li> <li>data_type (muda::details::MatrixFormatConverterBase)</li> <li>download_if_dirty (muda::lbvh::BVH)</li> <li>DefaultMortonCodeCalculator (muda::lbvh::DefaultMortonCodeCalculator)</li> <li>detect (muda::spatial_hash::SparseSpatialHash, muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_functions/#e","title":"e","text":"<ul> <li>empty (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>end (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>extent (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DoubletVectorViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>emplace_related_var (muda::ComputeGraph)</li> <li>eval (muda::ComputeGraphVar)</li> <li>Encode (muda::DeviceRunLengthEncode)</li> <li>ExclusiveScan (muda::DeviceScan)</li> <li>ExclusiveScanByKey (muda::DeviceScan)</li> <li>ExclusiveSum (muda::DeviceScan)</li> <li>ExclusiveSumByKey (muda::DeviceScan)</li> <li>Empty (muda::Empty)</li> <li>Event (muda::Event)</li> <li>elapsed_time (muda::Event)</li> <li>Extent2D (muda::Extent2D)</li> <li>Extent3D (muda::Extent3D)</li> <li>entry (muda::FieldBuilder)</li> <li>EntryProxy (muda::FieldBuilder::EntryProxy)</li> <li>elem_byte_size (muda::FieldEntryBase, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>elem_addr (muda::FieldEntryCore)</li> <li>entry_name (muda::FieldEntryViewerCore)</li> <li>extra (muda::KernelNodeParms)</li> <li>expand_buffer (muda::Logger)</li> <li>expand_if_needed (muda::Logger)</li> <li>expand_meta_data (muda::Logger)</li> <li>end_capture (muda::Stream)</li> <li>error (muda::cuda_error)</li> <li>error_string (muda::cuda_error)</li> <li>expand_blocks (muda::details::MatrixFormatConverter)</li> <li>exception (muda::exception)</li> </ul>"},{"location":"muda/class_member_functions/#f","title":"f","text":"<ul> <li>first (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>front (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>fill (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferLaunch, muda::BufferViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::FieldEntry, muda::FieldEntryLaunch, muda::VarViewT)</li> <li>free (muda::BufferLaunch, muda::Memory, muda::details::TempBuffer)</li> <li>find_var (muda::ComputeGraphVarManager)</li> <li>flatten (muda::Dense2DBase, muda::Dense3DBase)</li> <li>Flagged (muda::DevicePartition, muda::DeviceSelect)</li> <li>Field (muda::Field)</li> <li>FieldBuilder (muda::FieldBuilder)</li> <li>FieldEntry (muda::FieldEntry)</li> <li>FieldEntryBase (muda::FieldEntryBase)</li> <li>FieldEntryCore (muda::FieldEntryCore)</li> <li>FieldEntryLaunch (muda::FieldEntryLaunch)</li> <li>FieldEntryLayoutInfo (muda::FieldEntryLayoutInfo)</li> <li>FieldEntryViewCore (muda::FieldEntryViewCore)</li> <li>FieldEntryViewerCore (muda::FieldEntryViewerCore)</li> <li>Flags (muda::Flags)</li> <li>fire_and_forget (muda::GraphViewer)</li> <li>fn (muda::HostNodeParms)</li> <li>func (muda::KernelNodeParms, muda::cuda_error)</li> <li>file_line (muda::LaunchBase, muda::LaunchCore)</li> <li>FireAndForget (muda::Stream::FireAndForget)</li> <li>find_entry (muda::SubField)</li> <li>file (muda::cuda_error)</li> <li>fill_hash_cells (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_functions/#g","title":"g","text":"<ul> <li>graphviz (muda::ComputeGraph, muda::ComputeGraphVarManager)</li> <li>GraphPhaseGuard (muda::ComputeGraph::GraphPhaseGuard)</li> <li>graphviz_def (muda::ComputeGraphClosure, muda::ComputeGraphVar, muda::ComputeGraphVarBase)</li> <li>graphviz_id (muda::ComputeGraphClosure, muda::ComputeGraphVarBase)</li> <li>graphviz_var_usages (muda::ComputeGraphClosure)</li> <li>graphs (muda::ComputeGraphVarManager)</li> <li>get_index (muda::DoubletVectorViewerT, muda::TripletMatrixViewerT)</li> <li>Graph (muda::Graph)</li> <li>GraphExec (muda::GraphExec)</li> <li>GraphLaunch (muda::GraphLaunch)</li> <li>GraphNode (muda::GraphNode)</li> <li>GraphViewer (muda::GraphViewer)</li> <li>grid_dim (muda::KernelNodeParms)</li> <li>generic_spmv (muda::LinearSystemContext)</li> <li>gesv (muda::LinearSystemContext)</li> <li>GraphFireAndForget (muda::Stream::GraphFireAndForget)</li> <li>GraphTailLaunch (muda::Stream::GraphTailLaunch)</li> <li>get_or_create_node (muda::details::ComputeGraphAccessor)</li> <li>get_string_pointer (muda::details::HostDeviceStringCache)</li> </ul>"},{"location":"muda/class_member_functions/#h","title":"h","text":"<ul> <li>handle (muda::ComputeGraphNodeBase, muda::Graph, muda::GraphExec, muda::GraphNode, muda::GraphViewer, muda::HostNodeParms, muda::KernelNodeParms)</li> <li>HistogramEven (muda::DeviceHistogram)</li> <li>HistogramRange (muda::DeviceHistogram)</li> <li>height (muda::Extent2D, muda::Extent3D)</li> <li>has (muda::Flags)</li> <li>HostCall (muda::HostCall)</li> <li>HostDeviceConfig (muda::HostDeviceConfig)</li> <li>host_data (muda::HostDeviceConfig, muda::HostDeviceConfigView)</li> <li>HostDeviceConfigView (muda::HostDeviceConfigView)</li> <li>HostNodeParms (muda::HostNodeParms)</li> <li>HostDeviceStringCache (muda::details::HostDeviceStringCache)</li> <li>host_aabbs (muda::lbvh::BVH)</li> <li>host_nodes (muda::lbvh::BVH)</li> <li>host_objects (muda::lbvh::BVH)</li> <li>hash_cell (muda::spatial_hash::SpatialHashTableInfo)</li> </ul>"},{"location":"muda/class_member_functions/#i","title":"i","text":"<ul> <li>is_trans (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DenseMatrixViewT)</li> <li>instance (muda::ComputeGraphBuilder, muda::details::LaunchInfoCache)</li> <li>invoke_phase_actions (muda::ComputeGraphBuilder)</li> <li>is_building (muda::ComputeGraphBuilder)</li> <li>is_caturing (muda::ComputeGraphBuilder)</li> <li>is_direct_launching (muda::ComputeGraphBuilder)</li> <li>is_phase_none (muda::ComputeGraphBuilder)</li> <li>is_phase_serial_launching (muda::ComputeGraphBuilder)</li> <li>is_topo_building (muda::ComputeGraphBuilder)</li> <li>is_valid (muda::ComputeGraphNodeBase, muda::ComputeGraphVarBase, muda::IdWithType, muda::spatial_hash::CollisionPair)</li> <li>is_using (muda::ComputeGraphVarBase, muda::ComputeGraphVarManager)</li> <li>is_debug_sync_all (muda::Debug)</li> <li>is_sym (muda::DenseMatrixViewT)</li> <li>inc (muda::DenseVectorViewT)</li> <li>index (muda::DenseVectorViewerT)</li> <li>indices (muda::DeviceDoubletVector)</li> <li>If (muda::DevicePartition, muda::DeviceSelect)</li> <li>InclusiveScan (muda::DeviceScan)</li> <li>InclusiveScanByKey (muda::DeviceScan)</li> <li>InclusiveSum (muda::DeviceScan)</li> <li>InclusiveSumByKey (muda::DeviceScan)</li> <li>innermost_array_size (muda::FieldEntryLayoutInfo)</li> <li>instantiate (muda::Graph)</li> <li>IdWithType (muda::IdWithType)</li> <li>invoke (muda::Launch, muda::ParallelFor)</li> <li>init_stream (muda::LaunchCore)</li> <li>is_buffer_full (muda::Logger)</li> <li>is_meta_data_full (muda::Logger)</li> <li>impl (muda::MatrixFormatConverter)</li> <li>i (muda::ParallelForDetails)</li> <li>is_final_block (muda::ParallelForDetails)</li> <li>is_topo_built (muda::details::ComputeGraphAccessor)</li> <li>invert2x2 (muda::eigen::AnalyticalInverse)</li> <li>invert3x3 (muda::eigen::AnalyticalInverse)</li> <li>invert4x4 (muda::eigen::AnalyticalInverse)</li> <li>invalid_argument (muda::invalid_argument)</li> <li>IDs (muda::spatial_hash::CollisionPair)</li> <li>invalid (muda::spatial_hash::CollisionPair)</li> <li>is_home (muda::spatial_hash::SpatialPartitionCell)</li> <li>is_phantom (muda::spatial_hash::SpatialPartitionCell)</li> </ul>"},{"location":"muda/class_member_functions/#k","title":"k","text":"<ul> <li>kernel_name (muda::CubWrapper, muda::LaunchBase, muda::LaunchCore, muda::ViewerBase)</li> <li>Kernel (muda::Kernel)</li> <li>KernelLabel (muda::KernelLabel)</li> <li>KernelNodeParms (muda::KernelNodeParms)</li> <li>kernel_params (muda::KernelNodeParms)</li> <li>kernel_file (muda::ViewerBase)</li> <li>kernel_line (muda::ViewerBase)</li> </ul>"},{"location":"muda/class_member_functions/#l","title":"l","text":"<ul> <li>last (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>legacy_descr (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix)</li> <li>launch (muda::ComputeGraph, muda::GraphExec, muda::GraphLaunch, muda::GraphViewer)</li> <li>lda (muda::DenseMatrixViewT)</li> <li>layout (muda::FieldEntryBase, muda::FieldEntryCore, muda::FieldEntryLayoutInfo, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>layout_info (muda::FieldEntryBase, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::SubFieldInterface)</li> <li>Launch (muda::Launch)</li> <li>LaunchBase (muda::LaunchBase)</li> <li>LaunchCore (muda::LaunchCore)</li> <li>LinearSystemContext (muda::LinearSystemContext)</li> <li>label (muda::LinearSystemContext)</li> <li>LinearSystemHandles (muda::LinearSystemHandles)</li> <li>LogProxy (muda::LogProxy)</li> <li>Logger (muda::Logger)</li> <li>line (muda::cuda_error)</li> <li>LaunchCallable (muda::details::LaunchCallable)</li> <li>LaunchInfoCache (muda::details::LaunchInfoCache)</li> <li>loose_resize (muda::details::MatrixFormatConverterBase)</li> <li>logic_error (muda::logic_error)</li> </ul>"},{"location":"muda/class_member_functions/#m","title":"m","text":"<ul> <li>MUDA_VIEWER_COMMON_NAME (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewerT, muda::GraphViewer, muda::TripletMatrixViewerT, muda::lbvh::details::BVHViewerBase)</li> <li>map (muda::Dense1DT)</li> <li>MultiHistogramEven (muda::DeviceHistogram)</li> <li>MultiHistogramRange (muda::DeviceHistogram)</li> <li>Max (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>Min (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>matrix (muda::FieldBuilder::EntryProxy)</li> <li>matrix2x2 (muda::FieldBuilder::EntryProxy)</li> <li>matrix3x3 (muda::FieldBuilder::EntryProxy)</li> <li>matrix4x4 (muda::FieldBuilder::EntryProxy)</li> <li>map_dependencies (muda::Graph)</li> <li>mv (muda::LinearSystemContext)</li> <li>meta_data (muda::LoggerDataContainer)</li> <li>MatrixFormatConverter (muda::MatrixFormatConverter, muda::details::MatrixFormatConverter)</li> <li>Memory (muda::Memory)</li> <li>MatrixValueTZero (muda::details::MatrixFormatConverter)</li> <li>make_unique_blocks (muda::details::MatrixFormatConverter)</li> <li>make_unique_indices (muda::details::MatrixFormatConverter)</li> <li>make_unique_indices_and_blocks (muda::details::MatrixFormatConverter)</li> <li>make_unique_segments (muda::details::MatrixFormatConverter)</li> <li>merge_sort_indices_and_blocks (muda::details::MatrixFormatConverter)</li> <li>merge_sort_indices_and_segments (muda::details::MatrixFormatConverter)</li> <li>MatrixFormatConverterBase (muda::details::MatrixFormatConverterBase)</li> </ul>"},{"location":"muda/class_member_functions/#n","title":"n","text":"<ul> <li>non_zeros (muda::BSRMatrixViewT, muda::DeviceBCOOMatrix, muda::DeviceBCOOVector, muda::DeviceBSRMatrix)</li> <li>name (muda::ComputeGraph, muda::ComputeGraphClosure, muda::ComputeGraphNodeBase, muda::ComputeGraphVarBase, muda::FieldEntryBase, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::SubField, muda::ViewerBase)</li> <li>node_id (muda::ComputeGraphNodeBase)</li> <li>NonTrivialRuns (muda::DeviceRunLengthEncode)</li> <li>num_sub_fields (muda::Field)</li> <li>name_string_pointer (muda::FieldEntryCore)</li> <li>next (muda::LaunchBase)</li> <li>norm (muda::LinearSystemContext)</li> <li>next_buffer_idx (muda::LoggerViewer)</li> <li>next_meta_data_idx (muda::LoggerViewer)</li> <li>NodeParms (muda::NodeParms)</li> <li>num_entries (muda::SubField)</li> <li>num_elements (muda::SubFieldInterface)</li> <li>nodes (muda::lbvh::BVH)</li> <li>num_nodes (muda::lbvh::details::BVHViewerBase)</li> <li>num_objects (muda::lbvh::details::BVHViewerBase)</li> <li>not_implemented (muda::not_implemented)</li> </ul>"},{"location":"muda/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (TCB_SPAN_NAMESPACE_NAME::span, muda::ComputeGraph, muda::ComputeGraphVar, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DeviceBCOOMatrix, muda::DeviceBCOOVector, muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceTripletMatrix, muda::DeviceVar, muda::DeviceVector, muda::Event, muda::FieldEntryBase, muda::Flags, muda::Graph, muda::GraphExec, muda::HostDeviceConfig, muda::Kernel, muda::LinearSystemContext, muda::Logger, muda::Stream, muda::SubField, muda::SubFieldInterface, muda::ViewerBase, muda::details::HostDeviceStringCache, muda::details::TempBuffer, muda::lbvh::AABB, muda::lbvh::BVH, muda::lbvh::DefaultMortonCodeCalculator, muda::lbvh::query_nearest, muda::lbvh::query_overlap)</li> <li>operator[] (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::Field, muda::VarViewT, muda::details::HostDeviceStringCache)</li> <li>offset (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>origin_data (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>operator* (muda::BufferViewT, muda::DenseViewerT, muda::HostDeviceConfigView, muda::VarViewT)</li> <li>operator+ (muda::BufferViewT)</li> <li>operator ConstView (muda::COOVectorViewBase)</li> <li>operator&lt;&lt; (muda::ComputeGraph::AddNodeProxy, muda::LogProxy, muda::LoggerViewer)</li> <li>operator GraphViewer (muda::ComputeGraph)</li> <li>operator() (muda::ComputeGraphClosure, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DoubletVectorViewerT, muda::Kernel, muda::TripletMatrixViewerT, muda::eigen::AnalyticalInverse, muda::eigen::GaussEliminationInverse, muda::lbvh::DefaultMortonCodeCalculator, muda::lbvh::details::BVHViewerBase::DefaultQueryCallback, muda::lbvh::query_overlap, muda::spatial_hash::DefaultPredication, std::hash&lt; muda::ClosureId &gt;, std::hash&lt; muda::IdWithType&lt; T &gt; &gt;, std::hash&lt; muda::details::MatrixFormatConverterType &gt;)</li> <li>operator ROViewer (muda::ComputeGraphVar)</li> <li>operator RWViewer (muda::ComputeGraphVar)</li> <li>operator ConstViewer (muda::Dense2DBase, muda::Dense3DBase, muda::lbvh::details::BVHViewerBase)</li> <li>origin_col (muda::DenseMatrixViewerT)</li> <li>origin_row (muda::DenseMatrixViewerT)</li> <li>origin_size (muda::DenseVectorViewerT)</li> <li>operator auto_const_t&lt; T &gt; &amp; (muda::DenseViewerT)</li> <li>operator-&gt; (muda::DenseViewerT, muda::HostDeviceConfigView)</li> <li>operator BSRMatrixView&lt; Ty, N &gt; (muda::DeviceBSRMatrix)</li> <li>operator CBSRMatrixView&lt; Ty, N &gt; (muda::DeviceBSRMatrix)</li> <li>operator BufferView&lt; T &gt; (muda::DeviceBuffer, muda::DeviceVector)</li> <li>operator CBufferView&lt; T &gt; (muda::DeviceBuffer, muda::DeviceVector)</li> <li>operator Buffer2DView&lt; T &gt; (muda::DeviceBuffer2D)</li> <li>operator CBuffer2DView&lt; T &gt; (muda::DeviceBuffer2D)</li> <li>operator Buffer3DView&lt; T &gt; (muda::DeviceBuffer3D)</li> <li>operator CBuffer3DView&lt; T &gt; (muda::DeviceBuffer3D)</li> <li>operator CDenseMatrixView&lt; Ty &gt; (muda::DeviceDenseMatrix)</li> <li>operator DenseMatrixView&lt; Ty &gt; (muda::DeviceDenseMatrix)</li> <li>operator CDenseVectorView&lt; T &gt; (muda::DeviceDenseVector)</li> <li>operator DenseVectorView&lt; T &gt; (muda::DeviceDenseVector)</li> <li>operator CTripletMatrixView&lt; T, N &gt; (muda::DeviceTripletMatrix)</li> <li>operator TripletMatrixView&lt; T, N &gt; (muda::DeviceTripletMatrix)</li> <li>operator CVarView&lt; T &gt; (muda::DeviceVar)</li> <li>operator T (muda::DeviceVar)</li> <li>operator VarView&lt; T &gt; (muda::DeviceVar)</li> <li>operator cudaEvent_t (muda::Event)</li> <li>operator bool (muda::Flags, muda::LoggerViewer)</li> <li>operator mask_type (muda::Flags)</li> <li>operator! (muda::Flags)</li> <li>operator!= (muda::Flags)</li> <li>operator&amp; (muda::Flags)</li> <li>operator&amp;= (muda::Flags)</li> <li>operator&lt; (muda::Flags)</li> <li>operator&lt;= (muda::Flags)</li> <li>operator== (muda::Flags, muda::details::MatrixFormatConverterType)</li> <li>operator&gt; (muda::Flags)</li> <li>operator&gt;= (muda::Flags)</li> <li>operator^ (muda::Flags)</li> <li>operator^= (muda::Flags)</li> <li>operator| (muda::Flags)</li> <li>operator|= (muda::Flags)</li> <li>Offset2D (muda::Offset2D)</li> <li>offset_in_height (muda::Offset2D, muda::Offset3D)</li> <li>offset_in_width (muda::Offset2D, muda::Offset3D)</li> <li>Offset3D (muda::Offset3D)</li> <li>offset_in_depth (muda::Offset3D)</li> <li>operator int (muda::ParallelForDetails)</li> <li>operator cudaStream_t (muda::Stream::FireAndForget, muda::Stream::GraphFireAndForget, muda::Stream::GraphTailLaunch, muda::Stream::TailLaunch, muda::Stream)</li> <li>objects (muda::lbvh::BVH)</li> <li>object (muda::lbvh::details::BVHViewerBase)</li> <li>out_of_range (muda::out_of_range)</li> </ul>"},{"location":"muda/class_member_functions/#p","title":"p","text":"<ul> <li>pitch_bytes (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::Dense2DBase, muda::Dense3DBase, muda::DeviceBuffer2D, muda::DeviceBuffer3D)</li> <li>pitch_bytes_area (muda::Buffer3DViewT, muda::Dense3DBase, muda::DeviceBuffer3D)</li> <li>prepare_buffer (muda::CubWrapper)</li> <li>Proxy (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>parse (muda::KernelNodeParms)</li> <li>pop_kernel_label (muda::LaunchBase, muda::LaunchCore)</li> <li>pop_range (muda::LaunchBase, muda::LaunchCore)</li> <li>push_range (muda::LaunchBase, muda::LaunchCore)</li> <li>plus (muda::LinearSystemContext)</li> <li>PROXY_OPERATOR (muda::LogProxy)</li> <li>push_data (muda::LogProxy, muda::LoggerViewer)</li> <li>push_fmt_arg (muda::LogProxy)</li> <li>push_string (muda::LogProxy, muda::LoggerViewer)</li> <li>put (muda::Logger)</li> <li>proxy (muda::LoggerViewer)</li> <li>ParallelFor (muda::ParallelFor)</li> <li>ParallelForDetails (muda::ParallelForDetails)</li> <li>parallel_for_type (muda::ParallelForDetails)</li> <li>Profile (muda::Profile)</li> <li>ParallelForCallable (muda::details::ParallelForCallable)</li> <li>pass_type (muda::spatial_hash::SpatialPartitionCell)</li> </ul>"},{"location":"muda/class_member_functions/#q","title":"q","text":"<ul> <li>query (muda::ComputeGraph, muda::ComputeGraphVarBase, muda::Event, muda::lbvh::details::BVHViewerBase)</li> <li>query_nearest (muda::lbvh::query_nearest)</li> <li>query_overlap (muda::lbvh::query_overlap)</li> </ul>"},{"location":"muda/class_member_functions/#r","title":"r","text":"<ul> <li>rbegin (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>rend (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>row_offsets (muda::BSRMatrixViewT, muda::DeviceBSRMatrix)</li> <li>rows (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceTripletMatrix)</li> <li>reserve (muda::BufferLaunch, muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseVector, muda::NDReshaper, muda::details::TempBuffer)</li> <li>resize (muda::BufferLaunch, muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseVector, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::NDReshaper, muda::SubField, muda::SubFieldInterface, muda::details::TempBuffer)</li> <li>row_indices (muda::COOMatrixViewT, muda::DeviceTripletMatrix)</li> <li>remove_related_closure_infos (muda::ComputeGraphVarBase)</li> <li>row (muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DeviceDenseMatrix)</li> <li>row_offset (muda::DenseMatrixViewerT)</li> <li>reserve_offsets (muda::DeviceBSRMatrix)</li> <li>reshape (muda::DeviceBSRMatrix, muda::DeviceDenseMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix)</li> <li>reserve_doublets (muda::DeviceDoubletVector)</li> <li>resize_doublets (muda::DeviceDoubletVector)</li> <li>Reduce (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>ReduceByKey (muda::DeviceReduce)</li> <li>reserve_triplets (muda::DeviceTripletMatrix)</li> <li>resize_triplets (muda::DeviceTripletMatrix)</li> <li>raw_ptr (muda::DeviceVector)</li> <li>read (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>record (muda::LaunchBase, muda::LaunchCore)</li> <li>reorder (muda::LinearSystemContext)</li> <li>reserve_ratio (muda::LinearSystemContext, muda::LinearSystemHandles)</li> <li>reoder_method (muda::LinearSystemSolveReorder)</li> <li>reorder_method (muda::LinearSystemSolveReorder)</li> <li>reorder_method_int (muda::LinearSystemSolveReorder)</li> <li>retrieve (muda::Logger)</li> <li>retrieve_meta (muda::Logger)</li> <li>round_up_blocks (muda::ParallelFor)</li> <li>RangeName (muda::RangeName)</li> <li>require_total_buffer_byte_size (muda::SubFieldInterface)</li> <li>resize_data_buffer (muda::SubFieldInterface)</li> <li>round_up (muda::SubFieldInterface)</li> <li>radix_sort_indices_and_blocks (muda::details::MatrixFormatConverter)</li> <li>runtime_error (muda::runtime_error)</li> <li>radius (muda::spatial_hash::AABB)</li> </ul>"},{"location":"muda/class_member_functions/#s","title":"s","text":"<ul> <li>span_storage (TCB_SPAN_NAMESPACE_NAME::detail::span_storage)</li> <li>size (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DeviceBuffer, muda::DeviceDenseVector, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::SubField, muda::details::TempBuffer)</li> <li>size_bytes (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>span (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>subspan (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>subview (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::DenseVectorViewT, muda::DoubletVectorViewT, muda::TripletMatrixViewT)</li> <li>shrink_to_fit (muda::BufferLaunch, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::NDReshaper)</li> <li>serial_launch (muda::ComputeGraph)</li> <li>set_current_graph_as_this (muda::ComputeGraph)</li> <li>shared_capture_stream (muda::ComputeGraph)</li> <li>set_node (muda::ComputeGraphCaptureNode, muda::ComputeGraphNode)</li> <li>set_deps_range (muda::ComputeGraphClosure)</li> <li>set_handle (muda::ComputeGraphNodeBase)</li> <li>sync (muda::ComputeGraphVarBase, muda::ComputeGraphVarManager, muda::LinearSystemContext)</li> <li>sync_on (muda::ComputeGraphVarManager)</li> <li>set_sync_callback (muda::Debug)</li> <li>segment (muda::DenseVectorViewerT)</li> <li>sym (muda::DeviceDenseMatrix)</li> <li>SortKeys (muda::DeviceMergeSort, muda::DeviceRadixSort, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedSort)</li> <li>SortKeysCopy (muda::DeviceMergeSort)</li> <li>SortPairs (muda::DeviceMergeSort, muda::DeviceRadixSort, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedSort)</li> <li>SortPairsCopy (muda::DeviceMergeSort)</li> <li>StableSortKeys (muda::DeviceMergeSort, muda::DeviceSegmentedSort)</li> <li>StableSortPairs (muda::DeviceMergeSort, muda::DeviceSegmentedSort)</li> <li>SortKeysDescending (muda::DeviceRadixSort, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedSort)</li> <li>SortPairsDescending (muda::DeviceRadixSort, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedSort)</li> <li>Sum (muda::DeviceReduce, muda::DeviceSegmentedReduce)</li> <li>StableSortKeysDescending (muda::DeviceSegmentedSort)</li> <li>StableSortPairsDescending (muda::DeviceSegmentedSort)</li> <li>subvector (muda::DoubletVectorViewT)</li> <li>subvector_offset (muda::DoubletVectorViewT)</li> <li>scalar (muda::FieldBuilder::EntryProxy)</li> <li>shape (muda::FieldEntryBase, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>struct_stride (muda::FieldEntryBase, muda::FieldEntryCore, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>soa_elem_addr (muda::FieldEntryCore)</li> <li>set_event_record_node_parms (muda::GraphExec)</li> <li>set_event_wait_node_parms (muda::GraphExec)</li> <li>set_kernel_node_parms (muda::GraphExec)</li> <li>set_memcpy_node_parms (muda::GraphExec)</li> <li>set_memset_node_parms (muda::GraphExec)</li> <li>shared_mem_bytes (muda::KernelNodeParms)</li> <li>stream (muda::LaunchCore, muda::LinearSystemContext, muda::LinearSystemHandles)</li> <li>set_pointer_mode_device (muda::LinearSystemContext, muda::LinearSystemHandles)</li> <li>set_pointer_mode_host (muda::LinearSystemContext, muda::LinearSystemHandles)</li> <li>shrink_temp_buffers (muda::LinearSystemContext)</li> <li>solve (muda::LinearSystemContext)</li> <li>spmv (muda::LinearSystemContext)</li> <li>sysv (muda::LinearSystemContext)</li> <li>solve_sparse_error_threshold (muda::LinearSystemSolveTolerance)</li> <li>set (muda::Memory)</li> <li>Stream (muda::Stream)</li> <li>SoA (muda::SubField)</li> <li>SubField (muda::SubField)</li> <li>SubFieldInterface (muda::SubFieldInterface)</li> <li>submatrix (muda::TripletMatrixViewT)</li> <li>submatrix_offset (muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>set_capture_node (muda::details::ComputeGraphAccessor)</li> <li>set_event_record_node (muda::details::ComputeGraphAccessor)</li> <li>set_event_wait_node (muda::details::ComputeGraphAccessor)</li> <li>set_kernel_node (muda::details::ComputeGraphAccessor)</li> <li>set_memcpy_node (muda::details::ComputeGraphAccessor)</li> <li>set_memset_node (muda::details::ComputeGraphAccessor)</li> <li>set_var_usage (muda::details::ComputeGraphAccessor)</li> <li>set_unique_values_to_dense_vector (muda::details::MatrixFormatConverter)</li> <li>sort_indices_and_values (muda::details::MatrixFormatConverter)</li> <li>SparseSpatialHash (muda::spatial_hash::SparseSpatialHash)</li> <li>SpatialHashTableInfo (muda::spatial_hash::SpatialHashTableInfo)</li> <li>SpatialPartitionCell (muda::spatial_hash::SpatialPartitionCell)</li> <li>set_as_home (muda::spatial_hash::SpatialPartitionCell)</li> <li>set_as_phantom (muda::spatial_hash::SpatialPartitionCell)</li> <li>set_overlap (muda::spatial_hash::SpatialPartitionCell)</li> <li>SparseSpatialHashImpl (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>setup_hash_table (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>simple_count_collision_pairs (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>simple_fill_collision_pair_list (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>simple_setup_collision_pairs (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_functions/#t","title":"t","text":"<ul> <li>T (muda::BSRMatrixViewT, muda::DenseMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDenseMatrix)</li> <li>total_size (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DeviceBuffer2D, muda::DeviceBuffer3D)</li> <li>total_triplet_count (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>tripet_index_offset (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>triplet_count (muda::COOMatrixViewT, muda::DeviceTripletMatrix, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>total_doublet_count (muda::COOVectorViewBase, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>topo_build (muda::ComputeGraph)</li> <li>type (muda::ComputeGraphClosure, muda::ComputeGraphNodeBase)</li> <li>total_bytes (muda::Dense3DBase)</li> <li>triplet_capacity (muda::DeviceTripletMatrix)</li> <li>total_extent (muda::DoubletVectorViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>total_count (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>tail_launch (muda::GraphViewer)</li> <li>temp_buffer (muda::LinearSystemContext)</li> <li>temp_buffers (muda::LinearSystemContext)</li> <li>temp_host_buffer (muda::LinearSystemContext)</li> <li>temp_host_buffers (muda::LinearSystemContext)</li> <li>tolerance (muda::LinearSystemContext)</li> <li>transfer (muda::Memory)</li> <li>total_batch (muda::ParallelForDetails)</li> <li>total_num (muda::ParallelForDetails)</li> <li>TailLaunch (muda::Stream::TailLaunch)</li> <li>TripletMatrixViewT (muda::TripletMatrixViewT)</li> <li>total_block_cols (muda::TripletMatrixViewT)</li> <li>total_block_rows (muda::TripletMatrixViewT)</li> <li>TripletMatrixViewerT (muda::TripletMatrixViewerT)</li> <li>total_cols (muda::TripletMatrixViewerT)</li> <li>total_rows (muda::TripletMatrixViewerT)</li> <li>TempBuffer (muda::details::TempBuffer)</li> </ul>"},{"location":"muda/class_member_functions/#u","title":"u","text":"<ul> <li>update (muda::ComputeGraph, muda::ComputeGraphVar, muda::ComputeGraphVarBase)</li> <li>update_sub_graph (muda::ComputeGraphCaptureNode)</li> <li>unique_graphs (muda::ComputeGraphVarManager)</li> <li>Unique (muda::DeviceSelect)</li> <li>upload (muda::GraphExec, muda::Logger, muda::Memory)</li> <li>userdata (muda::HostNodeParms)</li> <li>update_capture_node (muda::details::ComputeGraphAccessor)</li> <li>update_event_record_node (muda::details::ComputeGraphAccessor)</li> <li>update_event_wait_node (muda::details::ComputeGraphAccessor)</li> <li>update_kernel_node (muda::details::ComputeGraphAccessor)</li> <li>update_memcpy_node (muda::details::ComputeGraphAccessor)</li> <li>update_memset_node (muda::details::ComputeGraphAccessor)</li> </ul>"},{"location":"muda/class_member_functions/#v","title":"v","text":"<ul> <li>values (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix)</li> <li>viewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::ComputeGraph, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::DeviceVar, muda::DeviceVector, muda::DoubletVectorViewT, muda::Event, muda::FieldEntry, muda::FieldEntryViewCore, muda::GraphExec, muda::Logger, muda::TripletMatrixViewT, muda::VarViewT, muda::lbvh::BVH)</li> <li>vector_size (muda::COOVectorViewBase)</li> <li>var_usages (muda::ComputeGraphClosure)</li> <li>var_id (muda::ComputeGraphVarBase)</li> <li>var_span (muda::ComputeGraphVarManager)</li> <li>volume (muda::Dense3DBase)</li> <li>VectorBlock&lt; ThisMapVector &gt; (muda::DenseVectorViewerT)</li> <li>view (muda::DeviceBSRMatrix, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::DeviceVar, muda::DeviceVector, muda::FieldEntry, muda::HostDeviceConfig, muda::Stream)</li> <li>valid (muda::Extent2D, muda::Extent3D)</li> <li>vector (muda::FieldBuilder::EntryProxy)</li> <li>vector2 (muda::FieldBuilder::EntryProxy)</li> <li>vector3 (muda::FieldBuilder::EntryProxy)</li> <li>vector4 (muda::FieldBuilder::EntryProxy)</li> <li>value (muda::IdWithType)</li> <li>VarViewT (muda::VarViewT)</li> <li>ViewerBase (muda::ViewerBase)</li> <li>view_name (muda::details::LaunchInfoCache)</li> <li>VectorValueTZero (muda::details::MatrixFormatConverter)</li> </ul>"},{"location":"muda/class_member_functions/#w","title":"w","text":"<ul> <li>write (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>width (muda::Extent2D, muda::Extent3D)</li> <li>wait (muda::LaunchBase, muda::LaunchCore, muda::Stream)</li> <li>when (muda::LaunchBase, muda::LaunchCore)</li> <li>wait_device (muda::LaunchCore)</li> <li>wait_event (muda::LaunchCore)</li> <li>wait_stream (muda::LaunchCore)</li> <li>workspace (muda::Stream)</li> <li>what (muda::exception)</li> </ul>"},{"location":"muda/class_member_functions/#z","title":"z","text":"<ul> <li>Zero (muda::Extent2D, muda::Extent3D, muda::Offset2D, muda::Offset3D)</li> </ul>"},{"location":"muda/class_member_functions/#_1","title":"~","text":"<ul> <li>~span (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>~GraphPhaseGuard (muda::ComputeGraph::GraphPhaseGuard)</li> <li>~ComputeGraph (muda::ComputeGraph)</li> <li>~ComputeGraphBuilder (muda::ComputeGraphBuilder)</li> <li>~ComputeGraphCaptureNode (muda::ComputeGraphCaptureNode)</li> <li>~ComputeGraphClosure (muda::ComputeGraphClosure)</li> <li>~ComputeGraphNode (muda::ComputeGraphNode)</li> <li>~ComputeGraphNodeBase (muda::ComputeGraphNodeBase)</li> <li>~ComputeGraphVar (muda::ComputeGraphVar)</li> <li>~ComputeGraphVarBase (muda::ComputeGraphVarBase)</li> <li>~ComputeGraphVarManager (muda::ComputeGraphVarManager)</li> <li>~DeviceBCOOMatrix (muda::DeviceBCOOMatrix)</li> <li>~DeviceBCOOVector (muda::DeviceBCOOVector)</li> <li>~DeviceBSRMatrix (muda::DeviceBSRMatrix)</li> <li>~DeviceBuffer (muda::DeviceBuffer)</li> <li>~DeviceBuffer2D (muda::DeviceBuffer2D)</li> <li>~DeviceBuffer3D (muda::DeviceBuffer3D)</li> <li>~DeviceDenseVector (muda::DeviceDenseVector)</li> <li>~DeviceDoubletVector (muda::DeviceDoubletVector)</li> <li>~DeviceTripletMatrix (muda::DeviceTripletMatrix)</li> <li>~DeviceVar (muda::DeviceVar)</li> <li>~Proxy (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>~Event (muda::Event)</li> <li>~Field (muda::Field)</li> <li>~FieldBuilder (muda::FieldBuilder)</li> <li>~FieldEntryBase (muda::FieldEntryBase)</li> <li>~Graph (muda::Graph)</li> <li>~GraphExec (muda::GraphExec)</li> <li>~GraphLaunch (muda::GraphLaunch)</li> <li>~KernelLabel (muda::KernelLabel)</li> <li>~LaunchBase (muda::LaunchBase)</li> <li>~LaunchCore (muda::LaunchCore)</li> <li>~LinearSystemContext (muda::LinearSystemContext)</li> <li>~LinearSystemHandles (muda::LinearSystemHandles)</li> <li>~Logger (muda::Logger)</li> <li>~MatrixFormatConverter (muda::MatrixFormatConverter, muda::details::MatrixFormatConverter)</li> <li>~NodeParms (muda::NodeParms)</li> <li>~Profile (muda::Profile)</li> <li>~RangeName (muda::RangeName)</li> <li>~Stream (muda::Stream)</li> <li>~SubField (muda::SubField)</li> <li>~SubFieldInterface (muda::SubFieldInterface)</li> <li>~HostDeviceStringCache (muda::details::HostDeviceStringCache)</li> <li>~MatrixFormatConverterBase (muda::details::MatrixFormatConverterBase)</li> <li>~TempBuffer (muda::details::TempBuffer)</li> <li>~BVH (muda::lbvh::BVH)</li> <li>~DefaultMortonCodeCalculator (muda::lbvh::DefaultMortonCodeCalculator)</li> <li>~query_nearest (muda::lbvh::query_nearest)</li> <li>~query_overlap (muda::lbvh::query_overlap)</li> </ul>"},{"location":"muda/class_member_functions/#_","title":"_","text":"<ul> <li>_update (muda::ComputeGraph)</li> <li>_building_eval (muda::ComputeGraphVarBase)</li> <li>_ceval (muda::ComputeGraphVarBase)</li> <li>_eval (muda::ComputeGraphVarBase)</li> <li>_is_debug_sync_all (muda::Debug)</li> <li>_mutex (muda::Debug)</li> <li>_sync_callback (muda::Debug)</li> <li>_retrieve (muda::Logger)</li> </ul>"},{"location":"muda/class_member_variables/","title":"Class Member Variables","text":""},{"location":"muda/class_member_variables/#a","title":"a","text":"<ul> <li>all_nodes_closure_style (muda::ComputeGraphGraphvizOptions)</li> <li>arc_style (muda::ComputeGraphGraphvizOptions)</li> <li>as_subgraph (muda::ComputeGraphGraphvizOptions)</li> <li>allCoords (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>allRadius (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#b","title":"b","text":"<ul> <li>begin (muda::CMatrixMapInfo, muda::MatrixMapInfo)</li> <li>buffer_byte_size_base (muda::LinearSystemContextCreateInfo)</li> <li>buffer_offset (muda::details::LoggerOffset)</li> <li>blocks_sorted (muda::details::MatrixFormatConverter)</li> <li>buffer_index (muda::details::HostDeviceStringCache::StringLocation)</li> </ul>"},{"location":"muda/class_member_variables/#c","title":"c","text":"<ul> <li>cluster_style (muda::ComputeGraphGraphvizOptions)</li> <li>cluster_var_style (muda::ComputeGraphGraphvizOptions)</li> <li>current (muda::MatrixFormatConverter)</li> <li>col_index (muda::TripletMatrixViewerT::CTriplet)</li> <li>callable (muda::details::LaunchCallable, muda::details::ParallelForCallable)</li> <li>col_tmp (muda::details::MatrixFormatConverter)</li> <li>count (muda::details::MatrixFormatConverter, muda::details::ParallelForCallable)</li> <li>cell_size (muda::spatial_hash::SpatialHashTableInfo)</li> <li>coord_min (muda::spatial_hash::SpatialHashTableInfo)</li> <li>cid (muda::spatial_hash::SpatialPartitionCell)</li> <li>ctlbit (muda::spatial_hash::SpatialPartitionCell)</li> <li>cellArrayKey (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellArrayKeySorted (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellArrayValue (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellArrayValueSorted (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellToCollisionPairUpperBound (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>cellToCollisionPairUpperBoundPrefixSum (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>collisionPairBuffer (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>collisionPairCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>collisionPairPrefixSum (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>closure_ids (muda::ComputeGraphVarBase::RelatedClosureInfo)</li> </ul>"},{"location":"muda/class_member_variables/#d","title":"d","text":"<ul> <li>DEFAULT_BUFFER_SIZE (muda::Logger)</li> <li>DEFAULT_META_SIZE (muda::Logger)</li> <li>data (muda::LoggerMetaData)</li> <li>dim (muda::details::LaunchCallable)</li> <li>data_type (muda::details::MatrixFormatConverterType)</li> <li>device_string (muda::details::StringPointer)</li> </ul>"},{"location":"muda/class_member_variables/#e","title":"e","text":"<ul> <li>extent (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>event_style (muda::ComputeGraphGraphvizOptions)</li> <li>elem_byte_size (muda::FieldEntryBaseData, muda::details::SoACopyMap)</li> <li>elem_count (muda::FieldEntryBaseData)</li> <li>elem_count_based_stride (muda::FieldEntryBaseData)</li> <li>exceeded (muda::details::LoggerMetaData)</li> <li>exceed_buffer (muda::details::LoggerOffset)</li> <li>exceed_meta_data (muda::details::LoggerOffset)</li> <li>empty_level (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#f","title":"f","text":"<ul> <li>from (muda::ComputeGraphDependency)</li> <li>FieldEntryBaseData (muda::FieldEntryBaseData)</li> <li>fmt_arg (muda::LoggerMetaData, muda::details::LoggerMetaData)</li> </ul>"},{"location":"muda/class_member_variables/#g","title":"g","text":"<ul> <li>graph_font (muda::ComputeGraphGraphvizOptions)</li> <li>graph_id (muda::ComputeGraphGraphvizOptions)</li> <li>graph_viewer_style (muda::ComputeGraphGraphvizOptions)</li> <li>graph (muda::ComputeGraphVarBase::RelatedClosureInfo)</li> </ul>"},{"location":"muda/class_member_variables/#h","title":"h","text":"<ul> <li>hostData (muda::HostNodeParms)</li> <li>host_string (muda::details::StringPointer)</li> <li>home (muda::spatial_hash::SpatialPartitionCell)</li> <li>h_spatialHashConfig (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#i","title":"i","text":"<ul> <li>inner_stride (muda::CMatrixMapInfo, muda::MatrixMapInfo)</li> <li>IsBlockMatrix (muda::DeviceBSRMatrix, muda::DeviceTripletMatrix)</li> <li>IsSegmentVector (muda::DeviceDoubletVector)</li> <li>index (muda::DoubletVectorViewerT::CDoublet)</li> <li>invalid_id (muda::IdWithType)</li> <li>id (muda::LoggerMetaData, muda::details::LocalVarInfo, muda::details::LoggerMetaData, muda::spatial_hash::CollisionPair)</li> <li>IsConst (muda::ViewBase, muda::ViewerBase)</li> <li>IsNonConst (muda::ViewBase, muda::ViewerBase)</li> <li>ij_hash (muda::details::MatrixFormatConverter)</li> <li>ij_hash_input (muda::details::MatrixFormatConverter)</li> <li>ij_pairs (muda::details::MatrixFormatConverter)</li> </ul>"},{"location":"muda/class_member_variables/#k","title":"k","text":"<ul> <li>kernelParmData (muda::KernelNodeParms)</li> </ul>"},{"location":"muda/class_member_variables/#l","title":"l","text":"<ul> <li>layout_info (muda::FieldEntryBaseData)</li> <li>log_id (muda::details::LoggerOffset)</li> <li>length (muda::details::StringPointer)</li> <li>lower (muda::lbvh::AABB)</li> <li>left_idx (muda::lbvh::details::Node)</li> <li>level (muda::spatial_hash::BoundingSphere, muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#m","title":"m","text":"<ul> <li>m_col (muda::BSRMatrixViewT, muda::DenseMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDenseMatrix)</li> <li>m_col_indices (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceTripletMatrix, muda::TripletMatrixViewerT)</li> <li>m_descr (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseVectorViewT, muda::DeviceBSRMatrix, muda::DeviceDenseVector)</li> <li>m_legacy_descr (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DeviceBSRMatrix)</li> <li>m_non_zeros (muda::BSRMatrixViewT)</li> <li>m_row (muda::BSRMatrixViewT, muda::DenseMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDenseMatrix)</li> <li>m_row_offsets (muda::BSRMatrixViewT, muda::DeviceBSRMatrix)</li> <li>m_trans (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::DenseMatrixViewT)</li> <li>m_values (muda::BSRMatrixViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DeviceBSRMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::TripletMatrixViewerT)</li> <li>m_data (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceDenseVector, muda::DeviceVar, muda::VarViewT, muda::details::TempBuffer)</li> <li>m_extent (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::Extent2D, muda::Extent3D)</li> <li>m_offset (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::Logger, muda::LoggerViewer, muda::Offset2D, muda::Offset3D)</li> <li>m_origin_height (muda::Buffer2DViewT, muda::Buffer3DViewT)</li> <li>m_origin_width (muda::Buffer2DViewT, muda::Buffer3DViewT)</li> <li>m_pitch_bytes (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::Dense2DBase, muda::Dense3DBase, muda::DeviceBuffer2D, muda::DeviceBuffer3D)</li> <li>m_pitch_bytes_area (muda::Buffer3DViewT, muda::Dense3DBase, muda::DeviceBuffer3D)</li> <li>m_block_dim (muda::BufferLaunch, muda::Kernel, muda::Launch, muda::ParallelFor)</li> <li>m_grid_dim (muda::BufferLaunch, muda::Kernel, muda::Launch, muda::ParallelFor)</li> <li>m_size (muda::BufferViewT, muda::COOVectorViewBase, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DeviceBuffer, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::details::TempBuffer)</li> <li>m_cols (muda::COOMatrixViewT, muda::DeviceTripletMatrix)</li> <li>m_row_indices (muda::COOMatrixViewT, muda::DeviceTripletMatrix, muda::TripletMatrixViewerT)</li> <li>m_rows (muda::COOMatrixViewT, muda::DeviceTripletMatrix)</li> <li>m_submatrix_extent (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_submatrix_offset (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_total_triplet_count (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_triplet_count (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_triplet_index_offset (muda::COOMatrixViewT, muda::TripletMatrixViewT, muda::TripletMatrixViewerT)</li> <li>m_doublet_count (muda::COOVectorViewBase, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_doublet_index_offset (muda::COOVectorViewBase, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_indices (muda::COOVectorViewBase, muda::DeviceDoubletVector, muda::lbvh::BVH)</li> <li>m_total_doublet_count (muda::COOVectorViewBase, muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_access_graph_index (muda::ComputeGraph, muda::ComputeGraphClosure)</li> <li>m_allow_access_graph (muda::ComputeGraph)</li> <li>m_allow_node_adding (muda::ComputeGraph)</li> <li>m_closure_need_update (muda::ComputeGraph)</li> <li>m_closures (muda::ComputeGraph)</li> <li>m_current_closure_id (muda::ComputeGraph)</li> <li>m_current_graph_phase (muda::ComputeGraph)</li> <li>m_current_node_id (muda::ComputeGraph)</li> <li>m_current_single_stream (muda::ComputeGraph)</li> <li>m_deps (muda::ComputeGraph)</li> <li>m_event (muda::ComputeGraph)</li> <li>m_event_result (muda::ComputeGraph)</li> <li>m_flags (muda::ComputeGraph, muda::GraphExec, muda::GraphViewer)</li> <li>m_global_to_local_var_id (muda::ComputeGraph)</li> <li>m_graph (muda::ComputeGraph, muda::ComputeGraphClosure, muda::GraphViewer)</li> <li>m_graph_exec (muda::ComputeGraph)</li> <li>m_graph_nodes (muda::ComputeGraph, muda::ComputeGraphClosure)</li> <li>m_is_capturing (muda::ComputeGraph)</li> <li>m_is_in_capture_func (muda::ComputeGraph)</li> <li>m_is_topo_built (muda::ComputeGraph)</li> <li>m_name (muda::ComputeGraph, muda::ComputeGraphClosure, muda::ComputeGraphNodeBase, muda::ComputeGraphVarBase, muda::FieldBuilder::EntryProxy, muda::FieldEntryBase, muda::FieldEntryCore, muda::SubField)</li> <li>m_need_update (muda::ComputeGraph)</li> <li>m_nodes (muda::ComputeGraph, muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>m_related_vars (muda::ComputeGraph)</li> <li>m_sub_graphs (muda::ComputeGraph)</li> <li>m_var_manager (muda::ComputeGraph, muda::ComputeGraphVarBase)</li> <li>m_cg (muda::ComputeGraph::AddNodeProxy, muda::ComputeGraph::GraphPhaseGuard, muda::details::ComputeGraphAccessor)</li> <li>m_node_name (muda::ComputeGraph::AddNodeProxy)</li> <li>m_current_graph (muda::ComputeGraphBuilder)</li> <li>m_sub_graph (muda::ComputeGraphCaptureNode)</li> <li>m_closure (muda::ComputeGraphClosure)</li> <li>m_clousure_id (muda::ComputeGraphClosure)</li> <li>m_deps_begin (muda::ComputeGraphClosure)</li> <li>m_deps_count (muda::ComputeGraphClosure)</li> <li>m_type (muda::ComputeGraphClosure, muda::ComputeGraphNodeBase, muda::ParallelForDetails)</li> <li>m_var_usages (muda::ComputeGraphClosure)</li> <li>m_node (muda::ComputeGraphNode)</li> <li>m_access_index (muda::ComputeGraphNodeBase)</li> <li>m_cuda_node (muda::ComputeGraphNodeBase)</li> <li>m_node_id (muda::ComputeGraphNodeBase)</li> <li>m_value (muda::ComputeGraphVar, muda::IdWithType)</li> <li>m_closure_ids (muda::ComputeGraphVarBase)</li> <li>m_is_valid (muda::ComputeGraphVarBase)</li> <li>m_related_closure_infos (muda::ComputeGraphVarBase)</li> <li>m_var_id (muda::ComputeGraphVarBase)</li> <li>m_graphs (muda::ComputeGraphVarManager)</li> <li>m_vars (muda::ComputeGraphVarManager)</li> <li>m_vars_map (muda::ComputeGraphVarManager)</li> <li>m_muda_stream (muda::CubWrapper)</li> <li>m_dim (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase)</li> <li>m_sym (muda::DenseMatrixViewT, muda::DeviceDenseMatrix)</li> <li>m_view (muda::DenseMatrixViewT, muda::DenseMatrixViewerT)</li> <li>m_col_offset (muda::DenseMatrixViewerT)</li> <li>m_col_size (muda::DenseMatrixViewerT)</li> <li>m_row_offset (muda::DenseMatrixViewerT)</li> <li>m_row_size (muda::DenseMatrixViewerT)</li> <li>m_inc (muda::DenseVectorViewT)</li> <li>m_origin_size (muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>m_capacity (muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::details::TempBuffer)</li> <li>m_count (muda::DeviceDoubletVector)</li> <li>m_segment_indices (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_segment_values (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_subvector_extent (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_subvector_offset (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_total_segment_count (muda::DoubletVectorViewT, muda::DoubletVectorViewerT)</li> <li>m_index (muda::DoubletVectorViewerT::Proxy, muda::TripletMatrixViewerT::Proxy)</li> <li>m_viewer (muda::DoubletVectorViewerT::Proxy, muda::LogProxy, muda::Logger, muda::TripletMatrixViewerT::Proxy)</li> <li>m_handle (muda::Event, muda::Graph, muda::GraphExec, muda::GraphNode, muda::Stream)</li> <li>m_name_to_index (muda::Field, muda::SubFieldInterface)</li> <li>m_string_cache (muda::Field)</li> <li>m_sub_fields (muda::Field)</li> <li>max_alignment (muda::FieldBuildOptions)</li> <li>min_alignment (muda::FieldBuildOptions)</li> <li>m_is_built (muda::FieldBuilder, muda::SubField)</li> <li>m_layout (muda::FieldBuilder, muda::FieldEntryLayoutInfo)</li> <li>m_options (muda::FieldBuilder)</li> <li>m_single_entry (muda::FieldBuilder)</li> <li>m_subfield (muda::FieldBuilder)</li> <li>m_builder (muda::FieldBuilder::EntryProxy)</li> <li>m_workpace (muda::FieldEntry)</li> <li>m_core (muda::FieldEntryBase, muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>m_field (muda::FieldEntryBase, muda::SubField, muda::SubFieldInterface)</li> <li>m_host_device_core (muda::FieldEntryBase)</li> <li>m_buffer (muda::FieldEntryCore, muda::Logger, muda::LoggerDataContainer, muda::LoggerViewer)</li> <li>m_info (muda::FieldEntryCore)</li> <li>m_innermost_array_size (muda::FieldEntryLayoutInfo)</li> <li>m_stride (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>m_mask (muda::Flags)</li> <li>m_cached (muda::Graph, muda::GraphExec)</li> <li>m_device_data (muda::HostDeviceConfig, muda::HostDeviceConfigView)</li> <li>m_host_data (muda::HostDeviceConfig, muda::HostDeviceConfigView)</li> <li>m_parms (muda::HostNodeParms, muda::KernelNodeParms)</li> <li>m_kernel (muda::Kernel)</li> <li>m_shared_memory_size (muda::Kernel)</li> <li>m_stream (muda::Kernel, muda::LaunchCore, muda::LinearSystemHandles, muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>m_args (muda::KernelNodeParms)</li> <li>m_shared_mem_size (muda::Launch, muda::ParallelFor)</li> <li>m_buffers (muda::LinearSystemContext)</li> <li>m_converter (muda::LinearSystemContext)</li> <li>m_create_info (muda::LinearSystemContext)</li> <li>m_current_label (muda::LinearSystemContext)</li> <li>m_handles (muda::LinearSystemContext, muda::MatrixFormatConverter, muda::details::MatrixFormatConverterBase)</li> <li>m_host_buffers (muda::LinearSystemContext)</li> <li>m_reorder (muda::LinearSystemContext)</li> <li>m_scalar_buffer (muda::LinearSystemContext)</li> <li>m_sync_callbacks (muda::LinearSystemContext)</li> <li>m_tolerance (muda::LinearSystemContext)</li> <li>m_cublas (muda::LinearSystemHandles)</li> <li>m_cusolver_dn (muda::LinearSystemHandles)</li> <li>m_cusolver_sp (muda::LinearSystemHandles)</li> <li>m_cusparse (muda::LinearSystemHandles)</li> <li>m_pointer_mode_device (muda::LinearSystemHandles)</li> <li>m_reserve_ratio (muda::LinearSystemHandles)</li> <li>m_reorder_method (muda::LinearSystemSolveReorder)</li> <li>m_solve_sparse_error_threshold (muda::LinearSystemSolveTolerance)</li> <li>m_log_id (muda::LogProxy)</li> <li>m_h_buffer (muda::Logger)</li> <li>m_h_meta_data (muda::Logger)</li> <li>m_h_offset (muda::Logger)</li> <li>m_log_viewer_ptr (muda::Logger)</li> <li>m_meta_data (muda::Logger, muda::LoggerDataContainer, muda::LoggerViewer)</li> <li>m_meta_data_id (muda::Logger, muda::LoggerViewer)</li> <li>m_sorted_meta_data (muda::Logger)</li> <li>m_sorted_meta_data_id (muda::Logger)</li> <li>m_buffer_size (muda::LoggerViewer, muda::details::HostDeviceStringCache)</li> <li>m_meta_data_id_size (muda::LoggerViewer)</li> <li>m_meta_data_size (muda::LoggerViewer)</li> <li>m_impls (muda::MatrixFormatConverter)</li> <li>m_active_num_in_block (muda::ParallelForDetails)</li> <li>m_batch_i (muda::ParallelForDetails)</li> <li>m_current_i (muda::ParallelForDetails)</li> <li>m_total_batch (muda::ParallelForDetails)</li> <li>m_total_num (muda::ParallelForDetails)</li> <li>m_workspace (muda::Stream)</li> <li>m_interface (muda::SubField)</li> <li>m_build_options (muda::SubFieldInterface)</li> <li>m_data_buffer (muda::SubFieldInterface)</li> <li>m_data_buffer_size (muda::SubFieldInterface)</li> <li>m_entries (muda::SubFieldInterface)</li> <li>m_host_device_new_cores (muda::SubFieldInterface)</li> <li>m_layout_info (muda::SubFieldInterface)</li> <li>m_new_cores (muda::SubFieldInterface)</li> <li>m_num_elements (muda::SubFieldInterface)</li> <li>m_struct_stride (muda::SubFieldInterface)</li> <li>m_block_col_indices (muda::TripletMatrixViewT)</li> <li>m_block_row_indices (muda::TripletMatrixViewT)</li> <li>m_block_values (muda::TripletMatrixViewT)</li> <li>m_total_block_cols (muda::TripletMatrixViewT)</li> <li>m_total_block_rows (muda::TripletMatrixViewT)</li> <li>m_total_cols (muda::TripletMatrixViewerT)</li> <li>m_total_rows (muda::TripletMatrixViewerT)</li> <li>m_dummy (muda::ViewerBase)</li> <li>m_error (muda::cuda_error)</li> <li>m_error_string (muda::cuda_error)</li> <li>m_file (muda::cuda_error)</li> <li>m_func (muda::cuda_error)</li> <li>m_line (muda::cuda_error)</li> <li>m_current_buffer_offset (muda::details::HostDeviceStringCache)</li> <li>m_device_string_buffers (muda::details::HostDeviceStringCache)</li> <li>m_empty_string_pointer (muda::details::HostDeviceStringCache)</li> <li>m_host_string_buffers (muda::details::HostDeviceStringCache)</li> <li>m_string_map (muda::details::HostDeviceStringCache)</li> <li>m_capture_name_string_cache (muda::details::LaunchInfoCache)</li> <li>m_current_capture_name (muda::details::LaunchInfoCache)</li> <li>m_current_kernel_file (muda::details::LaunchInfoCache)</li> <li>m_current_kernel_line (muda::details::LaunchInfoCache)</li> <li>m_current_kernel_name (muda::details::LaunchInfoCache)</li> <li>m_kernel_file_string_cache (muda::details::LaunchInfoCache)</li> <li>m_kernel_name_string_cache (muda::details::LaunchInfoCache)</li> <li>m_view_name_string_cache (muda::details::LaunchInfoCache)</li> <li>meta_data_offset (muda::details::LoggerOffset)</li> <li>m_N (muda::details::MatrixFormatConverterBase)</li> <li>m_data_type (muda::details::MatrixFormatConverterBase)</li> <li>m_what (muda::exception)</li> <li>m_aabbs (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>m_flag_container (muda::lbvh::BVH)</li> <li>m_h_aabbs (muda::lbvh::BVH)</li> <li>m_h_nodes (muda::lbvh::BVH)</li> <li>m_h_objects (muda::lbvh::BVH)</li> <li>m_host_dirty (muda::lbvh::BVH)</li> <li>m_morton (muda::lbvh::BVH)</li> <li>m_morton64 (muda::lbvh::BVH)</li> <li>m_objects (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>m_num_nodes (muda::lbvh::details::BVHViewerBase)</li> <li>m_num_objects (muda::lbvh::details::BVHViewerBase)</li> <li>max (muda::spatial_hash::AABB)</li> <li>min (muda::spatial_hash::AABB)</li> <li>m_impl (muda::spatial_hash::SparseSpatialHash)</li> <li>maxRadius (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>minCoord (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#n","title":"n","text":"<ul> <li>node_style (muda::ComputeGraphGraphvizOptions)</li> <li>need_pop (muda::Profile)</li> <li>N (muda::details::MatrixFormatConverterType)</li> </ul>"},{"location":"muda/class_member_variables/#o","title":"o","text":"<ul> <li>outer_stride (muda::CMatrixMapInfo, muda::MatrixMapInfo)</li> <li>offset_in_base_struct (muda::FieldEntryBaseData, muda::details::SoACopyMap)</li> <li>offset_in_struct (muda::FieldEntryBaseData)</li> <li>offset (muda::details::LoggerMetaData, muda::details::HostDeviceStringCache::StringLocation)</li> <li>offsets (muda::details::MatrixFormatConverter)</li> <li>object_idx (muda::lbvh::details::Node)</li> <li>o (muda::spatial_hash::BoundingSphere)</li> <li>oid (muda::spatial_hash::SpatialPartitionCell)</li> <li>overlap (muda::spatial_hash::SpatialPartitionCell)</li> <li>objCountInCell (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>objCountInCellPrefixSum (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#p","title":"p","text":"<ul> <li>ptr (TCB_SPAN_NAMESPACE_NAME::detail::span_storage)</li> <li>parent_idx (muda::lbvh::details::Node)</li> <li>pass (muda::spatial_hash::SpatialPartitionCell)</li> <li>pairCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>pairListOffset (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>potentialCollisionPairIdToCellIndex (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>potentialCollisionPairIdToCellIndexBuffer (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#r","title":"r","text":"<ul> <li>read_style (muda::ComputeGraphGraphvizOptions)</li> <li>read_write_style (muda::ComputeGraphGraphvizOptions)</li> <li>row_index (muda::TripletMatrixViewerT::CTriplet)</li> <li>row_tmp (muda::details::MatrixFormatConverter)</li> <li>right_idx (muda::lbvh::details::Node)</li> <li>r (muda::spatial_hash::BoundingSphere)</li> </ul>"},{"location":"muda/class_member_variables/#s","title":"s","text":"<ul> <li>size (TCB_SPAN_NAMESPACE_NAME::detail::span_storage, muda::details::LoggerMetaData, muda::details::HostDeviceStringCache::StringLocation)</li> <li>storage_ (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>show_all_graph_nodes_in_a_closure (muda::ComputeGraphGraphvizOptions)</li> <li>show_nodes (muda::ComputeGraphGraphvizOptions)</li> <li>show_vars (muda::ComputeGraphGraphvizOptions)</li> <li>shape (muda::FieldEntryBaseData)</li> <li>struct_stride (muda::FieldEntryBaseData)</li> <li>SPMV_ALG_DEFAULT (muda::LinearSystemAlgorithm)</li> <li>stream (muda::LinearSystemContextCreateInfo)</li> <li>sort_index (muda::details::MatrixFormatConverter)</li> <li>sort_index_input (muda::details::MatrixFormatConverter)</li> <li>sort_index_tmp (muda::details::MatrixFormatConverter)</li> <li>spatialHashConfig (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>spheres (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>sum (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#t","title":"t","text":"<ul> <li>to (muda::ComputeGraphDependency)</li> <li>type (muda::FieldEntryBaseData, muda::LoggerMetaData, muda::details::LoggerMetaData)</li> <li>temp_bcoo_matrix (muda::details::MatrixFormatConverter)</li> <li>temp_bcoo_vector (muda::details::MatrixFormatConverter)</li> <li>temp_segments (muda::details::MatrixFormatConverter)</li> <li>target (muda::lbvh::query_nearest, muda::lbvh::query_overlap)</li> </ul>"},{"location":"muda/class_member_variables/#u","title":"u","text":"<ul> <li>unique_blocks (muda::details::MatrixFormatConverter)</li> <li>unique_counts (muda::details::MatrixFormatConverter)</li> <li>unique_ij_pairs (muda::details::MatrixFormatConverter)</li> <li>unique_indices (muda::details::MatrixFormatConverter)</li> <li>unique_segments (muda::details::MatrixFormatConverter)</li> <li>unique_values (muda::details::MatrixFormatConverter)</li> <li>upper (muda::lbvh::AABB)</li> <li>uniqueKey (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>uniqueKeyCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#v","title":"v","text":"<ul> <li>value (TCB_SPAN_NAMESPACE_NAME::detail::is_container, muda::DoubletVectorViewerT::CDoublet, muda::TripletMatrixViewerT::CTriplet, muda::always_false, muda::always_true, muda::force_trivial, muda::force_trivially_constructible, muda::force_trivially_copy_assignable, muda::force_trivially_copy_constructible, muda::force_trivially_destructible, muda::is_cuda_arch)</li> <li>var_style (muda::ComputeGraphGraphvizOptions)</li> <li>var (muda::details::LocalVarInfo)</li> <li>validCellCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>validCollisionPairCount (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_variables/#w","title":"w","text":"<ul> <li>whole (muda::lbvh::DefaultMortonCodeCalculator)</li> </ul>"},{"location":"muda/class_member_variables/#_","title":"_","text":"<ul> <li>_dummy (muda::ViewBase)</li> </ul>"},{"location":"muda/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"muda/class_member_typedefs/#a","title":"a","text":"<ul> <li>auto_const_t (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::ViewBase, muda::ViewerBase, muda::lbvh::details::BVHViewerBase)</li> <li>aabb_getter_type (muda::lbvh::BVH)</li> <li>aabb_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> </ul>"},{"location":"muda/class_member_typedefs/#b","title":"b","text":"<ul> <li>Base (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DeviceHistogram, muda::DeviceMergeSort, muda::DevicePartition, muda::DeviceRadixSort, muda::DeviceReduce, muda::DeviceRunLengthEncode, muda::DeviceScan, muda::DeviceSegmentedRadixSort, muda::DeviceSegmentedReduce, muda::DeviceSegmentedSort, muda::DeviceSelect, muda::DeviceSpmv, muda::DeviceVector, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::FieldEntryViewerCore, muda::HostDeviceConfigView, muda::LaunchBase, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>Buffer2DView (muda::DenseMatrixViewT, muda::DenseMatrixViewerT)</li> <li>BufferView (muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>bit_type (muda::Flags)</li> <li>BlockMatrix (muda::TripletMatrixViewT)</li> </ul>"},{"location":"muda/class_member_typedefs/#c","title":"c","text":"<ul> <li>const_pointer (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>const_reference (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>ConstView (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DoubletVectorViewT, muda::TripletMatrixViewT, muda::VarViewT)</li> <li>CViewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT)</li> <li>CaptureAction (muda::ComputeGraphBuilder)</li> <li>ConstViewer (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>CBuffer2DView (muda::DenseMatrixViewT, muda::DenseMatrixViewerT)</li> <li>CMapMatrix (muda::DenseMatrixViewerT)</li> <li>CBufferView (muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>CMapVector (muda::DenseVectorViewerT)</li> <li>ConstMatMap (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>Cell (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_typedefs/#d","title":"d","text":"<ul> <li>difference_type (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::VarViewT)</li> <li>Dependency (muda::ComputeGraph)</li> <li>derived_type (muda::LaunchBase)</li> </ul>"},{"location":"muda/class_member_typedefs/#e","title":"e","text":"<ul> <li>element_type (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>ElementType (muda::FieldEntry)</li> </ul>"},{"location":"muda/class_member_typedefs/#f","title":"f","text":"<ul> <li>Float (muda::spatial_hash::SpatialHashTableInfo)</li> </ul>"},{"location":"muda/class_member_typedefs/#i","title":"i","text":"<ul> <li>iterator (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>iterator_category (muda::BufferViewT, muda::VarViewT)</li> <li>index_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> <li>Impl (muda::spatial_hash::SparseSpatialHash)</li> <li>I32 (muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_typedefs/#l","title":"l","text":"<ul> <li>Layout (muda::Field, muda::FieldEntryLayoutInfo)</li> </ul>"},{"location":"muda/class_member_typedefs/#m","title":"m","text":"<ul> <li>MapMatrix (muda::DenseMatrixViewerT)</li> <li>MapMatrixT (muda::DenseMatrixViewerT)</li> <li>MatrixType (muda::DenseMatrixViewerT)</li> <li>MapVector (muda::DenseVectorViewerT)</li> <li>MapVectorT (muda::DenseVectorViewerT)</li> <li>MatStride (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>mask_type (muda::Flags)</li> <li>MatrixValueT (muda::details::MatrixFormatConverter)</li> <li>morton_code_calculator_type (muda::lbvh::BVH)</li> </ul>"},{"location":"muda/class_member_typedefs/#n","title":"n","text":"<ul> <li>NonConstView (muda::BSRMatrixViewT, muda::Buffer3DViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DoubletVectorViewT, muda::TripletMatrixViewT)</li> <li>NonConstViewer (muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewerT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>NonConstMatMap (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>NodeParms (muda::Launch, muda::ParallelFor)</li> <li>non_const_enable_t (muda::ViewBase, muda::ViewerBase)</li> <li>node_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> </ul>"},{"location":"muda/class_member_typedefs/#o","title":"o","text":"<ul> <li>OtherView (muda::Buffer3DViewT)</li> <li>object_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> </ul>"},{"location":"muda/class_member_typedefs/#p","title":"p","text":"<ul> <li>pointer (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::VarViewT)</li> <li>Phase (muda::ComputeGraphBuilder)</li> <li>PhaseAction (muda::ComputeGraphBuilder)</li> </ul>"},{"location":"muda/class_member_typedefs/#r","title":"r","text":"<ul> <li>reference (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::VarViewT)</li> <li>reverse_iterator (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>ROViewer (muda::ComputeGraphVar)</li> <li>RWViewer (muda::ComputeGraphVar)</li> <li>real_type (muda::lbvh::BVH, muda::lbvh::details::BVHViewerBase)</li> </ul>"},{"location":"muda/class_member_typedefs/#s","title":"s","text":"<ul> <li>size_type (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>storage_type (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>subspan_return_t (TCB_SPAN_NAMESPACE_NAME::span)</li> <li>S (muda::ComputeGraph, muda::ComputeGraphClosure, muda::ComputeGraphNodeBase, muda::ComputeGraphVarManager, muda::Graph, muda::GraphExec, muda::LaunchCore, muda::details::ComputeGraphAccessor)</li> <li>SegmentVector (muda::DeviceBCOOVector, muda::DoubletVectorViewT)</li> </ul>"},{"location":"muda/class_member_typedefs/#t","title":"t","text":"<ul> <li>ThisView (muda::BSRMatrixViewT, muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOMatrixViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT, muda::DoubletVectorViewT, muda::TripletMatrixViewT, muda::VarViewT)</li> <li>ThisViewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOVectorViewBase, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseMatrixViewT, muda::DenseMatrixViewerT, muda::DenseVectorViewT, muda::DenseVectorViewerT, muda::DenseViewerT, muda::DoubletVectorViewT, muda::DoubletVectorViewerT, muda::FieldEntryViewCore, muda::TripletMatrixViewT, muda::TripletMatrixViewerT, muda::VarViewT, muda::lbvh::details::BVHViewerBase)</li> <li>ThisBuffer2DView (muda::DenseMatrixViewT, muda::DenseMatrixViewerT)</li> <li>ThisMapMatrix (muda::DenseMatrixViewerT)</li> <li>ThisBufferView (muda::DenseVectorViewT, muda::DenseVectorViewerT)</li> <li>ThisMapVector (muda::DenseVectorViewerT)</li> <li>this_type (muda::EventRecordNode, muda::EventWaitNode, muda::GraphNode, muda::HostNode, muda::HostNodeParms, muda::KernelNode, muda::KernelNodeParms, muda::MemcpyNode, muda::MemsetNode)</li> <li>ThisMatMap (muda::FieldEntryViewCore, muda::FieldEntryViewerCore)</li> <li>TypeN (muda::MatrixFormatConverter)</li> <li>type (muda::read_only_view, muda::read_write_view, std::tuple_element&lt; I, TCB_SPAN_NAMESPACE_NAME::span&lt; ElementType, Extent &gt; &gt;)</li> </ul>"},{"location":"muda/class_member_typedefs/#u","title":"u","text":"<ul> <li>U (muda::ComputeGraph, muda::Field, muda::Graph, muda::GraphExec, muda::MatrixFormatConverter, muda::SubField, muda::SubFieldInterface)</li> <li>U32 (muda::spatial_hash::SpatialHashTableInfo, muda::spatial_hash::SpatialPartitionCell, muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (TCB_SPAN_NAMESPACE_NAME::span, muda::BufferViewT, muda::Dense1DT, muda::Dense2DBase, muda::Dense3DBase, muda::DenseViewerT, muda::DeviceBuffer, muda::DeviceBuffer2D, muda::DeviceBuffer3D, muda::DeviceDenseMatrix, muda::DeviceVar, muda::HostDeviceConfig, muda::HostDeviceConfigView, muda::IdWithType, muda::VarViewT)</li> <li>ValueT (muda::BSRMatrixViewT, muda::DeviceBSRMatrix, muda::DeviceDoubletVector, muda::DeviceTripletMatrix, muda::DoubletVectorViewerT, muda::TripletMatrixViewerT)</li> <li>Viewer (muda::Buffer2DViewT, muda::Buffer3DViewT, muda::BufferViewT, muda::COOVectorViewBase, muda::DenseMatrixViewT, muda::DenseVectorViewT)</li> <li>VectorType (muda::DenseVectorViewerT)</li> <li>ViewerCore (muda::FieldEntryViewCore)</li> <li>VectorValueT (muda::details::MatrixFormatConverter)</li> <li>vector_type (muda::lbvh::query_nearest)</li> <li>Vector3 (muda::spatial_hash::AABB, muda::spatial_hash::BoundingSphere, muda::spatial_hash::SpatialHashTableInfo, muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>Vector3i (muda::spatial_hash::SpatialHashTableInfo, muda::spatial_hash::details::SparseSpatialHashImpl)</li> <li>Vector3u (muda::spatial_hash::SpatialHashTableInfo, muda::spatial_hash::SpatialPartitionCell, muda::spatial_hash::details::SparseSpatialHashImpl)</li> </ul>"},{"location":"muda/class_member_enums/","title":"Class Member Enums","text":""},{"location":"muda/class_member_enums/#b","title":"b","text":"<ul> <li>Bit (muda::Event)</li> </ul>"},{"location":"muda/class_member_enums/#f","title":"f","text":"<ul> <li>Flag (muda::Stream)</li> </ul>"},{"location":"muda/class_member_enums/#q","title":"q","text":"<ul> <li>QueryResult (muda::Event)</li> </ul>"},{"location":"muda/namespace_members/","title":"Namespace Members","text":""},{"location":"muda/namespace_members/#a","title":"a","text":"<ul> <li>as_bytes (TCB_SPAN_NAMESPACE_NAME)</li> <li>as_writable_bytes (TCB_SPAN_NAMESPACE_NAME)</li> <li>always_false_v (muda)</li> <li>as_extent (muda)</li> <li>as_offset (muda)</li> <li>atomic_add (muda, muda::eigen)</li> <li>atomic_and (muda)</li> <li>atomic_cas (muda)</li> <li>atomic_exch (muda)</li> <li>atomic_max (muda)</li> <li>atomic_min (muda)</li> <li>atomic_or (muda)</li> <li>atomic_sub (muda)</li> <li>atomic_xor (muda)</li> <li>as_eigen (muda::eigen)</li> </ul>"},{"location":"muda/namespace_members/#b","title":"b","text":"<ul> <li>byte (TCB_SPAN_NAMESPACE_NAME)</li> <li>BCOOMatrixView (muda)</li> <li>BCOOMatrixViewer (muda)</li> <li>BCOOVectorView (muda)</li> <li>BCOOVectorViewer (muda)</li> <li>BSRMatrixView (muda)</li> <li>Buffer2DView (muda)</li> <li>Buffer3DView (muda)</li> <li>BufferView (muda)</li> <li>block_dim (muda)</li> <li>block_idx (muda)</li> <li>brkpt (muda)</li> <li>ByteTempBuffer (muda::details)</li> <li>BVHViewer (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_members/#c","title":"c","text":"<ul> <li>CBCOOMatrixView (muda)</li> <li>CBCOOMatrixViewer (muda)</li> <li>CBCOOVectorView (muda)</li> <li>CBCOOVectorViewer (muda)</li> <li>CBSRMatrixView (muda)</li> <li>CBuffer2DView (muda)</li> <li>CBuffer3DView (muda)</li> <li>CBufferView (muda)</li> <li>CCOOMatrixView (muda)</li> <li>CCOOMatrixViewer (muda)</li> <li>CCOOVectorView (muda)</li> <li>CCOOVectorViewer (muda)</li> <li>CCSRMatrixView (muda)</li> <li>CDense (muda)</li> <li>CDense1D (muda)</li> <li>CDense2D (muda)</li> <li>CDense3D (muda)</li> <li>CDenseMatrixView (muda)</li> <li>CDenseMatrixViewer (muda)</li> <li>CDenseVectorView (muda)</li> <li>CDenseVectorViewer (muda)</li> <li>CDoubletVectorView (muda)</li> <li>CDoubletVectorViewer (muda)</li> <li>COMPUTE_GRAPH_ON (muda)</li> <li>COOMatrixView (muda)</li> <li>COOMatrixViewer (muda)</li> <li>COOVectorView (muda)</li> <li>COOVectorViewer (muda)</li> <li>CSRMatrixView (muda)</li> <li>CSRMatrixViewT (muda)</li> <li>CTripletMatrixView (muda)</li> <li>CTripletMatrixViewer (muda)</li> <li>CVarView (muda)</li> <li>ComputeGraphEventRecordNode (muda)</li> <li>ComputeGraphEventWaitNode (muda)</li> <li>ComputeGraphFlag (muda)</li> <li>ComputeGraphKernelNode (muda)</li> <li>ComputeGraphMemcpyNode (muda)</li> <li>ComputeGraphMemsetNode (muda)</li> <li>ComputeGraphNodeType (muda)</li> <li>ComputeGraphPhase (muda)</li> <li>ComputeGraphVarUsage (muda)</li> <li>check (muda)</li> <li>cube (muda)</li> <li>cublas_trans_operation (muda)</li> <li>cuda_data_type (muda)</li> <li>cusparse_index_type (muda)</li> <li>CBVHViewer (muda::lbvh)</li> <li>centroid (muda::lbvh)</li> <li>common_upper_bits (muda::lbvh)</li> <li>construct_internal_nodes (muda::lbvh::details)</li> </ul>"},{"location":"muda/namespace_members/#d","title":"d","text":"<ul> <li>data (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>dynamic_extent (TCB_SPAN_NAMESPACE_NAME)</li> <li>DEBUG_VIEWER (muda)</li> <li>DEFAULT_ASYNC_ALLOC_FREE (muda)</li> <li>DefaultTag (muda)</li> <li>Dense (muda)</li> <li>Dense1D (muda)</li> <li>Dense2D (muda)</li> <li>Dense3D (muda)</li> <li>DenseMatrixView (muda)</li> <li>DenseMatrixViewer (muda)</li> <li>DenseVectorView (muda)</li> <li>DenseVectorViewer (muda)</li> <li>DeviceCOOMatrix (muda)</li> <li>DeviceCOOVector (muda)</li> <li>DeviceCSRMatrix (muda)</li> <li>DoubletVectorView (muda)</li> <li>DoubletVectorViewer (muda)</li> <li>delete_function_object (muda::details)</li> <li>determine_range (muda::lbvh::details)</li> <li>distance (muda::spatial_hash)</li> </ul>"},{"location":"muda/namespace_members/#e","title":"e","text":"<ul> <li>enum_name (muda)</li> <li>EdgeEdgeDistanceType (muda::distance)</li> <li>edge_edge_ccd (muda::distance)</li> <li>edge_edge_ccd_broadphase (muda::distance)</li> <li>edge_edge_cd_broadphase (muda::distance)</li> <li>edge_edge_cross_norm2 (muda::distance)</li> <li>edge_edge_cross_norm2_gradient (muda::distance)</li> <li>edge_edge_cross_norm2_hessian (muda::distance)</li> <li>edge_edge_distance (muda::distance)</li> <li>edge_edge_distance_gradient (muda::distance)</li> <li>edge_edge_distance_hessian (muda::distance)</li> <li>edge_edge_distance_type (muda::distance)</li> <li>edge_edge_distance_unclassified (muda::distance)</li> <li>edge_edge_mollifier (muda::distance)</li> <li>edge_edge_mollifier_gradient (muda::distance)</li> <li>edge_edge_mollifier_hessian (muda::distance)</li> <li>edge_edge_mollifier_threshold (muda::distance)</li> <li>evd (muda::eigen)</li> <li>expand_bits (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_members/#f","title":"f","text":"<ul> <li>FieldEntryLayout (muda)</li> <li>FieldEntryType (muda)</li> <li>force_trivial_v (muda)</li> <li>force_trivially_constructible_v (muda)</li> <li>force_trivially_copy_assignable_v (muda)</li> <li>force_trivially_copy_constructible_v (muda)</li> <li>force_trivially_destructible_v (muda)</li> <li>fire_and_forget (muda::details::stream)</li> <li>find_split (muda::lbvh::details)</li> </ul>"},{"location":"muda/namespace_members/#g","title":"g","text":"<ul> <li>get (TCB_SPAN_NAMESPACE_NAME)</li> <li>GraphInstantiateFlagBit (muda)</li> <li>grid_dim (muda)</li> <li>grid_stride_loop_kernel (muda, muda::details)</li> <li>generic_host_call (muda::details)</li> <li>generic_kernel (muda::details)</li> <li>generic_kernel_with_range (muda::details)</li> <li>graph_fire_and_forget (muda::details::stream)</li> <li>graph_tail_launch (muda::details::stream)</li> </ul>"},{"location":"muda/namespace_members/#h","title":"h","text":"<ul> <li>HEAVY_WORKLOAD_BLOCK_SIZE (muda)</li> </ul>"},{"location":"muda/namespace_members/#i","title":"i","text":"<ul> <li>I32IdWithType (muda)</li> <li>I64IdWithType (muda)</li> <li>invoke (muda)</li> <li>is_cuda_arch_v (muda)</li> <li>is_read_only_view_v (muda)</li> <li>is_read_write_view_v (muda)</li> <li>is_trivial_v (muda)</li> <li>is_trivially_constructible_v (muda)</li> <li>is_trivially_copy_assignable_v (muda)</li> <li>is_trivially_copy_constructible_v (muda)</li> <li>is_trivially_destructible_v (muda)</li> <li>is_uniform_view_v (muda)</li> <li>inverse (muda::eigen)</li> <li>infinity (muda::lbvh)</li> <li>infinity&lt; double &gt; (muda::lbvh)</li> <li>infinity&lt; float &gt; (muda::lbvh)</li> <li>intersects (muda::lbvh)</li> <li>intersect (muda::spatial_hash)</li> </ul>"},{"location":"muda/namespace_members/#k","title":"k","text":"<ul> <li>KeyValuePair (muda)</li> <li>kernel_assign (muda::details::buffer)</li> <li>kernel_construct (muda::details::buffer)</li> <li>kernel_copy_construct (muda::details::buffer)</li> <li>kernel_destruct (muda::details::buffer)</li> <li>kernel_fill (muda::details::buffer)</li> </ul>"},{"location":"muda/namespace_members/#l","title":"l","text":"<ul> <li>LIGHT_WORKLOAD_BLOCK_SIZE (muda)</li> <li>LinearSystemReorderMethod (muda)</li> <li>LoggerBasicType (muda)</li> <li>LoggerFmtArg (muda)</li> <li>less (muda::details::buffer)</li> </ul>"},{"location":"muda/namespace_members/#m","title":"m","text":"<ul> <li>make_span (TCB_SPAN_NAMESPACE_NAME)</li> <li>MIDDLE_WORKLOAD_BLOCK_SIZE (muda)</li> <li>MUDA_DEFINE_ARITHMATIC_OPERATOR (muda)</li> <li>MUDA_DEFINE_COMPARISON_OPERATOR (muda)</li> <li>make_cdense (muda)</li> <li>make_cdense_1d (muda)</li> <li>make_cdense_2d (muda)</li> <li>make_cdense_3d (muda)</li> <li>make_dense (muda)</li> <li>make_dense_1d (muda)</li> <li>make_dense_2d (muda)</li> <li>make_dense_3d (muda)</li> <li>max (muda)</li> <li>min (muda)</li> <li>MatStride (muda::details::field)</li> <li>make_stride (muda::details::field)</li> <li>merge (muda::lbvh)</li> <li>mindist (muda::lbvh)</li> <li>minmaxdist (muda::lbvh)</li> <li>morton_code (muda::lbvh)</li> <li>mudaCudaGetErrorEnum (muda)</li> </ul>"},{"location":"muda/namespace_members/#n","title":"n","text":"<ul> <li>nearest (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_members/#o","title":"o","text":"<ul> <li>on (muda::config, muda)</li> <li>overlaps (muda::lbvh)</li> <li>operator&amp; (muda)</li> <li>operator+ (muda)</li> <li>operator&lt; (muda)</li> <li>operator&lt;&lt; (muda)</li> <li>operator&lt;= (muda)</li> <li>operator== (muda)</li> <li>operator&gt; (muda)</li> <li>operator&gt;= (muda)</li> <li>operator^ (muda)</li> <li>operator| (muda)</li> </ul>"},{"location":"muda/namespace_members/#p","title":"p","text":"<ul> <li>ParallelForType (muda)</li> <li>parallel_for_kernel (muda::details, muda)</li> <li>PointEdgeDistanceType (muda::distance)</li> <li>PointPointDistanceType (muda::distance)</li> <li>PointTriangleDistanceType (muda::distance)</li> <li>point_edge_ccd (muda::distance)</li> <li>point_edge_ccd_broadphase (muda::distance)</li> <li>point_edge_cd_broadphase (muda::distance)</li> <li>point_edge_distance (muda::distance)</li> <li>point_edge_distance_gradient (muda::distance)</li> <li>point_edge_distance_hessian (muda::distance)</li> <li>point_edge_distance_type (muda::distance)</li> <li>point_edge_distance_unclassified (muda::distance)</li> <li>point_point_ccd (muda::distance)</li> <li>point_point_ccd_broadphase (muda::distance)</li> <li>point_point_distance (muda::distance)</li> <li>point_point_distance_gradient (muda::distance)</li> <li>point_point_distance_hessian (muda::distance)</li> <li>point_point_distance_type (muda::distance)</li> <li>point_point_distance_unclassified (muda::distance)</li> <li>point_triangle_ccd (muda::distance)</li> <li>point_triangle_ccd_broadphase (muda::distance)</li> <li>point_triangle_cd_broadphase (muda::distance)</li> <li>point_triangle_distance (muda::distance)</li> <li>point_triangle_distance_gradient (muda::distance)</li> <li>point_triangle_distance_hessian (muda::distance)</li> <li>point_triangle_distance_type (muda::distance)</li> <li>point_triangle_distance_unclassified (muda::distance)</li> <li>pd (muda::eigen)</li> <li>print (muda)</li> <li>print_check (muda)</li> <li>print_convert (muda)</li> <li>profile_host (muda)</li> </ul>"},{"location":"muda/namespace_members/#q","title":"q","text":"<ul> <li>query (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_members/#r","title":"r","text":"<ul> <li>remove_pointer_t (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>RUNTIME_CHECK_ON (muda)</li> <li>reserve_1d (muda::details::buffer)</li> <li>reserve_2d (muda::details::buffer)</li> <li>reserve_3d (muda::details::buffer)</li> <li>raw_type_t (muda)</li> <li>read_only_view_t (muda)</li> <li>read_write_view_t (muda)</li> <li>remove_const (muda)</li> </ul>"},{"location":"muda/namespace_members/#s","title":"s","text":"<ul> <li>size (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>swap (muda::details::buffer)</li> <li>svd3x3 (muda::details::eigen)</li> <li>stream_error_callback (muda::details)</li> <li>svd (muda::eigen)</li> <li>squared_distance (muda::spatial_hash)</li> <li>span (muda)</li> <li>square (muda)</li> </ul>"},{"location":"muda/namespace_members/#t","title":"t","text":"<ul> <li>TRAP_ON_ERROR (muda)</li> <li>TripletMatrixView (muda)</li> <li>TripletMatrixViewer (muda)</li> <li>tail_launch (muda::details::stream)</li> <li>thread_idx (muda)</li> <li>trap (muda)</li> </ul>"},{"location":"muda/namespace_members/#u","title":"u","text":"<ul> <li>uncvref_t (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>U32IdWithType (muda)</li> <li>U64IdWithType (muda)</li> </ul>"},{"location":"muda/namespace_members/#v","title":"v","text":"<ul> <li>void_t (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>VarView (muda)</li> <li>vector_base (muda::details)</li> <li>vector_of_t (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_members/#w","title":"w","text":"<ul> <li>wait_device (muda)</li> <li>wait_event (muda)</li> <li>wait_stream (muda)</li> </ul>"},{"location":"muda/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"muda/namespace_member_functions/#a","title":"a","text":"<ul> <li>as_bytes (TCB_SPAN_NAMESPACE_NAME)</li> <li>as_writable_bytes (TCB_SPAN_NAMESPACE_NAME)</li> <li>as_extent (muda)</li> <li>as_offset (muda)</li> <li>atomic_add (muda, muda::eigen)</li> <li>atomic_and (muda)</li> <li>atomic_cas (muda)</li> <li>atomic_exch (muda)</li> <li>atomic_max (muda)</li> <li>atomic_min (muda)</li> <li>atomic_or (muda)</li> <li>atomic_sub (muda)</li> <li>atomic_xor (muda)</li> <li>as_eigen (muda::eigen)</li> </ul>"},{"location":"muda/namespace_member_functions/#b","title":"b","text":"<ul> <li>block_dim (muda)</li> <li>block_idx (muda)</li> <li>brkpt (muda)</li> </ul>"},{"location":"muda/namespace_member_functions/#c","title":"c","text":"<ul> <li>check (muda)</li> <li>cube (muda)</li> <li>cublas_trans_operation (muda)</li> <li>cuda_data_type (muda)</li> <li>cusparse_index_type (muda)</li> <li>centroid (muda::lbvh)</li> <li>common_upper_bits (muda::lbvh)</li> <li>construct_internal_nodes (muda::lbvh::details)</li> </ul>"},{"location":"muda/namespace_member_functions/#d","title":"d","text":"<ul> <li>data (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>delete_function_object (muda::details)</li> <li>determine_range (muda::lbvh::details)</li> <li>distance (muda::spatial_hash)</li> </ul>"},{"location":"muda/namespace_member_functions/#e","title":"e","text":"<ul> <li>enum_name (muda)</li> <li>edge_edge_ccd (muda::distance)</li> <li>edge_edge_ccd_broadphase (muda::distance)</li> <li>edge_edge_cd_broadphase (muda::distance)</li> <li>edge_edge_cross_norm2 (muda::distance)</li> <li>edge_edge_cross_norm2_gradient (muda::distance)</li> <li>edge_edge_cross_norm2_hessian (muda::distance)</li> <li>edge_edge_distance (muda::distance)</li> <li>edge_edge_distance_gradient (muda::distance)</li> <li>edge_edge_distance_hessian (muda::distance)</li> <li>edge_edge_distance_type (muda::distance)</li> <li>edge_edge_distance_unclassified (muda::distance)</li> <li>edge_edge_mollifier (muda::distance)</li> <li>edge_edge_mollifier_gradient (muda::distance)</li> <li>edge_edge_mollifier_hessian (muda::distance)</li> <li>edge_edge_mollifier_threshold (muda::distance)</li> <li>evd (muda::eigen)</li> <li>expand_bits (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_member_functions/#f","title":"f","text":"<ul> <li>fire_and_forget (muda::details::stream)</li> <li>find_split (muda::lbvh::details)</li> </ul>"},{"location":"muda/namespace_member_functions/#g","title":"g","text":"<ul> <li>get (TCB_SPAN_NAMESPACE_NAME)</li> <li>grid_dim (muda)</li> <li>grid_stride_loop_kernel (muda, muda::details)</li> <li>generic_host_call (muda::details)</li> <li>generic_kernel (muda::details)</li> <li>generic_kernel_with_range (muda::details)</li> <li>graph_fire_and_forget (muda::details::stream)</li> <li>graph_tail_launch (muda::details::stream)</li> </ul>"},{"location":"muda/namespace_member_functions/#i","title":"i","text":"<ul> <li>invoke (muda)</li> <li>inverse (muda::eigen)</li> <li>infinity (muda::lbvh)</li> <li>infinity&lt; double &gt; (muda::lbvh)</li> <li>infinity&lt; float &gt; (muda::lbvh)</li> <li>intersects (muda::lbvh)</li> <li>intersect (muda::spatial_hash)</li> </ul>"},{"location":"muda/namespace_member_functions/#k","title":"k","text":"<ul> <li>kernel_assign (muda::details::buffer)</li> <li>kernel_construct (muda::details::buffer)</li> <li>kernel_copy_construct (muda::details::buffer)</li> <li>kernel_destruct (muda::details::buffer)</li> <li>kernel_fill (muda::details::buffer)</li> </ul>"},{"location":"muda/namespace_member_functions/#l","title":"l","text":"<ul> <li>less (muda::details::buffer)</li> </ul>"},{"location":"muda/namespace_member_functions/#m","title":"m","text":"<ul> <li>make_span (TCB_SPAN_NAMESPACE_NAME)</li> <li>MUDA_DEFINE_ARITHMATIC_OPERATOR (muda)</li> <li>MUDA_DEFINE_COMPARISON_OPERATOR (muda)</li> <li>make_cdense (muda)</li> <li>make_cdense_1d (muda)</li> <li>make_cdense_2d (muda)</li> <li>make_cdense_3d (muda)</li> <li>make_dense (muda)</li> <li>make_dense_1d (muda)</li> <li>make_dense_2d (muda)</li> <li>make_dense_3d (muda)</li> <li>max (muda)</li> <li>min (muda)</li> <li>make_stride (muda::details::field)</li> <li>merge (muda::lbvh)</li> <li>mindist (muda::lbvh)</li> <li>minmaxdist (muda::lbvh)</li> <li>morton_code (muda::lbvh)</li> <li>mudaCudaGetErrorEnum (muda)</li> </ul>"},{"location":"muda/namespace_member_functions/#n","title":"n","text":"<ul> <li>nearest (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_member_functions/#o","title":"o","text":"<ul> <li>on (muda::config, muda)</li> <li>overlaps (muda::lbvh)</li> <li>operator&amp; (muda)</li> <li>operator+ (muda)</li> <li>operator&lt; (muda)</li> <li>operator&lt;&lt; (muda)</li> <li>operator&lt;= (muda)</li> <li>operator== (muda)</li> <li>operator&gt; (muda)</li> <li>operator&gt;= (muda)</li> <li>operator^ (muda)</li> <li>operator| (muda)</li> </ul>"},{"location":"muda/namespace_member_functions/#p","title":"p","text":"<ul> <li>parallel_for_kernel (muda::details, muda)</li> <li>point_edge_ccd (muda::distance)</li> <li>point_edge_ccd_broadphase (muda::distance)</li> <li>point_edge_cd_broadphase (muda::distance)</li> <li>point_edge_distance (muda::distance)</li> <li>point_edge_distance_gradient (muda::distance)</li> <li>point_edge_distance_hessian (muda::distance)</li> <li>point_edge_distance_type (muda::distance)</li> <li>point_edge_distance_unclassified (muda::distance)</li> <li>point_point_ccd (muda::distance)</li> <li>point_point_ccd_broadphase (muda::distance)</li> <li>point_point_distance (muda::distance)</li> <li>point_point_distance_gradient (muda::distance)</li> <li>point_point_distance_hessian (muda::distance)</li> <li>point_point_distance_type (muda::distance)</li> <li>point_point_distance_unclassified (muda::distance)</li> <li>point_triangle_ccd (muda::distance)</li> <li>point_triangle_ccd_broadphase (muda::distance)</li> <li>point_triangle_cd_broadphase (muda::distance)</li> <li>point_triangle_distance (muda::distance)</li> <li>point_triangle_distance_gradient (muda::distance)</li> <li>point_triangle_distance_hessian (muda::distance)</li> <li>point_triangle_distance_type (muda::distance)</li> <li>point_triangle_distance_unclassified (muda::distance)</li> <li>pd (muda::eigen)</li> <li>print (muda)</li> <li>print_check (muda)</li> <li>print_convert (muda)</li> <li>profile_host (muda)</li> </ul>"},{"location":"muda/namespace_member_functions/#q","title":"q","text":"<ul> <li>query (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_member_functions/#r","title":"r","text":"<ul> <li>reserve_1d (muda::details::buffer)</li> <li>reserve_2d (muda::details::buffer)</li> <li>reserve_3d (muda::details::buffer)</li> <li>remove_const (muda)</li> </ul>"},{"location":"muda/namespace_member_functions/#s","title":"s","text":"<ul> <li>size (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>swap (muda::details::buffer)</li> <li>svd3x3 (muda::details::eigen)</li> <li>stream_error_callback (muda::details)</li> <li>svd (muda::eigen)</li> <li>squared_distance (muda::spatial_hash)</li> <li>square (muda)</li> </ul>"},{"location":"muda/namespace_member_functions/#t","title":"t","text":"<ul> <li>tail_launch (muda::details::stream)</li> <li>thread_idx (muda)</li> <li>trap (muda)</li> </ul>"},{"location":"muda/namespace_member_functions/#w","title":"w","text":"<ul> <li>wait_device (muda)</li> <li>wait_event (muda)</li> <li>wait_stream (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"muda/namespace_member_variables/#a","title":"a","text":"<ul> <li>always_false_v (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/#c","title":"c","text":"<ul> <li>COMPUTE_GRAPH_ON (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/#d","title":"d","text":"<ul> <li>dynamic_extent (TCB_SPAN_NAMESPACE_NAME)</li> <li>DEBUG_VIEWER (muda)</li> <li>DEFAULT_ASYNC_ALLOC_FREE (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/#f","title":"f","text":"<ul> <li>force_trivial_v (muda)</li> <li>force_trivially_constructible_v (muda)</li> <li>force_trivially_copy_assignable_v (muda)</li> <li>force_trivially_copy_constructible_v (muda)</li> <li>force_trivially_destructible_v (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/#h","title":"h","text":"<ul> <li>HEAVY_WORKLOAD_BLOCK_SIZE (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/#i","title":"i","text":"<ul> <li>is_cuda_arch_v (muda)</li> <li>is_read_only_view_v (muda)</li> <li>is_read_write_view_v (muda)</li> <li>is_trivial_v (muda)</li> <li>is_trivially_constructible_v (muda)</li> <li>is_trivially_copy_assignable_v (muda)</li> <li>is_trivially_copy_constructible_v (muda)</li> <li>is_trivially_destructible_v (muda)</li> <li>is_uniform_view_v (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/#l","title":"l","text":"<ul> <li>LIGHT_WORKLOAD_BLOCK_SIZE (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/#m","title":"m","text":"<ul> <li>MIDDLE_WORKLOAD_BLOCK_SIZE (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/#r","title":"r","text":"<ul> <li>RUNTIME_CHECK_ON (muda)</li> </ul>"},{"location":"muda/namespace_member_variables/#t","title":"t","text":"<ul> <li>TRAP_ON_ERROR (muda)</li> </ul>"},{"location":"muda/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"muda/namespace_member_typedefs/#b","title":"b","text":"<ul> <li>byte (TCB_SPAN_NAMESPACE_NAME)</li> <li>BCOOMatrixView (muda)</li> <li>BCOOMatrixViewer (muda)</li> <li>BCOOVectorView (muda)</li> <li>BCOOVectorViewer (muda)</li> <li>BSRMatrixView (muda)</li> <li>Buffer2DView (muda)</li> <li>Buffer3DView (muda)</li> <li>BufferView (muda)</li> <li>ByteTempBuffer (muda::details)</li> <li>BVHViewer (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>CBCOOMatrixView (muda)</li> <li>CBCOOMatrixViewer (muda)</li> <li>CBCOOVectorView (muda)</li> <li>CBCOOVectorViewer (muda)</li> <li>CBSRMatrixView (muda)</li> <li>CBuffer2DView (muda)</li> <li>CBuffer3DView (muda)</li> <li>CBufferView (muda)</li> <li>CCOOMatrixView (muda)</li> <li>CCOOMatrixViewer (muda)</li> <li>CCOOVectorView (muda)</li> <li>CCOOVectorViewer (muda)</li> <li>CCSRMatrixView (muda)</li> <li>CDense (muda)</li> <li>CDense1D (muda)</li> <li>CDense2D (muda)</li> <li>CDense3D (muda)</li> <li>CDenseMatrixView (muda)</li> <li>CDenseMatrixViewer (muda)</li> <li>CDenseVectorView (muda)</li> <li>CDenseVectorViewer (muda)</li> <li>CDoubletVectorView (muda)</li> <li>CDoubletVectorViewer (muda)</li> <li>COOMatrixView (muda)</li> <li>COOMatrixViewer (muda)</li> <li>COOVectorView (muda)</li> <li>COOVectorViewer (muda)</li> <li>CSRMatrixView (muda)</li> <li>CSRMatrixViewT (muda)</li> <li>CTripletMatrixView (muda)</li> <li>CTripletMatrixViewer (muda)</li> <li>CVarView (muda)</li> <li>ComputeGraphEventRecordNode (muda)</li> <li>ComputeGraphEventWaitNode (muda)</li> <li>ComputeGraphKernelNode (muda)</li> <li>ComputeGraphMemcpyNode (muda)</li> <li>ComputeGraphMemsetNode (muda)</li> <li>CBVHViewer (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>DefaultTag (muda)</li> <li>Dense (muda)</li> <li>Dense1D (muda)</li> <li>Dense2D (muda)</li> <li>Dense3D (muda)</li> <li>DenseMatrixView (muda)</li> <li>DenseMatrixViewer (muda)</li> <li>DenseVectorView (muda)</li> <li>DenseVectorViewer (muda)</li> <li>DeviceCOOMatrix (muda)</li> <li>DeviceCOOVector (muda)</li> <li>DeviceCSRMatrix (muda)</li> <li>DoubletVectorView (muda)</li> <li>DoubletVectorViewer (muda)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>I32IdWithType (muda)</li> <li>I64IdWithType (muda)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#k","title":"k","text":"<ul> <li>KeyValuePair (muda)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#l","title":"l","text":"<ul> <li>LoggerFmtArg (muda)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>MatStride (muda::details::field)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>remove_pointer_t (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>raw_type_t (muda)</li> <li>read_only_view_t (muda)</li> <li>read_write_view_t (muda)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>span (muda)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>TripletMatrixView (muda)</li> <li>TripletMatrixViewer (muda)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#u","title":"u","text":"<ul> <li>uncvref_t (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>U32IdWithType (muda)</li> <li>U64IdWithType (muda)</li> </ul>"},{"location":"muda/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>void_t (TCB_SPAN_NAMESPACE_NAME::detail)</li> <li>VarView (muda)</li> <li>vector_base (muda::details)</li> <li>vector_of_t (muda::lbvh)</li> </ul>"},{"location":"muda/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"muda/namespace_member_enums/#c","title":"c","text":"<ul> <li>ComputeGraphFlag (muda)</li> <li>ComputeGraphNodeType (muda)</li> <li>ComputeGraphPhase (muda)</li> <li>ComputeGraphVarUsage (muda)</li> </ul>"},{"location":"muda/namespace_member_enums/#e","title":"e","text":"<ul> <li>EdgeEdgeDistanceType (muda::distance)</li> </ul>"},{"location":"muda/namespace_member_enums/#f","title":"f","text":"<ul> <li>FieldEntryLayout (muda)</li> <li>FieldEntryType (muda)</li> </ul>"},{"location":"muda/namespace_member_enums/#g","title":"g","text":"<ul> <li>GraphInstantiateFlagBit (muda)</li> </ul>"},{"location":"muda/namespace_member_enums/#l","title":"l","text":"<ul> <li>LinearSystemReorderMethod (muda)</li> <li>LoggerBasicType (muda)</li> </ul>"},{"location":"muda/namespace_member_enums/#p","title":"p","text":"<ul> <li>ParallelForType (muda)</li> <li>PointEdgeDistanceType (muda::distance)</li> <li>PointPointDistanceType (muda::distance)</li> <li>PointTriangleDistanceType (muda::distance)</li> </ul>"},{"location":"muda/functions/","title":"Functions","text":""},{"location":"muda/functions/#m","title":"m","text":"<ul> <li>mudaCudaGetErrorEnum (check.h, check_cublas.h, check_cusparse.h)</li> </ul>"},{"location":"muda/functions/#o","title":"o","text":"<ul> <li>operator== (matrix_format_converter_impl.h)</li> </ul>"},{"location":"muda/functions/#_","title":"_","text":"<ul> <li>__attribute__ (debug_break.h)</li> </ul>"},{"location":"muda/macros/","title":"Macros","text":""},{"location":"muda/macros/#c","title":"c","text":"<ul> <li>checkCudaErrors (check_cuda_errors.h)</li> </ul>"},{"location":"muda/macros/#d","title":"d","text":"<ul> <li>DEBUG_BREAK_IMPL (debug_break.h)</li> <li>DEBUG_BREAK_USE_BULTIN_TRAP (debug_break.h)</li> <li>DEBUG_BREAK_USE_SIGTRAP (debug_break.h)</li> <li>DEBUG_BREAK_USE_TRAP_INSTRUCTION (debug_break.h)</li> <li>def (syntax_sugar.h)</li> </ul>"},{"location":"muda/macros/#k","title":"k","text":"<ul> <li>kernel_name (syntax_sugar.h)</li> </ul>"},{"location":"muda/macros/#m","title":"m","text":"<ul> <li>MUDA_CHECK_ON (muda_config.h)</li> <li>MUDA_COMPUTE_GRAPH_ON (muda_config.h)</li> <li>MUDA_CONSTANT (muda_def.h)</li> <li>MUDA_CONSTEXPR (muda_def.h)</li> <li>MUDA_DEPRECATED (muda_def.h)</li> <li>MUDA_DEVICE (muda_def.h, syntax_sugar.h)</li> <li>MUDA_FALLTHROUGH (muda_def.h)</li> <li>MUDA_GENERIC (muda_def.h)</li> <li>MUDA_GLOBAL (muda_def.h)</li> <li>MUDA_HOST (muda_def.h)</li> <li>MUDA_INLINE (muda_def.h)</li> <li>MUDA_MANAGED (muda_def.h)</li> <li>MUDA_MAYBE_UNUSED (muda_def.h)</li> <li>MUDA_NODISCARD (muda_def.h)</li> <li>MUDA_NOEXCEPT (muda_def.h)</li> <li>MUDA_NORETURN (muda_def.h)</li> <li>MUDA_REQUIRES (muda_def.h)</li> <li>MUDA_SHARED (muda_def.h)</li> <li>MUDA_ASSERT (debug_log.h)</li> <li>MUDA_DEBUG_TRAP (debug_log.h)</li> <li>MUDA_ERROR (debug_log.h)</li> <li>MUDA_ERROR_WITH_LOCATION (debug_log.h)</li> <li>MUDA_KERNEL_ASSERT (debug_log.h)</li> <li>MUDA_KERNEL_CHECK (debug_log.h)</li> <li>MUDA_KERNEL_ERROR (debug_log.h)</li> <li>MUDA_KERNEL_ERROR_WITH_LOCATION (debug_log.h)</li> <li>MUDA_KERNEL_PRINT (debug_log.h)</li> <li>MUDA_KERNEL_WARN (debug_log.h)</li> <li>MUDA_KERNEL_WARN_WITH_LOCATION (debug_log.h)</li> <li>MUDA_DEFINE_ARITHMATIC_OPERATOR (extent.h)</li> <li>MUDA_DEFINE_COMPARISON_OPERATOR (extent.h)</li> <li>MUDA_HAS_CXX20 (platform.h)</li> <li>MUDA_BASELINE_CUDACC_VER_MAJOR (version.h)</li> <li>MUDA_BASELINE_CUDACC_VER_MINOR (version.h)</li> <li>MUDA_WITH_DEVICE_STREAM_MODEL (version.h)</li> <li>MUDA_VIEWER_COMMON_NAME (viewer_base.h)</li> </ul>"},{"location":"muda/macros/#n","title":"n","text":"<ul> <li>node (syntax_sugar.h)</li> </ul>"},{"location":"muda/macros/#p","title":"p","text":"<ul> <li>PROXY_OPERATOR (logger_viewer.h)</li> </ul>"},{"location":"muda/macros/#t","title":"t","text":"<ul> <li>TCB_SPAN_ARRAY_CONSTEXPR (span.hpp)</li> <li>TCB_SPAN_CONSTEXPR11 (span.hpp)</li> <li>TCB_SPAN_CONSTEXPR14 (span.hpp)</li> <li>TCB_SPAN_CONSTEXPR_ASSIGN (span.hpp)</li> <li>TCB_SPAN_EXPECT (span.hpp)</li> <li>TCB_SPAN_INLINE_VAR (span.hpp)</li> <li>TCB_SPAN_NAMESPACE_NAME (span.hpp)</li> <li>TCB_SPAN_NODISCARD (span.hpp)</li> <li>TCB_SPAN_NO_CONTRACT_CHECKING (span.hpp)</li> <li>TCB_SPAN_NO_EXCEPTIONS (span.hpp)</li> </ul>"},{"location":"muda/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"muda/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}